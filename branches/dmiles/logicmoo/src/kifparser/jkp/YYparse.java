/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

/*
This is a parser template file, in java, for running parsers
generated by the GNU Bison parser generator.
*/

/**************************************************/

package jkp;


/**************************************************/

import java.util.*;
import java.io.*;
import jbf.*;

/**************************************************/

// PREFIX



/**************************************************/

public
class YYparse {

    // Set up the fake goto mechanism
    protected int Goto;
    protected static final int yynewstate = 0;
    protected static final int yybackup = 1;
    protected static final int yydefault = 2;
    protected static final int yyreduce = 3;
    protected static final int yyerrlab = 4;
    protected static final int yyerrlab1 = 5;
    protected static final int yyerrdefault = 6;
    protected static final int yyerrpop = 7;
    protected static final int yyerrhandle = 8;

    public static final int YYCONTINUE = 1;
    public static final int YYACCEPT = 0;
    public static final int YYABORT = -1;

    public static final int YYEOF = 0;

    protected static final int YYEMPTY = -2;
    protected static final int YYTERROR = 1;
    protected static final int YYTERRCODE = 256;

// CONSTANTS

public static final int YYFINAL = 82;
public static final int YYFLAG = -32768;
public static final int YYNTBASE = 36;
public static final int YYLAST = 100;


// TOKENTYPES

public static final Integer INDVAR = YYtokentypes.Tokentype[258];
public static final Integer SEQVAR = YYtokentypes.Tokentype[259];
public static final Integer TRUE = YYtokentypes.Tokentype[260];
public static final Integer FALSE = YYtokentypes.Tokentype[261];
public static final Integer STRING = YYtokentypes.Tokentype[262];
public static final Integer INTEGER = YYtokentypes.Tokentype[263];
public static final Integer REAL = YYtokentypes.Tokentype[264];
public static final Integer EQ = YYtokentypes.Tokentype[265];
public static final Integer NOTEQ = YYtokentypes.Tokentype[266];
public static final Integer IMPLIES = YYtokentypes.Tokentype[267];
public static final Integer IMPLIED = YYtokentypes.Tokentype[268];
public static final Integer EQUIV = YYtokentypes.Tokentype[269];
public static final Integer EQLESS = YYtokentypes.Tokentype[270];
public static final Integer LESS = YYtokentypes.Tokentype[271];
public static final Integer EQGREATER = YYtokentypes.Tokentype[272];
public static final Integer GREATER = YYtokentypes.Tokentype[273];
public static final Integer QUOTE = YYtokentypes.Tokentype[274];
public static final Integer FORALL = YYtokentypes.Tokentype[275];
public static final Integer EXISTS = YYtokentypes.Tokentype[276];
public static final Integer AND = YYtokentypes.Tokentype[277];
public static final Integer OR = YYtokentypes.Tokentype[278];
public static final Integer NOT = YYtokentypes.Tokentype[279];
public static final Integer IF = YYtokentypes.Tokentype[280];
public static final Integer COND = YYtokentypes.Tokentype[281];
public static final Integer LISTOF = YYtokentypes.Tokentype[282];
public static final Integer DEFOBJECT = YYtokentypes.Tokentype[283];
public static final Integer DEFFUNCTION = YYtokentypes.Tokentype[284];
public static final Integer DEFRELATION = YYtokentypes.Tokentype[285];
public static final Integer DEFLOGICAL = YYtokentypes.Tokentype[286];
public static final Integer CONSTANT = YYtokentypes.Tokentype[287];
public static final Integer PLACEHOLDER = YYtokentypes.Tokentype[288];


    protected int yyreturn; // see ACTIONS switch
    protected int yystate;
    protected int yyn;
    protected int yylen;
    protected int yychar; /* the lookahead symbol */
    protected int yychar1;  /* lookahead token as an internal (translated)
			   Token number */
    protected int yynerrs; /* number of parse errors so far */
    protected int yydebug; /* nonzero means print parse trace */
    protected int yyerrstatus;	/* number of tokens to shift before error
			   messages enabled */
    public StringBuffer yytext; // string for current lexeme (volatile)
    public YYlocation yyloc; // location for current lexeme
    public Integer yylval; // the semantic value of the lookahead symbol
    protected Object yyval;   // the variable used to return semantic values
			 	// from the action routines

    protected Int_Stack yyss;
    protected Object_Stack yyvs;
/*    protected loc_stack yyls;*/
    protected YYlex yylex;
    protected java.io.PrintStream yyout;

// PROCS

static final int YYTRANSLATE(int x)
	{ return ((x) <= 288 ? yytranslate[x] : 67);}



public
YYparse(YYlex yyl, java.io.PrintStream fout)
{
    yyss = new Int_Stack();
    yyvs = new Object_Stack();
    yylex = yyl;
    yylval = null;
    yytext = yyl.yylval.text();
    yyloc = yyl.yylval.location();
    yydebug = 0;
    yyout = fout;
    
}

public YYparse(YYlex yyl) {this(yyl, System.out);}

public
int
yyparse() throws Exception, IOException, EmptyStackException
{
    int ok;
    yychar1 = 0;  /* lookahead Token as an internal (translated) */
    yystate = 0;
    yyerrstatus = 0;
    yynerrs = 0;
    yychar = YYEMPTY;  /* Cause a Token to be read.  */
    yyval = null;
  
    /* Initialize stack pointers.
       Waste one element of value and location stack
       so that they stay on the same level as the state stack.
       The wasted elements are never initialized.  */
  
    yyss.clear();
    yyvs.clear();
/*    yyls.clear();*/
    
    /* need to push a null value to match state 0 */
    yyvs.push(null);
  
    if(yydebug > 0) yyout.print("Starting parse\n");

/* Push a new state, which is found in	yystate	 .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
for(;;) {
branch: switch (Goto) {

case yynewstate:

  yyss.push(yystate);

  if (yydebug > 0) {
	yyout.print("Entering state ");
	yyout.print(yystate);
	yyout.print("\n");
  }

//  {Goto = yybackup; break branch;}
case yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    {Goto = yydefault; break branch;}

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.	 */

  if (yychar == YYEMPTY)
    {
      if(yydebug > 0) yyout.print("Reading a token: ");
      yylval = yylex.yylex();
      yychar = yylval == null ? YYEOF : yylval.intValue();
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

      if(yydebug > 0) yyout.print("Now at end of input.\n");
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

      if (yydebug >= 10)
	{
	    yyout.print("Next token is ");
	    yyout.print(yychar);
	    yyout.print(" (");
	    yyout.print(yytname[yychar1]);
	    yyout.print(")\n");
	}
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    {Goto = yydefault; break branch;}

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	{Goto = yyerrlab; break branch;}
      yyn = -yyn;
      {Goto = yyreduce; break branch;}
    }
  else if (yyn == 0)
    {Goto = yyerrlab; break branch;}

  if (yyn == YYFINAL)
    return YYACCEPT;

  /* Shift the lookahead token.	 */

  if (yydebug > 0) {
    yyout.print("Shifting token ");
    yyout.print(yychar);
    yyout.print(" (");
    yyout.print(yytname[yychar1]);
    yyout.print("), ");
  }

  /* Discard the token being shifted unless it is eof.	*/
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  yyvs.push(yylval);
/*  yyls.push(yylloc);*/

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus > 0) yyerrstatus--;

  yystate = yyn;
  {Goto = yynewstate; break branch;}

/* Do the default action for the current state.	 */
case yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    {Goto = yyerrlab; break branch;}

/* Do a reduction.  yyn is the number of a rule to reduce with.	 */
case yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvs.tth(1-yylen); /* implement default value of the action */

  if (yydebug > 0)
    {
      int i;

      yyout.print("Reducing via rule ");
      yyout.print(yyn);
      yyout.print(" (line ");
      yyout.print(yyrline[yyn]);
      yyout.print("), ");
      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++) {
	  yyout.print(yytname[yyrhs[i]]);
	  yyout.print(" ");
      }
      yyout.print(" -> ");
      yyout.print(yytname[yyr1[yyn]]);
      yyout.print("\n");
    }

/*$*/	/* the action file gets copied in in place of this dollarsign */

/* Provide a way to avoid having return statements in the actions
   and so avoid "statement not reached" errors"
*/
yyreturn = YYCONTINUE;

switch (yyn) {

case 1:
{	
						// form: sentence
						KifParser._result = ((KifSent)dollar(0)); 
						//System.out.println("Parsing result is: " + ($1).toString());
					;
    break;}
case 2:
{ 
						// sentence :   logconst
						yyval = ((KifSent)dollar(0));  
					;
    break;}
case 3:
{ 
						// sentence: relsent
						yyval = ((KifRelSent)dollar(0));  
					;
    break;}
case 4:
{ 
						// sentence: logsent
						yyval = ((KifSent)dollar(0));  
					;
    break;}
case 5:
{ 
						// logconst: TRUE
						yyval = new KifLogConst(true);
					;
    break;}
case 6:
{ 
						// logconst: FALSE
						yyval = new KifLogConst(false);
					;
    break;}
case 7:
{ 
						// relsent: tLPAREN tCONSTANT termseq tRPAREN
						yyval = new KifRelSent(((String)dollar(-2)), ((KifSeq)dollar(-1))); 
					;
    break;}
case 8:
{ 
						// relsent: tLPAREN tCONSTANT tRPAREN
						yyval = new KifRelSent(((String)dollar(-1))); 
					;
    break;}
case 9:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 10:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 11:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 12:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 13:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 14:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 15:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 16:
{
						yyval = ((String)dollar(0));
					;
    break;}
case 17:
{ 
						// logsent :   tLPAREN tNOT sentence tRPAREN
						yyval = new KifNegation (((KifSent)dollar(-1)));
					;
    break;}
case 18:
{ 
						// logsent: tLPAREN tAND sentence sentseq tRPAREN
						yyval = new KifConjunction(((KifSent)dollar(-2)), ((KifSeq)dollar(-1)));
					;
    break;}
case 19:
{ 
						// logsent: tLPAREN tOR sentence sentseq tRPAREN
						yyval = new KifDisjunction(((KifSent)dollar(-2)), ((KifSeq)dollar(-1)));
					;
    break;}
case 20:
{ 
						// logsent: tLPAREN tIMPLIES sentseq sentence tRPAREN
						yyval = new KifImplication(((KifSent)dollar(-1)), ((KifSeq)dollar(-2)));
					;
    break;}
case 21:
{ 
						// logsent: tLPAREN tIMPLIED sentence sentseq tRPAREN
						yyval = new KifImplication(((KifSent)dollar(-2)), ((KifSeq)dollar(-1)));
					;
    break;}
case 22:
{ 
						// logsent: tLPAREN tEQUIV sentence sentence tRPAREN
						yyval = new KifEquivalence(((KifSent)dollar(-2)), ((KifSent)dollar(-1)));
					;
    break;}
case 23:
{ 
						// sentseq:   sentence
						yyval = new KifSeq(((KifSent)dollar(0))); 
					;
    break;}
case 24:
{ 
						// sentseq: sentseq sentence
						yyval = new KifSeq(((KifSeq)dollar(-1)), ((KifSent)dollar(0)));
					;
    break;}
case 25:
{ 
						// term :   tSTRING
						yyval = new KifString(((String)dollar(0)));
					;
    break;}
case 26:
{ 
						// term :   tINDVAR
						yyval = new KifIndvar(((String)dollar(0)));
					;
    break;}
case 27:
{ 
						// term :   tINTEGER
						yyval = new KifInt(((String)dollar(0)));
					;
    break;}
case 28:
{ 
						// term :   tREAL
						yyval = new KifReal(((String)dollar(0)));
					;
    break;}
case 29:
{ 
						// term : funterm
						yyval = ((KifTerm)dollar(0));
					;
    break;}
case 30:
{ 
						// term : object constant
						yyval = new KifObjConst(((String)dollar(0)));
					;
    break;}
case 31:
{ 
						// termseq:   term
						yyval = new KifSeq(((KifTerm)dollar(0)));  
					;
    break;}
case 32:
{ 
						// termseq: termseq term
						yyval = new KifSeq(((KifSeq)dollar(-1)), ((KifTerm)dollar(0)));  
					;
    break;}
case 33:
{
						// termseq:   tSEQVAR
						yyval = new KifSeq(((KifSeqvar)dollar(0)));  
					;
    break;}
case 34:
{ 
						// term termseq tSEQVAR
						yyval = new KifSeq(((KifSeq)dollar(-1)), ((KifSeqvar)dollar(0)));  
					;
    break;}
case 35:
{
						// funterm: tLPAREN tCONSTANT termseq tRPAREN
						yyval = new KifFunTerm(((String)dollar(-2)), ((KifSeq)dollar(-1)));
					;
    break;}
case 36:
{
						// funterm: tLPAREN tCONSTANT tRPAREN
						yyval = new KifFunTerm(((String)dollar(-1)));
					;
    break;}
case 37:
{yyval = new String (yytext); ;
    break;}
case 38:
{yyval = new String (yytext); ;
    break;}
case 39:
{yyval = new String (yytext); ;
    break;}
case 40:
{yyval = new KifSeqvar (new String(yytext)); ;
    break;}
case 41:
{yyval = new String (yytext); ;
    break;}
case 42:
{yyval = new String (yytext); ;
    break;}
case 43:
{yyval = new String (yytext); ;
    break;}
case 44:
{yyval = new String (yytext); ;
    break;}
case 45:
{yyval = new String (yytext); ;
    break;}
case 46:
{yyval = new String (yytext); ;
    break;}
case 47:
{yyval = new String (yytext); ;
    break;}
case 48:
{yyval = new String (yytext); ;
    break;}
case 49:
{yyval = new String (yytext); ;
    break;}
case 50:
{yyval = new String (yytext); ;
    break;}
case 51:
{yyval = new String (yytext); ;
    break;}
case 52:
{yyval = new String (yytext); ;
    break;}
case 53:
{yyval = new String (yytext); ;
    break;}
case 54:
{yyval = new String (yytext); ;
    break;}
case 55:
{yyval = new String (yytext); ;
    break;}
case 56:
{yyval = new String (yytext); ;
    break;}
case 57:
{yyval = new String (yytext); ;
    break;}
case 58:
{yyval = new String (yytext); ;
    break;}
case 59:
{yyval = new String (yytext); ;
    break;}
case 60:
{yyval = new String (yytext); ;
    break;}
case 61:
{yyval = new String (yytext); ;
    break;}
case 62:
{yyval = new String (yytext); ;
    break;}
case 63:
{yyval = new String (yytext); ;
    break;}
case 64:
{yyval = new String (yytext); ;
    break;}
case 65:
{yyval = new String (yytext); ;
    break;}
case 66:
{yyval = new String (yytext); ;
    break;}
}


  if(yyreturn != YYCONTINUE) return yyreturn;

  yyvs.popn(yylen);
  yyss.popn(yylen);
/*  yyls.popn(yylen)*/

  if (yydebug > 0)
    {
	stackdump("state stack now");
    }

  yyvs.push(yyval);

/*  yylsp++;*/
  if (yylen == 0)
    {
/*remind:
      yyls.push(yylloc);
      yyls.last_line = (yylsp-1)->last_line;
      yyls.last_column = (yylsp-1)->last_column;
      yyls.text = 0;
*/
    }
  else
    {
/* remind:
      yylsp.last_line = (yylsp+yylen-1)->last_line;
      yylsp.last_column = (yylsp+yylen-1)->last_column;
*/
    }

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + yyss.peek();
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == yyss.peek())
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  {Goto = yynewstate; break branch;}

case yyerrlab:	 /* here on detecting error */

  if (yyerrstatus == 0)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;
	yyverror("parse error");
    }

//  {Goto = yyerrlab1; break branch;}
case yyerrlab1:	  /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.	*/

      /* return failure if at end of input */
      if (yychar == YYEOF)
	return YYABORT;

      if (yydebug > 0) {
	yyout.print("Discarding token ");
	yyout.print(yychar);
	yyout.print(" (");
	yyout.print(yytname[yychar1]);
	yyout.print(").\n");
      }
      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  {Goto = yyerrhandle; break branch;}

case yyerrdefault:  /* current state does not do anything special for the error token. */

/* if 0
  // This is wrong; only states that explicitly want error tokens
  // should shift them.
  yyn = yydefact[yystate];  // If its default is to accept any token, ok.  Otherwise pop it.
  if (yyn) {Goto = yydefault; break branch;}
*/

case yyerrpop:	 /* pop the current state because it cannot handle the error token */

  if (yyss.empty()) return YYABORT;
  yyvs.popn(1);
  yystate = yyss.pop();
/*  yyls.popn(1);*/

  if (yydebug > 0)
    {
	stackdump("Error: state stack now");
    }

case yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    {Goto = yyerrdefault; break branch;}

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    {Goto = yyerrdefault; break branch;}

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	{Goto = yyerrpop; break branch;}
      yyn = -yyn;
      {Goto = yyreduce; break branch;}
    }
  else if (yyn == 0)
    {Goto = yyerrpop; break branch;}

  if (yyn == YYFINAL)
    return YYACCEPT;

  if (yydebug > 0) {yyout.println("Shifting error token, ");}

  yyvs.push(yylval);
/*  yyls.push(yyloc);*/

  yystate = yyn;
//  {Goto = yynewstate; break branch;}

}//switch
}//for(;;)

} // parse

protected
void
stackdump(String s)
{
    int i;
    int x;
    int ssp1 = yyss.depth();
    yyout.print(s);
    for(i=0;i<ssp1;i++) {
	x = yyss.ith(i);
	yyout.print(" ");
	yyout.print(x);
    }
    yyout.print("\n");
}

public
String
yyerror_verbose(String msg0) throws ParseException
{
    yyn = yypact[yystate];
    if(yyn > YYFLAG && yyn < YYLAST) {
	int size = msg0.length();
	StringBuffer msg;
	int yychar1; // a TRANSLATEd char value
	int count;
	count = 0;

	/* Start yychar1 at -yyn if nec to avoid negative indexes in yycheck.*/
	for (yychar1 = (yyn < 0 ? -yyn : 0);
		(yyn+yychar1) < (yytname.length);
		yychar1++) {
	    if((yyn+yychar1) < yycheck.length
		    && yycheck[yyn+yychar1] == yychar1) {
		size += (yytname[yychar1].length()) + 15;
		count++;
	    }
	}
	msg = new StringBuffer(size+15);
	msg.append(msg0);
	msg.append("(state " + Integer.toString(yystate) + ")");
	yychar1 = (yyn < 0)? - yyn :0;
	for(count=0,yychar1 = (yyn < 0 ? -yyn : 0);
		(yyn+yychar1) < (yytname.length) && count < 5;
		yychar1++) {
	    if((yyn+yychar1) < yycheck.length
		    && yycheck[yyn+yychar1] == yychar1) {
		msg.append(count == 0 ? ", expecting `" : " or `");
		msg.append(yytname[yychar1]);
		msg.append("'");
		count++;
	    }
	}
	return msg.toString();
    }
    return msg0;
}

public
void
yyerror(String msg, boolean verbose, boolean dumpstack) throws ParseException
{
    String s;
    if(verbose) {
	s = yyerror_verbose(msg);
    } else {
	s = msg;
    }
    yyout.print("yyerror: ");
    if(yylval.intValue() == YYEOF) {
	yyout.print("at end of file");
    } else {
	yyout.print("line ");
	yyout.print(yyloc.lineno()+1);
    }
    yyout.println(" ; " + s);
    if(dumpstack) { stackdump("yyerror: state stack"); }
    throw new ParseException(s);
}

public void yyerror(String s, boolean verbose) throws ParseException
{ yyerror(s,verbose,false); }

public void yyerror(String s) throws ParseException
{ yyerror(s,false,false); }

public void yyreturn(int t) {yyreturn = t;}

public void setdebug(boolean i) {yydebug = i?1:0;}
public void setdebug(int i) {yydebug = i>0?i:0;}

public Object dollar(int i) {return yyvs.tth(i);}


// TABLES

public static final int yytranslate[] = {
     0,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     3,
     4,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
     2,     2,     2,     2,     2,     1,     2,     5,     6,     7,
     8,     9,    10,    11,    12,    13,    14,    15,    16,    17,
    18,    19,    20,    21,    22,    23,    24,    25,    26,    27,
    28,    29,    30,    31,    32,    33,    34,    35

};

public static final int yyprhs[] = {
     0,
     0,     2,     4,     6,     8,    10,    12,    17,    21,    23,
    25,    27,    29,    31,    33,    35,    37,    42,    48,    54,
    60,    66,    72,    74,    77,    79,    81,    83,    85,    87,
    89,    91,    94,    96,    99,   104,   108,   110,   112,   114,
   116,   118,   120,   122,   124,   126,   128,   130,   132,   134,
   136,   138,   140,   142,   144,   146,   148,   150,   152,   154,
   156,   158,   160,   162,   164,   166

};

public static final int yyrhs[] = {
    37,
     0,    38,     0,    39,     0,    42,     0,     7,     0,     8,
     0,    47,    40,    45,    48,     0,    47,    66,    48,     0,
    66,     0,    41,     0,    59,     0,    60,     0,    61,     0,
    62,     0,    54,     0,    55,     0,    47,    65,    37,    48,
     0,    47,    63,    37,    43,    48,     0,    47,    64,    37,
    43,    48,     0,    47,    56,    43,    37,    48,     0,    47,
    57,    37,    43,    48,     0,    47,    58,    37,    37,    48,
     0,    37,     0,    43,    37,     0,    51,     0,    49,     0,
    52,     0,    53,     0,    46,     0,    66,     0,    44,     0,
    45,    44,     0,    50,     0,    45,    50,     0,    47,    66,
    45,    48,     0,    47,    66,    48,     0,     3,     0,     4,
     0,     5,     0,     6,     0,     9,     0,    10,     0,    11,
     0,    12,     0,    13,     0,    14,     0,    15,     0,    16,
     0,    17,     0,    18,     0,    19,     0,    20,     0,    21,
     0,    22,     0,    23,     0,    24,     0,    25,     0,    26,
     0,    27,     0,    28,     0,    29,     0,    30,     0,    30,
     0,    32,     0,    33,     0,    34,     0

};

public static final int yyrline[] = {
 0,
    46,    53,    58,    63,    69,    74,    80,    85,    91,    95,
   100,   104,   108,   112,   116,   120,   125,   130,   135,   140,
   145,   150,   156,   161,   167,   172,   177,   182,   187,   192,
   198,   203,   208,   213,   219,   224,   240,   241,   242,   243,
   244,   245,   246,   247,   248,   249,   250,   251,   252,   253,
   254,   255,   256,   257,   258,   259,   260,   261,   262,   263,
   264,   265,   266,   267,   268,   269

};

public static final String yytname[] = {
   "$","error","$undefined.","'('","')'",
"INDVAR","SEQVAR","TRUE","FALSE","STRING","INTEGER","REAL","EQ","NOTEQ","IMPLIES",
"IMPLIED","EQUIV","EQLESS","LESS","EQGREATER","GREATER","QUOTE","FORALL","EXISTS",
"AND","OR","NOT","IF","COND","LISTOF","DEFOBJECT","DEFFUNCTION","DEFRELATION",
"DEFLOGICAL","CONSTANT","PLACEHOLDER","form","sentence","logconst","relsent",
"relconst","relop","logsent","sentseq","term","termseq","funterm","tLPAREN",
"tRPAREN","tINDVAR","tSEQVAR","tSTRING","tINTEGER","tREAL","tEQ","tNOTEQ","tIMPLIES",
"tIMPLIED","tEQUIV","tEQLESS","tLESS","tEQGREATER","tGREATER","tAND","tOR","tNOT",
"tCONSTANT", null

};

public static final int yyr1[] = {
     0,
    36,    37,    37,    37,    38,    38,    39,    39,    40,    40,
    41,    41,    41,    41,    41,    41,    42,    42,    42,    42,
    42,    42,    43,    43,    44,    44,    44,    44,    44,    44,
    45,    45,    45,    45,    46,    46,    47,    48,    49,    50,
    51,    52,    53,    54,    55,    56,    57,    58,    59,    60,
    61,    62,    -1,    -1,    -1,    63,    64,    65,    -1,    -1,
    -1,    -1,    -1,    -1,    -1,    66

};

public static final int yyr2[] = {
     0,
     1,     1,     1,     1,     1,     1,     4,     3,     1,     1,
     1,     1,     1,     1,     1,     1,     4,     5,     5,     5,
     5,     5,     1,     2,     1,     1,     1,     1,     1,     1,
     1,     2,     1,     2,     4,     3,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
     1,     1,     1,     1,     1,     1

};

public static final int yydefact[] = {
     0,
    37,     5,     6,     1,     2,     3,     4,     0,    44,    45,
    46,    47,    48,    49,    50,    51,    52,    56,    57,    58,
    66,     0,    10,    15,    16,     0,     0,     0,    11,    12,
    13,    14,     0,     0,     0,     9,    39,    40,    41,    42,
    43,    31,     0,    29,     0,    26,    33,    25,    27,    28,
    30,    23,     0,     0,     0,     0,     0,     0,    38,     8,
    32,     7,    34,     0,    24,     0,     0,     0,     0,    17,
     0,    36,    20,    24,    21,    22,    18,    19,    35,     0,
     0,     0

};

public static final int yydefgoto[] = {
    80,
    52,     5,     6,    22,    23,     7,    53,    42,    43,    44,
     8,    60,    46,    47,    48,    49,    50,    24,    25,    26,
    27,    28,    29,    30,    31,    32,    33,    34,    35,    51

};

public static final int yypact[] = {
     7,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,    66,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,    14,-32768,-32768,-32768,     7,     7,     7,-32768,-32768,
-32768,-32768,     7,     7,     7,     5,-32768,-32768,-32768,-32768,
-32768,-32768,     2,-32768,   -18,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,     7,     7,     7,     7,     7,     5,-32768,-32768,
-32768,-32768,-32768,     2,     5,    34,     5,    34,    34,-32768,
     2,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    18,
    21,-32768

};

public static final int yypgoto[] = {
-32768,
     0,-32768,-32768,-32768,-32768,-32768,   -10,   -40,   -38,-32768,
   -21,     6,-32768,   -39,-32768,-32768,-32768,-32768,-32768,-32768,
-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,-32768,    -6

};

public static final int yytable[] = {
     4,
    45,    36,    61,    63,     1,    59,    37,    38,    59,     1,
    39,    40,    41,     2,     3,    21,     1,    81,    37,    38,
    82,    45,    39,    40,    41,    71,    54,    55,     0,     0,
    61,    63,    56,    57,    58,    21,     1,    59,    64,     0,
     2,     3,    45,    66,     0,    68,    69,    21,    62,    45,
     0,     0,    65,     0,    67,     0,     0,     0,     0,     0,
     0,     0,     0,    70,     0,    74,     0,    74,    74,    72,
    73,    75,    76,    77,    78,     0,    79,     9,    10,    11,
    12,    13,    14,    15,    16,    17,     0,     0,     0,    18,
    19,    20,     0,     0,     0,     0,     0,     0,     0,    21

};

public static final int yycheck[] = {
     0,
    22,     8,    43,    43,     3,     4,     5,     6,     4,     3,
     9,    10,    11,     7,     8,    34,     3,     0,     5,     6,
     0,    43,     9,    10,    11,    64,    27,    28,    -1,    -1,
    71,    71,    33,    34,    35,    34,     3,     4,    45,    -1,
     7,     8,    64,    54,    -1,    56,    57,    34,    43,    71,
    -1,    -1,    53,    -1,    55,    -1,    -1,    -1,    -1,    -1,
    -1,    -1,    -1,    58,    -1,    66,    -1,    68,    69,    64,
    65,    66,    67,    68,    69,    -1,    71,    12,    13,    14,
    15,    16,    17,    18,    19,    20,    -1,    -1,    -1,    24,
    25,    26,    -1,    -1,    -1,    -1,    -1,    -1,    -1,    34

};



// SUFFIX



public
void
yyverror(String s) throws ParseException
{
	String msg = yyerror_verbose(s);
	System.out.print("yyverror: line ");
	System.out.print(yyloc.lineno()+1);
	System.out.println(" ; " + msg);
	throw new ParseException(s);
}



}; /*class*/
