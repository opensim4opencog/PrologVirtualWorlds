/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /development/LM/logicmoo-cvsbackup/logicmoo/src/kifparser/jbf/yylex.Cfa.template,v 1.1.1.1 2002-03-07 06:11:43 dmiles Exp $
 */

/**************************************************/
/* Indicate the flex optimization template */


//@FLEXFLAGS=Cfa@


/**************************************************/
//  This line is added by X.Luan, Nov 15, 96
package jkp;

@package@

/**************************************************/

import java.util.*;
import java.io.*;
import jbf.*;

/**************************************************/

// PREFIX

@PREFIX@

/**************************************************/


public
class @YYlex@ {

    // Set up the fake goto mechanism
    protected int Goto;
    protected static final int yynobranch = 0;
    protected static final int yy_find_action = 1;
    protected static final int yy_match = 2;
    protected static final int do_action = 3;

// CONSTANTS

@CONSTANTS@

// STATES

@STATES@

// MISC.

    protected static final int EOF = -1;


// Class State

    Int_Stack yy_start_stack;
    java.io.InputStream yyin;
    java.io.PrintStream yyout;
    int yy_start;		/* start state number */
    int yy_last_accepting_state;
    int yy_last_accepting_cpos;
    YYtoken yylval;
    Integer yytokentype;
    protected @StringBuffer@ lexeme;
    YYlexbuffer yytext;
    public int yydebug;

    boolean yy_at_bol;
    boolean is_interactive;
    int yy_current_state;
    int yy_act;


// PROCS

@PROCS@

public @YYlex@(java.io.InputStream fin) {this(fin,System.out);}
public @YYlex@() {this(System.in,System.out);}

public
@YYlex@(java.io.InputStream fin, java.io.PrintStream fout)
{
    yyin = fin;
    yyout = fout;
    yy_start_stack = new Int_Stack();
    yy_start = 1;		/* start state number */
    yy_last_accepting_state = 0;
    yy_last_accepting_cpos = 0;
    yy_current_state = 0;
    yy_act = 0;
    yy_at_bol = true; //pretend
    is_interactive= false;
    yylval = new YYtoken();
    yytokentype = null;
    yydebug = 0;
    yytext = new YYlexbuffer(yyin,yyout);
    lexeme = new @StringBuffer@();
    @constructor@
}

public
@Integer@
@yylex@() throws LexException, IOException, EmptyStackException
{
	yylval.clear();
	yytext.purge();

scanloop:
    while( true ) {	      /* loops until end-of-file is reached */

	yytext.setmark();

	int thisch = yytext.nextchar();
	if(thisch == EOF) thisch = YY_END_OF_BUFFER_CHAR;

branch: switch (Goto) {
case yynobranch:

	yy_current_state = yy_start;


































	while ( (yy_current_state = yy_nxt[yy_current_state][thisch]) > 0 )
	{
///**/yyout.println("(1)yy_current_state=" + yy_current_state);
	    if ( yy_accept[yy_current_state]  != 0) {
		yy_last_accepting_cpos = yytext.currentpos();
		yy_last_accepting_state = yy_current_state;
///**/yyout.println("(1)yy_last_accepting_state=" + yy_last_accepting_state);
///**/yyout.println("(1)yy_last_accepting_cpos=" + yy_last_accepting_cpos);
	    }
	   yy_at_bol = (thisch == '\n');
	   thisch = yytext.nextchar();
	   if(thisch == EOF) thisch = YY_END_OF_BUFFER_CHAR;
	}
	yy_current_state = -yy_current_state;

case yy_find_action:
	yy_act = yy_accept[yy_current_state];
///**/yyout.println("(4)yy_act=" + yy_act);
	if ( yy_act == 0 ) {
	    /* have to back up to last accepting state*/
	    do {
		yytext.backup();
	    } while(yytext.currentpos() >= yy_last_accepting_cpos);
	    thisch = yytext.nextchar();
///**/yyout.print("backup:"+" yyline="+lineno()+" ; yychar="+charno0()+" ; yylinechar="+charno()+" ; yytext=/"+yytext+"/");
	    yy_current_state = yy_last_accepting_state;
	    yy_act = yy_accept[yy_current_state];
///**/yyout.println("(5)yy_current_state=" + yy_current_state);
///**/yyout.println("(5)yy_act=" + yy_act);
	}

	// YY_DO_BEFORE_ACTION;

case do_action:	     /* This label is used only to access EOF actions. */

	yy_at_bol = (yytext.charno0() == 0);
	yytext.backup();
	yytext.getlexeme(yylval.text());	
	yytokentype = null; // => no token returned

///**/yyout.println("(6)yy_act=" + yy_act);
///**/yyout.println("(6)yytext=/"+yytext+ "/");
///**/yyout.println("(6)yy_at_bol=" + yy_at_bol);

///**/yyout.println("yytext.lexeme=/" + yytext + "/");

	switch ( yy_act ) { /* beginning of action switch */
		case 0: /* must back up */
		/* have to back up to last accepting state*/
		do {
		    yytext.backup();
		} while(yytext.currentpos() > yy_last_accepting_cpos);
		thisch = yytext.nextchar();
///**/yyout.print("backup:"+" yyline="+lineno()+" ; yychar="+charno0()+" ; yylinechar="+charno()+" ; yytext=/"+yytext+"/");
		yy_current_state = yy_last_accepting_state;
		{Goto = yy_find_action; break branch;}

// ACTIONS

@ACTIONS@

case YY_END_OF_BUFFER:
///**/yyout.println("case YY_END_OF_BUFFER");
	yy_act = YY_STATE_EOF(YY_START());
	{Goto = do_action; break branch;}

    default:
	yyfatalerror(
		"fatal flex scanner internal error--no action found" );
	break;
} /* end of action switch */
if(yytokentype != null) {
    yylval.settokentype(yytokentype);
    yytext.getlexemelocation(yylval.location());
    if(yydebug >= 1) yyreport(yylval);	  
    return yytokentype;
} else {
    if(yydebug >= 10) yyout.println("@yylex@: no token produced");
}
} //branch
} /* end of scanning one token */
} /* end of yylex */

public
void
yy_push_state( int new_state )
{
    yy_start_stack.push(YY_START());
    BEGIN(new_state);
}

public
void
yy_pop_state()
{
    BEGIN(yy_start_stack.pop());
}

protected 
int
yy_top_state()
{
    return yy_start_stack.top();
}

protected
void
yyfatalerror( String msg) throws LexException
{
    throw new LexException("yylex: fatalerror: " + msg);
}

public
void
yylexerror(String s) throws LexException
{
    yyout.println("yylexerror: "
		    + "char/line+char "
		    + yytext.charno0()
		    + "/"
		    + yytext.lineno()
		    + "+"
		    + yytext.charno0()
		    + " ; "
		    + s);
    throw new LexException(s);
}

public
YYtoken
yyreport(YYtoken yylval)
{
    if(yylval != null) {
	yyout.println("yylex: "
		    + " char/line+char "
		    + yylval.charno0()
		    + "/"
		    + yylval.lineno()
		    + "+"
		    + yylval.charno()
		    + " /"
		    + YYtokentypes.tokenname(yylval.tokentype())
		    + "/(" + yylval.tokentype()
		    + ") ; text=#"
		    + yylval.text
		    + "#");
    } else {
	yyout.println("yylex: "
		    + " char/line+char "
		    + yytext.charno0()
		    + "/"
		    + yytext.lineno()
		    + "+"
		    + yytext.charno0()
		    + " /EOF/");
    }
    return yylval;
}

protected void BEGIN(int n) {yy_start = 1+2*n;}
public void yybegin(int n) {BEGIN(n);}
public int YY_START() {return (yy_start-1)/2;}
protected int YY_AT_BOL() {return (yy_at_bol)?1:0;}
protected int YY_STATE_EOF(int st) {return YY_END_OF_BUFFER + st + 1;}

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
protected int YY_SC_TO_UI(char c) {return (int)((short)c);}

public
void
yy_set_interactive(boolean is_interactive)
{
    this.is_interactive= is_interactive;
}

protected
void
yy_set_bol(boolean at_bol)
{
    yy_at_bol = at_bol;
}

// TABLES

@TABLES@

// SUFFIX

@SUFFIX@

public void setdebug(boolean d) {yydebug = d?1:0; yytext.setdebug(d);}
public void setdebug(int i) {yydebug = i>0?i:0; yytext.setdebug(i);}

public void yyreturn(Integer ttype) {yytokentype = ttype;}
public void yyreturn(int ttype) {
    if(ttype >= 0 && ttype < YYtokentypes.tokenmax) {
	yytokentype = YYtokentypes.Tokentype[ttype];
    } else {
	yytokentype = new Integer(ttype);
    }
}
public @StringBuffer@ yytext() {return yylval.text();}

// return 0 based line number
public int lineno() {return yytext.lineno();}

// return 0 based absolute char number
public int charno0() {return yytext.charno0();}

// return 0 based char number within line
public int charno() {return yytext.charno();}

} // class YYlex
