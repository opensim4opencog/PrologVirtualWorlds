// Copyright © 2000 Microsoft Corporation.  All rights reserved.
// In installing/viewing this source code, you agree to the terms of the
// Microsoft Research Source License (MSRSL) included in the root of this source tree
// and available from http://www.vworlds.org/license.asp.

// vwprop.idl : IDL source for vwobject.dll
//

// This file will be processed by the MIDL tool to
// produce the type library (vwobject.tlb) and marshalling code.

///////////////////////////////////////////////////////////////////////////////////////////////
// This file contains the interface definitions for:-
//
// IPropertySecurity:  Each property and method on an object has its own security slot 
// associate with it.  This interface contains the methods for accessing security permissions
// and flags relating to client/server remoting and logging.  If security is enabled,
// the CheckSecurity method will be called to ensure that the caller of a method or property
// change has access privileges.  Security permissions of read/write/execute/add are stored
// in  fields for instance, exemplar, or all privileges.  To control access policy on an 
// object-specific basis, you need to write an OnXXXAccess method that runs on both client and
// server, where XXX is the property name.
//
// IObjectProperty:  Base Virtual Worlds property.  IThing, collections such as IPropertyList
// and IPropertyMap, and specialitzed properties such as an IVector are all derived from this
// interface.  Contains basic information on object type, parent, world, etc. and base methods
// for marshalling that are overriden by specific implementations.
//
// IPropertyCollection.  Based on IObjectProperty.  Contains methods for iterating through
// a collection (either a property list or property map.)
//
// IPropertyList:  Based on IPropertyCollection. Array-like collection class with an integer 
// index and value pairts, Values can be any Variant. Contains methods for adding, finding, 
// and deleting values.
//
// IPropertyMap:  Based on IPropertyCollection. Collection class with key, value pairs.  
// The key is a string, and the value can be any Variant. Contains methods for adding, searching, 
// and deleting values.
//
// IThing:  Based on IObjectProperty. Base Virtual Worlds exemplar.  Contains information 
// such as owner, container, and property maps of properties and methods.  Also contains methods 
// to check security on properties and methods and their respective maps,  manage creation 
// and deletion of properties and methods, change the value of a property or method, and call
// a method.
//
// IModule: Base Virtual Worlds code module.  We support C++ COM modules and script modules 
// written in VBScript or JavaScript.  Contains methods to load, install, and call methods 
// with a module. Also contains properties to determine whether a module is run on client
// and or server.
//
// ICOMModule: Based on IModule.  Has additional properties for COM CLSID and ProgID.
//
// IScriptModule: Based on IModule.  Has additional property of the URL whether the script
// resides and a function to add inline script to a module.
//
// IMethod: Base Virtual Worlds method, based on IObjectProperty.  Contains information 
// on whether the method is run on  client and/or server, the actual code of the method,
// the parameters of the method, and a way to call the method.
//
// Note: In general, a method Foo follows these naming convention:
//	Foo				Script entry point
//	FooEx			Script entry point with extra parameter
//	FooExt			C++ internal method, usually restricted, has the ShouldExecute and ShouldRemote blocks
//	FooInt			C++ internal method not exposed by COM, generally called by FooExt's ShouldExecute block
//	FooIntHelper	C++ internal method not exposed by COM, called by FooInt, factors out functionality

///////////////////////////////////////////////////////////////////////////////////////////////

	interface IThing;
	interface IWorld;

	import "oaidl.idl";
	import "vwbuffer.idl";
	import "vwobject.idl";

	[
		object,
		uuid(590D9842-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IPropertySecurity Interface"),
		pointer_default(unique)
	]
	interface IPropertySecurity : IDispatch
	{
		// Bits
		const unsigned long PSBIT_NONE = 0x00000000;

		// copyonget is enabled by default for object properties
		const unsigned long PSBIT_COPYONGET = 0x00000001;

		// volatile props are not logged but are remoted
		const unsigned long PSBIT_VOLATILE = 0x00000002;

		// local props are logged but not remoted
		const unsigned long PSBIT_LOCAL = 0x00000004;

		// NOTE: you can combine both PSBIT_LOCAL and PSBIT_VOLATILE for properties that
		// are neither remoted not logged

		// more understandable enums...
		const unsigned long PSBIT_NOTLOGGED = PSBIT_VOLATILE;
		const unsigned long PSBIT_NOTREMOTED = PSBIT_LOCAL;

		// internal marshalling flag
		const unsigned long PSBIT_BYVAL = 0x00000008;

		// only marshal to the owning client
		const unsigned long PSBIT_OWNERONLY = 0x00000010;

		// internal flag to fire onpropchange/onpropaccess
		const unsigned long PSBIT_NOTIFYONCHANGE = 0x00000020;
		const unsigned long PSBIT_NOTIFYONACCESS = 0x00000040;

		// flag to help UI filtering (off by default)
		const unsigned long PSBIT_FRIENDLY = 0x00000080;

		// flag to help object browser filtering (off by default)
		// used to tell which props/methods shouldn't be doc'ed
		const unsigned long PSBIT_HIDDEN = 0x00000100;

		// flag to mark client only properties that are accessable to only the user
		const unsigned long PSBIT_CLIENTPROPERTY =  0x00000200;

		// Flag to mark internal props/methods (not for authoring) 
		// Used to mark properties as not SaveToScript :	
		//		InternallyAdded - AddProperty
		//		InternallySet - PutProperty
		const unsigned long PSBIT_INTERNALLYADDED = 0x00000400;
		const unsigned long PSBIT_INTERNALLYSET =   0x00000800;

		// denotes a constant property, don't show in object browser
		const unsigned long PSBIT_CONSTANT = 0x00001000;

		// enabled bit, settable through Enable()
		const unsigned long PSBIT_ENABLED = 0x01000000;
		const unsigned long PSMASK_ENABLED = 0xFF000000;

		// NOTE: PSBIT_SYSTEMOVERRIDE is within PSMASK_ENABLED on purpose so it's not user-settable
		const unsigned long PSBIT_SYSTEMOVERRIDE = 0x02000000;
		
		// Permissions
		const unsigned long PS_NONE = 0x00000000;

		const unsigned long PS_READ = 0x00000001;
		const unsigned long PS_WRITE = 0x00000002;
		const unsigned long PS_EXECUTE = 0x00000004;
		const unsigned long PS_ADD	  = 0x00000008;

		const unsigned long PS_OWNER = 0x00000001;
		const unsigned long PS_EXEMPLAR = 0x00000002;
		const unsigned long PS_ALL = 0x00000004;
	
		// Definitions for default security bootstrapping
		// R = read, W = write, E = execute (methods), A = Add (collections)

		// Some frequently used combinations
		const unsigned long PS_OWNER_R			= PS_READ;
		const unsigned long PS_OWNER_RW			= PS_READ | PS_WRITE;
		const unsigned long PS_OWNER_RWA		= PS_READ | PS_WRITE | PS_ADD;
		const unsigned long PS_OWNER_E			= PS_EXECUTE;
		const unsigned long PS_EXEMPLAR_R		= (PS_READ << 8);
		const unsigned long PS_EXEMPLAR_RW		= (PS_READ << 8) | (PS_WRITE << 8);
		const unsigned long PS_EXEMPLAR_RWA		= (PS_READ << 8) | (PS_WRITE << 8) | (PS_ADD << 8);
		const unsigned long PS_EXEMPLAR_E		= (PS_EXECUTE << 8);
		const unsigned long PS_ALL_R			= (PS_READ << 16);
		const unsigned long PS_ALL_RW			= (PS_READ << 16) | (PS_WRITE << 16);
		const unsigned long PS_ALL_RWA			= (PS_READ << 16) | (PS_WRITE << 16) | (PS_ADD << 16);
		const unsigned long PS_ALL_E			= (PS_EXECUTE << 16);

		// All Access Property: Owner R W, Exemplar R W, All R W
		// NOTE: needs an OnXXXAccess to manage policy
		const unsigned long PS_ALLACCESSPROPERTY = PS_OWNER_RW | PS_EXEMPLAR_RW | PS_ALL_RW;

		// No Access Property: No permissions
		const unsigned long PS_NOACCESSPROPERTY = PS_NONE;

		// All Execute Method: Owner R W, Exemplar R W, All R, E
		const unsigned long PS_ALLEXECUTEMETHOD = PS_OWNER_RWA | PS_EXEMPLAR_RWA | PS_ALL_R | PS_OWNER_E | PS_EXEMPLAR_E | PS_ALL_E;

		// Global System Constant: All Access, NotLog, NotRem, CopyOnGet, IntAdd
		// NOTE: needs an OnGlobalConstantAccess method to prevent changes
		const unsigned long PS_GLOBALSYSTEMCONSTANT = PS_ALLACCESSPROPERTY;
		const unsigned long PSBIT_GLOBALSYSTEMCONSTANT = PSBIT_COPYONGET | PSBIT_INTERNALLYADDED | PSBIT_CONSTANT;

		// Global Default Method:  Owner R W A E, Exemplar R W E, All R E, IntAdd, IntSet
		const unsigned long PS_GLOBALDEFAULTMETHOD = PS_OWNER_RWA | PS_EXECUTE | PS_EXEMPLAR_RW | (PS_EXECUTE << 8) | PS_ALL_R | PS_ALL_E;
		const unsigned long PSBIT_GLOBALDEFAULTMETHOD = PSBIT_INTERNALLYADDED | PSBIT_INTERNALLYSET;

		// World Owner Property: All Access
		// NOTE: needs OnWorldOwnerAccess method to manage world owner policy)
		const unsigned long PS_WORLDOWNERPROPERTY = PS_ALLACCESSPROPERTY;
		const unsigned long PSBIT_WORLDOWNERPROPERTY = PSBIT_COPYONGET | PSBIT_INTERNALLYADDED;

		// World Owner Collection: Owner R W A, Exemplar R, All R
		const unsigned long PS_WORLDOWNERCOLLECTION = PS_OWNER_RWA | (PS_READ << 8) | (PS_READ << 16);

		// System Property: Owner R W, Exemplar R W, All R
		const unsigned long PS_SYSTEMPROPERTY = PS_OWNER_RW | PS_EXEMPLAR_RW | PS_ALL_R;
		const unsigned long PSBIT_SYSTEMPROPERTY = PSBIT_COPYONGET | PSBIT_INTERNALLYADDED;

		// NOTE: if writing Global property OnXXXChanged or OnXXXAccess handler, 
		// need to use PS_ALLEXECUTEMETHOD not PS_EVENTHANDLER

		// Event Handler: Owner R E, Exemplar R E, All R, InternallyAdded + Hidden
		const unsigned long PS_EVENTHANDLER = PS_READ | PS_EXECUTE | (PS_READ << 8) | (PS_EXECUTE << 8) | PS_ALL_R;
		const unsigned long PSBIT_EVENTHANDLER = PSBIT_INTERNALLYADDED /* | PSBIT_HIDDEN */;

		// System Event Handler: For OnSystemXXX handlers, Internally Added + InternallySet + Hidden
		// NOTE: May use PS_EVENTHANDLER or PS_ALLEXECUTE, depending on the method
		const unsigned long PSBIT_SYSTEMEVENTHANDLER = PSBIT_INTERNALLYADDED | PSBIT_INTERNALLYSET | PSBIT_HIDDEN;

		// Exemplar Default Collection: Owner R W A, Exemplar R W A, All R
		const unsigned long PS_EXEMPLARDEFAULTCOLLECTION = PS_OWNER_RWA | PS_EXEMPLAR_RWA | PS_ALL_R;

		// Exemplar Default Property: Owner R W A, Exemplar R W, All R, IntAdd
		const unsigned long PS_EXEMPLARDEFAULTPROPERTY = PS_OWNER_RWA | PS_EXEMPLAR_RW | PS_ALL_R;
		const unsigned long PSBIT_EXEMPLARDEFAULTPROPERTY = PSBIT_COPYONGET | PSBIT_INTERNALLYADDED;

		// Exemplar Default Method: Owner R W E, Exemplar R W E, All R, Internally Added
		const unsigned long PS_EXEMPLARDEFAULTMETHOD = PS_OWNER_RWA | PS_EXECUTE | PS_EXEMPLAR_RW | (PS_EXECUTE << 8) | PS_ALL_R;
		const unsigned long PSBIT_EXEMPLARDEFAULTMETHOD = PSBIT_INTERNALLYADDED;

		// Script Default Collection: Owner R W A, Exemplar R W A, All R
		const unsigned long PS_SCRIPTDEFAULTCOLLECTION = PS_EXEMPLARDEFAULTCOLLECTION;
		
		// Script Default Property: Owner R W, Exemplar R W, All R, No internally added for property, collection, method
		const unsigned long PS_SCRIPTDEFAULTPROPERTY = PS_EXEMPLARDEFAULTPROPERTY;
		const unsigned long PSBIT_SCRIPTDEFAULTPROPERTY = PSBIT_COPYONGET;

		// Script Default Method: Owner R W E, Exemplar R W E, All R E,
		const unsigned long PS_SCRIPTDEFAULTMETHOD = PS_EXEMPLARDEFAULTMETHOD;
		const unsigned long PSBIT_SCRIPTDEFAULTMETHOD = PSBIT_NONE;

		[restricted, helpstring("Initialize new property security with world, instance, exemplar, and copy pSecurity")] 
		HRESULT Initialize([in] IWorld *pWorld, [in] IThing* pExemplar, [in] IPropertySecurity* pSecurity);

		[restricted, helpstring("Clears values in security slot")] 
		HRESULT Cleanup();

		[propget, helpstring("Get world the security slot is attached to")] 
		HRESULT World([out, retval] IWorld** ppworld);
		[restricted, propput, helpstring("Internal method to set the world the security slot is attached to")] 
		HRESULT World([in] IWorld* pworld);

		// the exemplar where it is defined
		[propget, helpstring("Get exemplar that the security slot is defined on")] 
		HRESULT Exemplar([out, retval] IThing** ppExemplar);
		[restricted, propput, helpstring("Internal methd to set the exemplar the security slot to attached to")] 
		HRESULT Exemplar([in] IThing* pExemplar);

		// the instance to which it is attached.
		[propget, helpstring("Get the specifid instance which the security slot is attached to")] 
		HRESULT Instance([out, retval] IThing** ppInstance);
		[restricted, propput, helpstring("")] 
		HRESULT Instance([in] IThing* pInstance);

		// get/put property 
		[propget, helpstring("Checks security getting a property from a collection, returns VWOBJECT_E_PERMISSION_DENIED if caller doesn't have permission to access")] 
		HRESULT Property([out, retval] VARIANT* pvar);
		[propput, helpstring("Checks security adding property to a collection, updates references, etc. Returns VWOBJECT_E_PERMISSION_DENIED if caller doesn't have permission to access.")] 
		HRESULT Property([in] VARIANT var);

		[propget, helpstring("Returns pointer to security permission bits")] 
		HRESULT Permissions([out, retval] long* ulFlags); 
		[restricted, propput, helpstring("If caller has permission to set security bits, sets them, otherwise returnsVWOBJECT_E_PERMISSION_DENIED.")] 
		HRESULT Permissions([in] long ulFlags);

 		[propget, helpstring("Gets flags for determining client/server and logging behavior of a property/method")] 
		HRESULT Bits([out, retval] long *bits);
		[restricted, propput, helpstring("Checks security and sets flags for determining client/server and logging behavior of a property/method")] 
		HRESULT Bits([in] long bits);

		[propget, helpstring("Gets whether bits are PSBIT_MASKENABLED")] 
		HRESULT BitState([in] long bits, [out, retval] VARIANT_BOOL* bSet);
		[restricted, propput, helpstring("Sets whether client/server flags contain bits in the parameter bits")] 
		HRESULT BitState([in] long bits, [in] VARIANT_BOOL bSet);

		[propget, helpstring("Gets variant type")] 
		HRESULT vtType([out, retval] unsigned short *vartype);
		[restricted, propput, helpstring("Sets variant type")] 
		HRESULT vtType([in] unsigned short vartype);

		[propget, helpstring("Returns string associated with the IID of COM object")] 
		HRESULT PropertyIID([out, retval] BSTR* pbstrIID);
		[restricted, propput, helpstring("Sets string associated with the IID of COM object")] 
		HRESULT PropertyIID([in] BSTR bstrIID);

		// actual IID of COM object property
		// To be consistent w/ IObject::get_CLSID use IID* for out, REFIID for in
		[restricted, propget, helpstring("Does a memcopy of IID of COM object property into piid")] 
		HRESULT PropertyIIDExt([out, retval] IID* piid);
		[restricted, propput, helpstring("Does a memcopy of riid into IID of COM object property")] 
		HRESULT PropertyIIDExt([in] REFIID riid);

		// ObjectProperty Type
		[propget, helpstring("Gets the name of a property type and returns it as a string")] 
		HRESULT PropertyType([out, retval] BSTR* bstrType);
		[restricted, propput, helpstring("Sets the name of a property type as a string")] 
		HRESULT PropertyType([in] BSTR bstrType);

		// property marshalling/unmarshalling
		[restricted, helpstring("Write data on security slot into buffer for copying/remoting between client and server.")] 
		HRESULT Marshall([in] DWORD dwOptions, [in] IMarshallBuffer* pmarshallbuffer);
		[restricted, helpstring("Read security slot data from a buffer")] 
		HRESULT UnMarshall([in] IUnMarshallBuffer* punmarshallbuffer);

		[restricted, helpstring("Not used.")] 
		HRESULT ChangeMode([in] BSTR bstrMode);
		[restricted, helpstring("Not used.")] 
		HRESULT QueryMode([in] BSTR bstrGroup, [in] BSTR bstrPermission, [out, retval] VARIANT_BOOL* bPermitted);
		
		// Note: See extensive comment in propsecu.cpp on how security policy is checked
		[restricted, helpstring("The guts of security bit-checking: checks whether the caller has access to the particular property or method that is being accessed")] 
		HRESULT CheckSecurity([in] unsigned long ulFlags, [in] VARIANT_BOOL bQuiet, [out, retval] VARIANT_BOOL* pbSuccess);

		[restricted, helpstring("Copy a security slot")] 
		HRESULT CopyPermission([in] IPropertySecurity *pFrom);
		
		[restricted, helpstring("Enable bits with PSBIT_ENABLED.")] 
		HRESULT Enable();
	};
	
	[
		object,
		uuid(590D9840-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IObjectProperty Interface"),
		pointer_default(unique)
	]

	interface IObjectProperty : IDispatch
	{
const DISPID DISPID_PROPERTY_TYPE = 100;

		[restricted, helpstring("")] 
		HRESULT Terminate(void);

		// debugging support
		[hidden, propget, helpstring("")] 
		HRESULT RefCount([out, retval] DWORD *pdwRef);

		// actual CLSID of COM object property
		[restricted, propget, helpstring("Returns base CLSID")] 
		HRESULT CLSID([out, retval] CLSID* pclsid);

		[restricted, propget, helpstring("Returns base IID")]
		HRESULT IID([out,retval] IID* piid);

		[propget, helpstring("Gets world the property is attached to")] 
		HRESULT World([out, retval] IWorld** ppworld);
		[restricted, propput, helpstring("Sets world the property is attached to")] 
		HRESULT World([in] IWorld* pworld);

		[restricted, propget, helpstring("Gets the Thing the property is attached to")] 
		HRESULT Parent([out, retval] IThing** ppthing);
		[restricted, propput, helpstring("Sets the Thing the property is attached to")] 
		HRESULT Parent([in] IThing* pthing);

		// name of property in parent
		[restricted, propget, helpstring("Gets the name of the property ")] 	
		HRESULT PropertyName([out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Sets the name of the property")] 
		HRESULT PropertyName([in] BSTR bstr);

		// NOTE: propput can't be restricted because it needs to be called from automation

		// get/put type of property (string value)
		[propget, helpstring("Gets the type of property (Avatar, etc.)"), id(DISPID_PROPERTY_TYPE)] 
		HRESULT Type([out, retval] BSTR* pbstr);
		[propput, helpstring("Sets the type of property (Avatar, etc.)"), id(DISPID_PROPERTY_TYPE)] 
		HRESULT Type([in] BSTR bstr);

		[hidden, propget, helpstring("Internal method to get the associated security slot - see IPropertySecurity.")] 
		HRESULT Security([out, retval] IPropertySecurity** ppSecurity);
		[restricted, propput, helpstring("Internal method to set the associated security slot- see IPropertySecurity.")] 
		HRESULT Security([in] IPropertySecurity* pSecurity);

		// check if property is of type
		[helpstring("Checks if an object is a stub first, and if not, compares string value to see if a particular type (Avatar, etc.).")] 
		HRESULT IsOfType([in] BSTR bstr, [out, retval] VARIANT_BOOL* pbool);

		// format ASCII version of property
		[helpstring("Converts property to string for tracing purposes")] 
		HRESULT ToAscii([out, retval] BSTR* pbstr);

		// dump human-readable form of property to debugger 
		[hidden, helpstring("Dump human-readable form of property to debugger")] 
		HRESULT Dump();

		[restricted, helpstring("Create a copy of an IObjectProperty")]
		HRESULT Clone([in] IObjectProperty* pobjectproperty);

		// property marshalling/unmarshalling
		[restricted, helpstring("Write data into buffer for copying/remoting between client and server.")] 
		HRESULT Marshall([in] DWORD dwOptions, [in] IMarshallBuffer* pmarshallbuffer);
		[restricted, helpstring("Read data from a buffer")] 
		HRESULT UnMarshall([in] IUnMarshallBuffer* punmarshallbuffer);

		[restricted, helpstring("Implemented by various interfaces IThing, IPropertyList, etc. derived from IObjectProperty to write out object state to text script.")]
		HRESULT MarshallToScript([in] DWORD dwOptions, [in] BSTR bstrContext, [out] VARIANT_BOOL *pbAsVal, [out] BSTR *pbstrOut);
	};


	[
		object,
		uuid(590D9844-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IPropertyCollection Interface"),
		pointer_default(unique)
	]
	interface IPropertyCollection : IObjectProperty
	{
		[propget, helpstring("Check if collection is empty")] 
		HRESULT IsEmpty([out, retval] VARIANT_BOOL* pbool);

		[propget, helpstring("Returns number of items in the collection")] 
		HRESULT Count([out, retval] long* retval);		
		
		///////////////////////////////////////////////////////////////////////////////////////////////
		// Interating through a collection:
		//	Get the first item in the collection with FirstItem
		//	If pbool is TRUE, it is the only item, do processing.
		//	Otherwise, while pbool is FALSE,
		//		get the value, do processing, then do a NextItem
		///////////////////////////////////////////////////////////////////////////////////////////////

		// for lists, name will not be returned
		// pbool will be TRUE if item is last in collection		
		[restricted, helpstring("")] 
		HRESULT FirstItem([out] BSTR* name, [out] VARIANT* pvar, [out, retval] VARIANT_BOOL* pbool);
		[restricted, helpstring("")] 
		HRESULT NextItem([out] BSTR* name, [out] VARIANT* pvar, [out, retval] VARIANT_BOOL* pbool);

		// for enumeration support
		[restricted, propget, helpstring("Gets a value at a particular index")]
		HRESULT PropertyAtIndex([in] long index, [out, retval] VARIANT *pvar);

		[propget, helpstring("Helper function to create a new enumerator. Not used."), hidden, id(DISPID_NEWENUM)]
		HRESULT _NewEnum([out, retval] IUnknown** ppunk);
	};

	[
		object,
		uuid(590D9846-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IPropertyList Interface"),
		pointer_default(unique)
	]
	interface IPropertyList : IPropertyCollection
	{
const DISPID DISPID_PROPERTYLIST_ADD = 101;
const DISPID DISPID_PROPERTYLIST_PROPERTY = 102;
const DISPID DISPID_PROPERTYLIST_REMOVE = 103;
const DISPID DISPID_PROPERTYLIST_REMOVEAT = 104;
const DISPID DISPID_PROPERTYLIST_REMOVEALL = 105;
const DISPID DISPID_PROPERTYLIST_INSERTAT = 106;

		[helpstring("Adds a new property var to the end of the property list"), id(DISPID_PROPERTYLIST_ADD)] 
		HRESULT Add([in] VARIANT var);

		[helpstring("Inserts a new property var at index in a property list"), id(DISPID_PROPERTYLIST_INSERTAT)] 
		HRESULT InsertAt([in] long index, [in] VARIANT var);

		[propget, helpstring("Gets the property at index"), id(DISPID_PROPERTYLIST_PROPERTY)] 
		HRESULT Property([in] long index, [out, retval] VARIANT* pvar);
		[propput, helpstring("Sets the property at index"), id(DISPID_PROPERTYLIST_PROPERTY)] 
		HRESULT Property([in] long index, [in] VARIANT var);

		[hidden, propget, helpstring("Gets the security slot for the property at index")] 
		HRESULT PropertySecurity([in] long index, [out, retval] IPropertySecurity** ppSecurity);
			
		[helpstring("Removes var from property list"), id(DISPID_PROPERTYLIST_REMOVE)] 
		HRESULT Remove([in] VARIANT var);
		[helpstring("Removes property at index from property list"), id(DISPID_PROPERTYLIST_REMOVEAT)] 
		HRESULT RemoveAt([in] long index);

		[helpstring("Removes all items from a property list"), id(DISPID_PROPERTYLIST_REMOVEALL)] 
		HRESULT RemoveAll();

		// returns index of property in list
		[helpstring("Finds a property var and returns its index.  Returns -1 if not found.")] 
		HRESULT Find([in] VARIANT var, [out, retval] long* plval);

		// helper functions for C++
		[restricted, helpstring("Helper function to add a property of type string to a property list ")] 
		HRESULT AddString([in] BSTR bstr);
		[restricted, helpstring("Helper function to add an IObjectProperty to a property list ")] 
		HRESULT AddObjectProperty([in] IObjectProperty* pobjectproperty);
		[restricted, helpstring("Helper function to add an IObjectProperty with specified IID to a property list ")] 
		HRESULT AddObjectPropertyExt([in] REFIID iid, [in] IObjectProperty* pobjectproperty);
		[restricted, helpstring("Helper function to add a property of type IThing to a property list ")] 
		HRESULT AddThing([in] IThing* pthing);
		[restricted, helpstring("Helper function to add a boolean property to a property list ")] 
		HRESULT AddBOOL([in] VARIANT_BOOL boolVal);
		[restricted, helpstring("Helper function to add a property of type long to a property list ")] 
		HRESULT AddLong([in] long lval);
		[restricted, helpstring("Helper function to add a property of type short to a property list ")] 
		HRESULT AddShort([in] short sval);
		[restricted, helpstring("Helper function to add a property of type IDispatch to a property list ")] 
		HRESULT AddDispatch([in] IDispatch* pdisp);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a string at a particular index")] 
		HRESULT String([in] long index, [out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Internal helper function to set a string at a particular index")] 
		HRESULT String([in] long index, [in] BSTR bstr);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get an object property at a particular index")] 
		HRESULT ObjectProperty([in] long index, [out, retval] IObjectProperty** ppobjectproperty);
		[restricted, propput, helpstring("Internal helper function to set an object property at a particular index")] 
		HRESULT ObjectProperty([in] long index, [in] IObjectProperty* pobjectproperty);

		// specify the desired IID to check, return error if QI fails
		[restricted, propget, helpstring("")] 
		HRESULT ObjectPropertyExt([in] long index, [in] REFIID iid, [out, retval] IObjectProperty** ppobjectproperty);
//		[restricted, propput, helpstring("")] 
//		HRESULT ObjectPropertyExt([in] long index, [in] REFIID iid, [in] IObjectProperty* pobjectproperty);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a Thing at a particular index")] 
		HRESULT Thing([in] long index, [out, retval] IThing** ppthing);
		[restricted, propput, helpstring("Internal helper function to set a Thing at a particular index")] 
		HRESULT Thing([in] long index, [in] IThing* pthing);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a boolean valueat a particular index")] 
		HRESULT BOOL([in] long index, [out, retval] VARIANT_BOOL* pboolVal);
		[restricted, propput, helpstring("Internal helper function to set a boolean value at a particular index")] 
		HRESULT BOOL([in] long index, [in] VARIANT_BOOL boolVal);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a long at a particular index")] 
		HRESULT Long([in] long index, [out, retval] long* plval);
		[restricted, propput, helpstring("Internal helper function to set a long at a particular index")] 
		HRESULT Long([in] long index, [in] long lval);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get an IDispatch at a particular index")] 
		HRESULT Dispatch([in] long index, [out, retval] IDispatch** ppdisp);
		[restricted, propput, helpstring("Internal helper function to set an IDispatch at a particular index")] 
		HRESULT Dispatch([in] long index, [in] IDispatch* pdisp);

		// helper functions for C++
		[restricted, helpstring("Internal helper function to add a string at a specific index")] 
		HRESULT InsertStringAt([in] long index, [in] BSTR bstr);
		[restricted, helpstring("Internal helper function to add an IObjectProperty at a specific index")] 
		HRESULT InsertObjectPropertyAt([in] long index, [in] IObjectProperty* pobjectproperty);
		[restricted, helpstring("Internal helper function to add a property of type IThing  in a specific index")] 
		HRESULT InsertThingAt([in] long index, [in] IThing* pthing);
		[restricted, helpstring("Internal helper function to add a boolean value at a specific index")] 
		HRESULT InsertBOOLAt([in] long index, [in] VARIANT_BOOL boolVal);
		[restricted, helpstring("Internal helper function to add a long in a specific index")] 
		HRESULT InsertLongAt([in] long index, [in] long lval);
		[restricted, helpstring("Internal helper function to add a short at a specific index")] 
		HRESULT InsertShortAt([in] long index, [in] short sval);
		[restricted, helpstring("Internal helper function to add a property of IDispatch at a specific index")] 
		HRESULT InsertDispatchAt([in] long index, [in] IDispatch* pdisp);

		// helper functions for C++
		[restricted, helpstring("Internal helper function to delete a string")] 
		HRESULT RemoveString([in] BSTR bstr);
		[restricted, helpstring("Internal helper function to delete an object property ")] 
		HRESULT RemoveObjectProperty([in] IObjectProperty* pobjectproperty);
		[restricted, helpstring("Internal helper function to delete a Thing ")] 
		HRESULT RemoveThing([in] IThing* pthing);
		[restricted, helpstring("Internal helper function to delete a boolean value")] 
		HRESULT RemoveBOOL([in] VARIANT_BOOL boolVal);
		[restricted, helpstring("Internal helper function to delete a long")] 
		HRESULT RemoveLong([in] long lval);
		[restricted, helpstring("Internal helper function to delete a short")] 
		HRESULT RemoveShort([in] short sval);
		[restricted, helpstring("Internal helper function to delete an IDispatch object ")] 
		HRESULT RemoveDispatch([in] IDispatch* pdisp);

		[helpstring("Copy the current property list into the the parameter ppropertylist")] 
		HRESULT CopyTo([in] IPropertyList* ppropertylist);
	};

	[
		object,
		uuid(590D9848-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IPropertyMap Interface"),
		pointer_default(unique)
	]
	interface IPropertyMap : IPropertyCollection
	{
const DISPID DISPID_PROPERTYMAP_PROPERTY = 101;
const DISPID DISPID_PROPERTYMAP_REMOVE = 102;
const DISPID DISPID_PROPERTYMAP_REMOVEALL = 103;

		// get/put property by name
		[propget, helpstring("Get a property pvar with key bstrName"), id(DISPID_PROPERTYMAP_PROPERTY)] 
		HRESULT Property([in] BSTR bstrName, [out, retval] VARIANT* pvar);
		[propput, helpstring("Add a property pvar with key bstrName"), id(DISPID_PROPERTYMAP_PROPERTY)] 
		HRESULT Property([in] BSTR bstrName, [in] VARIANT var);

		[restricted, propget, helpstring("Internal method to get a property once hash key has been computed")] 
		HRESULT PropertyExt([in] BSTR bstrName, [in] UINT nHashOrig, [out, retval] VARIANT* pvar);

		[restricted, propput, helpstring("Internal method called from put_Property's execute block, checks Security before doing put")] 
		HRESULT PropertyInt([in] BSTR bstrName, [in] VARIANT var, [in] IPropertySecurity* pSecurity);
		
		// get property security by name
		[hidden, propget, helpstring("Gets property security for a property by name")] 
		HRESULT PropertySecurity([in] BSTR bstrName, [out, retval] IPropertySecurity **ppSecurity);
		[restricted, propget, helpstring("Internal method to get a property's security slot once hash key has been computed")] 
		HRESULT PropertySecurityExt([in] BSTR bstrName, [in] UINT nHashOrig, [out, retval] IPropertySecurity **ppSecurity);

		[helpstring("Deletes key,value pair with a key of bstrName"), id(DISPID_PROPERTYMAP_REMOVE)] 
		HRESULT Remove([in] BSTR bstrName);

		[restricted, helpstring("Internal method called from Remove's execute block, checks Security before doing delete")] 
		HRESULT RemoveInt([in] BSTR bstrName);

		[helpstring("Deletes all key, value pairs in a property map"), id(DISPID_PROPERTYMAP_REMOVEALL)] 
		HRESULT RemoveAll();

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a string value pbstr with key bstrName")] 
		HRESULT String([in] BSTR bstrName, [out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Internal helper function to set a string value pbstr with key bstrName")] 
		HRESULT String([in] BSTR bstrName, [in] BSTR bstr);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get an object property with key bstrName")] 
		HRESULT ObjectProperty([in] BSTR bstrName, [out, retval] IObjectProperty** ppobjectproperty);
		[restricted, propput, helpstring("Internal helper function to set an object proeprty with key bstrName")] 
		HRESULT ObjectProperty([in] BSTR bstrName, [in] IObjectProperty* pobjectproperty);

		// specify the desired IID to check, return error if QI fails
		[restricted, propget, helpstring("")] 
		HRESULT ObjectPropertyExt([in] BSTR bstrName, [in] REFIID iid, [out, retval] IObjectProperty** ppobjectproperty);
//		[restricted, propput, helpstring("")] 
//		HRESULT ObjectPropertyExt([in] BSTR bstrName, [in] REFIID iid, [in] IObjectProperty* pobjectproperty);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a Thing with key bstrName")] 
		HRESULT Thing([in] BSTR bstrName, [out, retval] IThing** ppthing);
		[restricted, propput, helpstring("Internal helper function to set a Thing with key bstrName")] 
		HRESULT Thing([in] BSTR bstrName, [in] IThing* pthing);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a boolean value with key bstrName")] 
		HRESULT BOOL([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pboolVal);
		[restricted, propput, helpstring("Internal helper function to set a boolean value with key bstrName")] 
		HRESULT BOOL([in] BSTR bstrName, [in] VARIANT_BOOL boolVal);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a long with key bstrName")] 
		HRESULT Long([in] BSTR bstrName, [out, retval] long* plval);
		[restricted, propput, helpstring("Internal helper function to set a long with key bstrName")] 
		HRESULT Long([in] BSTR bstrName, [in] long lval);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get a short with key bstrName")] 
		HRESULT Short([in] BSTR bstrName, [out, retval] short* psval);
		[restricted, propput, helpstring("Internal helper function to set a short with key bstrName")] 
		HRESULT Short([in] BSTR bstrName, [in] short sval);

		// helper functions for C++
		[restricted, propget, helpstring("Internal helper function to get an IDisptch* with key bstrName")] 
		HRESULT Dispatch([in] BSTR bstrName, [out, retval] IDispatch** ppdisp);
		[restricted, propput, helpstring("Internal helper function to set an IDispatch* with key bstrName")] 
		HRESULT Dispatch([in] BSTR bstrName, [in] IDispatch* pdisp);

		// is property valid?
		[helpstring("Checks if property exists in map")] 
		HRESULT IsValid([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pbool);

		[helpstring("Copies propertymap to ppropertymap")] 
		HRESULT CopyTo([in] IPropertyMap* ppropertymap);
	};



	[
		object,
		uuid(590D9852-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IThing Interface"),
		pointer_default(unique)
	]
	interface IThing : IObjectProperty
	{
const DISPID DISPID_THING_ADDPROPERTYINT = 101;
const DISPID DISPID_THING_REMOVEPROPERTY = 102;
const DISPID DISPID_THING_PROPERTY = 103;
const DISPID DISPID_THING_ADDMETHODINT = 104;
const DISPID DISPID_THING_REMOVEMETHOD = 105;
const DISPID DISPID_THING_METHOD = 106;
const DISPID DISPID_THING_INVOKEMETHODINT = 107;
const DISPID DISPID_THING_FIREEVENTINT = 108;
//const DISPID DISPID_THING_FINDWITHININT = 109;
const DISPID DISPID_THING_EXEMPLARINT = 110;
const DISPID DISPID_THING_MOVEINTOINT = 111;
const DISPID DISPID_THING_REMOTEPROPERTY = 112;
const DISPID DISPID_THING_INSTANCEPROPERTY = 113;
const DISPID DISPID_THING_TYPEINT = 114;
const DISPID DISPID_THING_OWNERINT = 115;
const DISPID DISPID_THING_ISSTUBINT = 116;

		// NOTE: remember to update CWorldObject::SendThingCommandExt when adding non-replicated methods

		const unsigned long FIREEVENT_SELF = 0x00000001;
		const unsigned long FIREEVENT_CONTAINER = 0x00000002;
		const unsigned long FIREEVENT_CONTENT = 0x00000004;
		const unsigned long FIREEVENT_PEER = 0x00000008;

		const unsigned long FIREEVENT_DEFAULT = 0x0000000f;

		// get/put object ID
		[hidden, propget, helpstring("Gets object's unique ID (numbering starts with Global at 1)")] 
		HRESULT ID([out, retval] long* id);
		[restricted, propput, helpstring("Used by system to assign a unique ID to a Thing")] 
		HRESULT ID([in] long id);

#if 0
		// Methods to get the date a thing is created, last modified, and last accessed
		[propget, helpstring("")]
		HRESULT CreatedDate([out, retval] DATE* pdate);
		[propget, helpstring("")]
		HRESULT ModifiedDate([out, retval] DATE* pdate);
		[propget, helpstring("")]
		HRESULT AccessedDate([out, retval] DATE* pdate);
#endif

		[restricted, propget, helpstring("Returns a string with the instance type")] 
		HRESULT InstanceType([out, retval] BSTR* pbstr);

		[propget, helpstring("Helper method to determine if an Thing is an exemplar")] 
		HRESULT IsExemplar([out, retval] VARIANT_BOOL* pbool);

		[restricted, propget, helpstring("Internal helper method to determine if a Thing is a wizard")] 
		HRESULT IsWizard([out, retval] VARIANT_BOOL* pbool);

		// logged, but not remoted entrypoint
		[hidden, propput, helpstring("System method to set type of object - e.g., Global or exemplar name"), id(DISPID_THING_TYPEINT)]
		HRESULT TypeInt([in] BSTR bstr);

		[hidden, propput, helpstring("System method to set owner of a thing (the avatar that creates the thing.)"), id(DISPID_THING_OWNERINT)]
		HRESULT OwnerInt([in] IThing* pThing);

		[propget, helpstring("Helper method to determine if an object is a stub (has not been completely remoted to client or has been deleted)")] 
		HRESULT IsStub([out, retval] VARIANT_BOOL* pbool);

		// logged, but not remoted entrypoint
		[hidden, propput, helpstring("System method to set Thing to be a stub.  Used during object creation and deletion."), id(DISPID_THING_ISSTUBINT)] 
		HRESULT IsStubInt([in] VARIANT_BOOL boolval);

		// get/put exemplar of object
		[propget, helpstring("Get Thing's exemplar")] 
		HRESULT Exemplar([out, retval] IThing** ppthing);

		// put exemplar
		[hidden, propput, helpstring("System method to set Things' exemplar.  Logged and remoted.  Currently only used to change avatars into hosts"), id(DISPID_THING_EXEMPLARINT)] 
		HRESULT ExemplarInt([in] IThing* pthing);
						   
		// find object by name within a containing object (walks contents recursively)
		[helpstring("Find object by name within a containing object, e.g., a room (walks contents recursively)")]
		HRESULT FindWithin([in] BSTR bstrName, [in, optional, defaultvalue(0)] VARIANT varQuiet, [out, retval] IThing** ppthing);

		// Move object into a container
		[restricted, helpstring("Internal method to change a thing's container.  Has the ShouldExecute, ShouldRemote blocks and calls MoveIntoInt to do work.")]
		HRESULT MoveIntoExt([in] IThing* pthing);
		[hidden, helpstring("Internal method to change a thing's container to pthing and fire appropriates methods, remote change, etc."), id(DISPID_THING_MOVEINTOINT)]
		HRESULT MoveIntoInt([in] IThing* pthing);

#if 0
		// assign ownership of an object to another user
		[restricted, helpstring("")]
		HRESULT GiveExt([in] IThing* pthingWhat, [in] IThing* pthingWho);
		[hidden, helpstring(""), id(DISPID_THING_GIVEINT)]
		HRESULT GiveInt([in] IThing* pthingWhat, [in] IThing* pthingWho);
#endif

		// valid property?
		[helpstring("Check if property with bstrName exists on Thing instance or exemplar, returns TRUE if so")] 
		HRESULT IsValidProperty([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pbool);
		[helpstring("Check if  property with bstrName exists on Thing instance, returns TRUE if so")] 
		HRESULT IsValidInstanceProperty([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pbool);

		// helper to create and add new properties
		[hidden, helpstring("Helper function to create and add a new property using a ProgID. Not used.")] 
		HRESULT CreateAndAddProperty([in] BSTR bstrProgID, [in] BSTR bstrName, [in, optional] VARIANT var);

		// add/remove property
		[helpstring("Adds a property with bstrName and value var to an object.  Optionally, can specify security permissions and client/server flags. Calls AddPropertyInt.")] 
		HRESULT AddProperty([in] BSTR bstrName, [in, optional] VARIANT var, [in, optional, defaultvalue(PSBIT_SCRIPTDEFAULTPROPERTY)] VARIANT flags, 
			[in, optional, defaultvalue(PS_SCRIPTDEFAULTPROPERTY)] VARIANT permission, [in, optional, defaultvalue(VT_VARIANT)] VARIANT type,
			[in, optional, defaultvalue("")] BSTR bstrIID, [in, optional, defaultvalue("")] BSTR bstrType);
		[restricted, helpstring("Internal C++ entry point for calling AddPropertyINt")] 
		HRESULT AddPropertyExt([in] BSTR bstrName, [in] VARIANT var, [in] long flags, 
			[in] long perms, [in] long type, [in] REFIID riid, [in] BSTR bstrType);
		[hidden, helpstring("Adds a property - has ShouldExecute/Should Remote bloks.  Calls AddPropertyIntHelper to validate name, check security, do a put_Property."), id(DISPID_THING_ADDPROPERTYINT)]
		HRESULT AddPropertyInt([in] BSTR bstrName, [in] VARIANT var, [in] IThing* pExemplar, 
			[in] long psbits, [in] long perms, [in] long type, [in] BSTR bstrIID, [in] BSTR bstrType);
		
		[helpstring("Removes a property of bstrName from things's property map.  Does not allow removing of internally added properties."), id(DISPID_THING_REMOVEPROPERTY)] 
		HRESULT RemoveProperty([in] BSTR bstrName);

		[hidden, propget, helpstring("On client, gets a property that only exists on server using synchronous call (use with caution as this will lock the client waiting for a return value from the server."), id(DISPID_THING_REMOTEPROPERTY)] 
		HRESULT RemoteProperty([in] BSTR bstrName, [out, retval] VARIANT* pvar);

		// get/put property by name
		[propget, helpstring("Gets a property of bstrName"), id(DISPID_THING_PROPERTY)] 
		HRESULT Property([in] BSTR bstrName, [out, retval] VARIANT* pvar);
		[propput, helpstring("Sets a property of bstrName"), id(DISPID_THING_PROPERTY)] 
		HRESULT Property([in] BSTR bstrName, [in] VARIANT var);

		// get property and exemplar where attached
		[restricted, propget, helpstring("Internal method to get a property and exemplar once hash value has been computer.")] 
		HRESULT PropertyExt([in] BSTR bstrName, [in] UINT nHashOrig, [out] IThing** ppexemplar, [out, retval] VARIANT* pvar);

		// can't have put_PropertyExt because signature is different from get_PropertyExt
//		[restricted, propput, helpstring("")] 
//		HRESULT PropertyExt([in] BSTR bstrName, [in] UINT nHashOrig, [in] VARIANT var);

		// instance a COPYONGET property
		[hidden, helpstring("Called from get_Property to instance a particular property"), id(DISPID_THING_INSTANCEPROPERTY)]
		HRESULT InstanceProperty([in] BSTR bstrName, [in] IThing* pExemplar);

		// get property security by name
		[hidden, propget, helpstring("")] 
		HRESULT PropertySecurity([in] BSTR bstrName, [out, retval] IPropertySecurity** ppSecurity);
		[restricted, propget, helpstring("")] 
		HRESULT PropertySecurityExt([in] BSTR bstrName, [in] UINT nHashOrig, [out] IThing** ppexemplar, [out] VARIANT_BOOL* pfInstance, [out, retval] IPropertySecurity **ppSecurity);

		// get instance property map
		[hidden, propget, helpstring("Returns a thing's property map of properties defined on a particular instance")] 
		HRESULT InstanceProperties([out, retval] IPropertyMap** pppropertymap);

		// get aggregated property map - including exemplars
		[restricted, propget, helpstring("Returns the property map of all thing properties - both instance and exemplar.")] 
		HRESULT Properties([out, retval] IPropertyMap** pppropertymap);

		// copy properties to existing property map
		[restricted, helpstring("Copies thing's property to ppropertymap")]
		HRESULT CopyPropertiesTo([in] IPropertyMap* ppropertymap);

		// valid method?
		[helpstring("Check if method with bstrName exists on Thing instance or exemplar, returns TRUE if so")] 
		HRESULT IsValidMethod([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pbool);
		[helpstring("Check if method with bstrName exists on Thing instance, returns TRUE if so")] 
		HRESULT IsValidInstanceMethod([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pbool);

		// helper to create and add new methods
		[hidden, helpstring("Script entry point to create a new method bstrName in module pmodule (can be named by varFuncName in module), with optional security permissions and client/server flags")] 
		HRESULT CreateAndAddMethod([in] long lFlags, [in] IModule* pmodule, [in] BSTR bstrName, 
				[in, optional, defaultvalue("")] VARIANT varFuncName,
				[in, optional, defaultvalue(PSBIT_SCRIPTDEFAULTMETHOD)] VARIANT varPsbits,
				[in, optional, defaultvalue(PS_SCRIPTDEFAULTMETHOD)] VARIANT varPermissions);
		[restricted, helpstring("C++ entry point for creating a new method bstrName in module pmodule, called bstrFunctName within the module, with optional security permissions and client/server flags")] 
		HRESULT CreateAndAddMethodExt([in] long lFlags, [in] IModule* pmodule, [in] BSTR bstrFuncName, 
				[in] BSTR bstrMethName, [in] long psbits, [in] long permissions);

		// add/remove method
		[helpstring("Script entry point todds a new method to a Thing (if method already exists with bstrName, an error is returned)")] 
		HRESULT AddMethod([in] BSTR bstrName, [in] IMethod* pmethod, 
				[in, optional, defaultvalue(PSBIT_SCRIPTDEFAULTMETHOD)] VARIANT varPsbits,
				[in, optional, defaultvalue(PS_SCRIPTDEFAULTMETHOD)] VARIANT varPermissions);
		[restricted, helpstring("Internal C++ method for adding a method to a Thing -  gets context and calls into AddMethodInt")] 
		HRESULT AddMethodExt([in] BSTR bstrName, [in] IMethod* pmethod, 
				[in] long psbits, [in] long permissions);
		[hidden, helpstring("Internal C++ method for adding a method - checks security, fires event, and calls into AddMethodIntHelper to do rest of work."), id(DISPID_THING_ADDMETHODINT)] 
		HRESULT AddMethodInt([in] BSTR bstrName, [in] IMethod* pmethod, [in] IThing* pExemplar, 
				[in] long psbits, [in] long permissions);

		[helpstring("Removes a method from a Thing's method map"), id(DISPID_THING_REMOVEMETHOD)] 
		HRESULT RemoveMethod([in] BSTR bstrName);

		// get/put method by name
		[propget, helpstring("Script entry point to get a method of bstrName, calls into get_MethodExt to check security."), id(DISPID_THING_METHOD)] 
		HRESULT Method([in] BSTR bstrName, [out, retval] IMethod** ppmethod);
		[propput, helpstring("Script entry point to set a method that already exists on a Thing, calls into other functions to check security etec."), id(DISPID_THING_METHOD)] 
		HRESULT Method([in] BSTR bstrName, [in] IMethod* pmethod);

		// get method and exemplar where attached
		[restricted, propget, helpstring("Internal method to get a method once hash value was been computed.")] 
		HRESULT MethodExt([in] BSTR bstrName, [in] UINT nHashOrig, [out] IThing** ppexemplar, [out, retval] IMethod** ppmethod);

		// can't have put_MethodExt because signature is different from get_MethodExt
//		[restricted, propput, helpstring("")] 
//		HRESULT MethodExt([in] BSTR bstrName, [in] UINT nHashOrig, [in] IMethod* pmethod);

		// get method security
		[hidden, propget, helpstring("Computes hash key for method and calls get_MethodSecurityExt to get the security slot for a method")] 
		HRESULT MethodSecurity([in] BSTR bstrName, [out, retval] IPropertySecurity** ppSecurity);
		[restricted, propget, helpstring("Checks permission for accessing a method's security, looks up method and security slot")] 
		HRESULT MethodSecurityExt([in] BSTR bstrName, [in] UINT nHashOrig, [out] IThing** ppexemplar, [out] VARIANT_BOOL* pfInstance, [out, retval] IPropertySecurity** ppSecurity);

		// get instance method map
		[hidden, propget, helpstring("Get property map of methods defined on this particular instance.")] 
		HRESULT InstanceMethods([out, retval] IPropertyMap** pppropertymap);

		// get aggregated method map - including exemplars
		[restricted, propget, helpstring("Get property map of all methods, exemplar and instance, defined on this Thing")] 
		HRESULT Methods([out, retval] IPropertyMap** pppropertymap);

		// copy methods to existing property map
		[restricted, helpstring("Copies methods in current thing to ppropertymap")] 
		HRESULT CopyMethodsTo([in] IPropertyMap* ppropertymap);

		///////////////////////////////////////////////////////////////////////////////////////////////
		// FireEvent methods:
		// Used to fire a system event regarding the creation or deletion of a Thing. Pre-defined events
		// we fire always include an internal system version and an extenal one:
		//	OnSystemEnter		OnEnter
		//	OnSystemLeave		OnLeave
		//  OnSystemActivate	OnActivate
		//	OnSystemDeactivate	OnDeactivate
		//	OnSystemCreate		OnCreate
		//	OnSystemDestroy		OnDestroy
		//	OnSystemConnect		OnConnect
		//	OnSystemDisconnect	OnDisconnect
		///////////////////////////////////////////////////////////////////////////////////////////////

		// FireEvent takes the event name to fire
		[helpstring("Script entry point to fire an event with name strEvent and optional arguments in var")] 
		HRESULT FireEvent([in] BSTR bstrEvent, [in, optional] VARIANT var);

		// FireEventExt takes the event name to fire
		[restricted, helpstring("C++ entry point to fire an event with name strEvent, paramters, and flags.  Has ShouldExecute, ShouldRemote blocks.")] 
		HRESULT FireEventExt([in] BSTR bstrEvent, [in] DISPPARAMS* pdispparams, [in] long lFlags);

		// FireEvent takes the event name to fire
		[hidden, helpstring("Internal method - converts property list to DISPPARAMS and calls FireEventExtHelper to do work of firing event."), id(DISPID_THING_FIREEVENTINT)] 
		HRESULT FireEventInt([in] BSTR bstrEvent, [in] IPropertyList* pproplist, [in] long lFlags);

		// InvokeMethod takes the method name to call
		// and a VARIANT containing either a single value or a SAFEARRAY of values
		[helpstring("Calls a method with optional parameters. Calls into module interface to either invoke by name or ID.")] 
		HRESULT InvokeMethod([in] BSTR bstrMethod, [in, optional] VARIANT var, [out, retval] VARIANT* pvar);

		[hidden, helpstring("Internal method to convert ppropertylist to DISPPARMS and calls InvokeMethodExtHelper to call method."), id(DISPID_THING_INVOKEMETHODINT)] 
		HRESULT InvokeMethodInt([in] IThing* pThing, [in] BSTR bstrMethod, [in] IPropertyList* pproplist, [out, retval] VARIANT* pvar);

		[restricted, helpstring("Internal method to call a method with paramters.  Calls into module interface to either invoke by name or ID.")] 
		HRESULT InvokeMethodExt([in] BSTR bstrMethod, [in] DISPPARAMS* pdispparams, [out, retval] VARIANT* pvar);

		// invoke current method on superclass IThing
		[helpstring("Script entry point to call method on Thing superclass - if you overwrite a system-defined method, you should then call the underlying super method")] 
		HRESULT InvokeSuperMethod([in, optional] VARIANT var, [out, retval] VARIANT* pvar);

		[restricted, helpstring("C++ entry point to call method on Thing superclass - - if you overwrite a system-defined method, you should then call the underlying super method")] 
		HRESULT InvokeSuperMethodExt([in, optional] DISPPARAMS* pdispparams, [out, retval] VARIANT* pvar);

		// get current method name during method invocation
		[restricted, propget, helpstring("Get current method name to determine status.  Not used.")]
		HRESULT CurrentMethodName([out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Sets current method name.  Not used.")] 
		HRESULT CurrentMethodName([in] BSTR bstr);

		// built-in properties
		[restricted, propget, helpstring("Get name of Thing")]
		HRESULT Name([out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Set name of Thing")]
		HRESULT Name([in] BSTR bstr);

		[restricted, propget, helpstring("Get text description of Thing")]
		HRESULT Description([out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Set text description of Thing")]
		HRESULT Description([in] BSTR bstr);

		// internal built-ins (can't set values directly)
		[restricted, propget, helpstring("Returns a property list of things that have been moved into the the current thing")]
		HRESULT Contents([out, retval] IPropertyList** ppproplist);

		// internal built-ins (can't set values directly from script)
		[restricted, propget, helpstring("Returns the the object the current thing is in (e.g., a room)")]
		HRESULT Container([out, retval] IThing** ppthing);
		[restricted, propput, helpstring("Sets the object the current thing is in (e.g., a room)")]
		HRESULT Container([in] IThing* pthing);

		[propget, helpstring("Returns the avatar that created a thing (avatars have NULL owners)")]
		HRESULT Owner([out, retval] IThing** ppthing);

		[hidden, helpstring("Script entry point to check thing's properties map for a specific permission(PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckPropertiesSecurity([in] unsigned long ulFlags, [out, retval] VARIANT_BOOL* pboolVal);
		[hidden, helpstring("Script entry point to check thing's methods map for a specific permission(PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckMethodsSecurity([in] unsigned long ulFlags, [out, retval] VARIANT_BOOL* pboolVal);

		[restricted, helpstring("Internal entry point to check thing's properties map for a specific permission(PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckPropertiesSecurityExt([in] unsigned long ulFlags);
		[restricted, helpstring("Internal entry point to check thing's methods map for a specific permission(PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckMethodsSecurityExt([in] unsigned long ulFlags);

		[hidden, helpstring("Script entry point to check a thing's property for a specific permission (PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckPropertySecurity([in] BSTR bstrName, [in] unsigned long ulFlags, [out, retval] VARIANT_BOOL* pboolVal);
		[hidden, helpstring("Script entry point to check a thing's method for a specific permission (PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckMethodSecurity([in] BSTR bstrName, [in] unsigned long ulFlags, [out, retval] VARIANT_BOOL* pboolVal);

		[restricted, helpstring("Internal entry point to check a thing's property for a specific permission (PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckPropertySecurityExt([in] BSTR bstrName, [in] unsigned long ulFlags);
		[restricted, helpstring("Internal entry point to check a thing's method for a specific permission (PS_ADD, PS_READ, PS_WRITE)")] 
		HRESULT CheckMethodSecurityExt([in] BSTR bstrName, [in] unsigned long ulFlags);

		[restricted, helpstring("Method called to fire property event change: OnXXXChanged")] 
		HRESULT NotifyObjectPropertyChanged([in] IObjectProperty* pprop, [in] long lHint, [in] VARIANT varHintData);
		[restricted, helpstring("Method called to fire method event change: OnXXXChanged")] 
		HRESULT NotifyMethodChanged([in] IMethod* pmethod, [in] long lHint, [in] VARIANT varHintData);

		// helper functions for C++
		[restricted, helpstring("Internal helper method to add a property with bstrName name and a string value")] 
		HRESULT AddString([in] BSTR bstrName, [in] BSTR bstr);
		[restricted, helpstring("Internal helper method to add a property with bstrName name and an object property value")] 
		HRESULT AddObjectProperty([in] BSTR bstrName, [in] IObjectProperty* pobjectproperty);
		[restricted, helpstring("")] 
		HRESULT AddObjectPropertyExt([in] BSTR bstrName, [in] REFIID iid, [in] IObjectProperty* pobjectproperty);
		[restricted, helpstring("Internal helper method to add a property with bstrName name and a thing value")] 
		HRESULT AddThing([in] BSTR bstrName, [in] IThing* pthing);
		[restricted, helpstring("Internal helper method to add a property with bstrName name and a boolean value")] 
		HRESULT AddBOOL([in] BSTR bstrName, [in] VARIANT_BOOL boolVal);
		[restricted, helpstring("Internal helper method to add a property with bstrName name and a long value")] 
		HRESULT AddLong([in] BSTR bstrName, [in] long lval);
		[restricted, helpstring("Internal helper method to add a property with bstrName name and a short value")] 
		HRESULT AddShort([in] BSTR bstrName, [in] short sval);
		[restricted, helpstring("Internal helper method to add a property with bstrName name and a dispatch value")] 
		HRESULT AddDispatch([in] BSTR bstrName, [in] IDispatch* pdisp);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a string property with bstrName name")] 
		HRESULT String([in] BSTR bstrName, [out, retval] BSTR* pbstr);
		[restricted, propput, helpstring("Internal method to set value of a string property with bstrName name")] 
		HRESULT String([in] BSTR bstrName, [in] BSTR bstr);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a an object property with bstrName name")] 
		HRESULT ObjectProperty([in] BSTR bstrName, [out, retval] IObjectProperty** ppobjectproperty);
		[restricted, propput, helpstring("Internal method to set value of a object property with bstrName name")] 
		HRESULT ObjectProperty([in] BSTR bstrName, [in] IObjectProperty* pobjectproperty);

		// specify the desired IID to check, return error if QI fails
		[restricted, propget, helpstring("Internal method to return value of a object property with bstrName name and specific IID")] 
		HRESULT ObjectPropertyExt([in] BSTR bstrName, [in] REFIID iid, [out, retval] IObjectProperty** ppobjectproperty);
//		[restricted, propput, helpstring("")] 
//		HRESULT ObjectPropertyExt([in] BSTR bstrName, [in] REFIID iid, [in] IObjectProperty* pobjectproperty);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a thing property with bstrName name")] 
		HRESULT Thing([in] BSTR bstrName, [out, retval] IThing** ppthing);
		[restricted, propput, helpstring("Internal method to set value of a thing property with bstrName name")] 
		HRESULT Thing([in] BSTR bstrName, [in] IThing* pthing);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a boolean property with bstrName name")] 
		HRESULT BOOL([in] BSTR bstrName, [out, retval] VARIANT_BOOL* pboolVal);
		[restricted, propput, helpstring("Internal method to set value of a boolean property with bstrName name")] 
		HRESULT BOOL([in] BSTR bstrName, [in] VARIANT_BOOL boolVal);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a long property with bstrName name")] 
		HRESULT Long([in] BSTR bstrName, [out, retval] long* plval);
		[restricted, propput, helpstring("Internal method to set value of a long property with bstrName name")] 
		HRESULT Long([in] BSTR bstrName, [in] long lval);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a short property with bstrName name")] 
		HRESULT Short([in] BSTR bstrName, [out, retval] short* psval);
		[restricted, propput, helpstring("Internal method to set value of a short property with bstrName name")] 
		HRESULT Short([in] BSTR bstrName, [in] short sval);

		// helper functions for C++
		[restricted, propget, helpstring("Internal method to return value of a dispatch property with bstrName name")] 
		HRESULT Dispatch([in] BSTR bstrName, [out, retval] IDispatch** ppdisp);
		[restricted, propput, helpstring("Internal method to set value of a dispatch property with bstrName name")] 
		HRESULT Dispatch([in] BSTR bstrName, [in] IDispatch* pdisp);
	};

	[
		object,
		uuid(590D984A-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IModule Interface"),
		pointer_default(unique)
	]
	interface IModule : IObjectProperty
	{
const DISPID DISPID_MODULE_FLAGS = 101;
const DISPID DISPID_MODULE_MODULENAME = 102;
const DISPID DISPID_MODULE_RELOAD = 103;

		// name of module
		[propget, helpstring("Returns world module name as string"), id(DISPID_MODULE_MODULENAME)] 
		HRESULT ModuleName([out, retval] BSTR* pbstr);

		// REVIEW: this can never change (it would have to get renamed in the module map also)
//		[hidden, propput, helpstring(""), id(DISPID_MODULE_MODULENAME)] 
//		HRESULT ModuleName([in] BSTR bstr);

		// type of module
		[hidden, propget, helpstring("Internal method to get module type (can be C++ module or script module)")] 
		HRESULT ModuleType([out, retval] long* plval);

		// get/put flags
		[propget, helpstring("Gets flags for whether module runs on client and/or server"), id(DISPID_MODULE_FLAGS)] 
		HRESULT Flags([out, retval] long* plVal);
		[hidden, propput, helpstring("Sets flags for whether module runs on client and/or server"), id(DISPID_MODULE_FLAGS)] 
		HRESULT Flags([in] long lVal);

		// Install - called (on server) to add exemplars to system when module first created
		[restricted, helpstring("Method called to add new exemplars, etc., within module to system when module is created")]
		HRESULT Install();

		[restricted, helpstring("Calls a method within the module by looking up its name")] 
		HRESULT InvokeByName([in] BSTR bstrSubName, [in] WORD wFlags, [out] DISPID* pdispid, [in] DISPPARAMS* pdispparams, [in] VARIANT_BOOL bQuiet, [out] VARIANT* pvar, [out] HRESULT* phr);
		[restricted, helpstring("Calls a method within the module by looking up its DISPID")] 
		HRESULT InvokeByDispID([in] DISPID dispid, [in] WORD wFlags, [in] DISPPARAMS* pdispparams, [in] VARIANT_BOOL bQuiet, [out] VARIANT* pvar, [out] HRESULT* phr);

		// get dispatch ptr (only for local invocations)
		[restricted, propget, helpstring("Gets the Dispatch pointer. Not used.")] 
		HRESULT Dispatch([out, retval] IDispatch** ppdispatch);

		// reload script or COM object from storage
		[hidden, helpstring("Reloads a module, checks for scripting security"), id(DISPID_MODULE_RELOAD)] 
		HRESULT Reload([in] VARIANT_BOOL bReinstall);

		// unload script or COM object from memory
		[restricted, helpstring("Unloads a module from memory")] 
		HRESULT Unload([in] VARIANT_BOOL bShutdown);

		// validate script or COM object
		[restricted, helpstring("Does a CoCreateInstance and makes sure module is safe for scripting")] 
		HRESULT Validate([out, retval] VARIANT_BOOL* pboolVal);

		[hidden, propget, helpstring("Checks if module has been unloaded")] 
		HRESULT IsShutdown([out, retval] VARIANT_BOOL* pboolVal);
	};

	[
		object,
		uuid(590D984C-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("ICOMModule Interface"),
		pointer_default(unique)
	]
	interface ICOMModule : IModule
	{
const DISPID DISPID_COMMODULE_MODULECLSID = 205;
const DISPID DISPID_COMMODULE_MODULEPROGID = 206;

		// restricted because CLSID isn't Automation-friendly type
		[restricted, propget, helpstring("Get the module's CLSID"), id(DISPID_COMMODULE_MODULECLSID)] 
		HRESULT ModuleCLSID([out, retval] CLSID* pclsid);
//		[restricted, propput, helpstring(""), id(DISPID_COMMODULE_MODULECLSID)] 
//		HRESULT ModuleCLSID([in] REFCLSID clsid);

		// does translation to CLSID
		[hidden, propput, helpstring("Set the module's ProgID"), id(DISPID_COMMODULE_MODULEPROGID)] 
		HRESULT ModuleProgID([in] BSTR bstr);
	};

	[
		object,
		uuid(590D984E-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IScriptModule Interface"),
		pointer_default(unique)
	]
	interface IScriptModule : IModule
	{
const DISPID DISPID_SCRIPTMODULE_SCRIPTPATH = 205;

		[propget, helpstring("Gets the URL of the script module"), id(DISPID_SCRIPTMODULE_SCRIPTPATH)] 
		HRESULT ScriptPath([out, retval] BSTR* pbstr);
		[hidden, propput, helpstring("Sets the URL of the script module"), id(DISPID_SCRIPTMODULE_SCRIPTPATH)] 
		HRESULT ScriptPath([in] BSTR bstr);

		// add a scriptlet (for in-line methods)
		[restricted, helpstring("Adds inline script code to a method")]
		HRESULT AddScriptlet([in] BSTR bstrCode);
	};

	[
		object,
		uuid(590D9850-A417-11CF-9BF0-0080C7A56A8A),
		dual,
		helpstring("IMethod Interface"),
		pointer_default(unique)
	]
	interface IMethod : IObjectProperty
	{
const DISPID DISPID_METHOD_FLAGS = 101;
const DISPID DISPID_METHOD_MODULE = 102;
const DISPID DISPID_METHOD_DISPID = 103;
const DISPID DISPID_METHOD_METHODNAME = 104;
const DISPID DISPID_METHOD_ARGUMENTSINT = 105;
const DISPID DISPID_METHOD_CODE = 106;

		// get/put flags
		[propget, helpstring("Checks security, gets flags (METHOD_CLIENT and/or METHOD_SERVER) for remoting"), id(DISPID_METHOD_FLAGS)] 
		HRESULT Flags([out, retval] long* plVal);
		[hidden, propput, helpstring("Checks security, internal method to set flags (METHOD_CLIENT and/or METHOD_SERVER) for remoting"), id(DISPID_METHOD_FLAGS)] 
		HRESULT Flags([in] long lVal);

		// get/put module
		[propget, helpstring("Gets the module the method is attached to"), id(DISPID_METHOD_MODULE)] 
		HRESULT Module([out, retval] IModule** ppmodule);
		[hidden, propput, helpstring("Internal method to set the module the method is attached to"), id(DISPID_METHOD_MODULE)] 
		HRESULT Module([in] IModule* pmodule);

		// dispid to method within module
		[hidden, propget, helpstring("Internal method to check security and return method's DispID"), id(DISPID_METHOD_DISPID)] 
		HRESULT DispID([out, retval] DISPID* pdispid);
		[hidden, propput, helpstring("Internal method to check security and set method's DispID"), id(DISPID_METHOD_DISPID)] 
		HRESULT DispID([in] DISPID dispid);

		// name of method within module
		[propget, helpstring("Gets name of method within the module (opposed to name on Thing)"), id(DISPID_METHOD_METHODNAME)] 
		HRESULT MethodName([out, retval] BSTR* pbstr);
		[hidden, propput, helpstring("Sets name of method within module (opposed to name on Thing)"), id(DISPID_METHOD_METHODNAME)] 
		HRESULT MethodName([in] BSTR bstr);

		// code (for inline methods)
		[propget, helpstring("Get actual code that runs method"), id(DISPID_METHOD_CODE)]
		HRESULT Code([out, retval] BSTR *pbstr);
		[hidden, propput, helpstring("Set the actual code that runs the method"), id(DISPID_METHOD_CODE)]
		HRESULT Code([in] BSTR bstr);

		// TRUE if an in-line method
		[hidden, propget, helpstring("Checks if a method contains inline code, returns true if so")]
		HRESULT IsInline([out, retval] VARIANT_BOOL *pbool);

		[restricted, helpstring("Invokes a method by calling into IModule to either run it by looking up name or DispID, and parses and runs inline script if necessary.")] 
		HRESULT InvokeMethodExt([in] DISPPARAMS* pdispparams, [out] HRESULT* phr, [out, retval] VARIANT* pvar);

		[hidden, propput, helpstring("Converts pproplist to DISPPARMS and sets arguments with put_ArgumentsExt"), id(DISPID_METHOD_ARGUMENTSINT)] 
		HRESULT ArgumentsInt([in] IPropertyList* pproplist);

//Comment out because there is no support for type library marshalling of  pointers to pointers to stucts
#if 0
		[restricted, propget, helpstring("Internal method to get arguments to method")] 
		HRESULT ArgumentsExt([out, retval] DISPPARAMS** ppdispparams);
#endif

		[restricted, propput, helpstring("Internal method to set arguments to method")] 
		HRESULT ArgumentsExt([in] DISPPARAMS* pdispparams);

		// Only property put for Arguments, no get.  (Get not used.)
		[hidden, propput, helpstring("Converts the var to DISPPARMAS and calles put_ArgumentsExt to set arguments to method")] 
		HRESULT Arguments([in] VARIANT var);

		// validate method (look at module state)
		[restricted, helpstring("Calls Validate method in IModule to ensure that method/module is safe for scripting")] 
		HRESULT Validate([out, retval] VARIANT_BOOL* pboolVal);
	};
