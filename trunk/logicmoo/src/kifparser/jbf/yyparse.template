/* Skeleton output parser for bison,
   Copyright (C) 1984, 1989, 1990 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* As a special exception, when this file is copied by Bison into a
   Bison output file, you may use that output file without restriction.
   This special exception was added by the Free Software Foundation
   in version 1.24 of Bison.  */

/*
This is a parser template file, in java, for running parsers
generated by the GNU Bison parser generator.
*/

/**************************************************/

package jkp;
@package@

/**************************************************/

import java.util.*;
import java.io.*;
import jbf.*;

/**************************************************/

// PREFIX

@PREFIX@

/**************************************************/

public
class @YYparse@ {

    // Set up the fake goto mechanism
    protected int Goto;
    protected static final int yynewstate = 0;
    protected static final int yybackup = 1;
    protected static final int yydefault = 2;
    protected static final int yyreduce = 3;
    protected static final int yyerrlab = 4;
    protected static final int yyerrlab1 = 5;
    protected static final int yyerrdefault = 6;
    protected static final int yyerrpop = 7;
    protected static final int yyerrhandle = 8;

    public static final int YYCONTINUE = 1;
    public static final int YYACCEPT = 0;
    public static final int YYABORT = -1;

    public static final int YYEOF = 0;

    protected static final int YYEMPTY = -2;
    protected static final int YYTERROR = 1;
    protected static final int YYTERRCODE = 256;

// CONSTANTS

@CONSTANTS@

// TOKENTYPES

@TOKENTYPES@

    protected int yyreturn; // see ACTIONS switch
    protected int yystate;
    protected int yyn;
    protected int yylen;
    protected int yychar; /* the lookahead symbol */
    protected int yychar1;  /* lookahead token as an internal (translated)
			   Token number */
    protected int yynerrs; /* number of parse errors so far */
    protected int yydebug; /* nonzero means print parse trace */
    protected int yyerrstatus;	/* number of tokens to shift before error
			   messages enabled */
    public @StringBuffer@ yytext; // string for current lexeme (volatile)
    public YYlocation yyloc; // location for current lexeme
    public @Integer@ yylval; // the semantic value of the lookahead symbol
    protected @Object@ yyval;   // the variable used to return semantic values
			 	// from the action routines

    protected Int_Stack yyss;
    protected @Object@_Stack yyvs;
/*    protected loc_stack yyls;*/
    protected @YYlex@ yylex;
    protected java.io.PrintStream yyout;

// PROCS

@PROCS@


public
@YYparse@(@YYlex@ yyl, java.io.PrintStream fout)
{
    yyss = new Int_Stack();
    yyvs = new @Object@_Stack();
    yylex = yyl;
    yylval = null;
    yytext = yyl.yylval.text();
    yyloc = yyl.yylval.location();
    yydebug = 0;
    yyout = fout;
    @constructor@
}

public @YYparse@(@YYlex@ yyl) {this(yyl, System.out);}

public
int
@yyparse@() throws Exception, IOException, EmptyStackException
{
    int ok;
    yychar1 = 0;  /* lookahead Token as an internal (translated) */
    yystate = 0;
    yyerrstatus = 0;
    yynerrs = 0;
    yychar = YYEMPTY;  /* Cause a Token to be read.  */
    yyval = null;
  
    /* Initialize stack pointers.
       Waste one element of value and location stack
       so that they stay on the same level as the state stack.
       The wasted elements are never initialized.  */
  
    yyss.clear();
    yyvs.clear();
/*    yyls.clear();*/
    
    /* need to push a null value to match state 0 */
    yyvs.push(null);
  
    if(yydebug > 0) yyout.print("Starting parse\n");

/* Push a new state, which is found in	yystate	 .  */
/* In all cases, when you get here, the value and location stacks
   have just been pushed. so pushing a state here evens the stacks.  */
for(;;) {
branch: switch (Goto) {

case yynewstate:

  yyss.push(yystate);

  if (yydebug > 0) {
	yyout.print("Entering state ");
	yyout.print(yystate);
	yyout.print("\n");
  }

//  {Goto = yybackup; break branch;}
case yybackup:

/* Do appropriate processing given the current state.  */
/* Read a lookahead token if we need one and don't already have one.  */
/* yyresume: */

  /* First try to decide what to do without reference to lookahead token.  */

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    {Goto = yydefault; break branch;}

  /* Not known => get a lookahead token if don't already have one.  */

  /* yychar is either YYEMPTY or YYEOF
     or a valid token in external form.	 */

  if (yychar == YYEMPTY)
    {
      if(yydebug > 0) yyout.print("Reading a token: ");
      yylval = yylex.@yylex@();
      yychar = yylval == null ? YYEOF : yylval.intValue();
    }

  /* Convert token to internal form (in yychar1) for indexing tables with */

  if (yychar <= 0)		/* This means end of input. */
    {
      yychar1 = 0;
      yychar = YYEOF;		/* Don't call YYLEX any more */

      if(yydebug > 0) yyout.print("Now at end of input.\n");
    }
  else
    {
      yychar1 = YYTRANSLATE(yychar);

      if (yydebug >= 10)
	{
	    yyout.print("Next token is ");
	    yyout.print(yychar);
	    yyout.print(" (");
	    yyout.print(yytname[yychar1]);
	    yyout.print(")\n");
	}
    }

  yyn += yychar1;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != yychar1)
    {Goto = yydefault; break branch;}

  yyn = yytable[yyn];

  /* yyn is what to do for this token type in this state.
     Negative => reduce, -yyn is rule number.
     Positive => shift, yyn is new state.
       New state is final state => don't bother to shift,
       just return success.
     0, or most negative number => error.  */

  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	{Goto = yyerrlab; break branch;}
      yyn = -yyn;
      {Goto = yyreduce; break branch;}
    }
  else if (yyn == 0)
    {Goto = yyerrlab; break branch;}

  if (yyn == YYFINAL)
    return YYACCEPT;

  /* Shift the lookahead token.	 */

  if (yydebug > 0) {
    yyout.print("Shifting token ");
    yyout.print(yychar);
    yyout.print(" (");
    yyout.print(yytname[yychar1]);
    yyout.print("), ");
  }

  /* Discard the token being shifted unless it is eof.	*/
  if (yychar != YYEOF)
    yychar = YYEMPTY;

  yyvs.push(yylval);
/*  yyls.push(yylloc);*/

  /* count tokens shifted since error; after three, turn off error status.  */
  if (yyerrstatus > 0) yyerrstatus--;

  yystate = yyn;
  {Goto = yynewstate; break branch;}

/* Do the default action for the current state.	 */
case yydefault:

  yyn = yydefact[yystate];
  if (yyn == 0)
    {Goto = yyerrlab; break branch;}

/* Do a reduction.  yyn is the number of a rule to reduce with.	 */
case yyreduce:
  yylen = yyr2[yyn];
  if (yylen > 0)
    yyval = yyvs.tth(1-yylen); /* implement default value of the action */

  if (yydebug > 0)
    {
      int i;

      yyout.print("Reducing via rule ");
      yyout.print(yyn);
      yyout.print(" (line ");
      yyout.print(yyrline[yyn]);
      yyout.print("), ");
      /* Print the symbols being reduced, and their result.  */
      for (i = yyprhs[yyn]; yyrhs[i] > 0; i++) {
	  yyout.print(yytname[yyrhs[i]]);
	  yyout.print(" ");
      }
      yyout.print(" -> ");
      yyout.print(yytname[yyr1[yyn]]);
      yyout.print("\n");
    }

/*$*/	/* the action file gets copied in in place of this dollarsign */

/* Provide a way to avoid having return statements in the actions
   and so avoid "statement not reached" errors"
*/
yyreturn = YYCONTINUE;

switch (yyn) {
@ACTIONS@

  if(yyreturn != YYCONTINUE) return yyreturn;

  yyvs.popn(yylen);
  yyss.popn(yylen);
/*  yyls.popn(yylen)*/

  if (yydebug > 0)
    {
	stackdump("state stack now");
    }

  yyvs.push(yyval);

/*  yylsp++;*/
  if (yylen == 0)
    {
/*remind:
      yyls.push(yylloc);
      yyls.last_line = (yylsp-1)->last_line;
      yyls.last_column = (yylsp-1)->last_column;
      yyls.text = 0;
*/
    }
  else
    {
/* remind:
      yylsp.last_line = (yylsp+yylen-1)->last_line;
      yylsp.last_column = (yylsp+yylen-1)->last_column;
*/
    }

  /* Now "shift" the result of the reduction.
     Determine what state that goes to,
     based on the state we popped back to
     and the rule number reduced by.  */

  yyn = yyr1[yyn];

  yystate = yypgoto[yyn - YYNTBASE] + yyss.peek();
  if (yystate >= 0 && yystate <= YYLAST && yycheck[yystate] == yyss.peek())
    yystate = yytable[yystate];
  else
    yystate = yydefgoto[yyn - YYNTBASE];

  {Goto = yynewstate; break branch;}

case yyerrlab:	 /* here on detecting error */

  if (yyerrstatus == 0)
    /* If not already recovering from an error, report this error.  */
    {
      ++yynerrs;
	@yyerror@("parse error");
    }

//  {Goto = yyerrlab1; break branch;}
case yyerrlab1:	  /* here on error raised explicitly by an action */

  if (yyerrstatus == 3)
    {
      /* if just tried and failed to reuse lookahead token after an error, discard it.	*/

      /* return failure if at end of input */
      if (yychar == YYEOF)
	return YYABORT;

      if (yydebug > 0) {
	yyout.print("Discarding token ");
	yyout.print(yychar);
	yyout.print(" (");
	yyout.print(yytname[yychar1]);
	yyout.print(").\n");
      }
      yychar = YYEMPTY;
    }

  /* Else will try to reuse lookahead token
     after shifting the error token.  */

  yyerrstatus = 3;		/* Each real token shifted decrements this */

  {Goto = yyerrhandle; break branch;}

case yyerrdefault:  /* current state does not do anything special for the error token. */

/* if 0
  // This is wrong; only states that explicitly want error tokens
  // should shift them.
  yyn = yydefact[yystate];  // If its default is to accept any token, ok.  Otherwise pop it.
  if (yyn) {Goto = yydefault; break branch;}
*/

case yyerrpop:	 /* pop the current state because it cannot handle the error token */

  if (yyss.empty()) return YYABORT;
  yyvs.popn(1);
  yystate = yyss.pop();
/*  yyls.popn(1);*/

  if (yydebug > 0)
    {
	stackdump("Error: state stack now");
    }

case yyerrhandle:

  yyn = yypact[yystate];
  if (yyn == YYFLAG)
    {Goto = yyerrdefault; break branch;}

  yyn += YYTERROR;
  if (yyn < 0 || yyn > YYLAST || yycheck[yyn] != YYTERROR)
    {Goto = yyerrdefault; break branch;}

  yyn = yytable[yyn];
  if (yyn < 0)
    {
      if (yyn == YYFLAG)
	{Goto = yyerrpop; break branch;}
      yyn = -yyn;
      {Goto = yyreduce; break branch;}
    }
  else if (yyn == 0)
    {Goto = yyerrpop; break branch;}

  if (yyn == YYFINAL)
    return YYACCEPT;

  if (yydebug > 0) {yyout.println("Shifting error token, ");}

  yyvs.push(yylval);
/*  yyls.push(yyloc);*/

  yystate = yyn;
//  {Goto = yynewstate; break branch;}

}//switch
}//for(;;)

} // parse

protected
void
stackdump(String s)
{
    int i;
    int x;
    int ssp1 = yyss.depth();
    yyout.print(s);
    for(i=0;i<ssp1;i++) {
	x = yyss.ith(i);
	yyout.print(" ");
	yyout.print(x);
    }
    yyout.print("\n");
}

public
String
yyerror_verbose(String msg0) throws ParseException
{
    yyn = yypact[yystate];
    if(yyn > YYFLAG && yyn < YYLAST) {
	int size = msg0.length();
	StringBuffer msg;
	int yychar1; // a TRANSLATEd char value
	int count;
	count = 0;

	/* Start yychar1 at -yyn if nec to avoid negative indexes in yycheck.*/
	for (yychar1 = (yyn < 0 ? -yyn : 0);
		(yyn+yychar1) < (yytname.length);
		yychar1++) {
	    if((yyn+yychar1) < yycheck.length
		    && yycheck[yyn+yychar1] == yychar1) {
		size += (yytname[yychar1].length()) + 15;
		count++;
	    }
	}
	msg = new StringBuffer(size+15);
	msg.append(msg0);
	msg.append("(state " + Integer.toString(yystate) + ")");
	yychar1 = (yyn < 0)? - yyn :0;
	for(count=0,yychar1 = (yyn < 0 ? -yyn : 0);
		(yyn+yychar1) < (yytname.length) && count < 5;
		yychar1++) {
	    if((yyn+yychar1) < yycheck.length
		    && yycheck[yyn+yychar1] == yychar1) {
		msg.append(count == 0 ? ", expecting `" : " or `");
		msg.append(yytname[yychar1]);
		msg.append("'");
		count++;
	    }
	}
	return msg.toString();
    }
    return msg0;
}

public
void
yyerror(String msg, boolean verbose, boolean dumpstack) throws ParseException
{
    String s;
    if(verbose) {
	s = yyerror_verbose(msg);
    } else {
	s = msg;
    }
    yyout.print("yyerror: ");
    if(yylval.intValue() == YYEOF) {
	yyout.print("at end of file");
    } else {
	yyout.print("line ");
	yyout.print(yyloc.lineno()+1);
    }
    yyout.println(" ; " + s);
    if(dumpstack) { stackdump("yyerror: state stack"); }
    throw new ParseException(s);
}

public void yyerror(String s, boolean verbose) throws ParseException
{ yyerror(s,verbose,false); }

public void yyerror(String s) throws ParseException
{ yyerror(s,false,false); }

public void yyreturn(int t) {yyreturn = t;}

public void setdebug(boolean i) {yydebug = i?1:0;}
public void setdebug(int i) {yydebug = i>0?i:0;}

public Object dollar(int i) {return yyvs.tth(i);}


// TABLES

@TABLES@

// SUFFIX

@SUFFIX@

}; /*class*/
