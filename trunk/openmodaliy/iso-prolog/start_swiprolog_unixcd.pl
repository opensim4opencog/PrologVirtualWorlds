% ===================================================================
% OPERATOR PRECEDANCE
% ===================================================================

/*
:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).
  */
              
:- op(1200,fx,::-).         /* operator for integrity constraints */

%:- op(1200,xfx,<--).
%:- op(1150,fx,[(tabled),(prolog),(default)]).


:- op(500,xfx,#).
:- op(500,xfy,:).
%:- op(550,xfx,:).
%:- op(500,xfx,'@').

:- op(900,xfx,<-).
:- op(400,fx,'~').
:- op(400,fy,not).    % negation
:- op(500,xfy,and).   % conjunction
:- op(600,xfy,or).   % disjunction
:- op(0,xfx, 'equal' ).
:- op(900,xfx,'<=').
:- op(900,xfx,'if').
:- op(1000,xfy,'=>').
:- op(400,fy,known).  % Found in Model
:- op(400,fy,possible).  % Not In Model
:- op(400,fy,next).  % Next time
:- op(400,fy,after).  % Next time
:- op(400,fy,then).  % Next time
:- op(650,xfy,=>).  % implication
:- op(700,xfy,<=>). % equivalence
:- op(400,fy,always).  % Necessity, Always
:- op(400,fy,possible).  % Possibly, Eventually
:- op(400,fy,necessary).  % Necessity




/*
:-module(moo_globalisms,[
	 setMooOption/1,
	 setMooOption/2,
	 getMooOption/1,
	 getMooOption/2,
	 ensureMooOption/2,
	 ensureMooOption/3,
	 setMooOptionDefaults/0]).
*/


% :-ensure_loaded(moo_threads).

% Database
:-dynamic(mooCache/1).
:-dynamic(mooCache/2).
:-dynamic(mooCache/3).
:-dynamic(mooCache/4).
:-dynamic(mooCache/5).
:-dynamic(mooCache/6).
:-dynamic(mooCache/7).
:-dynamic(mooCache/8).
:-dynamic(mooCache/9).

% User Agent
:-dynamic('$MooOption'/3).
:-dynamic(saved_note/4).
:-dynamic(act_mem/3).

% Database
:-dynamic(tq_attempted_request/0).
:-dynamic(title/1).

% TQ System
:-dynamic(tq_missed_one_answer/0).
:-dynamic(tq_least_one_answer/0).
:-dynamic(t_answer_found/1).


% ===================================================================
% OPERATION PREDICATES
% ===================================================================
% Defaults
:-dynamic(getDefaultKB/1).
:-dynamic(get_default_request_context/1).
:-dynamic(get_default_assertion_context/1).
:-dynamic(version_tag/1).

:-dynamic(answer_found/1).
:-dynamic(moo_K_scenario/2).
:-dynamic(telling_prolog/0).  % If set asserts clauses into prolog database
:-dynamic(telling_file/0).   % If set write assertions to file
:-dynamic(disp_debug/5).         %PREDICATE RESOLUTON
:-dynamic(contexts/2).            %CONTEXT STATES
:-dynamic(setting_table/2).
:-dynamic(tabling/1).
:-dynamic(tabled_t/1).
:-dynamic(tabled_f/1).
:-dynamic(answer_yes/0).
:-dynamic(already_asked/2).
:-dynamic(save_all/2).
:-dynamic(moo_K_scenario/6).         %We keep a cache of forall consultations
:-dynamic(consultation_mode_on/0).
:-dynamic(resource_cache/2).
:-dynamic(debuggerize/0).

:-dynamic( le_ele/1).


:-dynamic('surface-word'/2).
:-dynamic('surface-macro'/2).
:-dynamic('browser-only'/1).
:-dynamic('not-implemented'/1).
:-dynamic('surface-atom'/1).
:-dynamic('surface-single-arity'/1).
:-dynamic('surface-multiple-arity'/1).
:-dynamic('surface-instance'/2).
:-dynamic('surface-subclass'/2).
:-dynamic('surface-class'/1).
:-dynamic('surface-quantifier'/1).



indexPredicate(positive_fact_cache(1,1,1,1)).
indexPredicate(positive_rule_cache(1,1,1,1)).
indexPredicate(negative_fact_cache(1,1,1,1)).
indexPredicate(negative_rule_cache(1,1,1,1)).

:-dynamic(have_arity/4).

% these hold prototypes of calls
:-dynamic(positive_fact_cache/4).
:-dynamic(positive_rule_cache/4).
:-dynamic(negative_fact_cache/4).
:-dynamic(negative_rule_cache/4).

:-dynamic(make_positive_cache/2).


:-dynamic('in-active-memory'/2).

:-dynamic('should_be_loaded'/2).



setMooOption([]):-!.
setMooOption([H|T]):-!,
      setMooOption(H),!,
      setMooOption(T),!.
setMooOption(Var=_):-var(Var),!.
setMooOption(_=Var):-var(Var),!.
setMooOption((N=V)):-nonvar(N),!,setMooOption_thread(N,V),!.
setMooOption(N):-atomic(N),!,setMooOption_thread(N,true).
	
setMooOption(Name,Value):-setMooOption_thread(Name,Value).
setMooOption_thread(Name,Value):-
	((getThread(Process),
	retractall('$MooOption'(Process,Name,_)),
	asserta('$MooOption'(Process,Name,Value)),!)).


unsetMooOption(Name=Value):-nonvar(Name),
	unsetMooOption_thread(Name,Value).
unsetMooOption(Name):-nonvar(Name),
	unsetMooOption_thread(Name,_).
unsetMooOption(Name):-(retractall('$MooOption'(_Process,Name,_Value))).


unsetMooOption_thread(Name):-
	unsetMooOption_thread(Name,_Value).

unsetMooOption_thread(Name,Value):-
	getThread(Process),
	retractall('$MooOption'(Process,Name,Value)).
	
getMooOption_nearest_thread(Name,Value):-
	getMooOption_thread(Name,Value),!.
getMooOption_nearest_thread(Name,Value):-
	'$MooOption'(_,Name,Value),!.
getMooOption_nearest_thread(_Name,_Value):-!.



isMooOption(Name=Value):-!,isMooOption(Name,Value).
isMooOption(Name):-!,isMooOption(Name,true).

isMooOption(Name,Value):-getMooOption_thread(Name,Value).

getMooOption_thread(Name,Value):-
	((getThread(Process),
	'$MooOption'(Process,Name,Value))),!.


getMooOption(Name=Value):-nonvar(Name),!,ensureMooOption(Name,_,Value).
getMooOption(Name=Default,Value):-nonvar(Name),!,ensureMooOption(Name,Default,Value).
getMooOption(Name,Value):-nonvar(Name),!,ensureMooOption(Name,_,Value).


ensureMooOption(Name=Default,Value):-
	ensureMooOption(Name,Default,Value),!.
	
ensureMooOption(Name,_Default,Value):-
	getMooOption_thread(Name,Value),!.

ensureMooOption(Name,Default,Default):-
	setMooOption_thread(Name,Default),!.

ensureMooOption(Name,_Default,Value):-nonvar(Name),!,   
	setMooOption_thread(Name,Value),!.

ensureMooOption(_Name,Default,Default).



setMooOptionDefaults:-
             (unsetMooOption(_)),
             setMooOption(opt_callback='sendNote'),
             setMooOption(cb_consultation='off'),
             setMooOption(opt_debug='off'),
             setMooOption(cb_error='off'),
             setMooOption(cb_result_each='off'),

% User Agent Defaults for Blank Variables
             setMooOption(opt_cxt_request='GlobalContext'),
             setMooOption(opt_ctx_assert='GlobalContext'),
             setMooOption(opt_tracking_number='generate'),
             setMooOption(opt_agent='ua_parse'),
             setMooOption(opt_precompiled='off'),
             getMooOption(opt_theory,Context),setMooOption(opt_theory=Context),
             setMooOption(opt_notation='kif'),
             setMooOption(opt_timeout=2),
             setMooOption(opt_readonly='off'),
             setMooOption(opt_debug='off'),
             setMooOption(opt_compiler='Byrd'),
             setMooOption(opt_language = 'pnx_nf'),

%Request Limits
             setMooOption(opt_answers_min=1),
             setMooOption(opt_answers_max=999), %TODO Default
             setMooOption(opt_backchains_max=5),
             setMooOption(opt_deductions_max=100),
             setMooOption(opt_backchains_max_neg=5),
             setMooOption(opt_deductions_max_neg=20),
             setMooOption(opt_forwardchains_max=1000),
             setMooOption(opt_max_breath=1000), %TODO Default

%Request Contexts
             setMooOption(opt_explore_related_contexts='off'),
             setMooOption(opt_save_justifications='off'),
             setMooOption(opt_deductions_assert='on'),
             setMooOption(opt_truth_maintence='on'),
             setMooOption(opt_forward_assertions='on'),
             setMooOption(opt_deduce_domains='on'),
             setMooOption(opt_notice_not_say=off),


%Request Pobibility
             setMooOption(opt_certainty_max=1),
             setMooOption(opt_certainty_min=1),
             setMooOption(opt_certainty=1),
             setMooOption(opt_resource_commit='on').

% ===========================================================
% THREAD SERVICE
% ===========================================================

% imports these models from SWI-Prolog
% prolog_thread_create(Goal,Id,Options)
% prolog_current_thread(Id,Status)
% prolog_thread_at_exit(Goal)
% prolog_thread_self(Id)
% prolog_thread_at_exit(Id,Goal)
% prolog_thread_join(Id,_)

/*
:-module(moo_threads,
      [ getThread/1,
	 mooProcessCreate/1,
	 mooProcessCreate/3,
	 mooProcessCreate/4,
	 mooProcessCreate/5,
	 isMooProcess/2,
	 isMooProcess/5,
	 createProcessedGoal/1,
	 mooProcessSelfClean/0,
	 showMooStatisticsHTML/0,
	 cleanOldProcesses/0,
	 showMooProcessHTML/0]).
  */
% :-include('moo_header.pl').

:-dynamic(isMooProcess/5).


getThread(Id):-
	prolog_thread_self(Id).


createProcessedGoal(Goal):-
      mooProcessCreate((prolog_thread_at_exit((
	 (getThread(Id),prolog_thread_exit(i_am_done(Id))))),Goal),Id,[]).


mooProcessCreate(Perms,Name,Goal,Id,Options):-
        prolog_thread_create((prolog_thread_at_exit(mooProcessSelfClean),Goal),Id,Options),
        asserta(isMooProcess(Perms,Name,Goal,Id,Options)).

mooProcessCreate(Name,Goal,Id,Options):-
        prolog_thread_create((prolog_thread_at_exit(mooProcessSelfClean),Goal),Id,Options),
        asserta(isMooProcess(killable,Name,Goal,Id,Options)).

mooProcessCreate(Goal,Id,Options):-
        prolog_thread_create((prolog_thread_at_exit(mooProcessSelfClean),Goal),Id,Options),
        asserta(isMooProcess(killable,thread(Id),Goal,Id,Options)).

mooProcessCreate(Goal):-
        mooProcessCreate(Goal,_Id,[detach(true)]).

isMooProcess(ID,Goal):-
        isMooProcess(_,_,Goal,ID,_).

debugProcess(T):-
	prolog_thread_signal(T, (attach_console, true)).


mooProcessSelfClean:-
      trace, 
      getThread(Id),
      retractall(isMooProcess(_Perms,_Name,_Goal,Id,_Options)).




showMooStatisticsHTML:-
   writeFmt('<pre>'),prolog_statistics,writeFmt('</pre>').

showMooProcessHTML:-
        showMooStatisticsHTML,
        writeFmt('<hr><table border=1 width=80%><th>Id</th><th>Name</th><th>Status</th><th>Actions</th><th>Options</th><th>Goals</th>',[]),
        prolog_current_thread(Id,Status),
        isMooProcess(Perms,Name,Goal,Id,Options),
        writeMooProcessesHTML(Perms,Name,Goal,Id,Options,Status),
        fail.
showMooProcessHTML:-
        writeFmt('</table>',[]).


writeMooProcessesHTML(nokill,Name,Goal,Id,Options,Status):-
        writeFmt('<tr><td>~w</td><td><nobr>~w</td><td>~w</td><td>&nbsp;</a></td><td>~w</td><td>~w</td><tr>\n ',[Id,Name,Status,Options,Goal]),!.

writeMooProcessesHTML(Perms,Name,Goal,Id,Options,Status):-
        writeFmt('<tr><td>~w</td><td><nobr>~w</td><td>~w</td><td><A href="controlpanel.jsp?killable=~w">Kill</a></td><td>~w</td><td>~w</td><tr>\n ',[Id,Name,Status,Id,Options,Goal]),!.

cleanOldProcesses:-
        saveUserInput,
        prolog_current_thread(Id,Status),
        handleProcessStatus(Id,Status),fail.
cleanOldProcesses:-writeSavedPrompt,!.
cleanOldProcesses:-!.

handleProcessStatus(Id,running):-!. %Normal
handleProcessStatus(Id,exited(complete)):-!,prolog_thread_join(Id,_),!.
handleProcessStatus(Id,true):-!, writeSTDERR('% Process ~w complete.\n',[Id]),!,prolog_thread_join(Id,_),!.
handleProcessStatus(Id,exception(Error)):-!, writeSTDERR('% Process ~w exited with exceptions: ~q \n',[Id,Error]),!,prolog_thread_join(Id,_),!.
handleProcessStatus(Id,O):-!, writeSTDERR('% Process ~w exited "~q". \n',[Id,O]),!,prolog_thread_join(Id,_),!.


mutex_call(Goal,Id):-
                        mutex_create(Id),
                        mutex_lock(Id),!,
                        with_mutex(Id,Goal),!,
                        mutex_unlock_all.


% ===================================================================
% File 'moo_utility.pl' 
% Maintainer: Douglas Miles 
% Contact: dmiles@users.sourceforge.net; 
% Version: 'moo_utility.pl' 1.0.0 
% ===================================================================


:-multifile(expireOptimizationsInContext/3).

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).
            
% ===================================================================
% This File is the bootstrap for the Moo Infence engine one first calls "[belief_module]"
% So first is loads the proper files and then starts up the system
% There are no predicates defined in this file (it just uses other files' predicates)
% ===================================================================
% ===================================================================
% EXPORTS
% ===================================================================
isNonVar(Denotation):-not(isSlot(Denotation)).

% Is var means to Moo this is a Slot
isSlot(Denotation):-((isVarProlog(Denotation);isVarObject(Denotation))),!.

isSlot(Denotation,Denotation):- isVarProlog(Denotation),!.
isSlot(Denotation,PrologVar):- isVarObject(Denotation,PrologVar),!.

isHiddenSlot(Term):-fail.

isVarProlog(A):-((var(A);A='$VAR'(_))).

isVarObject(Denotation):-((
		  isObject(Denotation,BaseType),
		  arg(1,Denotation,Value),!,isSlot(Value))).

isVarObject(Denotation,Value):-((
		  isObject(Denotation,BaseType),
		  arg(1,Denotation,Value),!,isSlot(Value))).
	
isObject(Denotation,BaseType):-
	(((atom(BaseType) ->
		  (atom_concat('$',BaseType,F),functor(Denotation,F,2));
		  (functor(Denotation,F,2),atom_concat('$',BaseType,F))
		 ),!)).

isQualifiableAsClass(Atom):-atom(Atom),!.
isQualifiableAsClass('$Class'(Atom,_)):-atom(Atom),!.

isQualifiableAs(Denotation,BaseType,Value):-
		  isObject(Denotation,BaseType),
		  arg(1,Denotation,Value).


isQualifiedAs(Denotation,_,_):-not(compound(Denotation)),!,fail.
isQualifiedAs(Denotation,BaseType,Value):-
		  isQualifiedAs(Denotation,BaseType,Value,SubType).
isQualifiedAs(Denotation,BaseType,Value,SubType):-
		  isObject(Denotation,BaseType),
		  arg(1,Denotation,Value),
		  arg(2,Denotation,List),
		  lastImproperMember(BaseType,SubType,List).

lastImproperMember(Default,Default,List):-isVarProlog(List),!.
lastImproperMember(Default,Default,[]):-!.
lastImproperMember(Default,SubType,List):-proper_list(List),last(SubType,List).
lastImproperMember(Default,SubType,[SubType|End]):-isVarProlog(End),!.
lastImproperMember(Default,SubType,[_|Rest]):-
	lastImproperMember(Default,SubType,Rest),!.
	
		  

isQualifiedAndKnownAs(Denotation,BaseType,Value):-
		  isQualifiedAs(Denotation,BaseType,Value),!,
		  not(isVarProlog(Value)).

isQualifiedAndVarAs(Denotation,BaseType,Value):-
		  isQualifiedAs(Denotation,BaseType,Value),!,
		  isVarProlog(Value).

isQualifiedAndVarAndUnifiable(Denotation,BaseType,NValue):-
		  isQualifiedAs(Denotation,BaseType,Value),!,
		  (isVarProlog(Value);
		  (\+ \+ NValue=Value)),!.

isBodyConnective(Funct):-atom_concat(_,'_',Funct),!.
isBodyConnective(Funct):-atom_concat('t~',_,Funct),!.
isBodyConnective(Funct):-atom_concat('f~',_,Funct),!.
isBodyConnective(Funct):-member(Funct,[and,or,until,',',';',':-',unless,xor,holdsDuring]). % Other Propositional Wrappers

isEntityref(Var,Var):-isSlot(Var),!.
isEntityref(Term,A):-Term=..[F,A,B],!,atom_concat('$',_,F),!.





isLiteralTerm(A):-isLiteralTerm_util(A),!.
isLiteralTerm(not(A)):-isLiteralTerm_util(A),!.

isLiteralTerm_util(A):-var(A),!.
isLiteralTerm_util('$VAR'(_)):-!.
isLiteralTerm_util(string(_)):-!.
isLiteralTerm_util(A):-not(compound(A)),!.
isLiteralTerm_util(A):-string(A).


isEntitySlot(Term):-isSlot(Term),!.
isEntitySlot(Term):-not(compound(Term)),!.
isEntitySlot(Term):-isEntityFunction(Term,FnT,ArgsT),!.

isEntityFunction(Term,FnT,ArgsT):-isSlot(Term),!,fail.
isEntityFunction(Term,FnT,ArgsT):-atomic(Term),!,fail.
isEntityFunction(Term,FnT,ArgsT):-Term=..[FnT|ArgsT],hlPredicateAttribute(FnT,'Function'),!.



% ===================================================================
% getPrologVars/4. 
% ===================================================================

getPrologVars(Term, Vars, Singletons, Multiples) :-
    ((getPrologVars(Term, VarList, []),
    close_list(VarList),
    keysort(VarList, KeyList),
    split_key_list(KeyList, Vars, Singletons, Multiples))).

getPrologVars(Term,  [Term - x|V], V) :-isVarProlog(Term),!.
getPrologVars(Term, V, V) :-not(compound(Term)),!.
getPrologVars(Term,  V0, V) :-
	isQualifiedAs(Term,Type,PrologVar),
	Type \= existential,!,
	(isVarProlog(PrologVar) -> V0=[PrologVar - x|V]; V0=V),!.
	
getPrologVars(Term, V0, V) :- 
	 functor(Term, F, N),
	 getPrologVars(1, N, Term, V0, V).
getPrologVars(I, N, Term, V0, V) :-
    (  (I > N) -> V=V0
    ;   arg(I, Term, Arg),
	getPrologVars(Arg, V0, V1),
	J is I + 1,
	getPrologVars(J, N, Term, V1, V)
    ).

% ===================================================================
% getPrologVars/4. 
% ===================================================================

getAllPrologVars(Term, Vars, Singletons, Multiples) :-
    ((getAllPrologVars(Term, VarList, []),
    close_list(VarList),
    keysort(VarList, KeyList),
    split_key_list(KeyList, Vars, Singletons, Multiples))).

getAllPrologVars(Term,  [Term - x|V], V) :-isVarProlog(Term),!.
getAllPrologVars(Term, V, V) :-not(compound(Term)),!.
getAllPrologVars(Term, V0, V) :- 
	 functor(Term, F, N),
	 getAllPrologVars(1, N, Term, V0, V).
getAllPrologVars(I, N, Term, V0, V) :-
    (  (I > N) -> V=V0
    ;   arg(I, Term, Arg),
	getAllPrologVars(Arg, V0, V1),
	J is I + 1,
	getAllPrologVars(J, N, Term, V1, V)
    ).

% ===================================================================
% getSlots/4. Returns no Existential Body Vars
% ===================================================================

getSlots(Term, Vars, Singletons, Multiples) :-
    ((getSlots(Term, VarList, []),
    close_list(VarList),
    keysort(VarList, KeyList),
    split_key_list(KeyList, Vars, Singletons, Multiples))).

getSlots(Term,  [Term - x|V], V) :-isVarProlog(Term),!.
getSlots(Term, V, V) :-not(compound(Term)),!.
getSlots(Term, V, V) :-isHiddenSlot(Term),!.
getSlots(Term,  VO, V) :-
	isQualifiedAs(Term,existential,EVar),!,
	getSlots(EVar,  VO, V).
getSlots(Term,  V0, V) :-
	isQualifiedAs(Term,Type,PrologVar),!,
	(isVarProlog(PrologVar) -> V0=[Term - x|V]; V0=V),!.
getSlots(Term, V0, V) :- 
	 functor(Term, F, N),
	 getSlots(1, N, Term, V0, V).
getSlots(I, N, Term, V0, V) :-
    (  (I > N) -> V=V0
    ;   arg(I, Term, Arg),
	getSlots(Arg, V0, V1),
	J is I + 1,
	getSlots(J, N, Term, V1, V)
    ).


% ===================================================================
% getConstants/4. 
% ===================================================================

getConstants(Types,Term, Vars, Singletons, Multiples) :-
    ((getConstants(Types,Term, VarList, []),
    close_list(VarList),
    keysort(VarList, KeyList),
    split_key_list(KeyList, Vars, Singletons, Multiples))).

getConstants(Types,Term, [Term - x|V], V) :- getConstants(Types,Term),!.
getConstants(Types,Term, V, V) :- var(Term),!.
getConstants(Types,Term,  FOUND, V) :-
            Term=..[L,I|ST],
            getConstants(Types,L, VL, []),
            consts_l(Types,[I|ST], FLIST),
            append(V,FLIST,UND),
            append(VL,UND,FOUND),!.

getConstants(Types,Term, V, V) :- !.
    
consts_l(Types,[],[]).
consts_l(Types,[L|IST], FLIST):-
         getConstants(Types,L, FOUND,[]), 
         consts_l(Types,IST, FOUNDMore), !,
         append(FOUND,FOUNDMore,FLIST).

    
getConstants(_,Term):- (var(Term) ; Term='$VAR'(_)),!,fail.
getConstants(atomic,A):-atomic(A).
getConstants(skolems,'zzskFn'(_)).
getConstants(funct,'AssignmentFn'(_,_)).
getConstants(_,A):-!,fail.







retractallLogged(T):-
	format(':-retractall(~q).~n',[T]),
	retractall(T).

assertLogged(T):-
	format(':-assert(~q).~n',[T]),
	assert(T).



asserta_if_new(A):-A,!.
asserta_if_new(A):-asserta(A),!.


pvar_gen('$VAR'(N)):-idGen(N),!.


tn_link(Clause,ETracking,Context,ETracking):-!.

tn_link(Clause,ETracking,Context,theorya(Context,Num)):-atomic(ETracking),atom_codes(ETracking,[84,45|Rest]),!,number_codes(Num,Rest).
tn_link(Clause,ETracking,Context,theoryb(Context,ETracking)):-!.


ignore(X,Y):-ignore((X,Y)).


%   select(?Element, ?List, ?List2)
%   is true when the result of removing an occurrence of Element in List
%   is List2.
     /*
select(Element, [Element|Tail], Tail).
select(Element, [Head|Tail1], [Head|Tail2]) :-
        select(Element, Tail1, Tail2).
       */
	      
%======================================================================
% CLSID Generation
% idGen(+Var)
% Creates a new unique number   TODO
%
% Example:
% | ?- idGen(X).
% X = 2234
%======================================================================


idGen(X):-nonvar(X),!.
idGen('$VAR'(N)):-nonvar(N),!,sendNote(user,'MooKernel','Prolog Code Bug','Attempt to Gen CLSID on a frozen variable'),!,fail.
idGen(X):-retract(clsid(N)),X is N+1, assert(clsid(X)),!.
idGen(X):-get_time(T),convert_time(T,A,B,C,D,E,F,G),X  is 20000 + D *1000 + G * 1000 + F * 10 + E * 40,XX is X // 3 ,!,assert(clsid(X)).

getPrettyDateTime(String):-get_time(Time),convert_time(Time, String).

% ===================================================================
% has_singleton_vars(-Term).
% Checks for singleton variables
%
% Example:
%| ?- has_singleton_vars(a(X)).
% yes
%
%| ?- has_singleton_vars(a(X,X)).
% no
% ===================================================================


var_merge(L1,L2,O):-
	close_ll(L1,L11),
	close_ll(L2,L22),
	append(L1,L2,L4),
	catch(sort(L4,O),_,L4=O),!.
var_merge(L1,L2,L2):-!.

close_ll([],[]):-!.
close_ll(L1,[]):-isSlot(L1),!.
close_ll([H|T],[H|TT]):-close_ll(T,TT),!.


has_singleton_vars(Clause):-getPrologVars(Clause,_,[_|_],_).
has_singleton_vars(Clause):-getPrologVars(Clause,[_|_],_,[]).

% ===================================================================
% any_to_string(+Term,?String).
% converts any term to a list of prolog chars
%
% Example:
% | ?- any_to_string(X,Y).
% X = _h83
% Y = [95,104,56,51]
% | ?- any_to_string("X",Y).
% Y = [91,56,56,93]
% | ?- any_to_string("t(r)",Y).
% Y = [91,49,49,54,44,52,48,44,49,49,52,44,52,49,93]
% ===================================================================

any_to_string(Term,String) :- !,fmt_write_string(Atom,"%S",args(Term)),atom_codes(Atom,String).

% ===================================================================
% conv(?List,?Term) 
% conv_det(+List,-Term)
% term_to_list(?Term,?List)
% term_to_atomlist(?Term,?AtomList)

% Based on Conjuctions
% term_to_list/2 is the inverse of  conv(?List,?Term) and conv_det(+List,-Term)  

% term_to_atomlist/2 is a more agressive form of term_to_list
% Examples:
/*
| ?- conv(X,Y).
X = []
Y = true

| ?- conv([a,b],Y).
Y = (a  ','  b)

| ?- conv(Out,(a :- b)).
Out = [(a :- b)]


*/
% ===================================================================

conv([],true):-!.
conv([X|T],(X,R)) :- T \== [],!,conv(T,R).
conv([X],(X)).

conv_det([],true):-!.
conv_det(V1,_V2):-var(V1),!,fail.
conv_det([X|T],(X,R)) :- T \== [],!,conv_det(T,R).
conv_det([X],(X)).

term_to_list(Var,[]):-var(Var).
term_to_list(','(A,B,C,D,E,F),List):-!,term_to_list(((A,B),C),AL),term_to_list(((D,E),F),BL),append(AL,BL,List).
term_to_list(','(A,B,C,D,E),List):-!,term_to_list(((A,B),C),AL),term_to_list((D,E),BL),append(AL,BL,List).
term_to_list(','(A,B,C,D),List):-!,term_to_list(((A,B),C),AL),term_to_list((D),BL),append(AL,BL,List).
term_to_list(','(A,B,E),List):-!,term_to_list(((A,B)),AL),term_to_list((E),BL),append(AL,BL,List).
term_to_list((A,B),List):-!,term_to_list(A,AL),term_to_list(B,BL),append(AL,BL,List).
term_to_list(true,[]):-!.
term_to_list(List,List):-is_list(List).
term_to_list(Term,[Term]):-compound(Term).
term_to_list(Term,[Term]):-atomic(Term).

term_to_atomlist([Var],[Var]) :- ( var(Var) ; atomic(Var) ),!.
term_to_atomlist([TERM],[H|T]):-!,
         TERM=..[H|Args],
         term_to_atomlist(Args,T).
term_to_atomlist([H|T],List):-!,
         term_to_atomlist([H],HList),
         term_to_atomlist(T,TList),
         append(HList,TList,List).
term_to_atomlist(Term,AtomList):-!,
         conv(TermList,Term),
         term_to_atomlist(TermList,AtomList). 


% ===================================================================
% getSharedVariables(Term1,Term2).
% tests to see if Varables are shared between two Terms
% ===================================================================

getSharedVariables(Left,Right):-copy_term((Left,Right),(VLP,VRP)),numbervars((VLP,VRP)),
            term_to_atomlist(VLP,VLPP),term_to_atomlist(VRP,VRPP),
             member('$VAR'(N),VLPP),member('$VAR'(N),VRPP).
                                          
                                          
% ===================================================================
% delete_once/3.
/*
delete_once(+List1, ?Elem, ?List2)
Delete forall members of List1 that simultaneously equal with Elem and equal the result with List2. 
*/

% ===================================================================

delete_once([],X,X):-!.
delete_once(_,[],[]):-!.
delete_once([DeleteThisItem],[DeleteThisItem|ListOfMore],ListOfMore):-!.
delete_once([DeleteThisItem],[Skip|ListOfMore],[Skip|ListAfterDelete]):- !,
         delete_once([DeleteThisItem],ListOfMore,ListAfterDelete).
delete_once([DeleteThisItem|DeleteThese],SourceList,ResultList):-!,
         delete_once([DeleteThisItem],SourceList,DeleteThisItemResult),
         delete_once(DeleteThese,DeleteThisItemResult,ResultList).


% ===================================================================
% clean_true(+DirtyTerm,-CleanTerm).
% removes resundant true atoms from terms
% ===================================================================

clean_true(X,Y):-once((term_to_list(X,L))),once((delete(L,true,L2))),once((conv_det(L2,Y))).

% ===================================================================
% optional_bound(+Term1,+Term2).
% Prepairs an option binding and alway succeeds
% ===================================================================
optional_bound(Left,Right):-ignore(Left=Right).



% ===================================================================
% Global Variable Manipuitalion for Moo
% ===================================================================

%global_set(Name,Value):-flag(Name,_,Value).

global_increment(Name):-flag(Name,N,N+1).

%global_get(Name,Value):- flag(Name,Value,Value).

copy_term(Term,TermCopy,CopyOfVars):-copy_term(Term,TermCopy),
               getPrologVars(TermCopy,CopyOfVars,_,_).


% ===================================================================
%    moo_B_consult/1
% ===================================================================

moo_B_consult(FileName):-
      [FileName],!.

moo_B_consult(FileName):-real_prolog_file_name(FileName,AbsoluteFile),
      [AbsoluteFile].

% ===================================================================
%    moo_B_load_dyn/1
% ===================================================================

moo_B_load_dyn(FileName):-
               real_file_name(FileName,LocalFile),
               load_dyn(LocalFile).
/*
               file_open(LocalFile,'r',INPUT),
               repeat,
               file_read(INPUT,Term),
               assert(Term),
               Term=end_of_file,!,
               moo_B_seen,!.
  */

assert_prolog(X,_) :- (var(X)),!.
assert_prolog([H|T],Vars) :-list_to_term([H|T],Term),!,assert_prolog(Term,Vars).
assert_prolog(PTERM_NATIVE,Vars):-PTERM_NATIVE=..[C,X,Y],'surface-instance'(C,'Junctive',_),!,
         assert_prolog(X,Vars),
         assert_prolog(Y,Vars).
assert_prolog(X,_Vars) :- predicate_property(X,built_in),!. 
assert_prolog(X,_Vars) :- ground(X),retract(X),fail.
assert_prolog(X,_Vars) :- /* not(exists_in_database(X)),!, */ assert(X). %, writeIfOption(modification,(X),Vars).
assert_prolog(_X,_Vars) :- !. %,not(exists_in_database(X)), assert_prolog(X). %writeIfOption(disp_modification,assert_prolog(X),Vars)

assert_prolog(Context_atom,WFF,Vars):-
         add_context(Context_atom,WFF,WFFAC),
         assert_prolog(WFFAC,Vars).



do_to_conjuncts(Var,G):- (var(Var);var(G)),!.
do_to_conjuncts((A,B),G):- !,
         ignore(once(do_to_conjuncts(A,G))),
         ignore(once(do_to_conjuncts(B,G))).
do_to_conjuncts(A,G):- !,
         ignore((C=..[G,A],once(C))).  

do_to_conjuncts(Var,Var2,G):- (var(Var);var(Var2   );var(G)),!.



do_to_conjuncts(V,(A,B),G):- !, %numbervars((A,B)),
         ignore(once(do_to_conjuncts(V,A,G))),
         ignore(once(do_to_conjuncts(V,B,G))).

do_to_conjuncts(V,A,G):- !,
         ignore((C=..[G,V,A],once(C))).  
                        


mretractall(TERM):-!, functor(TERM,F,A),predicate_property(TERM,Z),!,abolish(F/A),predicate_property(TERM,Q),!,dynamic(F/A),predicate_property(TERM,P),!. 


set_for_hilog_table(PrologForm):- 
            functor(PrologForm,OP,_A), 
            (predicate_property(PrologForm,(built_in)) ; 'surface-instance'(OP,'Connective',_)),!.

set_for_hilog_table(PrologForm):- telling_file,
            functor(PrologForm,OP,A), 
         	write_clause_to_file(assert(functsymbol(OP/A))), % Asserts to be known for Non
         	write_clause_to_file((table(OP/A))), % 
            write_clause_to_file(hilog(OP)).
set_for_hilog_table(_PrologForm).

exists_in_database((Y:-_)):-predicate_property(Y,built_in).
exists_in_database((X)):-predicate_property(X,built_in).
exists_in_database((Y:-X)):-!,not(predicate_property(Y,built_in)),clause(Y,X).
exists_in_database((Y)):-!,not(predicate_property(Y,built_in)),clause(Y,true).



clause_id_gen(CLID):-idGen(CLID).



% not assertzble objects
non_assertzble(Var):-var(Var),!.
non_assertzble([]):-!.
non_assertzble(end_of_file):-!.
non_assertzble('end-of-file'):-!.
non_assertzble(fail):-!.
non_assertzble(false):-!.
non_assertzble(true):-!.
non_assertzble(comment(_C)):-!.
non_assertzble(browser_only(_C)):-!.
non_assertzble(List):-is_list(List),length(List,X),X<8,!. 

once_ignore(X):-once(ignore(X)).

get_storage_file(PrivateName,RD):-
   'LOGIC_ENGINE_RT'(RealDir),
   atom_codes(RealDir,RealDirS),
   append(RealDirS,[47|PrivateName],RDS),
   atom_codes(RD,RDS).

get_storage_exists_file(PrivateName,RD):-
   'LOGIC_ENGINE_RT'(RealDir),
   atom_codes(RealDir,RealDirS),
   append(RealDirS,[47|PrivateName],RDS),
   atom_codes(RD,RDS),
   (not(exists_file(RD)) -> 
      (file_open(RD,'w',IOPort),fmt_write(IOPort,"end_of_file.\n",_),file_close(IOPort))  % Make the file
      ; true ).


/*
% SWI Builtin
union([X|L1],L2,L3) :-
	identical_member(X,L2),
	!,
	union(L1,L2,L3).
union([X|L1],L2,[X|L3]) :-
	union(L1,L2,L3).
union([],L,L).
*/
% ===================================================================
%  safe_theory_info_db(Context_Name,Can,WFS,PFile) Creates file paths
% ===================================================================


safe_theory_info_db(Context_Name,Can,WFS,PFile):-
                  theory_make_status_start(theory(Context_Name,Can)=_),!,
                  add_file_extension(".wfs",Can,WFS),
                  add_file_extension(".P",Can,PFile),!.

safe_theory_info_db(Context_Name,error,error,error):- sendNote(error,ioSubsystem,'Context file not found',['the Context is like not correct ',Context_Name]),!,fail.

                  
actual_file_name(SourceFile,SourceFileLocal):-
            atom_codes(SourceFile,[99,58,47,47|Rest]),!,
            atom_codes(NewSourceFile,[99,58,47|Rest]),
            actual_file_name(NewSourceFile,SourceFileLocal).

actual_file_name(SourceFileLocal,SourceFileLocal):-!.


safe_file_open(SourceFile,MODE,HANDLE):-
                  actual_file_name(SourceFile,SourceFileLocal),
                  file_open(SourceFileLocal,MODE,TH),
                        (TH = (-1) ->
                                    (sendNote(error,ioSubsystem,'file not found',['the file or path ',SourceFile,' is not accessable ']),!,fail )
                                    ;
                                   HANDLE=TH) .





% ===================================================================
% split_key_list/4. (Adapted from Richard O'Keefe). 
% ===================================================================


split_key_list([], [], [], []).
split_key_list([V-_,W-_|Vs], Vars, Singletons, Multiples) :- W == V, !,
    Vars = [V|Vars1],
    Multiples = [V|Multiples1],
    split_key_list(Vs, V, Vs1),
    split_key_list(Vs1, Vars1, Singletons, Multiples1).
split_key_list([V-_|Vs], [V|Vars], [V|Singletons], Multiples) :-
    split_key_list(Vs, Vars, Singletons, Multiples).
split_key_list([W - _|Vs], V, Vs1) :- W == V, !,
    split_key_list(Vs, V, Vs1).
split_key_list(Vs1, _, Vs1).




close_list([]):-!.
close_list([_]):-!.
close_list([_,_]):-!.
close_list([_,_|CLOSE]):-!,close_list(CLOSE).
close_list([_,_,_|CLOSE]):-!,close_list(CLOSE).
close_list([_,_,_,_,_|CLOSE]):-!,close_list(CLOSE).
close_list([_,_,_,_,_,_,_|CLOSE]):-!,close_list(CLOSE).

open_list(A,B):-!,append(A,_,B).



unbind_numbers('$VAR'(P),'$VAR'(P)):-!.
unbind_numbers('AssignmentFn'(P,Q),'AssignmentFn'(P,Q)):-!.
unbind_numbers(P,_):-number(P),!.
unbind_numbers(P,P):-var(P),!.
unbind_numbers(P,Q):- !,P =.. [F|ARGS],!,
                   unbind_numbers_l(ARGS,UARGS),
                    Q=..[F|UARGS],!.

unbind_numbers_l([],[]).
unbind_numbers_l([A|RGS],[U|ARGS]):-!,
         unbind_numbers(A,U),
         unbind_numbers_l(RGS,ARGS),!.


consult_as_dynamic(FilenameLocal):- 
         open(FilenameLocal,'read',R),   
         repeat,
         read(R,TERM),
         ((TERM = end_of_file -> (true,!) ; 
               ((
                 assert(TERM),fail
                 ))
         )),!,
         close(R).

% ===================================================================
% Substitution based on ==
% ===================================================================

% Usage: subst(+Fml,+X,+Sk,?FmlSk)

subst(A,B,C,D):-(nd_subst(A,B,C,D)),!.

nd_subst(  Var, VarS,SUB,SUB ) :- Var==VarS,!.
nd_subst(        P, X,Sk,        P1 ) :- functor(P,_,N),nd_subst1( X, Sk, P, N, P1 ).

nd_subst1( _,  _, P, 0, P  ).

nd_subst1( X, Sk, P, N, P1 ) :- N > 0, P =.. [F|Args], nd_subst2( X, Sk, Args, ArgS ),
            nd_subst2( X, Sk, [F], [FS] ),
            P1 =.. [FS|ArgS].

nd_subst2( _,  _, [], [] ).
nd_subst2( X, Sk, [A|As], [Sk|AS] ) :- X == A, !, nd_subst2( X, Sk, As, AS).
nd_subst2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, nd_subst2( X, Sk, As, AS).
nd_subst2( X, Sk, [A|As], [Ap|AS] ) :- nd_subst( A,X,Sk,Ap ),nd_subst2( X, Sk, As, AS).
nd_subst2( X, Sk, L, L ).

weak_nd_subst(  Var, VarS,SUB,SUB ) :- Var=VarS,!.
weak_nd_subst(        P, X,Sk,        P1 ) :- functor(P,_,N),weak_nd_subst1( X, Sk, P, N, P1 ).

weak_nd_subst1( _,  _, P, 0, P  ).

weak_nd_subst1( X, Sk, P, N, P1 ) :- N > 0, P =.. [F|Args], weak_nd_subst2( X, Sk, Args, ArgS ),
            weak_nd_subst2( X, Sk, [F], [FS] ),
            P1 =.. [FS|ArgS].

weak_nd_subst2( _,  _, [], [] ).
weak_nd_subst2( X, Sk, [A|As], [Sk|AS] ) :- X = A, !, weak_nd_subst2( X, Sk, As, AS).
weak_nd_subst2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, weak_nd_subst2( X, Sk, As, AS).
weak_nd_subst2( X, Sk, [A|As], [Ap|AS] ) :- weak_nd_subst( A,X,Sk,Ap ),weak_nd_subst2( X, Sk, As, AS).
weak_nd_subst2( X, Sk, L, L ).


% ===================================================================
% Destructive Freezing/Melting
% ===================================================================

call_frozen(Goal):-
	copy_term(Goal,Copy),
	crossref_vars(Goal,Copy,CopyKey),
	call(Copy),
	setarg_vars(Copy,CopyKey,Goal).
	

freeze_vars(Fml,Frozen,MeltKey):-
	copy_term(Fml,Frozen),
	crossref_vars(Fml,Frozen,MeltKey),
	numbervars(Frozen),!.
	
melt_vars(Frozen,[]=[],Frozen):- !.
melt_vars(Frozen,[OV|OL]=[FV|VL],Thawed):-
	subst(Frozen,FV,OV,Thawing),
	melt_vars(Thawing,OL=VL,Thawed),!.

setarg_vars(Frozen,[]=[],Frozen):- !.
setarg_vars(Frozen,OL=NL,Thawed):-
	OT=..[getPrologVars|OL],
	NT=..[getPrologVars|NL],
	setarg_vars(1,Frozen,OT,OL,NT,NL,Thawed).
	
setarg_vars(_,Thawed,OT,OL,_,[],Thawed):-!.
setarg_vars(N,Frozen,OT,[OH|OL],NT,[NH|NL],Thawed):-
	setarg(N,OT,NH),
	NN is N +1,
	setarg_vars(NN,Frozen,OT,OL,NT,NL,Thawed),!.
	

crossref_vars(Fml,Frozen,FmlVars = FrozenVars):-
	free_variables(Fml,FmlVars),
	free_variables(Frozen,FrozenVars),!.


% ===================================================================
% Substitution based on =
% ===================================================================

% Usage: repl(+Fml,+X,+Sk,?FmlSk)

replc(Fml,X,Sk,FmlSk):-
	(repl(Fml,X,Sk,FmlSk)),!.
/*
	copy_term(Fml,FmlX),
	numbervars(FmlX),
	repl(FmlX,X,Sk,FmlSk),!.
*/	
		

repl(  Var, VarS,SUB,SUB ) :- Var=VarS,!.
repl(        P, X,Sk,        P1 ) :- functor(P,_,N),repl1( X, Sk, P, N, P1 ).

repl1( _,  _, P, 0, P  ).

repl1( X, Sk, P, N, P1 ) :- N > 0, P =.. [F|Args], repl2( X, Sk, Args, ArgS ),
            repl2( X, Sk, [F], [FS] ),
            P1 =.. [FS|ArgS].

repl2( _,  _, [], [] ).
repl2( X, Sk, [A|As], [Sk|AS] ) :- X = A, !, repl2( X, Sk, As, AS).
repl2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, repl2( X, Sk, As, AS).
repl2( X, Sk, [A|As], [Ap|AS] ) :- repl( A,X,Sk,Ap ),repl2( X, Sk, As, AS).
repl2( X, Sk, L, L ).

weak_repl(  Var, VarS,SUB,SUB ) :- Var=VarS,!.
weak_repl(        P, X,Sk,        P1 ) :- functor(P,_,N),weak_repl1( X, Sk, P, N, P1 ).

weak_repl1( _,  _, P, 0, P  ).

weak_repl1( X, Sk, P, N, P1 ) :- N > 0, P =.. [F|Args], weak_repl2( X, Sk, Args, ArgS ),
            weak_repl2( X, Sk, [F], [FS] ),
            P1 =.. [FS|ArgS].

weak_repl2( _,  _, [], [] ).
weak_repl2( X, Sk, [A|As], [Sk|AS] ) :- X = A, !, weak_repl2( X, Sk, As, AS).
weak_repl2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, weak_repl2( X, Sk, As, AS).
weak_repl2( X, Sk, [A|As], [Ap|AS] ) :- weak_repl( A,X,Sk,Ap ),weak_repl2( X, Sk, As, AS).
weak_repl2( X, Sk, L, L ).


%Shared with XSB




file_newer(F1,F2):- time_file(F1,T1),time_file(F2,T2),!,T1>T2.


%:-getenv('LOGIC_ENGINE_RT',RealDir),assert('LOGIC_ENGINE_RT'(RealDir)) .

reconsult(F):-consult(F).

set_global_compiler_options(_Ignore).
load_dyn(X):-[X].
assert_new(X):-retractall(X),assert(X).

%%:-load_library(library(quintus)).


file_open(FileName,r,IOPort):- open(FileName,read,IOPort,[type(binary)]).
file_open(FileName,w,IOPort):- open(FileName,write,IOPort,[type(binary)]).
file_close(IOPort):-close(IOPort).

fmt_write_string(String,Format,Args):- catch(Args=..[_|FARGS],_,FARGS=[]),
      string_to_atom(Format,FMTSTR),
      fmtString(String,FMTSTR,FARGS).

fmt_write(Format,Args):- catch(Args=..[_|FARGS],_,FARGS=[]),
      string_to_atom(Format,FMTSTR),
      writeFmt(FMTSTR,FARGS).

fmt_write(OUTPUT,Format,Args):- catch(Args=..[_|FARGS],_,FARGS=[]),
      string_to_atom(Format,FMTSTR),
      writeFmt(OUTPUT,FMTSTR,FARGS).

real_file_name(X,X).

setPrologFlag(X,Y):-catch(current_prolog_flag(X,Y),_,fail).
setPrologFlag(_,' ').

%import(_ignore).
%export(_ignore).

real_kif_file_name(_FileName,AbsoluteFile):-
      once(add_file_extension(".kif",_FileName,SeeThisFile)),
      once(add_file_user_lib_directory(SeeThisFile,AbsoluteFile)).
                                                         
real_prolog_file_name(_FileName,AbsoluteFile):-
      once(add_file_extension(".P",_FileName,SeeThisFile)),
      once(add_file_user_lib_directory(SeeThisFile,AbsoluteFile)).
                                                         

add_file_user_lib_directory(_LocalFile,AbsoluteFile):- 
         name(_LocalFile,FileNameString),
         once((('LOGIC_ENGINE_RT'(RTD),!,name(RTD,RTDString));((writeIfOption(cb_error,'MOO_XSB_RT Not Set in Environment',_),RTDString=[])))),
         once(append(RTDString,[47|FileNameString],LEPAth)),
         name(AbsoluteFile,LEPAth).

add_file_extension(EXT,FileName,LocalFile):-atom_codes(Extension,EXT),
            safe_file_name_extension(FileName, Extension, LocalFile).

safe_file_name_extension(SourceFile,Ext,SurfaceFile):-
            actual_file_name(SourceFile,File),
            file_name_extension(Base,_,File), 
            file_name_extension(Base,Ext,SurfaceFile). 


file_get0(IOPort,end_of_file):-  at_end_of_stream(IOPort),!.
file_get0(IOPort,Char):- get_code(IOPort,Char),ignore((Char<0)).
 

file_getbuf(IOPort,1,Char,1):-get_char(IOPort,Char).


max(X,Y,Max) :-
	X >= Y ->
		Max = X;
	%true ->
		Max = Y.

min(X,Y,Min) :-
	X =< Y ->
		Min = X;
	%true ->
		Min = Y.



isCharCodelist([]).  isCharCodelist([A|T]):-integer(A),A>9,A<128,isCharCodelist(T).


nop.
nop(_).

conjoin(A,B,C) :-
	A == true ->
		C = B;
	B == true ->
		C = A;
	A == false ->
		C = false;
	B == false ->
		C = false;
	%true ->
		C = (A , B).

disjoin(A,B,C) :-
	A == true ->
		C = true;
	B == true ->
		C = true;
	A == false ->
		C = B;
	B == false ->
		C = A;
	%true ->
		C = (A ; B).




delete_ident(V,_,V):-isSlot(V),!.
delete_ident([],_,[]):-!.
delete_ident([Item|L1],ItemT,L2):-Item==ItemT, !,delete_ident(L1,ItemT,L2).
delete_ident([A|L1],ItemT,[A|L2]):-!,delete_ident(L1,ItemT,L2).


nth_identical_member(X,[],_):-!,fail.
nth_identical_member(X,[XX|_],1):-X==XX,!.
nth_identical_member(X,[_|XXs],NN):- nth_identical_member(X,XXs,N),NN is N + 1.


% ==========================================================
% TEMP DB
% ==========================================================

assert_conj(end_of_file,0).
assert_conj(end_of_file:_,0).
assert_conj(true,0).
assert_conj((X,Y):V,(XX,YY):V):-!,
      assert_conj(X,XX),
      assert_conj(Y,YY).
assert_conj((X,Y),(XX,YY)):-!,
      assert_conj(X,XX),
      assert_conj(Y,YY).

assert_conj(Y,0):- catch(in_pl_db(Y),E,fail),!.
assert_conj(Y,Ref):-!,unnumbervars(Y,Z),logOnFailure(assert(Z,Ref)).

in_pl_db((IH:-IB)):-!,
	renumbervars((IH:-IB),(H:-B)),!, 
	clause(H,B,CLDEX),
	clause(RH,RBody,CLDEX),
	numbervars((RH,RBody),'Test',0,_),numbervars((H,Body),'Test',0,_),
	(RH,RBody)==(H,Body),!.

in_pl_db(IH):-!,
	renumbervars((IH),(H)),!,
	clause(H,true,CLDEX),
	clause(RH,true,CLDEX),
	numbervars((RH),'Test',0,_),numbervars((H),'Test',0,_),
	(RH)==(H),!.
	
renumbervars(N,U):-
	unnumbervars(N,U),
	numbervars(U,'Test',0,_),!.

retract_ref(0):-!.
retract_ref((X,Y)):-!,
	retract_ref(X),
	retract_ref(Y).
retract_ref(X):-!,erase(X);true.


retract_conj(end_of_file,true).
retract_conj(end_of_file:_,true).
retract_conj(true,true).
retract_conj((X,Y):V,(XX,YY):V):-!,
      retract_conj(X,XX),
      retract_conj(Y,YY).
retract_conj((X,Y),(XX):V):-!,
      retract_conj(X,XX),
      retract_conj(Y,YY).

retract_conj((IH:-IB),(IH:-IB)):-!,
	renumbervars((IH:-IB),(H:-B)),!, 
	clause(H,B,CLDEX),
	clause(RH,RBody,CLDEX),
	numbervars((RH,RBody),'Test',0,_),numbervars((H,Body),'Test',0,_),
	(RH,RBody)==(H,Body),erase(CLDEX).

retract_conj((IH),(IH)):-!,
	renumbervars((IH),(H)),!, 
	clause(H,B,CLDEX),
	clause(RH,RBody,CLDEX),
	numbervars((RH),'Test',0,_),numbervars((H),'Test',0,_),
	(RH)==(H),erase(CLDEX).

retract_conj((IH),true):-!.



listing_template(T):-clause(T,N),
	format('~q:-~q.\n',[T,N]),
	fail.
	
listing_template(T).



assert_conj_count(A,C):-
         flag('Assert Conj',_,0),
         assert_conj_c(A),!,
         flag('Assert Conj',C,C),!.

assert_conj_c(end_of_file).
assert_conj_c(true).
assert_conj_c((X,Y)):-
      assert_conj_c(X),
      assert_conj_c(Y).
assert_conj_c(Y):-logOnFailure(assert(Y)),global_increment('Assert Conj').

retract_conj_count(A,C):-
         flag('Retract Conj',_,0),
         retract_conj_c(A),!,
         flag('Retract Conj',C,C),!.

retract_conj_c(end_of_file).
retract_conj_c(true).
retract_conj_c((X,Y)):-
      retract_conj_c(X),
      retract_conj_c(Y).
retract_conj_c(Y):-retractall(Y),global_increment('Retract Conj').

assert_conj_q(true).
assert_conj_q((X,Y)):-!,
      assert_conj_q(X),
      assert_conj_q(Y).
assert_conj_q(Y):-logOnFailure(assert(Y)). % ,post_each_can_form(Y).

retract_conj_q(true).
retract_conj_q((X,Y)):-!,
      retract_conj_q(X),
      retract_conj_q(Y).
retract_conj_q(Y):-retractall(Y),post_each_can_form(Y).



concat_shell(Shell,yes):-logOnFailure(concat_atom(Shell,ShellCmd)),ignore(shell(ShellCmd)).

sandbox(G):-catch(G,_,fail). % TODO .. add to ISO Standard :)


my_catch(X,E,G):-catch(X,E,G).

deduce_by(_).

unifiable_member(X,[Y|_]) :-			% run-time predicate to
	unify_with_occurs_check(X,Y),!.				% find complementary ancestor
unifiable_member(X,[_|L]) :-
	unifiable_member(X,L).

identical_member(X,[Y|_])  :-			% run-time predicate to
	X == Y,					% find identical ancestor
	!.

identical_member(X,[_|L]) :-
	identical_member(X,L).
	
fidentical_member(X,[Y|_])  :-			% run-time predicate to
	X == Y -> ! ;identical_member(X,[_|L]).
	 		
	

nonidentical_member(X,[Y|L]) :-			% run-time predicate to
	X \== Y,				% find identical ancestor
	nonidentical_member(X,L).
nonidentical_member(_X,[]).

differing_member(X,[Y|L]) :-			% run-time predicate to
	dif(X,Y),				% constrain literal to not
	differing_member(X,L).			% be identical to ancestor
differing_member(_X,[]).


apply_to_conjuncts(Wff,P,Wff1) :-
	Wff = (A , B) ->
		apply_to_conjuncts(A,P,A1),
		apply_to_conjuncts(B,P,B1),
		conjoin(A1,B1,Wff1);
	%true ->
		P =.. G,
		append(G,[Wff,Wff1],G1),
		T1 =.. G1,
		call(T1).

apply_to_elements([X|L],P,Result) :-
	P =.. G,
	append(G,[X,X1],G1),
	T1 =.. G1,
	call(T1),
	apply_to_elements(L,P,L1),
	conjoin(X1,L1,Result).
apply_to_elements([],_,true).

apply_to_elements2([X|L],P,[X1|L1]) :-
	T1 =.. [P,X,X1],
	call(T1),
	apply_to_elements2(L,P,L1).
apply_to_elements2([],_,[]).


apply_to_list([],_,[]).
apply_to_list([Elem|List],P,[Elem1|List1]) :-
	T =.. [P,Elem,Elem1],
	call(T),
	apply_to_list(List,P,List1).


apply_to_list_flat([],_,[]).
apply_to_list_flat([Elem|List],P,ResList) :-
	T =.. [P,Elem,Result1],
	call(T),
	apply_to_list(List,P,List1),
	append(Result1,List1,ResList).




mreplc(F,F,R,R):-!.
mreplc(B,_,_,B):-not(compound(B)),!.
mreplc([H|Body],F,R,[NH|NBody]):-!,
	mreplc(H,F,R,NH),!,
	mreplc(Body,F,R,NBody),!.
mreplc(A,F,R,Rs):-!,
	A=..[H|Body],%  true,
	mreplc(H,F,R,NH),
	mreplc(Body,F,R,NBody),
	Rs=..[NH|NBody].
mreplc(B,_,_,B).



getfunctor(not(Fact),A):-!,getfunctor(Fact,A).
getfunctor('~'(Fact),A):-!,getfunctor(Fact,A).
getfunctor(Fact,holds):-Fact=..[holds,A|_],isSlot(A),!.
getfunctor(Fact,A):-Fact=..[holds,A|_],!.
getfunctor(Fact,A):-functor(Fact,A,_).


% uses getPrologVars(Goal, Vars, Singletons, Multiples)
		


list_to_comma(Var,Var):-isSlot(Var),!.
list_to_comma([Var],Var):-isSlot(Var),!.
list_to_comma([],true).
list_to_comma([X],X).
list_to_comma([X|Y],(XX,YY)):-!,
	list_to_comma(X,XX),
	list_to_comma(Y,YY).
list_to_comma(and(X,Y),(XX,YY)):-!,
	list_to_comma(X,XX),
	list_to_comma(Y,YY).
list_to_comma(X,X).
	


conjunctsToList(Ante,Ante):-isSlot(Ante),!.
conjunctsToList([],[]).
conjunctsToList(and(A,B),List):-
	conjunctsToList(A,AL),		
	conjunctsToList(B,BL),
	append(AL,BL,List).		
conjunctsToList([A|B],List):-
	conjunctsToList(A,AL),		
	conjunctsToList(B,BL),
	append(AL,BL,List).		
conjunctsToList((A,B),List):-
	conjunctsToList(A,AL),		
	conjunctsToList(B,BL),
	append(AL,BL,List).		
conjunctsToList((Ante),[(Ante)]).




prologEach([],Item,_):-!.
prologEach([Item|Rest],Test,Goal):-((
	not(not((Item=Test,Goal))),!,
	prologEach(Rest,Test,Goal),!)).


prologAtLeastOne([],Item,_):-!.
prologAtLeastOne([Item|Rest],Item,Goal):-once(Goal),!.
prologAtLeastOne([_|Rest],Item,Goal):-
	prologAtLeastOne(Rest,Item,Goal),!.

prologPartitionList(Pos,Item,Goal,Passed,Unshared):-
	(prologPartitionList1(Pos,Item,Goal,Passed,Unshared)).

prologPartitionList1([],_,_,[],[]):-!.
prologPartitionList1([Item|Rest],Test,Goal,[Item|Passed],Failures):-
	not(not((Item=Test,Goal))),!,
	prologPartitionList1(Rest,Test,Goal,Passed,Failures).
prologPartitionList1([Failed|Rest],Item,Goal,Passed,[Failed|Failures]):-!,
	prologPartitionList1(Rest,Item,Goal,Passed,Failures).


remove_numbers([],[]):-!.
remove_numbers([N|L],LL):-number(N),remove_numbers(L,LL),!.
remove_numbers([N|L],[N|LL]):-remove_numbers(L,LL),!.

%% :-include('moo_header.pl').
% This file changes Well Founded Semantic Prolog into a more normaized form of WFS-Prolog

/*
For example:

Special predicates...

		not('instance'('Fido','Cat')) to

		~'instance''('Fido','Cat'))

Holdable (Hilog) predicates...

		nextto('Fido','Cat')

		'Q'(nextto,'Fido','Cat')

Meta/Aggregate Predicates

Logical Connective Predicates are not re-literated but explored the equal way Aggregates are

Inline-Predicates (Implemented outside the scope of the Logic Engine)


All predicates have an additional property about how negation is preformed:

Eigther by failure or by explicit negative forms

Explicit negative forms are created internally by taking the root operator and appending '~' to it's name
Failure based predicates are wrapped with 'not/1' and wont be checked for explicit negation


possible(X) -> (X ; not(not(X))
consistent(X) -> (not(not(X))
forall(X) -> (X , not(not(X)) )
any(X) -> (X)
exists(X) -> (X ; not(not(X) )
never(X) -> not(X)
known(X) -> (X ; not(X))

matrix (X/not(X))  (and/or)  (not(X)/not(not(X)))


   X 
  ~X
  -X
 -~X
   X
  ~X
  -X
 -~X




X ; not(X)
not(X) ; not(X)
not(not(X)) ; not(X)
X ; not(X)
not(X) ; not(X)
not(not(X)) ; not(X)


*/


/*
:-module(
      moo_krlog,
      [krlog_to_prolog/2,prolog_to_krlog/2,pterm_to_bt/3]
      ).
*/

% ===================================================================
% krlog_to_prolog(KRProlog,Prolog)  Converts And/Or/Implies terms to Proper Prolog
% ====================================================================

krlog_to_prolog(A,A):-isSlot(A),!.
krlog_to_prolog(<=>(A,B),<=>(AA,BB)):- !,
      krlog_to_prolog(A,AA),
      krlog_to_prolog(B,BB).
krlog_to_prolog(if(A,B),':-'(AA,BB)):- !,
      krlog_to_prolog(A,AA),
      krlog_to_prolog(B,BB).
krlog_to_prolog(entails(B,A),':-'(AA,BB)):- !,
      krlog_to_prolog(A,AA),
      krlog_to_prolog(B,BB).
krlog_to_prolog(LIST,OLIST):- is_list(LIST),!,
      krlog_to_prolog_l(LIST,OLIST).
krlog_to_prolog(=>(A,B),O):- !,
      krlog_to_prolog((B:-A),O).


krlog_to_prolog(consistent(A),consistent(O)):- !,           
      krlog_to_prolog(A,O).
krlog_to_prolog(inconsistent(A),consistent(O)):- !,           
      krlog_to_prolog(not(A),O).
krlog_to_prolog(known(A),known(O)):- !,           
      krlog_to_prolog((A),O).

krlog_to_prolog(and(A,B),O):- !,
      krlog_to_prolog((A,B),O).
krlog_to_prolog(and(A,B,C),O):- !,
      krlog_to_prolog((A,B,C),O).
krlog_to_prolog(and(A,B,C,D),O):- !,
      krlog_to_prolog((A,B,C,D),O).
krlog_to_prolog(and(A,B,C,D,E),O):- !,
      krlog_to_prolog((A,B,C,D,E),O).
krlog_to_prolog(and(A,B,C,D,E,F),O):- !,
      krlog_to_prolog((A,B,C,D,E,F),O).
krlog_to_prolog(or(A,B),O):- !,
      krlog_to_prolog((A;B),O).
krlog_to_prolog(or(A,B,C),O):- !,
      krlog_to_prolog((A;B;C),O).
krlog_to_prolog(or(A,B,C,D),O):- !,
      krlog_to_prolog((A;B;C;D),O).
krlog_to_prolog(or(A,B,C,D,E),O):- !,
      krlog_to_prolog((A;B;C;D;E),O).
krlog_to_prolog(or(A,B,C,D,E,F),O):- !,
      krlog_to_prolog((A;B;C;D;E;F),O).

krlog_to_prolog(not(A),not(AA)):- !,
      krlog_to_prolog(A,AA).
krlog_to_prolog('neg'(A),'neg'(AA)):- !,
      krlog_to_prolog(A,AA).
krlog_to_prolog('not'(A),'not'(AA)):- !,
      krlog_to_prolog(A,AA).
krlog_to_prolog('not'(A),'not'(AA)):- !,
      krlog_to_prolog(A,AA).

krlog_to_prolog(','(A,B),','(AA,BB)):- !,
      krlog_to_prolog(A,AA),
      krlog_to_prolog(B,BB).

krlog_to_prolog(';'(A,B),';'(AA,BB)):- !,
      krlog_to_prolog(A,AA),
      krlog_to_prolog(B,BB).

krlog_to_prolog(':-'((A1,A2),B), O):- isNonVar(A1),!,
      krlog_to_prolog((':-'(A1,B),':-'(A2,B)),O).

krlog_to_prolog(':-'((A1;A2),B), O):-  isNonVar(A1),!,
      krlog_to_prolog((':-'(A1,B),':-'(A2,B)),O).

krlog_to_prolog(':-'(A,B),':-'(AA,BB)):- !,
      krlog_to_prolog(A,AA),
      krlog_to_prolog(B,BB).

krlog_to_prolog(COMP,OCOMP):-compound(COMP),!,
      COMP=..[F|ARGS],
      krlog_to_prolog_l(ARGS,OARGS),
      OCOMP=..[F|OARGS].

krlog_to_prolog(A,A).


krlog_to_prolog_l([],[]):-!.
krlog_to_prolog_l([HK|TK],[HP|TP]):-!,
               krlog_to_prolog(HK,HP),
               krlog_to_prolog_l(TK,TP).


% ===================================================================
% prolog_to_krlog(KRProlog,Prolog)  Converts And/Or/Implies terms to Proper Prolog
% ====================================================================

prolog_to_krlog(A,A):-isSlot(A),!.

prolog_to_krlog(LIST,OLIST):- is_list(LIST),!,
      prolog_to_krlog_l(LIST,OLIST).
prolog_to_krlog(or(B,A),or(BB,AA)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB),!.
prolog_to_krlog((B:-A),'=>'(BB,AA)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB).
prolog_to_krlog((B:-true),BB):- !,
      prolog_to_krlog(B,BB).
prolog_to_krlog(<=>(B,A),<=>(BB,AA)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB).
prolog_to_krlog(and(B,A),and(BB,AA)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB).
prolog_to_krlog(=>(B,A),=>(BB,AA)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB).
prolog_to_krlog(forall(B,A),forall(B,AA)):- !,
      prolog_to_krlog(A,AA).
prolog_to_krlog(exists(B,A),exists(B,AA)):- !,
      prolog_to_krlog(A,AA).
prolog_to_krlog((A,B),and(AA,BB)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB).
prolog_to_krlog((A;B),or(AA,BB)):- !,
      prolog_to_krlog(A,AA),
      prolog_to_krlog(B,BB).
prolog_to_krlog(not(not(B)),consistent(BB)):- !,
      prolog_to_krlog(B,BB).
prolog_to_krlog(not(B),not(BB)):- !,
      prolog_to_krlog(B,BB),!.
prolog_to_krlog(call(B),(BB)):- !,
      prolog_to_krlog(B,BB).

prolog_to_krlog(COMP,OCOMP):-compound(COMP),
      COMP =.. [F,P|ARGS], memberchk(F,['M','N','O','P','Q','R','holds','holds']),
      prolog_to_krlog_l([P|ARGS],[PO|OARGS]),
      OCOMP =.. [holds,PO|OARGS].

prolog_to_krlog(COMP,not(OCOMP)):-compound(COMP),
      COMP=.. [F,P|ARGS], memberchk(F,['~M','~N','~O','~P','~Q','~R','~holds','~holds']),
      prolog_to_krlog_l([P|ARGS],[PO|OARGS]),
      OCOMP =.. [holds,PO|OARGS].


prolog_to_krlog(A,A).

prolog_to_krlog_l([],[]):-!.
prolog_to_krlog_l([HK|TK],[HP|TP]):-!,
               prolog_to_krlog(HK,HP),
               prolog_to_krlog_l(TK,TP).


conj_set(CNF,Set):-
	conjunctsToList(CNF,CNFList),
	disj_list(CNFList,Set).
	
disj_list([],[]).

disj_list([CNF|List],[Set|SetL]):-!,
	or_to_list(CNF,Set),
	disj_list(List,SetL).

or_to_list(or(A,B),CC):-
	or_to_list(A,AA),
	or_to_list(B,BB),
	append(AA,BB,CC).
	
or_to_list(CNF,[CNF]).


list_to_and([A],A):-!.
list_to_and([A|L],and(A,O)):-!,
		  list_to_and(L,O).




	             	 	
fdelete([],T,[]):-!.

fdelete([Replace|Rest],[H|T],Out):-
	functor(Replace,F,_),memberchk(F,[H|T]),!,
       fdelete(Rest,[H|T],Out),!.

fdelete([Replace|Rest],[H|T],[Replace|Out]):-!,
       fdelete(Rest,[H|T],Out),!.

fdelete([Replace|Rest],F,Out):-
	functor(Replace,F,_),!,%F=FF,
       fdelete(Rest,F,Out),!.

fdelete([Replace|Rest],F,[Replace|Out]):-
       fdelete(Rest,F,Out),!.



% ===================================================================
% getCleanCharsWhitespaceProper/2.. Cleans String Up before parser uses it
% ===================================================================

getCleanCharsWhitespaceProper([],[]):-!.
getCleanCharsWhitespaceProper(X,Z) :- !,logOnFailure(ascii_clean(X,Y)),!,logOnFailure(getCleanCharsWhitespaceProper3(Y,Z)),!.

% Converts not ANSI Chars to whitespace 
ascii_clean([],[]):-!.
ascii_clean([X|String],[Y|Out]) :- transpose_char(X,Y),!,ascii_clean(String,Out).


string_clean(X,X).

transpose_char(10,32).
%transpose_char(32,32).
%transpose_char(X,32):-not(integer(X)),!.
%transpose_char(X,32):-X<33,!.
transpose_char( X , X).
   
% Blocks of Spaces are removed from a Charlist 
getCleanCharsWhitespaceProper3([],[]).
getCleanCharsWhitespaceProper3([32],[]).
getCleanCharsWhitespaceProper3([10],[]).
getCleanCharsWhitespaceProper3([13],[]).
getCleanCharsWhitespaceProper3([32,32],[]).
getCleanCharsWhitespaceProper3([32,32,32],[]).
getCleanCharsWhitespaceProper3([X],[X]):-!.
getCleanCharsWhitespaceProper3([32,32,32,32,32,32,32|String],[32|Out]) :-!, getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([32,32,32,32,32|String],[32|Out]) :- !,getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([32,32,32|String],[32|Out]) :-!, getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([32,32|String],[32|Out]) :- !,getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3([X|String],[X|Out]) :- !,getCleanCharsWhitespaceProper3(String,Out),!.
getCleanCharsWhitespaceProper3(X,X):-!.



% ===================================================================
% writeIfOption(class(input),message(input),respoinse(output))
% generic call interface that was hooked into the belief engine with "ua_set_agent_callback(console_post)"
%This is not a predicate the useragent calls, but one that is called by the belief module to communicate  a question to the useragent or inform it of something.  
% The useragent decides if it can answer the a question and if not itself may ask a human user that is using it.
% There is three arguments to the my_callback predicate: Class, Message and Response
%
% Whenever the belief engine calls 'my_callback' only the first two arguments (Class,Message) are bound to supply information relevant to a Server invoked request.
%
% Class is a programmer defined message catagory  
% The Class is inteded to contain user defined message names that are sent as a callback function that is sent to the user's module consultation 
% Is is the type of Message catagory for the user agent.. A list of these are in TABLE 1.1 in <http://127.0.0.1/moo_interface_advanced.html>
% (Class is always a ground Term)
%
% Message is a prolog term in the writeFmt defined by it's Class
% Each Class has a one known Message writeFmt shown in the table.   
% Message sometimes is ground term. 
%
%
% Response has normally has 2 response single_bindings: continue or abort
% This response is sent back to the belief_engine.
% If the belief_engine didn't receive 'abort', then it moves to the next stage in the command.
% 
% ===================================================================

			  /*      				   
:-module(moo_generation,
	 [ 
	 writeDebug/1,
	 writeDebug/2,
	 writeDebugFast/1,
	 logOnFailureIgnore/1,
	 setMooOptionExplicitWriteSettings/0,
	 setMooOptionImplicitWriteSettings/0,
	 sendNote/1,
	 sendNote/4,
	 writeFailureLog/2,
	 debugOnFailure/2,
	 writeObject/2,
	 writeObject/3,
	 writeObject_conj/2]).
					 */

% :-include('moo_header.pl').

% :-use_module(moo_globalisms).

% Assertion Time Errors

% Contradiction: The assertion contradicts other assertion(s) in the knowledge base. ; RAP note: this should be followed by a explaination as per the XML element definition for "explaination" 
% Syntax error: Illegal character in assertion 
% Syntax error: Unmatched parentheses in assertion 
% Syntax error: Missing parentheses in assertion 
% Syntax error: Unspecified 
% Argument type violation ; RAP note: this should be followed by a explaination of the type violation as per the XML element definition for "explaination" 
% Out of memory error 
% Broken socket: The connection between the web-based GUI and the belief engine is broken 
% Redundant assertion: ; RAP note: this should be followed by a explaination of the type violation as per the XML element definition for "explaination" 
% Undefined constant: Do you wish to add the constants to the Context? ; RAP note: this should be followed by a list of constants and a prompt to the user 


% ==========================================================
%  Sending Notes
% ==========================================================
writeDebug(T):-!.  writeDebug(C,T):-!.
 
%writeDebug(T):-(isMooOption(opt_debug=off)),!.
%writeDebug(C,T):-(isMooOption(opt_debug=off)),!.

logOnFailureIgnore(X):-ignore(logOnFailure(X)),!.

writeModePush(_Push):-!.
writeModePop(_Pop):-!.

writeDebug(T):-!,
	((
	if_prolog(swi,
		(prolog_current_frame(Frame),
		prolog_frame_attribute(Frame,level,Depth),!,
		Depth2 = (Depth-25))),
	writeFmt(';;',[T]),!,
	indent_e(Depth2),!,
	writeFmt('~q\n',[T]))),!.

indent_e(X):- catch((X < 2),_,true),write(' '),!.
indent_e(X):-XX is X -1,!,write(' '), indent_e(XX).


writeDebug(C,T):-!,
	((
	writeFmt('<font size=+1 color=~w>',[C]),
	writeDebug(T),
        writeFmt('</font>',[]))),!.

dumpstack_argument(T):-isMooOption(opt_debug=off),!.  
	
dumpstack_argument(Frame):-
	write(frame=Frame),write(' '),
	dumpstack_argument(1,Frame).

dumpstack_argument(1,Frame):-!,
	prolog_frame_attribute(Frame,goal,Goal),!,
	write(goal=Goal),write('\n').
	
dumpstack_argument(N,Frame):-
	prolog_frame_attribute(Frame,argument(N),O),!,
	write(N=O),write(' '),
	NN is N +1,
	dumpstack_argument(NN,Frame).
	
dumpstack_argument(N,Frame):-!,write('\n').
	
:-dynamic(mods/1).

write_response_begin:-!.
write_response_end:-!.

sendNote(X):-var(X),!.
sendNote(X):-mods(X),!.
sendNote(X):-!,assert(mods(X)).
sendNote(X).			 

sendNote(To,From,Subj,Message):-sendNote(To,From,Subj,Message,_).

sendNote(To,From,Subj,Message,Vars):-
	not(not((numbervars((To,From,Subj,Message,Vars)),
	%writeDebug(sendNote(To,From,Subj,Message,Vars)),
	catch(sendNote_1(To,From,Subj,Message,Vars),E,
	writeFmt('send note ~w ~w \n <HR>',[E,sendNote(To,From,Subj,Message,Vars)]))))).


sendNote_1(To,From,Subj,surf,Vars):-!.
sendNote_1(To,From,[],surf,Vars):-!.
sendNote_1(To,From,[],end_of_file,Vars):-!.
sendNote_1(doug,From,_,_,Vars):-!.
sendNote_1(extreme_debug,From,_,_,Vars):-!.
sendNote_1(debug,'Belief',_,_,Vars):-!.

%sendNote_1(canonicalizer,From,Subj,Message,Vars):-!.


sendNote_1(canonicalizer,From,Subj,Message,Vars):-
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,nv(Subj),Vars,SS),
            toMarkUp(kif,nv(Message),Vars,SA),
            writeFmt('<font color=red>canonicalizer</font>: ~w "~w" (from ~w). \n',[SA,SS,SFrom]),!.

/*

sendNote_1(debug,From,Subj,Message,Vars):- %isMooOption(disp_notes_nonuser=on),!,
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,Subj,Vars,SS),
            toMarkUp(kif,Message,Vars,SA),
            writeFmt('% debug: ~w "~w" (from ~w). \n',[SA,SS,SFrom]).
sendNote_1(debug,From,Subj,Message,Vars):-!.
*/


sendNote_1(To,From,Subj,Message,Vars):- isMooOption(client=consultation),  !, 
            toMarkUp(kif,To,Vars,STo),
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,nv(Subj),Vars,S),
            toMarkUp(kif,nv(Message),Vars,A),
            fmtString(Output,'~w (~w from ~w) ',[A,S,SFrom]),
	    sayn(Output),!.

sendNote_1(To,From,'Rejected',Message,Vars):- isMooOption(client=automata),  !.

sendNote_1(To,From,Subj,Message,Vars):- isMooOption(client=automata),  !, 
            toMarkUp(kif,To,Vars,STo),
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,nv(Subj),Vars,S),
            toMarkUp(kif,nv(Message),Vars,A),
            writeFmt(user_error,'% ~w (~w from ~w) ',[A,S,SFrom]).

sendNote_1(To,From,Subj,Message,Vars):- isMooOption(client=html),  !, %  In Html
            toMarkUp(kif,To,Vars,STo),
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,nv(Subj),Vars,S),
            toMarkUp(html,nv(Message),Vars,A),
            writeFmt('<hr><B>To=<font color=green>~w</font> From=<font color=green>~w</font> Subj=<font color=green>~w</font></B><BR>~w\n',[To,From,S,A]),!.

sendNote_1(To,From,Subj,Message,Vars):- isMooOption(client=console),!, % In KIF
            toMarkUp(kif,To,Vars,STo),
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,nv(Subj),Vars,SS),
            toMarkUp(kif,nv(Message),Vars,SA),
            writeFmt(user_error,'; ~w: ~w "~w" (from ~w). \n',[STo,SA,SS,SFrom]),!.
  
sendNote_1(To,From,Subj,Message,Vars):-  % In KIF
            toMarkUp(kif,To,Vars,STo),
            toMarkUp(kif,From,Vars,SFrom),
            toMarkUp(kif,nv(Subj),Vars,SS),
            toMarkUp(kif,nv(Message),Vars,SA),
            writeFmt(user_error,'; ~w: ~w "~w" (from ~w). \n',[STo,SA,SS,SFrom]),!.

sendNote(To,From,Subj,Message,Vars):-!.


writeDebugFast(X):-writeq(X),nl.

logOnFailure(assert(X,Y)):- catch(assert(X,Y),_,Y=0),!.
logOnFailure(assert(X)):- catch(assert(X),_,true),!.
logOnFailure(assert(X)):- catch(assert(X),_,true),!.
%logOnFailure(X):-catch(X,E,true),!.
logOnFailure(X):-catch(X,E,(writeFailureLog(E,X),!,catch((true,X),_,fail))),!.
logOnFailure(X):- writeFailureLog('Predicate Failed',X),!.


writeFailureLog(E,X):-
		writeFmt(user_error,'\n% error:  ~q ~q\n',[E,X]),flush_output(user_error),!,
		%,true.
		writeFmt('\n;; error:  ~q ~q\n',[E,X]),!,flush_output. %,say([E,X]).
		
debugOnFailure(assert(X,Y)):- catch(assert(X,Y),_,Y=0),!.
debugOnFailure(assert(X)):- catch(assert(X),_,true),!.
debugOnFailure(assert(X)):- catch(assert(X),_,true),!.
%logOnFailure(X):-catch(X,E,true),!.
debugOnFailure(X):-catch(X,E,(writeFailureLog(E,X),fail)),!.
debugOnFailure(X):-true,X.

debugOnFailure(arg_domains,CALL):-!,logOnFailure(CALL),!.
debugOnFailure(Module,CALL):-debugOnFailure(CALL),!.


noDebug(CALL):-CALL.
	


%unknown(Old, autoload).

% ================================================================
%   Serialize Objects to XML
% ================================================================


%%writeObject(OBJ,Vars):-!. %,writeq(OBJ),!.
%writeObject(OBJ,Vars):-!,catch(writeq(OBJ),_,true),nl,!.

writeObject(quiet,Term,Vars):-!.

writeObject(Verbose,Term,Vars):-writeObject(Term,Vars).

		
writeObject(OBJ,Vars):- isMooOption(client=html),!,
		((toMarkUp(html,OBJ,Vars,Chars),write(Chars))),!.
		
writeObject(OBJ,Vars):- isMooOption(client=atomata),!,
		((toMarkUp(kif,OBJ,Vars,Chars),write(Chars))),!.

writeObject(OBJ,Vars):- isMooOption(client=console),!,
		((toMarkUp(kif,OBJ,Vars,Chars),write(Chars))),!.

writeObject(OBJ,Vars):- isMooOption(client=consultation),!,
		(say(OBJ,Vars)),!.

writeObject(OBJ,Vars):- !,
		((toMarkUp(kif,OBJ,Vars,Chars),write(Chars))),!.


writeObject_conj(A,Vars):-isSlot(A),!,
	writeObject(A,Vars).

writeObject_conj(and(A,true),Vars):-!,
	writeObject_conj(A,Vars).

writeObject_conj(and(true,A),Vars):-!,
	writeObject_conj(A,Vars).

writeObject_conj(and(A,B),Vars):-!,
	writeObject_conj(A,Vars),
	writeObject_conj('\n\n Also \n\n ',Vars),
	writeObject_conj(B,Vars).

writeObject_conj(Output,Vars):-
	%write(Output),nl.
	writeObject(Output,Vars).


:-dynamic(resolve_skolem/2).


writeIfOption(C,P):-once_ignore(writeUAEvent(C,P,_)).

writeIfOption(C,M,Vars):-once_ignore(writeUAEvent(C,M,Vars)).

setMooOptionExplicitWriteSettings:-
             setMooOption(disp_explicit='off'),
             setMooOption(disp_modification='off'),
             setMooOption(disp_debug='off'),
             setMooOption(disp_note_user='off'),
             setMooOption(disp_notes_nonuser='off'),
             setMooOption(disp_qresults='off'),
             setMooOption(disp_explaination_true='off'),
             setMooOption(disp_explaination_other='off'),
             setMooOption(disp_bindings='off'),
             setMooOption(disp_answers_num_yes='off'),
             setMooOption(disp_answers_num_no='off'),
             setMooOption(disp_answers_num_definate='off'),
             setMooOption(disp_answers_num_tries='off'),
             setMooOption(disp_cputime='off'),
             setMooOption(disp_compiled='off'),
             setMooOption(disp_ground_forms='off').

setMooOptionImplicitWriteSettings:-
	       setMooOptionExplicitWriteSettings,
             setMooOption(disp_explicit='off'),
             setMooOption(disp_modification='on'),
             setMooOption(disp_debug='on'),
             setMooOption(disp_note_user='on'),
             setMooOption(disp_notes_nonuser='on'),
             setMooOption(disp_explaination_true='on'),
             setMooOption(disp_explaination_other='off'),
             setMooOption(disp_bindings='on'),
             setMooOption(disp_answers_num_yes='on'),
             setMooOption(disp_answers_num_no='on'),
             setMooOption(disp_answers_num_definate='on'),
             setMooOption(disp_answers_num_tries='on'),
             setMooOption(disp_cputime='on'),
             setMooOption(disp_compiled='on'),
             setMooOption(disp_ground_forms='on'),
	     setMooOption(traceOutput,yes),
	      setMooOption(prover,decider),
	      setMooOption(translationMode,flatRelational),
	      setMooOption(decider,on),
	      writeSTDERR(setMooOptionExplicitWriteSettings).






/*

15 Display options

disp_request
disp_note_user
disp_notes_nonuser
disp_compile
disp_modification
disp_debug
disp_trace
disp_answers
disp_explaination_true
disp_truth_othe r
disp_result
disp_statistics
disp_errors
disp_success
disp_other

10 options

opt_answers_max=[0-n] Default is Unlimited
opt_answers_min=[0-n]  Default is 1
opt_backchain_depth_max=[0-n] Default is 10
opt_deduceSurface_max=[0-n] Default is 1000
opt_timeout=[seconds] Default=60
opt_readonly=[true|false] Default is False
opt_deduce_assert=[true|false] Defualt is True
opt_language=[pnx_nf|getNegationForm|hylog|prolog|sigmese]   Default is Sigmese
opt_format=[kif|prolog]  Default is KIF
opt_compiled=[true|false]  Default is false

3 Callbacks

cb_error=[true|false] Default is false
cb_answer=[true|false] Default is false
cb_consult=[true|false] Default is false


*/

write_val(Any,Vars):- isMooOption(client=html)
      -> write_val_xml(Any,Vars) ;
      write_sterm(Any,Vars).
      
write_val_xml(Any,Vars):-
      toMarkUp(leml,Any,Vars,Chars),write(Chars),nl.


         
writeUAEvent(_,_,_):-isMooOption(disp_hide_all=true),!.
writeUAEvent(_,_,_):-telling_file,!.
writeUAEvent(Class,_,_):-isMooOption(Class=false),!.
writeUAEvent(Class,_,_):-isMooOption(disp_explicit=true),not(isMooOption(_Class=true)),!.

writeUAEvent(request_start,Note,Vars):-!,
         (isMooOption(client=html) -> 
          (writeFmt('<Answer>\n'),le_push('Answer'));
          true).

writeUAEvent(request_end,(Result,Normal,Elapsed,Num,Bindings),Vars):-!, 
                  (isMooOption(client=html) -> 
                     ((    
                       (toMarkUp(leml,note('user',logicEngine,Result,(Result,Normal,Elapsed,Num,Bindings)),Vars,Chars),once((var(Chars);write(Chars)))),
                       writeFmt('<Summary result="~w" solutions="~d" bindings="~d" cpu="~f"/>\n</Answer>\n',[Result,Num,Bindings,Elapsed]),
                       le_pull('Answer')
                     ));
                       writeFmt('\n%%  ~w solutions="~d" bindings="~d" cpu="~f"\n',[Result,Num,Bindings,Elapsed])).

writeUAEvent(Class,Message,Vars):-not(isMooOption(client=html)),!, toMarkUp(kif,[Class,Message],Vars,Chars),write(Chars),nl.
writeUAEvent(Class,Message,Vars):-isMooOption(client=html),!, event_to_chars(leml,Class,_Message,Vars,Chars),write(Chars),nl.
writeUAEvent(cb_consultation, assertion([PredicateI|ConsultTemplate],_Context_atom,_SN), continue):- 
               agentConsultation(_Context_atom,[PredicateI|ConsultTemplate], _ListOfGafsAsserted).
writeUAEvent(_,_,_):-!.


/*toMarkUp(Sterm,VS,Chars):-
           once(( isMooOption(client=html) -> 
            toMarkUp(leml,Sterm,VS,Chars);
            toMarkUp(kif,Sterm,VS,Chars))).
  */

/*
Where the parameters are some string syntax or other straightforward data
structure and we've used I to signify a parameter that is used by the
function and O to signify a parameter that is returned by the
function.  If that were forall it had, we think that is sufficient for
the bulk of interactions.  Everything else is helpful but not strictly
essential.  Because of that, we believe that it is possible to run
our system with just the above commands after startup.

   We have shown a number of features implemented such as

  - explaination trees
  - belief execution time and search controls
  - compilation
  - consultation mode

The expanded API is
*/          
%=================================================================
%  CONSULTATION MANAGEMENT DIRECTIVES
%=================================================================

/*
where the xxxNative versions take the disp_modification WFSform and the other
versions take STANDARD.  Consultation mode has a simple default interface too:
*/



/* ; where the list is of arguments
missing that is requested from the user.  The default is to ask for
any and forall arguments that are missing

%TODO

ua_consultationModeEvery() ; ask the user for as many inputs as he's willing

to give
etc. ; other modes...

A further expansion to handle communication with a user agent external to
Prolog would add a message sent to a socket that process is listening to.
and a message string sent from Prolog to the user agent to request user input

"userInputRequest predicateName<cr>"

Where <cr> indicates a carriage return or some other suitable delimiter.

*/



% ===========================================================
% SOCKET SERVER - Looks at first charicater of request and decides between:
%  Http, Native or Soap and replies accordingly
% ===========================================================
/*
:-module(moo_httpd,[
   createPrologServer/1,
   xmlPrologServer/1,
   read_line_with_nl/3,
   decodeRequest/2,
   invokePrologCommandRDF/6,
   serviceAcceptedClientSocketAtThread/1]).
*/

% :-include(moo_header).



% :-use_module(moo_threads).
%% :-ensure_loaded(system_dependant).

:-dynamic(isKeepAlive/1).

createPrologServer(Port) :-
        mooProcessCreate(nokill,'Moo XML/SOAP Server Socket',xmlPrologServer(Port),_,[]).

xmlPrologServer(Port):-
        tcp_socket(ServerSocket),
        catch(ignore(tcp_setopt(ServerSocket, reuseaddr)),_,true),
        at_halt(tcp_close_socket(ServerSocket)),
        attemptServerBind(ServerSocket, Port),
        tcp_listen(ServerSocket, 655),
        repeat,
	       acceptClientsAtServerSocket(ServerSocket),
        fail.


attemptServerBind(ServerSocket, Port):-
        catch((tcp_bind(ServerSocket, Port),
        flush_output,
        writeSTDERR('cs.\nMoo server started on port ~w. \n\nYes\n?- ',[Port]),flush_output),
        error(E,_),
        (writeSTDERR('\nWaiting for OS to release port ~w. \n(sleeping 4 secs becasue "~w")\n',[Port,E]),
        sleep(4),
        attemptServerBind(ServerSocket, Port))),!.


acceptClientsAtServerSocket(ServerSocket):-
		tcp_open_socket(ServerSocket, AcceptFd, _),
                cleanOldProcesses,!,
		tcp_accept(AcceptFd, ClientSocket, ip(A4,A3,A2,A1)),!,
                getPrettyDateTime(DateTime),
                sformat(Name,'Dispatcher for ~w.~w.~w.~w  started ~w ',[A4,A3,A2,A1,DateTime]),
                mooProcessCreate(killable,Name,serviceAcceptedClientSocketAtThread(ClientSocket),_,[detatch(true)]),!.

serviceAcceptedClientSocketAtThread(ClientSocket):-
	tcp_open_socket(ClientSocket, In, Out),!,
        setMooOption('$socket_in',In),
        setMooOption('$socket_out',Out),!,
        serviceIO(In,Out),
        flush_output,
	catch(tcp_close_socket(ClientSocket),_,true),
	prolog_thread_exit(complete).



getPrettyDateTime(String):-get_time(Time),convert_time(Time, String).

serviceIO(In,Out):-
        peek_char(In,Char),!,
	%writeSTDERR(serviceIOBasedOnChar(Char,In,Out)),
	serviceIOBasedOnChar(Char,In,Out),!.


serviceIOBasedOnChar('G',In,Out):-!,  
         serviceHttpRequest(In,Out).

serviceIOBasedOnChar('P',In,Out):-!,
         serviceHttpRequest(In,Out).

serviceIOBasedOnChar('<',In,Out):-!,
         serviceSoapRequest(In,Out).  % see moo_soap.pl

serviceIOBasedOnChar(C,In,Out):-
        serviceNativeRequest(C,In,Out).

% ===========================================================
% HTTPD SERVICE
% ===========================================================

serviceHttpRequest(In,Out):-
        readHTTP(In,Options),
        writeFmtFlushed(Out,'HTTP/1.1 200 OK\nServer: Moo-HTTPD\nContent-Type: text/html\n\n',[]),
        setMooOption(client,html),
        tell(Out),
        writeSTDERR('REQUEST: "~q" \n',[Options]), 
	processRequest(Options),
	flush_output.


readHTTP(In,Request):-
        read_line_with_nl(In, Codes, []),
        append("GET /",Stuff,Codes), %true,
        append(RequestCodes,[72,84,84,80|_],Stuff),
        atom_codes(RequestEncoded,RequestCodes),
        decodeRequest(RequestEncoded,Request).

readHTTP(In,Request):-
        read_line_with_nl(In, Codes, []),
        append("POST /",Stuff,Codes), %true,
        append(RequestCodes,[72,84,84,80|_],Stuff),
        atom_codes(RequestEncoded,RequestCodes),
        decodeRequest(RequestEncoded,Request).


read_line_with_nl(Fd, Codes, Tail) :-
        get_code(Fd, C0),
        read_line_with_nl(C0, Fd, Codes, Tail).
read_line_with_nl(end_of_file, _, Tail, Tail) :- !.
read_line_with_nl(-1, _, Tail, Tail) :- !.
read_line_with_nl(10, _, [10|Tail], Tail) :- !.
read_line_with_nl(C, Fd, [C|T], Tail) :-
        get_code(Fd, C2),
        read_line_with_nl(C2, Fd, T, Tail).



decodeRequest(RequestEncoded,[file=Request]):-
      concat_atom([X],'?',RequestEncoded),
      www_form_encode(Request,X),!.
decodeRequest(RequestEncoded,[file=Request|ENCARGS]):-
      concat_atom([X,ARGS],'?',RequestEncoded),
      www_form_encode(Request,X),
      concat_atom(ArgList,'&',ARGS),
      decodeRequestArguments(ArgList,ENCARGS).

decodeRequestArguments([],[]):-!.
decodeRequestArguments([ctx=Value|List],[ctx=CValue,theory=KValue|ARGS]):-
          concat_atom([KValue,CValue],':',Value),!,
          decodeRequestArguments(List,ARGS).
decodeRequestArguments([Arg|List],[DName=DValue|ARGS]):-
          split_nv(Arg,Name,Value),
          www_form_encode(AName,Name),
          www_form_encode(AValue,Value),!,
          decodeRequestAtom(AName,DName),
          decodeRequestAtom(AValue,DValue),
          decodeRequestArguments(List,ARGS).

%ctx=PrologMOO%3ASTRUCTURAL-ONTOLOGY&

split_nv(Arg,Name,Value):-concat_atom([Name,Value],'=',Arg),!.
split_nv(Arg,Arg,Arg).

decodeRequestAtom(A,A):-var(A),!.
decodeRequestAtom(tn,tn):-!.
decodeRequestAtom(N,N):-number(N),!.
decodeRequestAtom(A=B,AA=BB):-
                decodeRequestAtom(A,AA),
                decodeRequestAtom(B,BB),!.
decodeRequestAtom(A,T):-catch(atom_to_term(A,T,_),_,fail),number(T),!.
decodeRequestAtom(A,T):-catch(atom_to_term(A,T,_),_,fail),not(var(T)),not(compound(T)),!.
decodeRequestAtom(A,T):-atom(A),catch(atom_codes(A,[95|_]),_,fail),catch(atom_to_term(A,T,_),_,fail),!.
decodeRequestAtom(A,A):-!.

% ===========================================================
% NATIVE SERVICE
% ===========================================================

serviceNativeRequest(_,In,Out):-
        writeFmt(Out,'<?xml version="1.0" encoding="ISO-8859-1"?>\n',[]),
        getThread(Session),
        retractall(isKeepAlive(Session)),
        xmlClearTags,
        repeat,
                catch(
                        read_term(In,PrologGoal,[variable_names(ToplevelVars),character_escapes(true),syntax_errors(error)]),
                        E,
                        writeErrMsg(Out,E)),
                %writeSTDERR(PrologGoal:ToplevelVars),
                invokePrologCommandRDF(Session,In,Out,PrologGoal,ToplevelVars,Returns),
                notKeepAlive(Out,Session),!.

notKeepAlive(Out,Session):-isKeepAlive(Session),
        write(Out,
                'complete.\n'
                %'<prolog:keepalive/>\n'
                                ),catch(flush_output(Out),_,true),!,fail.
notKeepAlive(Out,Session):-catch(flush_output(Out),_,true).


keep_alive:-getThread(Me),retractall(isKeepAlive(Me)),assert(isKeepAlive(Me)),writeFmtFlushed('<keepalive/>\n',[]).
goodbye:-getThread(Me),retractall(isKeepAlive(Me)),writeFmt('<bye/>/n',[]).


invokePrologCommandRDF(Session,In,Out,PrologGoal,ToplevelVars,Returns):-var(PrologGoal),!.

invokePrologCommandRDF(Session,In,Out,PrologGoal,ToplevelVars,Returns):-
        term_to_atom(Session,Atom),concat_atom(['$answers_for_session',Atom],AnswersFlag),
        writeFmt(Out,'<prolog:solutions goal="~q">\n',[PrologGoal]),
        flag(AnswersFlag,_,0),
        set_output(Out),set_input(In),!,
        getCputime(Start),
        callNondeterministicPrologCommand(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars),
        xmlExitTags,
        getCputime(End),
        flag(AnswersFlag,Returns,Returns),
%       (Returns > 0 ->
%               writeFmt(Out,'<prolog:yes/>\n',[]) ;
%               writeFmt(Out,'<prolog:no/>\n',[])),!,
        Elapsed is End -Start,
        writeFmt(Out,'</prolog:solutions answers="~w" cputime="~g">\n',[Returns,Elapsed]),!.

callNondeterministicPrologCommand(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars):-
        ground(PrologGoal),!,
        catch(
                (PrologGoal,
                 flag(AnswersFlag,Answers,Answers+1),
                 writePrologToplevelVarsXML(Out,PrologGoal,AnswersFlag,ToplevelVars)
                 ),
           Err,writeErrMsg(Out,Err,PrologGoal)),!.





callNondeterministicPrologCommand(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars):-
        catch(
                (PrologGoal,
                 flag(AnswersFlag,Answers,Answers+1),
                 writePrologToplevelVarsXML(Out,PrologGoal,AnswersFlag,ToplevelVars),
                 fail),
           Err,writeErrMsg(Out,Err,PrologGoal)),!.
callNondeterministicPrologCommand(Session,AnswersFlag,In,Out,PrologGoal,ToplevelVars):-!.


writePrologToplevelVarsXML(Out,PrologGoal,AnswersFlag,ToplevelVars):-
         flag(AnswersFlag,Answers,Answers),
        writeFmt(Out,'<prolog:result solution="~w">\n',[Answers]),
        writePrologToplevelVarsXML2(Out,ToplevelVars),
        writeFmt(Out,'</prolog:result>\n',[]),!.

writePrologToplevelVarsXML2(Out,[]):-!.
writePrologToplevelVarsXML2(Out,[Term|REST]):-!,Term=..[_,N,V],
         writeFmtFlushed(Out,'       <prolog:p>~w = ~q</prolog:p>\n',[N,V]),
         writePrologToplevelVarsXML2(Out,REST),!.


writeFmt(A,B,C):-!.
writeFmt(A,B):-!.

writeFmt(A,B,C):-
        writeFmtFlushed(A,B,C).
writeFmt(A,B):-
        writeFmtFlushed(A,B).


throwMoo(Module,Type,Details):-
        current_prolog_flag(debug_on_error, DebugOnError),
        set_prolog_flag(debug_on_error, false),!,
        throw(mooException(Module,Type,Details,DebugOnError)),
        ifInteractive(writeDebug('Post throwMoo')),!.



% :-include('moo_header.pl').

/*

When this enter in thru this interface various things may happen:

1)   The surface is stored as-is (noncanonicalize)
2)   The surface is checked for truth (untrusted/trusted)
3)   The surface is canonicalized (canonicalize)
4)   The canonicalized form is complied (compile)
5)   The compiled form reaches active memory									 
									 
Prototype: tell(+Assertion[,Ctx][,Tracking]).

Assertion: is any writeFmt in KIF/STANDARD/Prolog
Ctx: Prolog atom defining the context the assertion or command is ran in
Tracking: Prolog Term provided by external source for tracking purposes


Usage: a component needs to modify the known world

See examples above

*/
% Entry point for Compiling assertions and retractions 

% =====================================================================================
%  agentInsert(Insert_chars,Ctx,TN,Context,User)
% =====================================================================================
agentInsert(Insert_chars,Cxt):-!,
         agentInsert(Insert_chars,Ctx,TN,Context,'Maintainer').
         
agentInsert(Insert_chars,Ctx,TN):- 
         agentInsert(Insert_chars,Ctx,TN,Context,'Maintainer').

agentInsert(Insert_chars,Ctx,TN,Context,User):-!,   
            once(tell_retract_parse_chars(Insert_chars,Pterm,Vars)),
            invokeInsert([untrusted,canonicalize],surface,Pterm,Ctx,TN,Context,Vars,User).


dte:- agentInsert("(isa Joe Human)",'GlobalContext').

% ===================================================================
% Normalizing Surfaces
% ===================================================================

toFSCK(Form,_,_,AssertionO,SourceCtxO,SourceTNO):-
			Form=..[asserted,SourceCtx,Assertion],!,
			toFSCK(Assertion,SourceCtx,SourceTN,AssertionO,SourceCtxO,SourceTNO).
toFSCK(Form,_,_,AssertionO,SourceCtxO,SourceTNO):-
			Form=..[pnf,Assertion,SourceCtx,SourceTN],!,
			atom_codes(SourceTN,[84,45|TNCODES]),catch(number_codes(SourceTNM,TNCODES),_,SourceTNM=TN),
			toFSCK(Assertion,SourceCtx,SourceTNM,AssertionO,SourceCtxO,SourceTNO).
toFSCK(Form,_,_,AssertionO,SourceCtxO,SourceTNO):-
			Form=..[ist,SourceCtx,Assertion],!,
			toFSCK(Assertion,SourceCtx,SourceTN,AssertionO,SourceCtxO,SourceTNO).
toFSCK('BACKWARD'(Formula),Ctx,TN,Formula,Ctx,TN):-!.
toFSCK('FORWARD'(Formula),Ctx,TN,Formula,Ctx,TN):-!.
toFSCK('sharedNotes'(_,Formula),Ctx,TN,Formula,Ctx,TN):-!.
toFSCK('clause-form'(Formula),Ctx,TN,Formula,Ctx,TN):-!.
toFSCK('request'(Formula),Ctx,TN,'request'(Formula),Ctx,TN):-!.
toFSCK((Formula),Ctx,TN,(Formula),Ctx,TN):-!.


% ===================================================================
% MOO TELL/RETRACT
% ===================================================================

:-index(invokeInsert(1,1,1,0,0,0,0,0)).

% ======================================================
% Ignored Invokations
% ======================================================
invokeInsert(Driver,Any,surf,Ctx,TN,Context_Name,Vars,Maintainer):-!.
invokeInsert(Driver,Form,formula,Ctx,TN,Context_Name,Vars,Maintainer):-!.        
invokeInsert(Driver,Any,comment(_),Ctx,TN,Context_Name,Vars,Maintainer):-!.
invokeInsert(Driver,Any,file_comment(_),Ctx,TN,Context_Name,Vars,Maintainer):-!.
invokeInsert(Driver,Any,end_of_file,Ctx,TN,Context_Name,Vars,Maintainer):-!.
invokeInsert(Driver,Any,true,Ctx,TN,Context_Name,Vars,Maintainer):-!.
invokeInsert(Driver,Any,(true:-true),Ctx,TN,Context_Name,Vars,Maintainer):-!.
invokeInsert(Driver,Any,Form,Ctx,TN,Context_Name,Vars,Maintainer):-var(Ctx),
	sendNote(user,'Assert mech','Variable in Context',Form),!,true.
invokeInsert(Driver,Any,Form,Ctx,TN,Context_Name,Vars,Maintainer):-var(Context_Name),
	sendNote(user,'Assert mech','Variable in Context',Form),!,true.



% ======================================================
% Conjunctive Invokations
% ======================================================
invokeInsert(Driver,Type,(Form,Ula),Ctx,TN,Context,Vars,Maintainer):-!,
		logOnFailure(invokeInsert(Driver,Type,Form,Ctx,TN,Context,Vars,Maintainer)),!,
		logOnFailure(invokeInsert(Driver,Type,Ula,Ctx,TN,Context,Vars,Maintainer)),!.

invokeInsert(Driver,Type,and(Form,Ula),Ctx,TN,Context,Vars,Maintainer):-!,
		logOnFailure(invokeInsert(Driver,Type,Form,Ctx,TN,Context,Vars,Maintainer)),!,
		logOnFailure(invokeInsert(Driver,Type,Ula,Ctx,TN,Context,Vars,Maintainer)),!.


% ======================================================
% Choose KIF or ACE (For now always choosing kif)
% ======================================================
invokeInsert(Driver,chars,CHARS,Ctx,TN,Context_Name,Vars,Maintainer):-!,
         invokeInsert(Driver,kif,CHARS,Ctx,TN,Context_Name,Vars,Maintainer),!.       


% ======================================================
% Make Surface Forms from KIF chars
% ======================================================
invokeInsert(Driver,kif,CHARS,Ctx,ETN,Context_Name,_,Maintainer):-!,
         once(getSurfaceFromChars(CHARS,STERM,Vars)),                      
         getMooTermFromSurface(STERM,Formula),!,   
         invokeInsert(Driver,surface,Formula,Ctx,ETN,Context_Name,Vars,Maintainer),!.       

% ======================================================
% Make Surface Forms from ACE chars
% ======================================================
invokeInsert(Driver,ace,CHARS,Ctx,TN,Context_Name,Vars,Maintainer):-
         ace_to_surface(CHARS,Formula),
         getMooTermFromSurface(STERM,Formula),!,
         invokeInsert(Driver,surface,Formula,Ctx,TN,Context_Name,Vars,Maintainer),!.       

% ======================================================
% Actually Assert the surface (trusted/untrusted)
% ======================================================
invokeInsert(Driver,surface,FormulaIn,Ctx,TN,SContext,Vars,Maintainer):-!,         
	logOnFailure(toFSCK(FormulaIn,Ctx,TN,Formula,SCtx,STN)),!,
	invokeInsert(Driver,fsck,Formula,SCtx,STN,SContext,Vars,Maintainer),!.         

% ======================================================
% Check for Simple Surface
% ======================================================
/*
invokeInsert(Driver,fsck,Surface,Ctx,TN,Context,Vars,Maintainer):-
	        getConstants(atomic,Surface,C,_,_),
		once(disabledKeywords(C)),!,
		idGen(TN), % create tracking now if needed
		destroyTN(Context,TN,_),
		ignore((
			logOnFailure(assertaClean(mooCache(Surface,entails(true,true),[],Vars,Context,TN,Maintainer,not_used)))
		)),!.
*/
     
disabledKeywords(L):-
	member(T,L),
	disabledKeyword(T),!.
	
disabledKeyword('AbstractionFn').	
disabledKeyword('GeneralizedUnionFn').	
disabledKeyword('GeneralizedIntersectionFn').	
disabledKeyword('UnionFn').	
disabledKeyword('ExtensionFn').	
disabledKeyword('IntersectionFn'). 
disabledKeyword('ComplementFn'). 
disabledKeyword('RangeFn'). 
disabledKeyword('DomainFn'). 
%disabledKeyword(A):-atom(A),atom_concat(_,'Fn',A),!.	
disabledKeyword(A):-atom(A),atom_concat(_,'On',A),!.	

/*
disabledKeyword(exists).	
*/

tam(Surface,Vars):-
	flag(indent,_,0),
	TN = test,
	Context = 'PrologMOO',
	Maintainer = 'Maintainer',
	Ctx = 'Context',
%	writeObject(Surface,Vars),
%	once(writeObject('$spacer',Vars)),
	logOnFailure(getAssertionClauses(Context,Surface,CAN,Vars,Flags)),
	once(writeObject('$spacer',Vars)),
	once(writeObject(ff(Flags),Vars)),
	once(writeObject('$spacer',Vars)),
	flag(clause_id,_,0),
	Result = 'on',
	tam(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result),
	flag(clause_id,CLID,CLID),
	format('<hr>Clauses: ~w',[CLID]).

	

tam(Surface,and(CAN1,CAN2),Flags,Vars,Context,TN,Maintainer,Result):-!,
	tam(Surface,CAN1,Flags,Vars,Context,TN,Maintainer,Result),
	tam(Surface,CAN2,Flags,Vars,Context,TN,Maintainer,Result).
tam(Surface,entails(true,CAN2),Flags,Vars,Context,TN,Maintainer,Result):-!,
	tam(Surface,CAN2,Flags,Vars,Context,TN,Maintainer,Result).
tam(Surface,entails(false,CAN2),Flags,Vars,Context,TN,Maintainer,Result):-!,
	tam(Surface,absurd(CAN2),Flags,Vars,Context,TN,Maintainer,Result).
tam(Surface,true,Flags,Vars,Context,TN,Maintainer,Result):-!.
	

tam(Surface,entails(OAnte,OConsq),Flags,Vars,Context,TN,Maintainer,Result):-!, 
	flag(indent,_,0),
	once(writeObject('$spacer',Vars)),
	once(writeObject_conj(entails(OAnte,OConsq),Vars)),
%	once(writeObject('$spacer',Vars)),
%	once(writeObject(ff(Flags),Vars)),
	once(writeObject('$spacer',Vars)),
	flag(clause_id,CLID,CLID+1),
	logOnFailure(once(putAttributeStructures(Surface,Rule,Context,Flags,entails(OAnte,OConsq),entails(Ante,Consq)))),!,
		convertListNotNeg([Consq],[NConsq]),
		conjunctsToList(Ante,List),%true,
		reorderAnteceedants([NConsq|List],List,All),!,
		convertListNotNeg(All,AnteListS),!,
		unnumbervars(
				(NConsq,AnteListS,Vars,Context,surf(Context,TN,CLID,Vars)),
				(UNConsq,UAnteListS,UVars,UContext,UCtx,UExplaination)),
		numbervars((UNConsq,UAnteListS,UVars,UContext,UCtx,UExplaination),'$VAR',0,_),% true,
	length(AnteListS,Cost),
		format('~q.~n',['2'(UNConsq,UAnteListS,Cost,UVars,UContext,UCtx,UExplaination)]),!.
		


tam(Surface,surface,Flags,Vars,Context,TN,Maintainer,Result):-!,
	tam(Surface,Surface,Flags,Vars,Context,TN,Maintainer,Result).
     
% Simple Fact
tam(Surface,OConsq,Flags,Vars,Context,TN,Maintainer,Result):-!,
	flag(indent,_,0),
	once(writeObject('$spacer',Vars)),
	once(writeObject_conj(OConsq,Vars)),
%	once(writeObject('$spacer',Vars)),
%	once(writeObject(ff(Flags),Vars)),
	once(writeObject('$spacer',Vars)),
	flag(clause_id,CLID,CLID+1),
	logOnFailure(once(putAttributeStructures(Surface,Rule,Context,Flags,OConsq,Consq))),!,
	convertListNotNeg([Consq],[NConsq]),
	unnumbervars((NConsq,Ctx,surf(Context,TN,CLID,Vars)),(UConsq,UCtx,UExplaination)),
	numbervars((UConsq,UCtx,UExplaination),'$VAR',0,_),!,
	format('~q.~n',['1'(UConsq,Context,UCtx,UExplaination)]).
	
	

% ======================================================
% Do truth checks and assets surface and NNF
% ======================================================
invokeInsert(Driver,fsck,Surface,Ctx,TN,Context,Vars,Maintainer):-!,
		idGen(TN), % create tracking now if needed
	        destroyTN(Context,TN,_),
		ignore((
		% This may fail and will give an error message
			% Vars come back Numbered
			((
			  logOnFailure(getAssertionClauses(Context,Surface,CAN,Vars,Flags)) ->
				((
						% This may fail but it will give a message
						%getTruthCheckResults(tell,Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result),
						%Result = on, 
						% TODO assert the kr terms and delete them from list
						(save_can_to_file(Context,Handle) ->
							format(Handle,'~q.\n',['mooCache'(Surface,CAN,Flags,Vars,Context,TN,Maintainer,on)]);
                                                        assert(mooCache(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result))),!,
						ignore((
							memberchk(compile,Driver),
							recanonicalizeTN(Context,TN)))
					));
				% This will save errors
						(save_can_to_file(Context,Handle) ->
							format(Handle,'~q.\n',['error1'(Surface,CAN,Flags,Vars,Context,TN,Maintainer,on)]);
                                                        assert(mooCache(Surface,CAN,Flags,Vars,Context,TN,Maintainer,on))),!
			  )),!
				
		)),!.

	
% =================================================
% Assert clean and new (Prolog) 												 
% =================================================
assertaClean(X):-unnumbervars(X,Y),!,asserta(Y).

assertzClean(X):-unnumbervars(X,Y),!, assert(Y).


assertAll([]):-!.
assertAll(end_of_file).
assertAll([H|T]):-!,((assertAll(H),assertAll(T))),!.
assertAll((H,T)):-!,notace((assertAll(H),assertAll(T))),!.	
assertAll(':-'(T)):-!,call(T).
assertAll(InContext):-isClaused(InContext),!.
assertAll(T):-catch(asserta(T),E,format('~n% prolog warning ~w ~n',[E])),!. 

isClaused(InContext):-
	(not(not((numbervars(InContext,'$VAR',0,_),!,isClausedG(InContext))))),!.
	
isClausedG(mooCache(C,A,_,Context,TN)):-
	clause(mooCache(C,_,_,_),true,OldID),
	clause(mooCache(OC,OA,_,_,_,_),true,OldID),
	numbervars(OC:OA,'$VAR',0,_),
	C:A==OC:OA,!,ifInteractive(write(',')),!.

isClausedG(mooCache(C,_,Context,TN)):-
	clause(mooCache(C,_,Context,_),true,OldID),
	clause(mooCache(OC,_,_,_),true,OldID),
	numbervars(OC,'$VAR',0,_),
	C==OC,!,ifInteractive(write(',')),!.

isClausedG(mooCache(_,C,Context,_,_)):-
	clause(mooCache(_,C,Context,_,_),true,OldID),
	clause(mooCache(_,OC,Context,_,_),true,OldID),
	numbervars(OC,'$VAR',0,_),
	C==OC,!,ifInteractive(write(',')),!.

isClausedG((InContext:-B)):-isClausedG(InContext,B),!.
isClausedG(InContext):-isClausedG(InContext,true),!.

isClausedG(C,A):-
	clause(C,A,OldID),
	clause(OC,OA,OldID),
	numbervars(OC+OA,'$VAR',0,_),
	C:A==OC:OA,!.
	
		
countAssertions((C:-A),N):-countAssertions(C,A,N).
countAssertions(C,N):-countAssertions(C,true,N).	

countAssertions(C,A,N):-
       % numbervars(C:A,'$VAR',0,_),
	flag(clauses_count,_,0),
	clause(C,A,ID),
	flag(clauses_count,X,X+1),fail.
countAssertions(C,A,N):-flag(clauses_count,N,N),!.


% ===================================================================
% MOO TM (Surface)
% ===================================================================
	 
% Assertion Time Errors

% Contradiction: The assertion contradicts other assertion(s) in the knowledge base. ; RAP note: this should be followed by a explaination as per the XML element definition for "explaination" 
% (done/implied) Syntax error: Illegal character in assertion 
% (done) Syntax error: Unmatched parentheses in assertion 
% (done)  Syntax error: Missing parentheses in assertion 
% (done/implied) Syntax error: Unspecified 
% Argument type violation ; RAP note: this should be followed by a explaination of the type violation as per the XML element definition for "explaination" 
% Out of memory error 
% (in Java) Broken socket: The connection between the web-based GUI and the belief engine is broken 
% (done to test)  Redundant assertion: ; RAP note: this should be followed by a explaination of the type violation as per the XML element definition for "explaination" 
% (done to test)  Undefined constant: Do you wish to add the constants to the Context? ; RAP note: this should be followed by a list of constants and a prompt to the user 

/* 
% Context/Ctx Must Be loaded
getTruthCheckResults(Action,Driver,surface,Formula,Ctx,TN,SContext,Vars,Maintainer,notice(' You need to load the Context. Would you like to do so now?',not(isKnowledgeBaseLoaded(SContext,Ctx)))):-
		not(isKnowledgeBaseLoaded(SContext,Ctx)),!.
*/

% ===================================================================
% MOO Consitancy checking
% ===================================================================

% This next line disables truth checks on everything 
getTruthCheckResults(AskInsert,Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,on):-!.

% Normalize the Forms and make appropiate checks
getTruthCheckResults(tell,Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result):-
	unnumbervars((Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer),(USurface,UCAN,UFlags,UCtx,UTN,UContext,UVars,UMaintainer)),
	numbervars((USurface,UCAN,UFlags,UCtx,UTN,UContext,UVars,UMaintainer),'$VAR',0,_),
	getTruthCheckResultsInsert(Driver,USurface,UCAN,UFlags,UCtx,UTN,UContext,UVars,UMaintainer,Result),!.

getTruthCheckResults(Ask,Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result):- !,
	unnumbervars((Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer),(USurface,UCAN,UFlags,UCtx,UTN,UContext,UVars,UMaintainer)),
	numbervars((USurface,UCAN,UFlags,UCtx,UTN,UContext,UVars,UMaintainer),'$VAR',0,_),
	getTruthCheckResults_ask(Driver,USurface,UCAN,UFlags,UCtx,UTN,UContext,UVars,UMaintainer,Result),!.

% ===================================================================
% MOO Consitancy For Assert/Insert
% ===================================================================

% This next line disables truth checks on Insert
getTruthCheckResultsInsert(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,on):-!.

% Allow Trusted Driver
getTruthCheckResultsInsert(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,on):-memberchk(trusted,Driver),!.

% Surface is Redundant and On?
getTruthCheckResultsInsert(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,notice(' Redundant assertion <pre>~s</pre> original author was ~w.\n',[MaintainerForm,PMaintainer])):-
	mooCache(_,surface,Surface,_,Context,PTN,PMaintainer,_),!,flag(indent,_,0),flag(explaination_linenumber,_,0),
	isMooOption(client=E),
	toMarkUp(E,surf(SContext,TN),OldVars,MaintainerForm),!.
	
% Surface Contants must forall be declared
getTruthCheckResultsInsert(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result):-
	isMooOption(opt_deduce_domains=off),       
		once(getConstants(atomic,Surface,UsedConstants,_,_)),	
		getTruthCheckResults_constants(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result),!.
		
getTruthCheckResults_constants(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,
	notice('Undefined constant: ~w\nTry asserting the as "(instance -Word- -Something-)"',[UnDefinedList])):-
		logOnFailure(checkAllConstantsHaveTypes(Formula,Constants,UnDefinedList)),
		UnDefinedList=[_|_],!. %TODO

% Surface Contants must forall be declared
getTruthCheckResultsInsert(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result):-
	isMooOption(opt_deduce_domains=off),       
		once(getConstants(atomic,Surface,UsedConstants,_,_)),	
		getTruthCheckResults_constants(Driver,Surface,CAN,Flags,Ctx,TN,Context,Vars,Maintainer,Result),!.


% Each predicate has adequate nth-domains
/* TDODO
getTruthCheckResults(Action,Driver,surface,Formula,Ctx,TN,SContext,Vars,Maintainer,notice(' Relation missing Domian constaints',R)):-
		Formula=..[Relation|ARGS],
		relation_missing_nth_domains_l([Relation|ARGS],R),!.
*/		
relation_missing_nth_domains(Formula,domain(R,Missing,_)):-
		Formula=..[R|ARGS],
		length(ARGS,L),
		is_nth_domain_missing(Relation,L,Missing),!.
relation_missing_nth_domains(Formula,nv(MissingList)):-
		Formula=..[_|ARGS],
		relation_missing_nth_domains_l(ARGS,MissingList).

relation_missing_nth_domains_l([],[]):-!.
relation_missing_nth_domains_l([A|RGS],[Missing|List]):-
		relation_missing_nth_domains(A,Missing),
		relation_missing_nth_domains_l(RGS,List).

% Nth Domains

getTruthCheckResults(Action,Driver,surface,Formula,Ctx,TN,SContext,Vars,Maintainer,notice('Nth-domain violations ~w.\n',[BadList])):-	 
       Formula =.. [V|Ector],
       logOnFailure(once(nth_domain_check_surface_expression(V,1,Ector,BadList))),memberchk(and(_,_),BadList).

% Relation on Head
getTruthCheckResults(Action,Driver,surface,Formula,Ctx,TN,SContext,Vars,Maintainer,notice('Clause heads must be relations. "~w"\n',['instance'(V,AC)])):-
       Formula =.. [V|Ector],not(arg_meets_class_contraint(V,VS,'Relation')),!.
       	

getTruthCheckResults(Action,Driver,surface,Formula,Ctx,TN,SContext,Vars,Maintainer,accept('Passed Checks')):-!.


nth_domain_check_surface_expression(V,N,[],[]):-!.
nth_domain_check_surface_expression(V,N,[E|Ctor],[B|AdList]):-
		nth_domain_each_arg(V,N,E,B),
		NN is N + 1,
		nth_domain_check_surface_expression(V,NN,Ctor,AdList).
				
nth_domain_each_arg(V,N,E,null):-isSlot(E),!.

nth_domain_each_arg(P,N,E,(and('instance'(E,EC),'domain'(P,N,PC)))):-
	is_nth_domain_of(P,N,PC),
	not(arg_meets_class_contraint(E,EC,PC)).

nth_domain_each_arg(P,N,E,(and('instance'(E,EC),'domainSubclass'(P,N,PC)))):-
	is_nth_domain_of(P,N,PC),
	not(arg_meets_class_contraint(E,EC,PC)).

nth_domain_each_arg(V,N,E,null):-!.

	
% (not A:-u(A, holds('Class-Class', 'subclass', B, C), 'Formula'), not holds('Entity-Class', 'instance', D, C), holds('Entity-Class', 'instance', D, B))

        
checkAllConstantsHaveTypes(Formula,[],[]):-!.

checkAllConstantsHaveTypes('instance'(C,H),[TC|List],UnDefinedList):-C==TC,!, 
		checkAllConstantsHaveTypes('instance'(C,H),List,UnDefinedList).

checkAllConstantsHaveTypes('subclass'(C,H),[TTC|List],UnDefinedList):-C==TC,!,
		checkAllConstantsHaveTypes('subclass'(C,H),List,UnDefinedList).

checkAllConstantsHaveTypes('subAttribute'(C,H),[TC|List],UnDefinedList):-C==TC,!,
		checkAllConstantsHaveTypes('subAttribute'(C,H),List,UnDefinedList).

checkAllConstantsHaveTypes('subcontext'(C,H),[TC|List],UnDefinedList):-C==TC,!,
		checkAllConstantsHaveTypes('subcontext'(C,H),List,UnDefinedList).

checkAllConstantsHaveTypes('subrelation'(C,H),[TC|List],UnDefinedList):-C==TC,!,
		checkAllConstantsHaveTypes('subrelation'(C,H),List,UnDefinedList).
		
checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-
		member(C,['$VAR',exists,forall,'instance','subclass',and,=>,or,<=>,not,not,'Entity','Context','KnowledgeBase']),!,
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-number(C),!, % Numbers
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-catch(atom_codes(C,[34|Codes]),_,fail),!, %Strings
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-
		in_cache('instance'(C,_),SContext,SCtx,O),!,
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-
		in_cache('subclass'(C,_),SContext,SCtx,O),!,
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-
		in_cache('subrelation'(C,_),SContext,SCtx,O),!,
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],UnDefinedList):-
		in_cache('subAttribute'(C,_),SContext,SCtx,O),!,
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).

checkAllConstantsHaveTypes(Formula,[C|List],[C|UnDefinedList]):-!,
		checkAllConstantsHaveTypes(Formula,List,UnDefinedList).
		



% TODO - NTH-DOMAIN CHECK


% TODO - CONTRADICTION CHECK

% Surface Is accepted becasue none of the above cauth a rejection
getTruthCheckResults(Action,Driver,Form,Formula,Ctx,TN,SContext,Vars,Maintainer,accept('Accepted')):-!.	
	
	% ask_pclause_proc(inconsistent(CL),SCtx,SContext,QM,Vars,Result,Explaination),!,
        %  ( (Result > 0) -> ( sendNote('<A Color="red">(Retraction for Hypothetcal)</A>'),assert(tq_skipped),nl,nl,sendNote(user,truthConsistency,'Retract: '(not(CL)),['truthConsistency Says Veto this Assertion ',Explaination]),nl,nl); true),
	 
% ===================================================================
% MOO TM (Canonical Form)
% ===================================================================
	 
% TN Must be Bound
getTruthCheckResults_can(Driver,wfs,CAN,Ctx,TN,Context,Vars,Maintainer,notice(' Prolog Code Error: You Sent a Tracking Number?',TN)):-isSlot(TN),!.

% Surface Contants must forall be declared
getTruthCheckResults_can(Driver,wfs,CAN,Ctx,TN,Context,Vars,Maintainer,notice('Currently Unused Constant in Belief',Const)):-	 
		getConstants(atomic,CAN,UsedConstants,_,_),
		'not-implemented'(Const),member(Const,UsedConstants),!.


% Normalize the Wfs to check Redudant
getTruthCheckResults_can(Driver,wfs,CAN,Ctx,TN,Context,Vars,Maintainer,R):-
	catch(unnumbervars(CAN,RFormula),_,fail),numbervars(RFormula,'$VAR',0,_),
	getTruthCheckResults_can_redundant(CAN,Action,Driver,wfs,RFormula,Ctx,TN,Context,Vars,Maintainer,R),!.

% Wfs is Redundant and On?
getTruthCheckResults_can_redundant(CAN,Action,Driver,wfs,RFormula,Ctx,TN,Context,Vars,Maintainer,notice(' Redundant assertion',author(PMaintainer,STN))):-
	mooCache(PredR,Form,RFormula,Rvars,Context,STN,PMaintainer,on),!.
	
% Wfs is Redundant and Disabled?
getTruthCheckResults_can_redundant(CAN,Action,Driver,wfs,RFormula,Ctx,TN,Context,Vars,Maintainer,notice(' Redundant assertion (and Disabled)',author(PMaintainer,OFF,STN))):-
	mooCache(PredR,Form,RFormula,Rvars,Context,STN,PMaintainer,rejected),!.
	 
% =============================================================================
% HEAD BODY CHECK FOR PROLOG
% =============================================================================

% Clause is ground (Fine)
getTruthCheckResults_can(Driver,Form,CAN,Ctx,TN,Context,Vars,Maintainer,accept('Ground Fact')):-
		getPrologVars(CAN,[],_,_),!.

% No Singles (Fine)
getTruthCheckResults_can(Driver,Form,CAN,Ctx,TN,Context,Vars,Maintainer,accept('Complete')):-
		getPrologVars(CAN,_,[],_),!.

% Head is ground (Fine)
getTruthCheckResults_can(Driver,Form,entails(ANT,CAN) ,Ctx,TN,Context,Vars,Maintainer,warn(Warning)):-
		once(getPrologVars(CAN,[],_,_)),
		once(getPrologVars(CAN,ANT,_,_)),
		O=' ', %toMarkUp(kif,ANT,Vars,O),
		fmtString(S,'Creates ground fact from ante variables ~w (<font color=green>Warning</font>)',[O]),
		string_to_atom(S,Warning),!.
		

% Detect 3 Singletons in Head or Gaf (<font color=red>rejected</font>)
getTruthCheckResults_can(Driver,Form,entails(true,CAN),Ctx,TN,Context,Vars,Maintainer,notice(Warning,'rejected')):-
		once(getPrologVars(CAN,_,[A,B,C|D],_)),
		O=' ', %toMarkUp(kif,[A,B,C|D],Vars,O),
		fmtString(S,'3 or more Universal Variables In Head on Canonicalization ~w (<font color=red>rejected</font>)',[O]),
		string_to_atom(S,Warning),!.

% Detect 2 Singletons in Head or Gaf (<font color=green>warning</font>)
getTruthCheckResults_can(Driver,Form,entails(true,CAN),Ctx,TN,Context,Vars,Maintainer,warn(Warning)):-not(memberchk(test_question,Driver)),
		once(getPrologVars(CAN,_,[A,B|D],_)),
		O=' ', %toMarkUp(kif,[A,B|D],Vars,O),
		fmtString(S,'2 Universal Variables In Head on Canonicalization ~w (<font color=red>rejected</font>)',[O]),
		string_to_atom(S,Warning),!.

% Detect 3 Singletons in Clause (<font color=red>rejected</font>)
getTruthCheckResults_can(Driver,Form,CAN,Ctx,TN,Context,Vars,Maintainer,notice(Warning,'rejected')):-
		once(getPrologVars(CAN,_,[A,B,C|D],_)),
		O=' ', %toMarkUp(kif,[A,B,C|D],Vars,O),
		fmtString(S,'3 or more Universal Variables In Clause on Canonicalization ~w (<font color=red>rejected</font>)',[O]),
		string_to_atom(S,Warning),!.

% Detect No Overlap  (<font color=red>rejected</font>)
getTruthCheckResults_can(Driver,Form,entails(B,CAN),Ctx,TN,Context,Vars,Maintainer,notice('No connection between Head and Body Variables (<font color=red>rejected</font>)','rejected')):-
		once(getPrologVars(CAN,Avars,_,_)),
		once(getPrologVars(B,[BV|BVars],_,_)),
		intersection(Avars,[BV|BVars],[]),!.

% Detect 1 Singleton in Head or Gaf (<font color=green>warning</font>)
getTruthCheckResults_can(Driver,Form,entails(true,CAN),Ctx,TN,Context,Vars,Maintainer,warn(Warning)):-not(memberchk(test_question,Driver)),
		once(getPrologVars(CAN,_,[A|B],_)),
		O=' ', %toMarkUp(kif,[A|B],Vars,O),
		fmtString(S,'Universal Variables In Head on Canonicalization ~w (<font color=red>warning</font>)',[O]),
		string_to_atom(S,Warning),!.
		
% Detect 1 Singleton in Head or Gaf (<font color=green>warning</font>)
getTruthCheckResults_can(Driver,Form,CAN,Ctx,TN,Context,Vars,Maintainer,warn(Warning)):- not(memberchk(test_question,Driver)),
		once(getPrologVars(CAN,_,[A|B],_)),
		O=' ', %toMarkUp(kif,[A|B],Vars,O),
		fmtString(S,'Universal Variables In Canonicalization ~w (<font color=red>warning</font>)',[O]),
		string_to_atom(S,Warning),!.

getTruthCheckResults_can(Driver,Form,CAN,Ctx,TN,Context,Vars,Maintainer,accept('Accepted')):-!.


% TODO Turn on/off

% =========================================
% Limits for Compiler
% =========================================
%clean_clauses((CAN,B),BB):-found_in(CAN,B),!,clean_clauses(B,BB).
clean_clauses((CAN,B),BB):-unused_clause(CAN),!,clean_clauses(B,BB).
clean_clauses((CAN,B),(CAN,BB)):-!,clean_clauses(CAN,CAN),clean_clauses(B,BB).
clean_clauses((equal(X,Y) :- CAN),(same(X,Y) :- CAN)):-!.
clean_clauses((CAN , B),BB):-unused_clause(CAN),!,clean_clauses(B,BB).
clean_clauses((CAN , B),(CAN , BB)):-!,clean_clauses(CAN,CAN),clean_clauses(B,BB).
clean_clauses(CAN,true):-unused_clause(CAN).
clean_clauses(CAN,CAN).

unused_clause(end_of_file).
unused_clause((not(equal(_,_)) :- _ )).
unused_clause((not(same(_,_)) :- _ )).
unused_clause((_ :- not(equal(_,_))  )).
unused_clause(true).
unused_clause(nop).
unused_clause(surf).
%unused_clause((equal(_,_):-_)).
%unused_clause((not(equal(_,_)):-_)).
unused_clause((not('domain-check'(_,_,_)):-_)).
found_in(CAN,B):-CAN==B,!.
found_in(CAN,(B , BB)):- !,
      found_in(CAN,B),
      found_in(CAN,BB).



/*
moo_assert_can_rule_phase2(Consq,ProtoConsq,AnteListS,AnteProto,Vars,Context,Explaination):-
		contridictory([+Consq|AnteListS]),!,
		moo_assert_can_rule_phase3(contridictory,Consq,ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination).

moo_assert_can_rule_phase2(Consq,ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination):-
		contridictory([-Consq|AnteListS]),!,
		moo_assert_can_rule_phase3(contridictory,Consq,ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination).

contridictory(List):-
		findall(Mem,member(+Mem,List),Pos),
		findall(Mem,member(-Mem,List),Negs),!,
		intersection(Pos,Negs,[_|_]).

moo_assert_can_rule_phase2(Consq,ProtoConsq,AnteListS,AnteProto,Vars,Context,Explaination):-
		mooCache(Consq,PBefore,AnteListS,PAfter,PCost,Context,PCtx,PExplaination),
		intersection(PAnteListS,AnteListS,[_|_]),
		is_semantic_duplication(Consq,ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination,PAnteListS,PBefore,PAfter,PCost,Context,PCtx,PExplaination),!.
		
% Logically entails the same things
is_semantic_duplication(Consq,ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination,PAnteListS,PBefore,PAfter,PCost,Context,PCtx,PExplaination):-
		subset(PAnteListS,AnteListS),!,
		moo_assert_can_rule_phase3(slower(Consq,PExplaination),ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination),!.

is_semantic_duplication(Consq,ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination,PAnteListS,PBefore,PAfter,PCost,Context,PCtx,PExplaination):-
		subset(AnteListS,PAnteListS),!,
		moo_assert_can_rule_phase3(faster(Consq,PExplaination),ProtoConsq,AnteProto,AnteListS,Vars,Context,Explaination),!.

*/

% =====================================================================================
%  retract(Retract_chars,Ctx,TN,Context,User)
% =====================================================================================

bp_retract(Retraction_Chars,Context,TN,L,User):-
      (((idGen(TN),TrackingAtom=(TN)) ; TrackingAtom=TN)),!,
      setMooOption(OptionList),
      write_response_begin,!, %%true,
      tell_retract_parse_chars(Retraction_Chars,Formula,Vars),
      %%ignore(once(retract(Retraction_Chars,_Ctx,TrackingAtom,Context,User))),
      retract_odbc(Formula,Ctx,TrackingAtom,Context,Vars,User),
      write_response_end.


     /*
retract(Retract_chars,Cxt):-!,
         retract(Retract_chars,Ctx,TN,Context,'Maintainer').
         
retract(Retract_chars,Ctx,TN):- 
         retract(Retract_chars,Ctx,TN,Context,'Maintainer').

retract(Retract_chars,Ctx,TN,Context,User):-!,   
            once(tell_retract_parse_chars(Retract_chars,Pterm,Vars)),
            moo_invoke(retract,forall,surface,Pterm,Ctx,TN,Context,Vars,User).
       */



/*
:-module(moo_java,[
   startJava/0,
   startJamud/0,
   createJamud/0,
   loadJamudReferences/0]).
*/


:-dynamic(java_object_known/1).
:-module_transparent(java_object_known/1).



startJava:-
	 java_start("/opt/sourceforge/logicmoo/src:/opt/sourceforge/logicmoo/src/partner/jamud/src:/opt/sourceforge/logicmoo/lib/:cos.jar:/opt/sourceforge/logicmoo/lib/ecs-1.4.1.jar:/opt/sourceforge/logicmoo/lib/jdom.jar:/opt/sourceforge/logicmoo/lib/jaxp.jar:/opt/sourceforge/logicmoo/lib/rdf-api-2001-01-19.jar:/opt/sourceforge/logicmoo/lib/plc.jar:/opt/sourceforge/logicmoo/lib/cpj.jar:/opt/sourceforge/logicmoo/lib/nanoxml.jar:/opt/sourceforge/logicmoo/lib/jpl.jar:/opt/sourceforge/logicmoo/lib/crawler.jar").

startJamud:-
	 jamud_object(JAMUD),!,
	 java_invoke_method(JAMUD,startJamud(_X)).

createJamud:-
	 mooBaseJavaClass(MudClass),
	 java_create_object(MudClass,JAMUD),
	 %java_object(JAMUD)
	 format('\MudClass=~q\n',[JAMUD]),!,
	 assert(jamud_object(JAMUD)),!.
			
createJamud:-
	    format('\nCould not create the LogicMOO object\n',[]).
	 

loadJamudReferences:-
               jamud_object(JAMUD),
	 java_invoke_method(JAMUD,getJamudInstance(Instance)),
	 java_invoke_method(JAMUD,getJamudMudObjectRoot(MudRoot)),!,
	 assert(jamud_instance(Instance)),
	 assert(jamud_root(MudRoot)).
	 %showInstanceValue(MudRoot).
	 


showInstanceValue(Object):-
   getJavatypeValueFn(Object,Name,_ActualName,Value),
   format('\n ~q \n',[equal('JavaMemberFn'('JavaObjectFn'(Object),Name),Value)]),
   fail.
showInstanceValue(_Object):-
   inferJavatypeMemberFnTuples(Term),
   format('\n~q\n',[Term]),
   fail.

java_object_known(_).


showInstanceValue(_Object):-!.

:-dynamic(classToPLStructure/2).

javaClassToPLStructure(Object,Term):-
	 nonvar(Object),classToPLStructure(Object,Term),!.

javaClassToPLStructure(Object,Term):-
      jamud_object(JAMUD),
      java_invoke_method(JAMUD,classToPLStructure(Object,Term)),!,
      assert(classToPLStructure(Object,Term)).

getInstanceValue(Object,ActualName,Value):-
      getInstanceValue(Object,_Name,ActualName,Value),!.
getInstanceValue(Object,Name,Value):-
      getInstanceValue(Object,Name,_ActualName,Value),!.

getInstanceValue(Object,Name,ActualName,Value):-
      getInstanceValue(Object,Name,ActualName,Value,_Type).


inferJavatypeMemberFnTuples(equal('JavaMemberFn'('JavaObjectFn'(Object),Name),Result)):-
      java_object(Object),java_object_known(Object),
      getJavatypeValueFn(Object,Name,_ActualName,Result).

getJavatypeValueFn(Object,ActualName,Value):-
      getJavatypeValueFn(Object,_Name,ActualName,Value),!.
getJavatypeValueFn(Object,Name,Value):-
      getJavatypeValueFn(Object,Name,_ActualName,Value),!.

getJavatypeValueFn(Object,Name,ActualName,'JavaValueFn'(Type,Value)):-
      getInstanceValue(Object,Name,ActualName,Value,Type).


getInstanceValue(Object,Name,ActualName,Value,Type):-
      javaClassToPLStructure(Object,Term),
      get_call_term_from_class(Object,Term,Name,Value,Type,ActualName,CallTerm),
      catch(CallTerm,E,format('\nAttempting "~q" resulted in ~q\n',[CallTerm,E])).

get_call_term_from_class(Object,Term,Name,Value,Type,Name,java_get_value(Object,MethodCall)):-
      catch(arg(1,Term,Arg1),_,fail),
      arg(1,Arg1,FieldsList),
      member(Field,FieldsList),
      functor(Field,ActualName,1),
      arg(1,Field,Type),
      MethodCall=..[ActualName,Value].

get_call_term_from_class(Object,Term,Name,Value,Type,ActualName,java_invoke_method(Object,MethodCall)):-
      catch(arg(2,Term,Arg1),_,fail),
      arg(1,Arg1,MethodsList),
      member(Method,MethodsList),
      functor(Method,ActualName,MA),
      arg(MA,Method,Type),
      match_method(MethodsList,Method,ActualName,MA,Name,Value,MethodCall).

match_method(_MethodsList,_Method,ActualName,_MA,Name,_Value,_MethodCall):-
      var(Name),
      % Make sure we don't walk blindly into some side-effect method when the Name is a variable
      member(Lead,['load','save','set','add','wait','equals','toString',
	 'unload','create','destroy','kill','stop','terminate','final','write','print','append',
	 ('['),('_'),('(') ]),atom_concat(Lead,_,ActualName),!,fail.
      
% Not that zero length happens but just incase fail. 
match_method(_MethodsList,_Method,_ActualName,_0,_Name,_Value,_MethodCall):-!,fail.

% Explore Simple No parameter methods
match_method(MethodsList,_Method,ActualName,1,Name,Value,MethodCall):-!,
           % Look for an identical match
      ((Name == ActualName) ;
           % Or no match, guess what was wanted by prepending 'get' or 'to'
      ((atom_concat('get',Name,ActualName);atom_concat('to',Name,ActualName)),
   	   % If we did a prepend, confirm that the Name was not already in list 
	 \+ (member(Term,MethodsList),functor(Term,Name,_)))),!,
      MethodCall=..[ActualName,Value].

% Explore Explicitly called 
match_method(_MethodsList,_Method,ActualName,MA,Name,Value,MethodCall):-
      nonvar(Name),functor(Name,ActualName,TA),
      Name =.. [ActualName|Rest],!,
      ((TA is MA -1 , Left= Rest);append(Left,[_],Rest)),!,
      append(Left,[Value],NewRest),!,MethodCall =.. [ActualName|NewRest].






% ===================================================================
% File 'moo_markup.pl'
% Maintainers: Douglas Miles
% Contact: dmiles@users.sourceforge.net ;
% Version: 'moo_markup.pl' 1.0.0
% Revised At:  $Date: 2002-11-16 04:41:12 $

% ===================================================================
% Major functions:
% This file meets the needs of an external agent working for the needs of eigther an automated or human user
% Interface with Java with XML to display explaination trees and variable bindings
% ===================================================================

% :-include('moo_header.pl').
:-index(getMarkupFormula(1,1,1,1)).
:-index(toMarkUp_lang(1,1,1,1)).

%Tests

%stest3 :- toMarkUp(html, explaination(('Military':996:subclass('IntransitiveRelation', 'BinaryRelation')^B)* ('Military':836:subclass('BinaryRelation', 'Relation')^C)*forall('IntransitiveRelation', forall(D, forall('Relation', holds(subclass, 'IntransitiveRelation', D)and holds(subclass, D, 'Relation')=>holds(subclass, 'IntransitiveRelation', 'Relation'))))*sfind(instance(subclass, 'PartialOrderingRelation'))*sfind(subclass('PartialOrderingRelation', 'TransitiveRelation'))* ('Military':2756:instance(on, 'IntransitiveRelation')^E)), ['X'=on|A],O),write_ln(O).

% ================================================================
%   Transform Signals to Objects
% ================================================================

% ===================================================================
% writeMarkup(-Prolog)
%
% Replaces writeq in some cases
% ===================================================================
writeMarkup(Term):-term_to_leml(Term,Chars),write(Chars).


% ===================================================================
% toMarkUp_lang(-Markup,-Prolog,-PrologVarableList, +Output)
%
% Markup := [html,kif,pml,leml] (Expandable)
% Prolog := any prolog term
% PrologVaraibles list is the equal list as produced by read/3  [=(Name,Val)|...]
% Output is an CharicterAtom (the difference is this atom is not added the the symbol table)
% ===================================================================
% ===================================================================
% term_to_leml(-Prolog, +Output)
%
% arity 2 version (note html) is sufficient for printing values
% ===================================================================
term_to_leml(Term,Chars):-toMarkUp(html,Term,_,Chars),!.


toMarkUp(chat,Var,VS,Chars):-!,catch(toMarkUp(kif,Var,VS,Chars),_,true),!.
toMarkUp(java,Var,VS,Chars):-!,catch(toMarkUp(html,Var,VS,Chars),_,true),!.

toMarkUp(L,T,V,Chars):-!,
        ignore(catch(/**/((
        copy_term((T,V),(CT,CV)),
        numbervars((CT,CV),'$VAR',0,_),%true,
        toMarkUp_lang(L,CT,CV,Chars))),_,true)),!.

% VARIABLES
toMarkUp_lang(L,C,Vars,Out):-isSlot(C),!,toMarkUp_slotValue(L,C,Vars,Out).

toMarkUp_lang(html,'$spacer',Vars,'\n<hr>\n').
toMarkUp_lang(_,'$spacer',Vars,'\n;; ------------------------------------------------------------------------------\n\n').

tml(Form):-toMarkUp_lang(html,formula(Form),Vars,Out),write(Out),nl.

toMarkUp_lang(L,formula(C),Vars,Out):-!,
        getMarkupFormula(L,C,Vars,Out).

% ===================================================
% Pretty Print Formula
% ===================================================
%getMarkupFormula(L,C,Vars,Out):-       writeq( C=Vars),nl,fail.


getMarkupFormula(L,C,Vars,Out):-isSlot(C),!,toMarkUp_lang(L,C,Vars,Out).
getMarkupFormula(L,C,Vars,Out):-not(compound(C)),!,toMarkUp_lang(L,C,Vars,Out).

% QUOTED STRING FORMAT
getMarkupFormula(L,Atom,_VS,Chars):-((isCharCodelist(Atom);string(Atom))),!,
        catch(sformat(Chars,'"~s"',[Atom]),_,sformat(Chars,'"~w"',[Atom])).

getMarkupFormula(L,string(C),Vars,C):-!.

getMarkupFormula(L,hidden(F,Args),Vars,''):-!.

getMarkupFormula(html,colourize(Color,Thing),Vars,Chars):-!,
        getMarkupFormula(html,Thing,Vars,Chars1),!,
        sformat(Chars,'<font color="~w">~w</font>\n',[Color,Chars1]).

getMarkupFormula(L,colourize(Color,Thing),Vars,Chars):-!,
        getMarkupFormula(L,Thing,Vars,Chars),!.

/*
getMarkupFormula(L,','(A,B),Vars,Chars):-!,
        prolog_to_krlog(','(A,B),KR),
        getMarkupFormula(L,KR,Vars,Chars),!.
*/


getMarkupFormula(L,write_dollar('$v',[A|Args]),Vars,Chars):-!,
                Flag=..[getPrologVars,A|Args],!,
                getMarkupFormula(L,Flag,Vars,Chars).

getMarkupFormula(L,table_(Goal,Lits),Vars,Chars):-!,
                getMarkupFormula(L,table_p(Lits,Goal),Vars,Chars).


getMarkupFormula(L,write_dollar(F,[A|Args]),Vars,Chars):-!,
        getMarkupFormula(L,A,Vars,Chars1),
        getMarkupFormula(L,hidden(F,Args),Vars,Chars2),!,
        sformat(Chars,'~w~w',[Chars1,Chars2]).

getMarkupFormula(L,'$existential'(VarName,Name,Literal),Vars,O):-!,
        getMarkupFormula(L,'existential'(VarName),Vars,O).

getMarkupFormula(L,'$eval'(Function),Vars,O):-!,
        getMarkupFormula(L,' eval'(Function),Vars,O).


getMarkupFormula(L,functional(VarName,Domains,Literal),Vars,O):-
        toMarkUp_lang(L,Literal,Vars,O),!.

close_list_var(M,[]):-isSlot(M),!.
close_list_var([[M]|Ms],[M|Ls]):-!,
        close_list_var(Ms,Ls).
close_list_var([M|Ms],[M|Ls]):-!,
        close_list_var(Ms,Ls).

getMarkupFormula(L,Term,Vars,Chars):-
        Term=..[F,A|Args],
        atom_concat('$',_,F), !,
        getMarkupFormula(L,write_dollar(F,[A|Args]),Vars,Chars).


getMarkupFormula(L,unused(C,P),Vars,O):-!,
        getMarkupFormula(L,notused(C,writeq(P)),Vars,O).

getMarkupFormula(L,ff([]),Vars,'[]'):-!.

getMarkupFormula(L,ff([Flag|Flags]),Vars,Chars):-!,
        getMarkupFormula(L,flag(Flag),Vars,Chars1),
        getMarkupFormula(L,ff(Flags),Vars,Chars2),
        sformat(Chars,'~w, ~w',[Chars1, Chars2]).

getMarkupFormula(L,domargs([]),Vars,''):-!.

getMarkupFormula(L,domargs([(P:N)]),Vars,Chars):-!,
        getMarkupFormula(L,P,Vars,Chars1),
        sformat(Chars,'~w:~w',[Chars1,N]).

getMarkupFormula(L,domargs([(P:N)|Flags]),Vars,Chars):-!,
        getMarkupFormula(L,P,Vars,Chars1),
        getMarkupFormula(L,domargs(Flags),Vars,Chars2),
        sformat(Chars,'~s:~w,~w',[Chars1,N,Chars2]).

getMarkupFormula(L,flag(Flag),Vars,Chars):-
        Flag=..[domainV,Var,DomArgs],!,
        getMarkupFormula(L,Var,Vars,VarChars),
        getMarkupFormula(L,domargs(DomArgs),Vars,ArgChars),
        sformat(Chars,'~w(~w,[~w])',[domainV,VarChars,ArgChars]).

getMarkupFormula(L,flag(Flag),Vars,Chars):-
        Flag=..[Name,Var,Args],!,
        getMarkupFormula(L,Var,Vars,VarChars),
        sformat(Chars,'~w(~w, ~q)',[Name,VarChars,Args]).
getMarkupFormula(L,flag(Flag),Vars,Chars):-!,
        getMarkupFormula(L,writeq(Flag),Vars,Chars).







getMarkupFormula(L,writeq(Atom),_VS,Chars):-!,sformat(Chars,'~q',[Atom]).

getMarkupFormula(L,[],Vars,''):-!.
%getMarkupFormula(L,[A | B],Vars,Chars):-proper_list([A | B]),append(['('|[A | B],[')'],TRY),toMarkUp_list(L,[Su|Bj],Vars,Chars).
%getMarkupFormula(L,[A | B],Vars,Chars):-catch(TRY=..['',A | B],_,fail),getMarkupFormula(L,TRY,Varsr,Chars),!.
%getMarkupFormula(L,[A | B],Vars,Chars):-catch(TRY=..[A | B],_,fail),getMarkupFormula(L,TRY,Vars,Chars),!.
%getMarkupFormula(L,[A | B],Vars,Chars):-catch(TRY=..[A | B],_,fail),getMarkupFormula(L,TRY,Vars,Chars),!.
getMarkupFormula(L,[Su|Bj],Vars,Chars):-
        toMarkUp_list(L,[Su|Bj],Vars,Chars1),
        sformat(Chars,'(~w)',[Chars1]).

/*
getMarkupFormula(L,Term,Vars,O):-
        Term=..[holds,F|Args],isNonVar(F),not_a_function(F),!,
        NTerm=..[F|Args],
        getMarkupFormula(L,NTerm,Vars,O).
*/
getMarkupFormula(L,'$VAR'(_)* X ,Vars,Out):-!,getMarkupFormula(L, X ,Vars,Out).
getMarkupFormula(L, X * '$VAR'(_) ,Vars,Out):-!,getMarkupFormula(L, X ,Vars,Out).
getMarkupFormula(L,(A * []),Vars,Out):-!,getMarkupFormula(L,A ,Vars,Out).
getMarkupFormula(L,([] * A),Vars,Out):-!,getMarkupFormula(L,A ,Vars,Out).
getMarkupFormula(L,deduced* X ,Vars,Out):-!,getMarkupFormula(L, X ,Vars,Out).
getMarkupFormula(L, X * deduced ,Vars,Out):-!,getMarkupFormula(L, X ,Vars,Out).


getMarkupFormula(L,domainV(Var,ReqsL),Vars,Chars):-
        getMarkupFormula(L,' domainV'(Var,writeq(ReqsL)),Vars,Chars).
getMarkupFormula(L,domainC(Var,ReqsL),Vars,Chars):-
        getMarkupFormula(L,' domainC'(Var,writeq(ReqsL)),Vars,Chars).
getMarkupFormula(L,domainA(Var,ReqsL),Vars,Chars):-
        getMarkupFormula(L,' domainA'(Var,writeq(ReqsL)),Vars,Chars).
getMarkupFormula(L,existsC(Var,ReqsL),Vars,Chars):-
        getMarkupFormula(L,' existsC'(Var,writeq(ReqsL)),Vars,Chars).
getMarkupFormula(L,existsA(Var,ReqsL),Vars,Chars):-
        getMarkupFormula(L,' existsA'(Var,writeq(ReqsL)),Vars,Chars).

getMarkupFormula(L,(A * B),Vars,Chars):-!,
        getMarkupFormula(L,B,Vars,Chars2),
        getMarkupFormula(L,A,Vars,Chars1),
        sformat(Chars,'~w\n~w',[Chars2, Chars1]).

getMarkupFormula(L,formula(C),Vars,Out):-!,
        getMarkupFormula(L,C,Vars,Out).


getMarkupFormula(html,undefined_constants(UnDefinedList),_,O):-
        getMarkupFormula(kif,nv(UnDefinedList),_,I),
        sformat(O,'\n<font color=red>Warning Undefined constants: <font color=black size=+1>~w</font></font>',[I]).

getMarkupFormula(kif,undefined_constants(UnDefinedList),_,O):-
        getMarkupFormula(kif,(UnDefinedList),_,I),
        sformat(O,'\Warning Undefined constants ~w',[I]).



getMarkupFormula(L,C,Vars,Out):-is_list(C),!,make_args_out(L,C,Vars,Out1),sformat(Out,'(~w)',[Out1]).
%getMarkupFormula(L,C,Vars,Out):-not(compound(C)),!,toMarkUp_lang(L,C,Vars,Out).

/*
getMarkupFormula(L,and(A,B),VS,Chars):-
        collect_op(and(A,B),O),!,
        getMarkupFormula(L,O,VS,Chars).

collect_op(and(A,B),and(A,B)):-not(A=and(_,_)),not(B=and(_,_)).
collect_op(and(A,B
*/

% ==================================================
% Unest And/Or
% ==================================================

getMarkupFormula(L,and(and(and(and(and(F,E),D),C),B),A),VS,Chars):-!, getMarkupFormula(L,and(F,E,D,C,B,A),VS,Chars).
getMarkupFormula(L,and(and(and(and(E,D),C),B),A),VS,Chars):-!, getMarkupFormula(L,and(E,D,C,B,A),VS,Chars).
getMarkupFormula(L,and(and(and(D,C),B),A),VS,Chars):-!, getMarkupFormula(L,and(D,C,B,A),VS,Chars).
getMarkupFormula(L,and(and(B,C),A),VS,Chars):-!, getMarkupFormula(L,and(C,B,A),VS,Chars).
getMarkupFormula(L,and(A,and(B,and(C,and(D,and(E,F))))),VS,Chars):-!, getMarkupFormula(L,'and'(A,B,C,D,E,F),VS,Chars).
getMarkupFormula(L,and(A,and(B,and(C,and(D,E)))),VS,Chars):-!, getMarkupFormula(L,'and'(A,B,C,D,E),VS,Chars).
getMarkupFormula(L,and(A,and(B,and(C,D))),VS,Chars):-!, getMarkupFormula(L,'and'(A,B,C,D),VS,Chars).
getMarkupFormula(L,and(A,and(B,C)),VS,Chars):-!, getMarkupFormula(L,'and'(A,B,C),VS,Chars).
getMarkupFormula(L,or(or(or(or(D,E),D),B),A),VS,Chars):-!, getMarkupFormula(L,or(E,D,C,B,A),VS,Chars).
getMarkupFormula(L,or(or(or(C,D),B),A),VS,Chars):-!, getMarkupFormula(L,or(D,C,B,A),VS,Chars).
getMarkupFormula(L,or(or(B,C),A),VS,Chars):-!, getMarkupFormula(L,or(C,B,A),VS,Chars).
getMarkupFormula(L,or(A,or(B,or(C,or(D,E)))),VS,Chars):-!, getMarkupFormula(L,'or'(A,B,C,D,E),VS,Chars).
getMarkupFormula(L,or(A,or(B,or(C,D))),VS,Chars):-!, getMarkupFormula(L,'or'(A,B,C,D),VS,Chars).
getMarkupFormula(L,or(A,or(B,C)),VS,Chars):-!, getMarkupFormula(L,'or'(A,B,C),VS,Chars).

% ==================================================
% Mark terms as implemented in code
% ==================================================

getMarkupFormula(html,incode(X),Vars,HAtom):-!,
        getMarkupFormula(L,bullet(X),Vars,Atom),
        sformat(HAtom,'<table border=0><tr><td><pre>~w</pre></td><td><pre>Implemented in code.</pre></td></tr></table>',[Atom]).

getMarkupFormula(kif,incode(X),Vars,HAtom):-!,
        getMarkupFormula(L,bullet(X),Vars,Atom),
        sformat(HAtom,'~w\nImplemented in code.\n',[Atom]).


getMarkupFormula(html,incode(X,M),Vars,HAtom):-!,
        getMarkupFormula(L,bullet(X),Vars,Atom),
        sformat(HAtom,'<table border=0><tr><td><pre>~w</pre></td><td><pre>Implemented in code.\n~w</pre></td></tr></table>',[Atom,M]).

getMarkupFormula(kif,incode(X,M),Vars,HAtom):-!,
        getMarkupFormula(L,bullet(X),Vars,Atom),
        sformat(HAtom,'~w\nImplemented in code.\n (~w)\n',[Atom,M]).

% ==================================================
% Finds the clausification then displays the explaination
% ==================================================

getMarkupFormula(L,cfind(entails(Pre,Post)),Vars,Out):-
        mooCache(PredR,Post,Pre,T,true,Context,Explaination),
        getMarkupFormula(L,Explaination,Vars,Out),!.

% ==================================================
% Show explaination of cross reference optimization
% ==================================================
getMarkupFormula(L,g_h(_),Vars,''):-!.
getMarkupFormula(L,tid(_),Vars,''):-!.

getMarkupFormula(L,crossref(X,Y),Vars,Atom):-!,
        crossref_to_explaination(crossref(X,Y),P),
        getMarkupFormula(L,P,Vars,Atom).

getMarkupFormula(L,crossref(X),Vars,Atom):-!,
        crossref_to_explaination(crossref(X),P),
        getMarkupFormula(L,P,Vars,Atom).


% ==================================================
% Surface Find
% ==================================================

getMarkupFormula(L,sfind(X),Vars,Out):- nonvar(X),
        mooCache(PredR, surface, X,V,Context, Ctx, TN, Auth, State),!,
        var_merge(Vars,V,TVars),!,
        getMarkupFormula(L,surf(Context,TN),TVars,Out).

% ==================================================
% Find a surface form, Display its explaination, show instanced version
% ==================================================

getMarkupFormula(L,sfindi(X),Vars,Out):- nonvar(X),
        mooCache(PredR, surface, X,V,Context, Ctx, TN, Auth, State),!,
        var_merge(Vars,V,TVars),!,
        getMarkupFormula(L,surf(Context,TN) * bullet_a(X),TVars,Out).

getMarkupFormula(L,sfindi(X),Vars,Out):- nonvar(X),
        getMarkupFormula(L,bullet_a(X),Vars,Out).


% ==================================================
% VIA
% ==================================================

getMarkupFormula(L,via(Form,V),Vars,Out):-
        (var_merge(Vars,V,TVars)),
        getMarkupFormula(L,via(Form),TVars,Out),!.


getMarkupFormula(L,via(entails(Pre,(Post))),Vars,Out):-not(isMooOption(show_entails,true)),!,
        getMarkupFormula(L,(  via('=>'(Pre,Post)) ),Vars,Out).


getMarkupFormula(L,'-'(Form),Vars,Out):-
        getMarkupFormula(L,not(Form),Vars,Out).

getMarkupFormula(L,'+'(Form),Vars,Out):-
        getMarkupFormula(L,(Form),Vars,Out).

getMarkupFormula(L,via(Form),Vars,Out):-
        getMarkupFormula(L,bullet_a(Form),Vars,Out).


getMarkupFormula(L,(entails(CList,UConsq,false)),Vars,Out):-!,
        getMarkupFormula(L,entails(CList,not(UConsq)),Vars,Out).

getMarkupFormula(L,(entails(CList,UConsq,true)),Vars,Out):-!,
        getMarkupFormula(L,entails(CList,(UConsq)),Vars,Out).

getMarkupFormula(L,(entails(true,(Post))),Vars,Out):-!,
        getMarkupFormula(L,(Post),Vars,Out).

% ==================================================
% nv(_) Print list as non-vecorted
% ==================================================

getMarkupFormula(L,nv(Subj),Vars,Chars):-!,toMarkUp_list(L,Subj,Vars,Chars).

% ==========================
% Maintainerial writing
% ==========================

getMarkupFormula(L,surf(Context,TN),Vars,Atom):-
        mooCache(PredR,surface, OForm, OVars,Context,TN,_, _),!,
        getMarkupFormula(L,OForm,OVars,Orig),
        flag(explaination_linenumber,LN,LN+1),
        getMarkupFormula(L,bullet(Context,TN,LN,Orig),Vars,Atom).
getMarkupFormula(L,surf(Context,TN),Vars,Atom):-!,
        getMarkupFormula(L,bullet('assertion lookup failure'(Context,TN)),Vars,Atom).

% ==========================
% Bullet writing
% ==========================

getMarkupFormula(L,bullet_a(X),Vars,S):-
        flag(indent,_,0),
        getMarkupFormula(L,X,Vars,SStatement),
        flag(explaination_linenumber,LN,LN),
        LNB is LN-1,
        sformat(S,'~wa. ~w\n',[LNB,SStatement]).

getMarkupFormula(L,bullet(X),Vars,Atom):-!,
        flag(explaination_linenumber,LN,LN+1),
        getMarkupFormula(L,X,Vars,Orig),
        getMarkupFormula(L,bullet('Kernel','GlobalContext',9100000,LN,Orig),Vars,Atom).

getMarkupFormula(html,bullet(Context,TN,LN,Orig),Vars,Atom):-!,%true,
        flag(indent,_,0),
        (catch((TN < 100000),_,fail) ->
                sformat(Atom,'~w <A href="stheory.jsp?req=SA&stheory=~w&id=~w" title="~w ~w ~w" ><img border=0 src="bullet.gif"/></A> ~w',[LN,Context,TN,TN,Context,Orig]);
                sformat(Atom,'~w <img border=0 src="bullet.gif" title="Not added to browser ~w (~w)"> ~w',[LN,Context,Orig])),!.

getMarkupFormula(kif,bullet(Context,TN,LN,Orig),Vars,Atom):-!,
        flag(indent,_,0),
%       getMarkupFormula(kif,asserted(Ctx,Orig),Vars,F),
        getMarkupFormula(kif,Orig,Vars,F),
        sformat(Atom,'~w. ~w',[LN,F]).

% ==========================
% Slolem  rewriting
% ==========================

getMarkupFormula(L,(X),Vars,Out):- nonvar(X),X=..['E',Sk|ArgS],!,
        Y=..[Sk|ArgS],!,
        getMarkupFormula(L,Y,Vars,Out).

% =====================
% remove_nonvars
% =====================

remove_nonvars(V,V):-isSlot(V),!.
remove_nonvars([],[]):-!.
remove_nonvars([V|L],LL):-isNonVar(V),!,remove_nonvars(L,LL).
remove_nonvars([V|L],[V|LL]):-remove_nonvars(L,LL).



% =====================
% Forall
% =====================

getMarkupFormula(L,forall(V,F),Vars,Chars):-not(is_list(V)),!,
        group_forall(forall(V,F),Next),!,
        cleanQuantifierConversionForWrite_forall(Next,O),
        getMarkupFormula(L,O,Vars,Chars).

cleanQuantifierConversionForWrite_forall(forall(VL,F),O):-
        remove_nonvars(VL,NL),
        ((NL=[],!,O=F);(!,O=forall(NL,F))).

getMarkupFormula(L,forall(V,F),Vars,Chars):- not(is_list(V)),!,
        getMarkupFormula(L,forall([V],F),Vars,Chars).

group_forall(forall(V1,forall(V2,forall(V3,forall(V4,forall(V5,F))))),forall([V1,V2,V3,V4,V5],F)):-!.
group_forall(forall(V1,forall(V2,forall(V3,forall(V4,F)))),forall([V1,V2,V3,V4],F)):-!.
group_forall(forall(V1,forall(V2,forall(V3,F))),forall([V1,V2,V3],F)):-!.
group_forall(forall(V1,forall(V2,F)),forall([V1,V2],F)):-!.
group_forall(forall(V1,F),forall([V1],F)):-!.

% =====================
% Exists
% =====================



getMarkupFormula(L,exists(V,F),Vars,Chars):-not(is_list(V)),!,
        group_exists(exists(V,F),Next),!,
        cleanQuantifierConversionForWrite_exists(Next,O),
        getMarkupFormula(L,O,Vars,Chars).

cleanQuantifierConversionForWrite_exists(exists(VL,F),O):-
        remove_nonvars(VL,NL),
        ((NL=[],!,O=F);(!,O=exists(NL,F))).

getMarkupFormula(L,exists(V,F),Vars,Chars):- not(is_list(V)),!,
        getMarkupFormula(L,exists([V],F),Vars,Chars).

group_exists(exists(V1,exists(V2,exists(V3,exists(V4,exists(V5,F))))),exists([V1,V2,V3,V4,V5],F)):-!.
group_exists(exists(V1,exists(V2,exists(V3,exists(V4,F)))),exists([V1,V2,V3,V4],F)):-!.
group_exists(exists(V1,exists(V2,exists(V3,F))),exists([V1,V2,V3],F)):-!.
group_exists(exists(V1,exists(V2,F)),exists([V1,V2],F)):-!.
group_exists(exists(V1,F),exists([V1],F)):-!.
% =====================
% Exists
% =====================

getMarkupFormula(L,exists(V,F),Vars,Chars):-not(is_list(V)),!,
        group_exists(exists(V,F),Next),!,
        cleanQuantifierConversionForWrite_exists(Next,O),
        getMarkupFormula(L,O,Vars,Chars).

cleanQuantifierConversionForWrite_exists(exists(VL,F),O):-
        remove_nonvars(VL,NL),
        ((NL=[],!,O=F);(!,O=exists(NL,F))).

getMarkupFormula(L,exists(V,F),Vars,Chars):- not(is_list(V)),!,
        getMarkupFormula(L,exists([V],F),Vars,Chars).

group_exists(exists(V1,exists(V2,exists(V3,exists(V4,exists(V5,F))))),exists([V1,V2,V3,V4,V5],F)):-!.
group_exists(exists(V1,exists(V2,exists(V3,exists(V4,F)))),exists([V1,V2,V3,V4],F)):-!.
group_exists(exists(V1,exists(V2,exists(V3,F))),exists([V1,V2,V3],F)):-!.
group_exists(exists(V1,exists(V2,F)),exists([V1,V2],F)):-!.
group_exists(exists(V1,F),exists([V1],F)):-!.

% =====================
% Findall
% =====================
        /*
getMarkupFormula(L,findall(V,F),Vars,Chars):-not(is_list(V)),!,
        group_findall(findall(V,F),Next),!,
        cleanQuantifierConversionForWrite_findall(Next,O),
        getMarkupFormula(L,O,Vars,Chars).

cleanQuantifierConversionForWrite_findall(findall(VL,F),O):-
        remove_nonvars(VL,NL),
        ((NL=[],!,O=F);(!,O=findall(NL,F))).

getMarkupFormula(L,findall(V,F),Vars,Chars):- not(is_list(V)),!,
        getMarkupFormula(L,findall([V],F),Vars,Chars).

group_findall(findall(V1,findall(V2,findall(V3,findall(V4,findall(V5,F))))),findall([V1,V2,V3,V4,V5],F)):-!.
group_findall(findall(V1,findall(V2,findall(V3,findall(V4,F)))),findall([V1,V2,V3,V4],F)):-!.
group_findall(findall(V1,findall(V2,findall(V3,F))),findall([V1,V2,V3],F)):-!.
group_findall(findall(V1,findall(V2,F)),findall([V1,V2],F)):-!.
group_findall(findall(V1,F),findall([V1],F)):-!.
                                 */
% =====================
% Indentation
% =====================

getMarkupFormula(L,C,Vars,Out):-
                C=..[Pred|ARGS],!,
                flag(indent,X,X+1),
                indent_it_x(X,PreOut),!,
                toMarkUp_lang(L,Pred,Vars,PredOut),!,
                make_args_out(L,ARGS,Vars,ArgsOut),!,
                sformat(Out,'~w(~w ~w)',[PreOut,PredOut,ArgsOut]), !,
                flag(indent,NX,NX-1).

make_args_out(L,[],Vars,''):-!.
make_args_out(L,[C],Vars,ArgsOut):-
                getMarkupFormula(L,C,Vars,ArgsOut).
make_args_out(L,[C|GS],Vars,ArgsOut):-
                getMarkupFormula(L,C,Vars,Out1),
                make_args_out(L,GS,Vars,Out2),!,
                sformat(ArgsOut,'~w ~w',[Out1,Out2]).

indent_it_x(0,''):-!.
indent_it_x(1,'\n         '):-!.
indent_it_x(X,Out):-XX is X -1,!, indent_it_x(XX,OutP),!,sformat(Out,'~w   ',[OutP]),!.

% =====================
% Prolog Tr./ansformation
% =====================

toMarkUp_lang(L,':-'(C,true),Vars,Out):-prolog_to_krlog(C,KR),!,toMarkUp_lang(L,KR,Vars,Out).
toMarkUp_lang(L,':-'(C,A),Vars,Out):-prolog_to_krlog(C,KRC),prolog_to_krlog(A,KRA),!,toMarkUp_lang(L,'=>'(KRA,KRC),Vars,Out).

toMarkUp_lang(L,(T^V),Vars,Out):-var_merge(Vars,V,TVars),!,toMarkUp_lang(L,T,TVars,Out).

%Terminal Control
toMarkUp_lang(html,lparen,Vars,'('):-!.
toMarkUp_lang(html,rparen,Vars,')'):-!.
toMarkUp_lang(kif,lparen,Vars,'('):-!.
toMarkUp_lang(kif,rparen,Vars,')'):-!.
toMarkUp_lang(html,nl,Vars,'<br>'):-!.
toMarkUp_lang(html,tab,Vars,'<li>'):-!.
toMarkUp_lang(kif,nl,Vars,'\n'):-!.
toMarkUp_lang(kif,tab,Vars,'\t'):-!.

% No parens (nv = no vector)
toMarkUp_lang(L,nv(Subj),Vars,Chars):-is_list(Subj),!,toMarkUp_list(L,Subj,Vars,Chars).
toMarkUp_lang(L,nv(Subj),Vars,Chars):-!,toMarkUp_lang(L,Subj,Vars,Chars).

toMarkUp_lang(_,writeFmt(F,A),Vars,Out):-sformat(Out,F,A),!.
toMarkUp_lang(_,surf,Vars,''):-!.
toMarkUp_lang(_,end_of_file,Vars,''):-!.

toMarkUp_lang(_,',',Vars,'and'):-!.
toMarkUp_lang(_,';',Vars,'or'):-!.
toMarkUp_lang(_,'=',Vars,'equal'):-!.
toMarkUp_lang(_,'deduced',Vars,' ').

% QUOTED STRING FORMAT
toMarkUp_lang(kif,Atom,_VS,Chars):-isCharCodelist(Atom),!,
        catch(sformat(Chars,'"~s"',[Atom]),_,sformat(Chars,'"~w"',[Atom])).
toMarkUp_lang(kif,Atom,_VS,Chars):-string(Atom),!,
        catch(sformat(Chars,'"~s"',[Atom]),_,sformat(Chars,'"~w"',[Atom])).


%LISTS
%toMarkUp_lang(LANG,[COMP],Vars,Atom)

toMarkUp_lang(L,[],Vars,Atom):-toMarkUp_lang(L,'NullSet',Vars,Atom).
%toMarkUp_lang(html,[Su|Bj],Vars,Chars):-toMarkUp_list(html,[Su|Bj],Vars,Chars1),sformat(Chars,'<div>(<ul>~w </ul>)</div>',[Chars1]).
toMarkUp_lang(kif,[Su|Bj],Vars,Chars):-toMarkUp_list(kif,[Su|Bj],Vars,Chars1),sformat(Chars,'(~w)',[Chars1]).


close_varlist([]):-!.
close_varlist('$VAR'(_)):-!.
close_varlist([V|VV]):-close_varlist(VV),!.

% SPECIAL FORMATS

toMarkUp_lang(_,writeq(Term),Vars,Atom):-!,sformat(Atom,'~q',[Term]).
toMarkUp_lang(kif,maillink(Title,Address,Subject),Vars,Address):-!.
toMarkUp_lang(kif,weblink(Title,URL),Vars,Title):-!.
toMarkUp_lang(kif,helplink(Title,URL),Vars,Title):-!.
toMarkUp_lang(L,explaination(PB),Vars,Atom):-
        flag(explaination_linenumber,_,1),
        getMarkupFormula(L,PB,Vars,AtomS),!,
        sformat(Atom,'\nExplaination:\n~w\n',[AtomS]).

toMarkUp_lang(LANG,krlog(COMP),Vars,Atom):-!,prolog_to_krlog(COMP,KR),toMarkUp_lang(LANG,KR,Vars,Atom).

toMarkUp_lang(LANG,kif(COMP),Vars,Atom):-!,toMarkUp_lang(kif,COMP,Vars,Atom).
toMarkUp_lang(LANG,html(COMP),Vars,Atom):-!,toMarkUp_lang(html,COMP,Vars,Atom).

toMarkUp_lang(html,select(Name,OptionList),Vars,Out):-toMarkUp_lang(html,options(OptionList),Vars,Options),sformat(Out,'<select sort name="~w" id="~w" size="1">~w</select>',[Name,Name,Options]).
toMarkUp_lang(html,chectheoryox(Name,on),Vars,Out):-
                sformat(Out,'<input type=chectheoryox name="~w" id="~w" checked>',[Name,Name]),!.
toMarkUp_lang(html,chectheoryox(Name,_),Vars,Out):-
                sformat(Out,'<input type=chectheoryox name="~w" id="~w">',[Name,Name]),!.
toMarkUp_lang(html,options([]),Vars,'').

toMarkUp_lang(L,getPrologVars(Form),Vars,Chars):-markUpVARLIST(L,Form,Vars,SChars),sformat(Chars,'~w',[SChars]),!.

toMarkUp_lang(L,getPrologVars(Form),Vars,Chars):-!,sformat(Chars,'; var_post_err (~q). ',[Form]).


toMarkUp_lang(html,qresult(Res),Vars,Chars):-!,sformat(Chars,'Result ',[Res]).

toMarkUp_lang(kif,qresult(Res),Vars,''):-!. %,sformat(Chars,'res="~w"\n',[Res]).

% Back into Standard Terms

format_o(Format,Stuff):-
        toMarkUp_lang(html,Stuff,_,Out),writeFmt(Format,[Out]).


toMarkUp_lang(html,options([Option|List]),Vars,Out):-
               toMarkUp_lang(html,option(Option),Vars,Out2),
               toMarkUp_lang(html,options(List),Vars,Out3),
               atom_concat(Out2,Out3,Out).

toMarkUp_lang(html,option(Option),Vars,Out):-sformat(Out,'<option value="~w">~w</option>',[Option,Option]).

% Numbers
toMarkUp_lang(_,Atom,_VS,Chars):-number(Atom),!,sformat(Chars,'~w',[Atom]).

toMarkUp_lang(L,Value,Vars,Chars):-
        mooCache(PredR, skolem, Value = x(Name,Expression),SKVARS,Context, Ctx, TN, Auth, State),!,
            toMarkUp_lang(kif,Name,Vars,NameQ),  prependQuestionMark(NameQ,NameQM),
            subst(x(Sk,Expression),Sk,NameQM,x(NSk,NExpression)),!,
            toMarkUp_lang(L,exists([NSk],NExpression),SKVARS,Chars).

% all other Formulas get intercepted here
toMarkUp_lang(L,Term,Vars,Chars):-compound(Term),!,
        getMarkupFormula(L,Term,Vars,Chars),!.

% PRETTYNESS
toMarkUp_lang(_,';',Vars,'or ').
toMarkUp_lang(_,',',Vars,'and ').
toMarkUp_lang(_,'neg',Vars,'neg ').
%toMarkUp_lang(_,entails,Vars,'modus-ponens ').
%toMarkUp_lang(_,entails,Vars,'modus-tollens ').



% Not compound - TEXT
toMarkUp_lang(html,Atom,Vars,Chars):-
        atom_codes(Atom,[115,107|_]),!,
                atom_lookup_theory_ctx(html,Atom,Context,Result,ID,Color,Page),!,
                (Result=ml(This) -> toMarkUp_lang(html,This,Vars,SResult) ; SResult=Result),
                (Context=none ->
                        sformat(Chars,'<font color=~w>~w</font>',[Color,SResult]);
                        sformat(Chars,'<A HREF="~w.jsp?logicforms=logicforms&submit=All%20Forms&data=~w&theory=~w">~w</A>',[Page,ID,Context,SResult])
                ).

toMarkUp_lang(html,Atom,Vars,Chars):-
                atom_lookup_theory_ctx(html,Atom,Context,Result,ID,Color,Page),!,
                (Result=ml(This) -> toMarkUp_lang(html,This,Vars,SResult) ; SResult=Result),
                (Context=none ->
                        sformat(Chars,'<font color=~w>~w</font>',[Color,SResult]);
                        sformat(Chars,'<A HREF="~w.jsp?req=SC&term=~w&stheory=~w">~w</A>',[Page,ID,Context,SResult])
                ).

toMarkUp_lang(kif,Atom,Vars,Chars):-
                atom_lookup_theory_ctx(kif,Atom,Context,Result,ID,Color,Page),!,
                (Result=ml(This) -> toMarkUp_lang(html,This,Vars,SResult) ; SResult=Result),
                        sformat(Chars,'~w',[SResult]).

% Lookup Proc
atom_lookup_theory_ctx(kif,Atom,none,none,Atom,Atom,black,stheory):-!.

atom_lookup_theory_ctx(_,Atom,Context,'GlobalContext',Atom,Atom,purple,skolems):-
        hlPredicateAttribute(Atom,'SkolemFunction'),!,isMooOption(opt_theory=Context),!.

atom_lookup_theory_ctx(Lang,Atom,Context,Atom,B,C,stheory):-
        atom_lookup_theory_ctx(Lang,Atom,Context,Atom,B,C).

atom_lookup_theory_ctx(kif,Atom,none,none,Atom,Atom,black):-!.
atom_lookup_theory_ctx(L,Atom,none,none,Atom,Atom,black):-once(atom_codes(Atom,Codes)),
        once((memberchk(34,Codes);memberchk(63,Codes);memberchk(32,Codes);memberchk(37,Codes))),!. % String
atom_lookup_theory_ctx(_,Atom,Context,'GlobalContext',Atom,Atom,blue):-!,isMooOption(opt_theory=Context),!. % Leftover must be PrologMOO (TODO)
atom_lookup_theory_ctx(_,Atom,'PrologMOO','GlobalContext',Atom,Atom,blue):-!.

codes_to_links(Codes,PrettyAtom):-
        getUnquotedCodes(Codes,UCodes),
        getKIFTokens(UCodes,WordList),
        concat_atom(WordList,'-',PrettyAtom),!.

getUnquotedCodes([34|Codes],UCodes):-
        (reverse(Codes,RCodes)),
        (ltrim(RCodes,[34|RUCodes])),
        reverse(RUCodes,UCodes).

getUnquotedCodes(UCodes,UCodes):-!.


%TODO Number?

% ================================================
%      toMarkUp_list
% ================================================

toMarkUp_list(L,Var,VS,Chars):-isSlot(Var),!,toMarkUp_slotValue(L,Var,VS,Chars).
toMarkUp_list(_,[],VS,''):-!.
toMarkUp_list(LANG,[H],VS,Chars):-!,
        toMarkUp_lang(LANG,H,VS,Chars).
toMarkUp_list(LANG,[H|T],VS,Chars):-!,
        toMarkUp_lang(LANG,H,VS,Chars1),
        toMarkUp_list(LANG,T,VS,Chars2),
        sformat(Chars,'~w ~w',[Chars1,Chars2]).

markUpVARLIST(L,[],Vars,''):-!.
markUpVARLIST(L,'$VAR'(_),Vars,''):-!.

markUpVARLIST(L,[VV|Varnames],Vars,Chars):-
                  VV=..[_,Name,Value],!,
                  toMarkupVarEquals(L,Name,Value,Vars,Chars1),
                  markUpVARLIST(L,Varnames,Vars,Chars2),
                  sformat(Chars,'~w\n~w',[Chars1,Chars2]).

toMarkupVarEquals(_,Name,Value,Vars,Chars):-
            toMarkUp_lang(kif,Name,Vars,NameQ),
            toMarkUp_slotValue(L,Value,Vars,ValChars),
            sformat(Chars,'~w = ~w',[NameQ,ValChars]).


% Real Prolog Var
toMarkUp_slotValue(L,Slot,VarList,Chars):- isVarProlog(Slot),!,
        toMarkUp_makeNamePrologVar(L,VarList,Slot,Name),
        atom_concat('?',Name,Chars),!.
% Slot 'Typed'
toMarkUp_slotValue(L,Slot,VarList,Chars):-isQualifiedAs(Slot,BaseType,Value,Subtype), !,
        toMarkUp_makeName(L,VarList,Slot,Subtype,Value,Name),
        close_freeVars(VarList,NVarList),
        append(NVarList,[Name=Value],NV),
        toMarkUp_lang(L,Value,NV,VChars),
        sformat(Chars,'<div title="~w">~w</div>',[Subtype,VChars]).

toMarkUp_makeNamePrologVar(L,VarList,Value,Name):-member(Name=Var,VarList),Var==Value,!.
toMarkUp_makeNamePrologVar(L,VarList,Value,Name):-getVarAtom(Value,NUame),atom_concat('?',NUame,Name).

getVarAtom(Value,Name):-var(Value),!,term_to_atom(Value,Vname),atom_codes(AVAR,[95,_|CODES]),atom_codes(Name,CODES),!.
getVarAtom('$VAR'(VNUM),Name):-concat_atom([VNUM],Name),!.



toMarkUp_makeName(L,VarList,Slot,BaseType,Value,Name):-
        member(Name=Var,VarList),Var==Slot,!.
toMarkUp_makeName(L,VarList,Slot,BaseType,Value,Name):-
        member(Name=Var,VarList),Var==Value,!.
toMarkUp_makeName(L,VarList,Slot,BaseType,Value,Name):-atom_concat('?',BaseType,Name).



close_freeVars(V,V):-proper_list(V),!.
close_freeVars(V,[]):-isSlot(V),!. %Closing List if there are no free getPrologVars
close_freeVars([X|XX],[X|More]):- close_freeVars(XX,More).





toMarkup_varProlog(kif,Var,_VS,NameQ):- _VS=[VV|_],nonvar(VV),VV=..[_,Name,VarRef],number(Name),Var==VarRef,!,sformat(NameQ,'?~d',[Name]).
toMarkup_varProlog(kif,Var,_VS,NameQ):- _VS=[VV|_],nonvar(VV),VV=..[_,Name,VarRef],Var==VarRef,!,sformat(NameQ,'?~w',[Name]).

toMarkup_varProlog(html,Var,_VS,NameQ):- _VS=[VV|_],nonvar(VV),VV=..[_,Name,VarRef],number(Name),Var==VarRef,!,sformat(NameQ,'?~d',[Name]).
toMarkup_varProlog(html,Var,_VS,NameQ):- _VS=[VV|_],nonvar(VV),VV=..[_,Name,VarRef],Var==VarRef,!,sformat(NameQ,'?~w',[Name]).

toMarkup_varProlog(T,Var,[_|Rest],Name):-nonvar(Rest),toMarkup_varProlog(T,Var,Rest,Name).
toMarkup_varProlog(kif,VAR,_,VarName):-term_to_atom(VAR,AVAR),atom_codes(AVAR,[95|CODES]),!,catch(sformat(VarName,'?HYP-~s',[CODES]),_,VarName='?HYP-AVAR').
toMarkup_varProlog(kif,VAR,_,VarName):-term_to_atom(VAR,AVAR),atom_codes(AVAR,CODES),!,catch(sformat(VarName,'?HYP-~s',[CODES]),_,VarName='?HYP-AVAR').
toMarkup_varProlog(html,VAR,VS,VarName):-toMarkup_varProlog(kif,VAR,VS,VarName).

prependQuestionMark(Name,NameQ):-atom_concat('?',Name,NameQ).


:-dynamic( ax_worldwalker /1).

writeDebug(What):-writeDebug(unknown,What).
 
writeDebug(A,B):-ax_worldwalker(X),once((!,catch2((
        sformat(This,'debug ~w:~w',[A,B]),actx_invoke_object(X,[say],[This],[])
        )))).

 
writeDebug(A,B):-!,catch(write((A:B)),_,true),nl.

%writeDebug(A,B):-catch(post((A:B)),_,true).

/*
writeDebug(make_scripts,Scripted:Proposed_Method) :- !, write_debug1(Scripted), write(Proposed_Method), write('.'), nl.
writeDebug(make_scripts,Scripted) :- !,write(Scripted), write('.'), nl.
writeDebug(Who,What):-ground(What),writeq(Who=What),nl,ttyflush.
writeDebug(_,_).
*/

write_debug1(Scripted:Proposed_Method) :- !, write_debug1(Scripted), write(Proposed_Method), write(';'), nl.
write_debug1(Scripted) :- write(Scripted), write(';'), nl.

%//------------------------------------------------------------------------------

/****************************************************************************/
% replace(+Element1,+List1,+Element2,-List2)
%    replaces all instances of Element1 in List1 with Element2 and returns
%       the new list as List2
%    does not replace variables in List1 with Element1

replace(_,[],_,[]).
replace(X,[H|T],A,[A|T2]) :- nonvar(H), H = X, !, replace(X,T,A,T2).
replace(X,[H|T],A,[H|T2]) :- replace(X,T,A,T2).

%//------------------------------------------------------------------------------

replaceall(_,_,[],[]):-!.
replaceall(X,INS,[X|TXT],OUT):-!,append([13,10|INS],TXT,OUT).
replaceall(X,INS,[A|TXT],[A|OUT]):-!,replaceall(X,INS,TXT,OUT).

%//------------------------------------------------------------------------------

aformat(Atom,Format,List):-
	sformat(String,Format,List),
	string_to_atom(String,Atom).

%//------------------------------------------------------------------------------

assert_new(X):-catch((X),_,fail),!.
assert_new(X):-catch(asserta((X)),_,true),!.
assert_new(_X):-!.

%//------------------------------------------------------------------------------

try(Process):-ignore(catch(Process)).

%//------------------------------------------------------------------------------

try2(Process):-catch(Process,_,true).

%//------------------------------------------------------------------------------

catch(Process):-catch(Process,_Error,(writeDebug(Process,_Error),fail)).

%//------------------------------------------------------------------------------

catch2(Process):-catch(Process,_,fail).

%//------------------------------------------------------------------------------

post(X):-term_to_atom(X,R),assertz(result(R)).

:-post(just_loaded).

%//------------------------------------------------------------------------------

real_atom([]):-!,fail.
real_atom(X):-atomic(X).

%//------------------------------------------------------------------------------

list_term_to_atom([],[]):-!.
list_term_to_atom([TH|TL],[AH|AL]):-!,term_to_atom(TH,AH),list_term_to_atom(TL,AL).

                              




/*
:- module(moo_nfs,
      [nnf/2,
      nfs_cnf/2,
      dnf/2,
      pnf/2,
      cf/2]).

  */
% :-include('moo_header.pl').

/******************************************************************************

Note: this file is used as sanity reference 

none of the predicates are used




Purpose: 1. Compute normal forms for first-order formula.
         2. Skolemize first-order formula.

Version: 0.1

Language: SWI Prolog

Filename: nfs

Date: 1999.7.15

Maintainer: Anthony Aaby

Usage: see nfs_help

Copyright (C) 1999 Anthony A. Aaby

This program is free software; you can redistribute it  and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place   not    Suite 330, Boston, MA  02111-1307, USA.

To reach the author send email to aabyan@wwc.edu
or Anthony Aaby
   Computer Science Department
   Walla Walla College
   College Place, WA 99324

FORMULA SYNTAX
        not A =  not    A
        A/\B  = A  and  B
        A\/B  = A or B
        A=>B  = A  =>   B
        A<=>B = A  <=>   B
     forall(X,A) = forall(X,A)
  exists(X,A) = exists(X,A)
          []F = known F
          <>F = consistent F
          0 F = next F
   until(A,B) = until(A,B)
******************************************************************************/

%

:- op(400,fy,known).  % Necessity, Always
:- op(400,fy,consistent).  % Possibly, Eventually
:- op(400,fy,next).  % Next time
:- op(400,fy,  not   ).    % negation
:- op(500,xfy, and ).   % conjunction
:- op(600,xfy,or).   % disjunction
:- op(650,xfy, =>  ).  % implication
:- op(700,xfy, <=>  ). % equivalence

%%% Negation Normal Form

% Usage: nnf(+Fml, ?NNF)

nnf(Fml,NNF) :- nnf(Fml,[],NNF,_).

%  not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not     not   
%  nnf(+Fml,+FreeV,-NNF,-Paths)
%
% Fml,NNF:    See above.
% FreeV:      List of free variables in Fml.
% Paths:      Number of disjunctive paths in Fml.

nnf(known F,FreeV,BOX,Paths) :- !,
	nnf(F,FreeV,NNF,Paths), nfs_cnf(NNF,CNF), boxRule(known CNF, BOX).

nnf(consistent F,FreeV,DIA,Paths) :- !,
	nnf(F,FreeV,NNF,Paths), dnf(NNF,DNF), diaRule(consistent DNF, DIA).

nnf(next F,FreeV,CIR,Paths) :- !,
	nnf(F,FreeV,NNF,Paths), cirRule(next NNF, CIR).

nnf(until(A,B),FreeV,NNF,Paths) :- !,
	nnf(A,FreeV,NNF1,Paths1),
	nnf(B,FreeV,NNF2,Paths2),
	Paths is Paths1 + Paths2,
	NNF = until(NNF1, NNF2).

nnf(forall(X,F),FreeV,forall(X,NNF),Paths) :- !,
	nnf(F,[X|FreeV],NNF,Paths).

nnf(exists(X,Fml),FreeV,NNF,Paths) :- !,
	skolemize(Fml,X,FreeV,FmlSk),
	nnf(FmlSk,FreeV,NNF,Paths).

nnf(A  and  B,FreeV,NNF,Paths) :- !,
	nnf(A,FreeV,NNF1,Paths1),
	nnf(B,FreeV,NNF2,Paths2),
	Paths is Paths1 * Paths2,
	(Paths1 > Paths2  -> NNF = (NNF2  and  NNF1);
		            NNF = (NNF1  and  NNF2)).

nnf(A or B,FreeV,NNF,Paths) :- !,
	nnf(A,FreeV,NNF1,Paths1),
	nnf(B,FreeV,NNF2,Paths2),
	Paths is Paths1 + Paths2,
	(Paths1 > Paths2  -> NNF = (NNF2 or NNF1);
		            NNF = (NNF1 or NNF2)).

nnf(Fml,FreeV,NNF,Paths) :- 
	(Fml =  not   (  not   A)      -> Fml1 = A;
	 Fml =  not   (known F)   -> Fml1 = consistent (  not   F);
	 Fml =  not   (consistent F)   -> Fml1 = known (  not   F);
	 Fml =  not   (next F)   -> Fml1 = next (  not   F);
	 Fml =  not  until(A,B) -> (nnf(  not   A,FreeV,NNA,_), nnf(  not   B,FreeV,NNB,_),
                             Fml1 = forall(NNB)or until(NNB,NNA  and  NNB));
	 Fml =  not  forall(X,F)  -> Fml1 = exists(X,-F);
	 Fml =  not  exists(X,F)   -> Fml1 = forall(X,-F);
	 Fml =  not   (A or B)   -> Fml1 =  not  A  and   not  B;
	 Fml =  not   (A  and  B)   -> Fml1 =  not  A or  not  B;
	 Fml = (A  =>   B)   -> Fml1 =  not  A or B;
	 Fml =  not   (A  =>   B)  -> Fml1 = A  and   not  B;
	 Fml = (A  <=>   B)  -> Fml1 = (A  and  B) or (  not   A  and   not  B);
	 Fml =  not   (A  <=>   B) -> Fml1 = (A  and   not  B) or (  not   A  and  B)),!,
	nnf(Fml1,FreeV,NNF,Paths).

nnf(Lit,_,Lit,1).

boxRule(known (A and B), (BA)  and  (BB)) :- !, boxRule(known A,BA), boxRule(known B,BB).
boxRule(BOX, BOX).
diaRule(consistent (A or B), (DA) or (DB)) :- !, diaRule(consistent A,DA), diaRule(consistent B,DB).
diaRule(DIA, DIA).
cirRule(next (A or B), (DA) or (DB)) :- !, cirRule(next A,DA), cirRule(next B,DB).
cirRule(next (A  and  B), (DA)  and  (DB)) :- !, cirRule(next A,DA), cirRule(next B,DB).
cirRule(CIR, CIR).

%%%  Conjunctive Normal Form (CNF)  not     not    assumes Fml in NNF

% Usage: nfs_cnf( +NNF, ?CNF )

nfs_cnf(P  and  Q, P1  and  Q1):- !, nfs_cnf(P, P1), nfs_cnf(Q, Q1).
nfs_cnf(P or Q,     CNF):- !, nfs_cnf(P, P1), nfs_cnf(Q, Q1), cnf1(P1 or Q1, CNF).
nfs_cnf(CNF,       CNF).

cnf1((P  and  Q) or R, P1  and  Q1):- !, cnf1(P or R, P1), cnf1(Q or R, Q1).
cnf1(P or (Q  and  R), P1  and  Q1):- !, cnf1(P or Q, P1), cnf1(P or R, Q1).
cnf1(CNF,             CNF).

%%%  Disjunctive Normal Form (DNF)  not     not    assumes Fml in NNF

% Usage: dnf( +NNF, ?DNF )

dnf(P or Q, P1 or Q1):- !, dnf(P, P1), dnf(Q, Q1).
dnf(P  and  Q,     DNF):- !, dnf(P, P1), dnf(Q, Q1), dnf1(P1  and  Q1, DNF).
dnf(DNF,       DNF).

dnf1(P  and  (Q or R), P1 or Q1):- !, dnf1(P  and  Q, P1), dnf1(P  and  R, Q1).
dnf1((P or Q)  and  R, P1 or Q1):- !, dnf1(P  and  R, P1), dnf1(Q  and  R, Q1).
dnf1(DNF,             DNF).

%%%  Prenex Normal Form (PNF)

% Usage: pnf( +Fml, ?PNF )  not     not    assumes Fml in NNF

pnf(F,PNF) :- pnf(F,[],PNF).

% pnf(+Fml, +Vars, ?PNF)

pnf(     forall(X,F),Vs, forall(X,PNF)) :- !, pnf(F,[X|Vs], PNF).
pnf(      exists(X,F),Vs,  exists(X,PNF)) :- !, pnf(F,[X|Vs], PNF).

pnf(  exists(X,A)  and  B,Vs,  exists(Y,PNF)) :- !, copy_term((X,A,Vs),(Y,Ay,Vs)),
                                        pnf(Ay  and  B,[Y|Vs], PNF).
pnf(  exists(X,A) or B,Vs,  exists(Y,PNF)) :- !, copy_term((X,A,Vs),(Y,Ay,Vs)),
                                        pnf(Ay or B,[Y|Vs], PNF).
pnf( forall(X,A)  and  B,Vs, forall(Y,PNF)) :- !, copy_term((X,A,Vs),(Y,Ay,Vs)),
                                        pnf(Ay  and  B,[Y|Vs], PNF).
pnf( forall(X,A) or B,Vs, forall(Y,PNF)) :- !, copy_term((X,A,Vs),(Y,Ay,Vs)),
                                        pnf(Ay or B,[Y|Vs], PNF).

pnf( A  and   exists(X,B),Vs,  exists(Y,PNF)) :- !, copy_term((X,B,Vs),(Y,By,Vs)),
                                        pnf(A  and  By,[Y|Vs], PNF).
pnf( A or  exists(X,B),Vs,  exists(Y,PNF)) :- !, copy_term((X,B,Vs),(Y,By,Vs)),
                                        pnf(A or By,[Y|Vs], PNF).
pnf( A  and  forall(X,B),Vs, forall(Y,PNF)) :- !, copy_term((X,B,Vs),(Y,By,Vs)),
                                        pnf(A  and  By,[Y|Vs], PNF).
pnf( A or forall(X,B),Vs, forall(Y,PNF)) :- !, copy_term((X,B,Vs),(Y,By,Vs)),
                                        pnf(A or By,[Y|Vs], PNF).

pnf(        A  and  B,Vs,       PNF ) :- pnf(A,Vs,Ap), pnf(B,Vs,Bp), 
                                     (A\=Ap; B\=Bp), pnf(Ap  and  Bp,Vs,PNF).
pnf(        A or B,Vs,       PNF ) :- pnf(A,Vs,Ap), pnf(B,Vs,Bp), 
                                     (A\=Ap; B\=Bp), pnf(Ap or Bp,Vs,PNF).

pnf(          PNF, _,       PNF ).

%%%  Clausal Form (CF)  not     not    assumes Fml in PNF  and
%                                 each quantified variable is unique

% cf(+Fml, ?Cs)
% Cs is a list of the form: [cl(Head,Body), ...]
% Head  and Body are lists.

cf(PNF, Cla):- removeQ(PNF,[], UnQ), nfs_cnf(UnQ,CNF), clausify(CNF,Cla,[]).

% removes quantifiers
removeQ( forall(X,F),Vars, RQ) :- removeQ(F,[X|Vars], RQ).
removeQ(  exists(X,F),Vars, RQ) :- skolemize(F,X,Vars,Fsk),
                               removeQ(Fsk,Vars, RQ).
removeQ( F,_,F ).

clausify( (P  and  Q), C1, C2 ) :- !, clausify( P, C1, C3 ), clausify( Q, C3, C2 ).
clausify( P, [cl(A,B)|Cs], Cs ) :- inclause( P, A, [], B, [] ), !.
clausify( _, C, C ).

inclause( (P or Q), A, A1, B, B1 ) :- !, inclause( P, A2, A1, B2, B1 ),
                                        inclause( Q, A,  A2, B,  B2 ).

inclause(  not  P, A,  A, B1, B ) :- !, notin( P, A ), putin( P, B, B1 ).
inclause( P,  A1, A, B,  B ) :- !, notin( P, B ), putin( P, A, A1 ).

notin(X,[Y|_]) :- X==Y, !, fail.
notin(X,[_|Y]) :- !,notin(X,Y).
notin(_,[]).

putin(X,[],   [X]   ) :- !.
putin(X,[Y|L],[Y|L] ) :- X == Y,!.
putin(X,[Y|L],[Y|L1]) :- putin(X,L,L1).

%%%  Skolemizing   not     not    Two methods

% Usage: skolemize(+Fml,+X,+FreeV,?FmlSk)
% Replaces existentially quantified variable with the formula
% VARIABLES MUST BE PROLOG VARIABLES
% exists(X,p(X))  not    -> p(p(exists))

skolemize(Fml,X,FreeV,FmlSk):-
	copy_term((X,Fml,FreeV),(Fml,Fml1,FreeV)),
	copy_term((X,Fml1,FreeV),(exists,FmlSk,FreeV)).

% Usage: skolem( +Fml, +X, +FreeV, ?FmlSk )
% Replaces existentially quantified variable with a unique function
% fN(Vars) N=1,...
% VARIABLES MAYBE EITHER PROLOG VARIABLES OR TERMS

skolem( F, X, FreeV, FmlSk) :- gensym( f, Fun ), Sk =..[Fun|FreeV],
                                subst( F, X, Sk, FmlSk ).

%%% Substitution

/*
% Usage: subst(+Fml,+X,+Sk,?FmlSk)

subst( forall(Y,P), X,Sk, forall(Y,P1) ) :- !, subst( P,X,Sk,P1 ).
subst(  exists(Y,P), X,Sk,  exists(Y,P1) ) :- !, subst( P,X,Sk,P1 ).
subst(    P  and  Q, X,Sk,   P1  and  Q1 ) :- !, subst( P,X,Sk,P1 ),
                                         subst( Q,X,Sk,Q1 ).
subst(    P or Q, X,Sk,   P1 or Q1 ) :- !, subst( P,X,Sk,P1 ),
                                         subst( Q,X,Sk,Q1 ).
subst(        P, X,Sk,        P1 ) :- functor(P,_,N),
                                      subst1( X, Sk, P, N, P1 ).

subst1( _,  _, P, 0, P  ).
subst1( X, Sk, P, N, P1 ) :- N > 0, P =..[F|Args], subst2( X, Sk, Args, ArgS ),
                             P1 =..[F|ArgS].

subst2( _,  _, [], [] ).
subst2( X, Sk, [A|As], [Sk|AS] ) :- X == A, !, subst2( X, Sk, As, AS).
subst2( X, Sk, [A|As], [A|AS]  ) :- var(A), !, subst2( X, Sk, As, AS).
subst2( X, Sk, [A|As], [Ap|AS] ) :- subst( A,X,Sk,Ap ),
                                    subst2( X, Sk, As, AS).
                                    
*/                                    

/********************************  The End ***********************************/




%:-module(moo_algebra,[]).


% :-include('moo_header.pl').
% ===================================================================
% Contact: dmiles@users.sourceforge.net ; 
% ===================================================================
 % ========================================
% Equality and Sameness
% ========================================
predicates_declared_inline_HL(equal,2).
predicates_declared_inline_HL('~equal',2).
predicates_declared_inline_HL(resolve_skolem,2).
predicates_declared_inline_HL('different',2).
predicates_declared_inline_HL('~different',2).

% ==========================================
% Equal/Evaluate
% ==========================================

% Success based equals
equal(A,B,incode(equal(A,B))):-
	equal(A,B).
equal(A,B,Explaination):-
	ground((A,B)),
	deduceSurfaceGuarded(equal,true,equal(A,B),_,_,Explaination).

% Failure Based Equals
not_equal(A,B,incode(not(equal(A,B)))):-not(equal(A,B)).

equal(X,Y):-
	writeDebug(X=Y),
	equals_proc(X,Y),!,  % equal happens once
	writeDebug(found(X=Y)).

equal(X,Y):-unify_with_occurs_check(X,Y),!.

equals_proc(Var,NV):-var(Var),nonvar(NV),!,equals_var(NV,Var),!.

equals_proc(NV,Var):-var(Var),nonvar(NV),!,equals_var(NV,Var),!.

equals_proc(NV1,NV2):-!,equals_var(NV1,Var1),!,equals_var(NV2,Var2),!,Var1==Var2,!.


equals_var(X,Y):-not(compound(X)),!,unify_with_occurs_check(X,Y),!.
equals_var(X,Y):-eval_lr(X,Y).
equals_var('Fn'(F1, V1),Var):-!,eval_lr('Fn'(F1, V1),Var).

eval_lr(X,X):-number(X),!.
eval_lr(X,X):-not(compound(X)),!.


eval_lr('AdditionFn'(V1,V2),R):-
      eval_lr(V1,R1),
      eval_lr(V2,R2), 
      sandbox((R is R1 + R2)),!.

eval_lr('SubtractionFn'(V1,V2),R):-
      eval_lr(V1,R1),
      eval_lr(V2,R2),
      sandbox((R is R1 - R2)).

eval_lr('MultiplicationFn'(V1,V2),R):-
      eval_lr(V1,R1),
      eval_lr(V2,R2),
      sandbox((R is R1 * R2)),!.

eval_lr('DivisionFn'(V1,V2),R):-
      eval_lr(V1,R1),
      eval_lr(V2,R2),
      sandbox((R is R1 / R2)),!.

%eval_lr('QuantityConversionFn'('Percent', 'DivisionFn'(_G36802, 'MillionBarrelsPerDay'(69.86))),Result):-
eval_lr('QuantityConversionFn'('Percent', X),Result):-!,eval_lr('MultiplicationFn'(X,100),Result).

%goal(instance('MillionBarrelsPerDay'(69.86), 'FlowRate'))
eval_lr('MaxFn'(A,B),NumOut):-!,
		eval_lr(A,AO),
		eval_lr(B,BO),
		((catch(AO<BO,_fail),NumOut=A);NumOut=B),!.

eval_lr('MinFn'(A,B),NumOut):-!,
		eval_lr(A,AO),
		eval_lr(B,BO),
		((catch(AO>BO,_fail),NumOut=A);NumOut=B),!.

eval_lr('SignumFn'(A),NumOut):-!,
		eval_lr(A,AO),
		number(AO),
		once(((AO = 0,NumOut=0);(AO>0,NumOut=1);(AO<0,NumOut=(-1)))).

eval_lr('MagnitudeFn'('MeasureFn'(NumIn,_)),NumOut):-!,eval_lr(NumIn,NumOut).
eval_lr('MeasureFn'(NumIn,_),NumOut):-!,eval_lr(NumIn,NumOut).
eval_lr('Dollars'(NumIn),NumOut):-!,eval_lr(NumIn,NumOut).
eval_lr('BillionDollars'(NumIn),NumOut):-!,eval_lr(NumIn,Value),!,eval_lr_nvf('Fn'('MultiplicationFn',[100000,'Fn'('MultiplicationFn',[10000,Value])]),NumOut),!.
eval_lr('BarrelsPerDay'(Value),R):-!,eval_lr(Value,R),!.
eval_lr('MillionBarrelsPerDay'(Num),R):-!,eval_lr(Num,Value),!,eval_lr_nvf('Fn'('MultiplicationFn',[1000000,Value]),R),!.

eval_lr(X,Y):-sandbox((X=..[_,R],!,eval_lr(R,Y))),!.

eval_lr('Fn'(A,V),Z):-var(A),!,eval_lr_vf('Fn'(A,V),Z).
eval_lr('Fn'(Var,['Fn'(Var2,_)|_]),_):-  var(Var2),!, fail.  %TODO Algebra
eval_lr('Fn'(A,V),Z):-eval_lr_nvf('Fn'(A,V),Z).
eval_lr(X,Y):-unify_with_occurs_check(X,Y),!.
   


eval_lr_nvf(X,X):-(var(X)),!.
eval_lr_nvf(X,X):-(number(X)),!.

eval_lr_nvf('Fn'('YearFn',[Value]),Value):-!.

eval_lr_nvf('Fn'('QuantityConversionFn',['PercentFn',Value]),R):-!,eval_lr(Value,VR),!,eval_lr_nvf('Fn'('MultiplicationFn',[100,Value]),R).

eval_lr_nvf('Fn'('MeasureFn',[EXPR,Type]),'Fn'('MeasureFn',[R,Type])):-eval_lr(EXPR,R).

eval_lr_nvf('Fn'('AdditionFn',[BX,BY]),BZ):- eval_lr_nvf(BX,X),eval_lr_nvf(BY,Y),eval_lr_nvf(BZ,Z),(sandbox(plus(X,Y,Z));sandbox(Z is X+Y);sandbox(X is Z-Y);sandbox(Y is Z-X)),!.
eval_lr_nvf('Fn'('SubtractionFn',[BX,BY]),BZ):- eval_lr_nvf(BX,X),eval_lr_nvf(BY,Y),eval_lr_nvf(BZ,Z),(sandbox(plus(Z,X,Y));sandbox(Z is X-Y);sandbox(X is Z+Y);sandbox(Y is Z+X)),!.
eval_lr_nvf('Fn'('MultiplicationFn',[BX,BY]),BZ):- eval_lr_nvf(BX,X),eval_lr_nvf(BY,Y),eval_lr_nvf(BZ,Z),(sandbox(Z is X*Y);sandbox(X is Z/Y);sandbox(Y is Z/X)),!.
eval_lr_nvf('Fn'('DivisionFn',[BX,BY]),BZ):- eval_lr_nvf(BX,X),eval_lr_nvf(BY,Y),eval_lr_nvf(BZ,Z),(sandbox(Z is X/Y);sandbox(X is Z*Y);sandbox(Y is Z*X)),!.

eval_lr_nvf('Fn'('AssignmentFn',[OP|ARGS]),Z):- !,
                  'AssignmentFn'(OP,ARGS,Z),!.

eval_lr_nvf(X,Y):-unify_with_occurs_check(X,Y),!.

%eval_lr_nvf('Fn'(Op,X),Z):-eval_lr_list(X,RX),!,fun('Fn'(Op,RX),Method),eval_lr(Method,Z),!.

eval_lr_vf(X,Y):-unify_with_occurs_check(X,Y),!.

eval_lr_list([],[]).
eval_lr_list([H|T],[HO|TO]):-
            eval_lr(H,HO),!,
            eval_lr_list(T,TO),!.
   
fun('Fn'('PercentFn',[Value]),'Fn'('AssignmentFn',['DivisionFn',Value,100])).

fun(Have,Todo):-on_the_surface(equal(Have,Todo)).

on_the_surface(equal(Have,Todo)) :- mooCache(PredR,ASID,surface,(equal(X , Y)),Vars,Context,TN,On),unnumbervars((X,Y),(Have,Todo)),!.





fun('Fn'('AdditionFn',[X,Y]),'Fn'('AssignmentFn',['AdditionFn',X,Y])).
fun('Fn'('Plus',[X,Y]),'Fn'('AssignmentFn',['AdditionFn',X,Y])).
'AssignmentFn'('AdditionFn',[X,Y],Z):-sandbox(plus(X,Y,Z)).

fun('Fn'('MultiplicationFn',[X,Y]),'Fn'('AssignmentFn',['MultiplicationFn',X,Y])).
fun('Fn'('TimesFn',[X,Y]),'Fn'('AssignmentFn',['MultiplicationFn',X,Y])).
'AssignmentFn'('MultiplicationFn',[X,Y],Z):- nonvar(X),nonvar(Y),!,sandbox(Z is X*Y).
'AssignmentFn'('MultiplicationFn',[X,Y],Z):- var(X),nonvar(Y),nonvar(Z),!,sandbox(X is Z/Y).
'AssignmentFn'('MultiplicationFn',[X,Y],Z):- var(Y),nonvar(X),nonvar(Z),!,sandbox(Y is Z/X).

fun('Fn'('DivisionFn',[X,Y]),'Fn'('AssignmentFn',['DivisionFn',X,Y])).
fun('Fn'('QuotientFn',[X,Y]),'Fn'('AssignmentFn',['DivisionFn',X,Y])).
'AssignmentFn'('DivisionFn',[X,Y],Z):- sandbox(Z is X/Y).

fun('Fn'('DifferenceFn',[X,Y]),'Fn'('AssignmentFn',['SubtractionFn',X,Y])).
fun('Fn'('SubtractionFn',[X,Y]),'Fn'('AssignmentFn',['SubtractionFn',X,Y])).
'AssignmentFn'('SubtractionFn',[X,Y],Z):- sandbox(Z is X-Y),!.
'AssignmentFn'('SubtractionFn',[X,Y],Z):- sandbox(plus(Y,Z,X)).


/*
eval_lr('Fn'(if,[C,X,Y]),Z):-
        eval_lr(C,C1),
        auxif(C1,X,Y,A),
        eval_lr(A,Z),!.
*/
auxif(true,X,_,X).
auxif(false,_,X,X).


/*
eval_lr(F,Lx):-
        atom(F),
        fun('Fn'(F,X),Y),
        make_lambda(X,Y,Lx).
*/
make_lambda([],Y,Y).
make_lambda([X|Xs],Y,'Fn'('LambdaFn',[X,Z])):-make_lambda(Xs,Y,Z).

/*eval_lr('Fn'(Fx,[A]),Z):-
        eval_lr(Fx,Lx),
        eval_lr(A,A1),
        copy_term(Lx,'Fn'('LambdaFn',[A1,Y])),
        eval_lr(Y,Z),!.

eval_lr('Fn'(Fx,[A|As]),Z):-
        eval_lr(Fx,Lx),
        eval_lr(A,A1),
        copy_term(Lx,'Fn'('LambdaFn',[A1,Y])),
        eval_lr('Fn'(Y,As),Z),!.
  */

%eval_lr([X|Xs],[Y|Ys]):-eval_lr(X,Y),eval_lr(Xs,Ys),!.

%eval_lr((X,Xs),(Y,Ys)):-eval_lr(X,Y),eval_lr(Xs,Ys),!.





%eval_lr(X,Y):-compound(X),
 %              sandbox((X=..[FX|AX],eval_lr(AX,AY),YY=..[FX|AY],eval_lr(YY,Y))).

/*eval_lr(X,Y):-compound(X),!,
               sandbox((X=..[FX|AX],!,eval_lr(AX,Y))).
  */

% Function definitions:

/*
fun('Fn'(inc,[X]),'Fn'('AssignmentFn',['AdditionFn',X,1])).
'AssignmentFn'(inc,X,1,Z):- Z is X +1.
*/





/*
fun('Fn'(lessThan,[X,Y]),'Fn'('AssignmentFn',[lessThan,X,Y])).
'AssignmentFn'(lessThan,X,Y,Z):-sandbox((X<Y,Z=true;Z=false)).

fun('Fn'(lessThanOrEqualTo,[X,Y]),'Fn'('AssignmentFn',[lessThanOrEqualTo,X,Y])).
'AssignmentFn'(lessThanOrEqualTo,X,Y,Z):-sandbox((X=<Y,Z=true;Z=false)).

fun('Fn'(greaterThan,[X,Y]),'Fn'('AssignmentFn',[greaterThan,X,Y])).
'AssignmentFn'(greaterThan,X,Y,Z):-sandbox((X>Y,Z=true;Z=false)).

fun('Fn'(greaterThanOrEqualTo,[X,Y]),'Fn'('AssignmentFn',[greaterThanOrEqualTo,X,Y])).
'AssignmentFn'(greaterThanOrEqualTo,X,Y,Z):-sandbox((X>=Y,Z=true;Z=false)).
*/
/*

fun('Fn'(and,[X,Y]),'Fn'('AssignmentFn',[and,X,Y])).
'AssignmentFn'(and,X,Y,Z):-sandbox((byrd_solve(X),byrd_solve(Y),Z=true;Z=false)).

fun('Fn'(exists,[X,Y]),'Fn'('AssignmentFn',[exists,X,Y])).
'AssignmentFn'(exists,X,Y,Z):-sandbox((holds(X,byrd_solve(Y)),Z)).

fun('Fn'(pred,[X]),'Fn'('AssignmentFn',[pred,X,Y])).
'AssignmentFn'(pred,X,Y):-sandbox((Y=pred(X);Y=false)).

fun('Fn'(equal,[X,Y]),'Fn'('AssignmentFn',[equal,X,Y])).
'AssignmentFn'(equal,X,Y,true):-!,equal(X,Y),!.
'AssignmentFn'(equal,_,_,false):-!.
*/




%fun('Fn'('logic-<=>',[A,B]),'Fn'('AssignmentFn',['logic-<=>',A,B])).
%'AssignmentFn'('logic-<=>',A,B,true):-getNegationForm(AA,A),getNegationForm(BB,B),A=B.
   /*
fun('Fn'(hd,[[X|_]],X)).

fun('Fn'(tl,[[_|T]]),T).

fun('Fn'(map,[F,L]),
                        'Fn'(if,[    'Fn'(equal,[L,[]]),
                                [],
                                ['Fn'(F,['Fn'(hd,[L])])|'Fn'(map,[F,'Fn'(tl,[L])]) ]
                        ] )
).


fun('Fn'(concatenate,[X,Y]),
                                'Fn'(if,[    'Fn'(equal,[X,[]]),
                                        Y,
                                        ['Fn'(hd,[X])|'Fn'(concatenate,['Fn'(tl,[X]),Y])]
                                ])
).

fun('Fn'(factorial,[N]),
        'Fn'(if,[    'Fn'(equal,[N,1]),
                1,
                'Fn'('MultiplicationFn',[N,'Fn'(factorial,['Fn'('SubtractionFn',[N,1])])])
        ])
).
      */



% ========================================
% Logical Equivalency
% ========================================
predicates_declared_inline_HL('logic-<=>',2).
predicates_declared_inline_HL('~logic-<=>',2).

'logic-<=>'(A,B):-getNegationForm(A,AA),!,getNegationForm(B,BB),!,unify_with_occurs_check(AA,BB).
'~logic-<=>'(A,B):-!,not('logic-<=>'(A,B)).

predicates_declared_inline_HL('domain-check',3).
'domain-check'(_,_,_).

% ========================================
% Skolem Unification
% ========================================
%:-multifile(equal/2).


:-dynamic(startsAfterEndingOf/2).
:-dynamic(laterThan/2).

% ========================================
% Greater/Less Than 
% ========================================

predicates_declared_inline_HL('greaterThan',2).
predicates_declared_inline_HL('~greaterThan',2).

predicates_declared_inline_HL('lessThan',2).
predicates_declared_inline_HL('~lessThan',2).

predicates_declared_inline_HL('greaterThanOrEqualTo',2).
predicates_declared_inline_HL('~greaterThanOrEqualTo',2).

predicates_declared_inline_HL('lessThanOrEqualTo',2).
predicates_declared_inline_HL('~lessThanOrEqualTo',2).

lessThan(X,Y):-greaterThan(Y,X),!.

lessThanOrEqualTo(X,Y):-!,greaterThanOrEqualTo(Y,X),!.

greaterThan(X,Y):-not((atom(X);atom(Y))),(ground((X,Y)),!,eval_lr(X,RX),!,eval_lr(Y,RY),!,sandbox(RX > RY)),!.

greaterThanOrEqualTo(X,Y):-(ground((X,Y)),not((atom(X);atom(Y))),!,eval_lr(X,RX),!,eval_lr(Y,RY),!,sandbox(RX >= RY)),!.

'~lessThan'(X,Y):-'~greaterThan'(Y,X).

'~lessThanOrEqualTo'(X,Y):-'~greaterThanOrEqualTo'(Y,X).

'~greaterThan'(X,Y):-!,not(greaterThan(X,Y)),!.
'~greaterThanOrEqualTo'(X,Y):-not(greaterThanOrEqualTo(X,Y)),!.

% Handbox is like Sandbox but makes sure turms are evaluatable
handbox(X):-catch(handbox1(X),_,fail).
handbox1(X > Y):-!,RX is X, RY is Y,RX > RY.
handbox1(X >= Y):- RX is X, RY is Y,RX >= RY.


% TODO Properly implement



:-arithmetic_function('BillionDollars'/1).
:-arithmetic_function('BillionDollars'/2).
:-arithmetic_function('Fn'/2).

'Fn'(F,A,R):-catch(eval_lr('Fn'(F,A),R),_,fail).


%% :-include('moo_header.pl').


/*
predicates_declared_inline_HL('subAttibute',2).
predicates_declared_inline_HL('~subAttibute',2).

predicates_declared_inline_HL('attribute',2).
predicates_declared_inline_HL('~attribute',2).

predicates_declared_inline_HL('subset',2).
predicates_declared_inline_HL('~subset',2).

predicates_declared_inline_HL('element',2).
predicates_declared_inline_HL('~element',2).
*/
:-dynamic('instance'/2).
:-multifile('~instance'/2).

/*
predicates_declared_inline_HL('instance',2).
predicates_declared_inline_HL('~instance',2).
*/

/*'instance'(X,Y):-is_instance_of(X,Y).

'~instance'(X,Y):-is_instance_of(X,Y),!,fail.
'~instance'(X,Y):-isNonVar(Y),!.

predicates_declared_inline_HL('t_instance',2).
predicates_declared_inline_HL('~t_instance',2).
  */


predicates_declared_inline_HL('~u',3).
predicates_declared_inline_HL('u',3).
%u(A,B,'Quantity'):-'equal'(X,Y).


%u(_,_,'Skolem'):-!,fail.
u('zzskFn'(A),B,'Skolem'):-nonvar(A),!,unify_with_occurs_check(A,B),!.


u(A,B,_):-!,A==B.

u(A,B,_):-!,unify_with_occurs_check(A,B),!.
%u(A,B,_):-catch(unify_with_occurs_check(A,B),E,fail),!.
%u(A,B,_):-mooCache(PredR,surface,'equal'(A,B):L,Context,TN,Maintainer,On).

predicates_declared_inline_HL('resolve_skolem',2).

:-dynamic('subclass'/2).
:-multifile('~subclass'/2).

/*
predicates_declared_inline_HL('subclass',2).
predicates_declared_inline_HL('~subclass',2).
predicates_declared_inline_HL('subrelation',2).
predicates_declared_inline_HL('~subrelation',2).
predicates_declared_inline_HL('inverse',2).
predicates_declared_inline_HL('~inverse',2).
predicates_declared_inline_HL('disjoint',2).
predicates_declared_inline_HL('~disjoint',2).
predicates_declared_inline_HL('range',2).
predicates_declared_inline_HL('~range',2).
predicates_declared_inline_HL('documentation',2).
predicates_declared_inline_HL('~documentation',2).
*/


'subclass'(X,Y):-is_subclass_of(X,Y).

'~subclass'(X,Y):-is_subclass_of(X,Y),!,fail.
'~subclass'(X,Y):-isNonVar(Y),!.

:-dynamic('domain'/2).
:-multifile('~domain'/2).

/*
predicates_declared_inline_HL('domain',3).
predicates_declared_inline_HL('~domain',3).
predicates_declared_inline_HL('domainSubclass',3).
predicates_declared_inline_HL('~domainSubclass',3).
*/
/*
'domain'(X,Y,Z):-is_nth_domain_of(X,Y,Z).

'~domain'(X,Y,Z):-is_nth_domain_of(X,Y),!,fail.
'~domain'(X,Y,Z):-isNonVar(Y),!.

'domainSubclass'(X,Y,Z):-is_nth_domain_of(X,Y,Z).

'~domainSubclass'(X,Y,Z):-is_nth_domain_of(X,Y),!,fail.
'~domainSubclass'(X,Y,Z):-isNonVar(Y),!.

% Impliements  deduce-same

% u/3 is the identity predicate it recognises 17 major classes and selects the correct belief mechanism for each type of unification
% based on the the_hash_set(
% ['Collection','Representation','Formula','Region','Process','Object','Attribute','FunctionQuantity','Function','Relation','Quantity','Proposition','Set','Class','Physical','Abstract', 'Entity']).



	      */
	


/*
% =====================================================================================
% UNIFICATION
% =====================================================================================
ideduce_cache(true,Depth,Table,u(A,B,Class),Agent,Explaination):-writeDebug(u(A,B,Class)),
		deduce_cache_u(Table,A,B,Class,Agent,Explaination).
		

deduce_cache_u(Table,A,B,Class,Agent,Explaination):-Class=='Class',!,fail.
deduce_cache_u(Table,U,W,'Skolem',Agent,U):-!,unify_with_occurs_check(U,W),!.
deduce_cache_u(Table,U,W,_,Agent,U):-!,unify_with_occurs_check(U,W).

%deduce_cache_u(Table,A,B,Class,Agent,Explaination):-var(A),!,deduce_cache_u_var(Table,A,B,Class,Agent,Explaination).
%deduce_cache_u(Table,A,B,Class,Agent,Explaination):-atomic(A),!,deduce_cache_u_atom(Table,A,B,Class,Agent,Explaination).
%deduce_cache_u(Table,A,B,Class,Agent,Explaination):-atomic(B),!,deduce_cache_u_compound_atom(Table,B,A,Class,Agent,Explaination).
%deduce_cache_u(Table,A,B,Class,Agent,Explaination):-deduce_cache_u_compound_compound(Table,B,A,Class,Agent,Explaination).

deduce_cache_u_atom(Table,Class,B,Odd,Agent,Explaination):-isa_class(Class),!,fail.
deduce_cache_u_atom(Table,A,B,Class,Agent,Explaination):-atomic(B),!,deduce_cache_u_atom_atom(Table,A,B,Class,Agent,Explaination).
deduce_cache_u_atom(Table,A,B,Class,Agent,Explaination):-deduce_cache_u_atom_compound(Table,A,B,Class,Agent,Explaination).

%TODO Reduce if Possible
deduce_cache_u_var(Table,A,B,Class,Agent,instance(B,Class)):-unify_with_occurs_check(A,B),!.

deduce_cache_u_atom_atom(Table,A,A,Class,Agent,instance(A,Class)).

%Analogy TODO
deduce_cache_u_atom_compound(Table,A,B,Class,Agent,P):-!,equal(B,A,P).

deduce_cache_u_compound_atom(Table,A,B,Class,Agent,P):-!,equal(A,B,P).


% More Analogy
deduce_cache_u_compound_compound(Table,A,B,Class,Agent,instance(A,Class)):-unify_with_occurs_check(A,B),!.
deduce_cache_u_compound_compound(Table,A,B,Class,Agent,Explaination):-A=..[PA|AL],B=..[BA|BL],!,deduce_cache_u_compound_compound(Table,A,PA,AL,B,PB,BL,Class,Agent,Explaination).

deduce_cache_u_compound_compound(Table,A,'E',[SK|LA],B,'E',[SK|LB],Class,Agent,Explaination):-!,deduce_cache_u_same_skolems(Table,A,B,SK,LA,LB,Class,Agent,Explaination).
deduce_cache_u_compound_compound(Table,A,'E',[AL|LA],B,'E',[BL|LB],Class,Agent,Explaination):-!,fail,deduce_cache_u_diff_skolems(Table,A,AL,LA,B,BL,LB,Class,Agent,Explaination).

deduce_cache_u_same_skolems(Table,A,B,SK,LA,LB,Class,Agent,and(instance('E'(SK, B),Class),nearIdent('E'(SK, B),A,P1,P2))):-
		writeDebug(deskolemize(u(A, B, Class))),
		mooCache(PredR,(u(A, 'E'(SK, B), Class)),Agent,ANTE,P1),
		writeDebug(deskolemize_rule(ANTE)),
		Depth2 is Depth-1,

		deduce_backchain(true,Depth2,Table,ANTE,Agent,P2).


ideduce_cache(true,Depth,Table,'~u'(U,W,'Skolem'),Agent,deduced):-!,not((unify_with_occurs_check(U,W))),!.
ideduce_cache(true,Depth,Table,'~u'(U,W,FS),Agent,deduced):-not(unify_with_occurs_check(U,W)),!.
ideduce_cache(true,Depth,Table,'~u'(A,B,Class),Agent,sfind(instance(B,Class))):-!,not(unify_with_occurs_check(A,B)).

*/
								       


:-dynamic(known_property_value(Property,Value)). % like known_property_value(size,big)
:-dynamic(known_proper_noun(ProperNoun,LogicalThing)). %like known_proper_noun('Superman','TheManOfSteel')
:-dynamic(known_noun(Word,PlurSing)). %like known_noun(apple,snglr)
:-dynamic(known_verb_to_predicate(Verb,Tense,SingPlur,LogicalPredicate)). %like known_verb_to_predicate(kissed,past,snglr,kiss)
:-dynamic(known_request_word(WhWhat,LogicalWhWhat)). %known_request_word(how,methodUsed)
:-dynamic(known_copula(IS_BE,PlurSing)).
:-dynamic(known_class(EnglishCol,Tense,LogicalClass)).
:-dynamic(known_determiner(Tense,LogicalQuant,Quantifier)).
:-dynamic(known_verb_frame(Verb,Tense,SingPlur,Frame_with_Subj_and_Obj,Subj,Obj)).

%:-module(moo_english,[]).

% :-include('moo_header.pl').


%:-use_module(library(lists)).
lfl(A):-any_to_words(A,X),phrase(sentence(P), X),post(P).
/*

%---------------------------------------------------------------
% Test data
%---------------------------------------------------------------
expr(Z) --> term(X), "+", expr(Y), {Z is X + Y}.
expr(Z) --> term(X), "-", expr(Y), {Z is X - Y}.
expr(X) --> term(X).

term(Z) --> number(X), "*", term(Y), {Z is X * Y}.
term(Z) --> number(X), "/", term(Y), {Z is X / Y}.
term(Z) --> number(Z).

number(C) --> "+", number(C).
number(C) --> "-", number(X), {C is -X}.
number(X) --> [C], {"0"=<C, C=<"9", X is C - "0"}.


imp --> [vp].
decl --> [np, vp].
decl --> [np, vp, pp].
decl --> [pp, np, vp].
decl --> [set].


np --> [set].
np --> [set, pp].

set --> [object].
set --> [object, object].
set --> [object, object, object].
set --> [object, object, object, object].

object --> [pn].
object --> [spec, noun ].
object --> [noun].

spec --> [det].
spec --> [adj].
spec --> [adj_sat].
spec --> [num].
spec --> [spec, spec].

vp  --> [iv].
vp  --> [tv, np].
vp  --> [tv, np, pp].
vp  --> [dv, np, pp].
vp  --> [adv, vp].
pp  --> [p, np].
*/

%list_to_terms([],true):-!.
/*list_to_terms([T1,T2,T3,T4,T5,T6],((T1,T2,T3,T4,T5,T6)) ).
list_to_terms([T1,T2,T3,T4,T5], ((T1,T2,T3,T4,T5)) ).
list_to_terms([T1,T2,T3,T4], ((T1,T2,T3,T4)) ).
list_to_terms([T1,T2,T3], ((T1,T2,T3)) ).

list_to_terms([T1,T2|T3L],T):-nonvar(T),T=( (T1,T2),T3 ),!,list_to_terms(T3L,T3).
list_to_terms([T1|T2T3L],T):-nonvar(T),T=( T1,(T2,T3) ),!,list_to_terms(T2T3L,(T2,T3)).
list_to_terms([T1],T1):-!.
list_to_terms([T1|L],(T1,TL) ):-list_to_terms(L,TL).
 */

list_to_terms(List,(A,B)):-list_to_terms(A,AL),list_to_terms(B,BL),append(AL,BL,List).
list_to_terms(List,(A;B)):-list_to_terms(A,AL),list_to_terms(B,BL),append(AL,[or|BL],List).

:-multifile(s/3).
:-multifile(vp/4).
:-multifile(vg/5).
:-multifile(pp/3).
/*
sent --> s(gap(0)).
sent --> np(gap(0)), s(gap(np)).
s(Gap) --> np(gap(0)), vp(Gap).
np(gap(0)) --> pn.
np(gap(0)) --> det, noun.
np(Gap) --> det, noun, pp(Gap).
np(gap(np)) --> [].
pp(Gap) --> p, np(Gap).
vp(gap(0)) --> iv.
vp(Gap) --> tv, np(Gap).
vp(Gap) --> datv, np(Gap), pp(gap(0)).
vp(Gap) --> datv, np(gap(0)), pp(Gap).

det --> [Det], {lex(Det,det)}.
p --> [P], {lex(P,p)}.
noun --> [N], {lex(N,noun)}.
verb --> [V], {lex(V,v)}.
pn --> [PN], {lex(PN,pn)}.
tv --> [TV], {lex(TV,tv)}.
datv --> [DV], {lex(DV,dv)}.
iv --> [IV],{lex(IV,iv)}.

wrap(A):-any_to_words(A,X),phrase(sentence(P),X),loglang(P).


lex(kim,np).
lex(sandy,np).
lex(lee,np).
lex(baby,noun).
lex(man,noun).
lex(woman,noun).
lex(telescope,noun).
lex(park,noun).
lex(a,det).
lex(the,det).
lex(to,p).
lex(with,p).
lex(in,p).
lex(died,iv).
lex(ate,tv).
lex(ate,tv).
lex(saw,tv).
lex(gave,tv).
lex(gave,dv).
lex(handed,dv).
lex(Word,noun):-w_n([Word],_).
lex(Word,adj):-w_a([Word],_).
lex(Word,adj_sat):-w_as([Word],_).
lex(Word,adv):-w_av([Word],_).
lex(Word,VT):-member(VT,[iv,tv,dv]),w_v([Word],_).
% Students visited the town. 

s(at(NP,VP))  -->  np(Num, NP), vp(Num, VP). 

%Noun Phrase 
% this student, a beer, the town 
np(Num, np(Det, N))  -->  detp(Num, Det), ng(Num,_, N). 
% students, beers, towns(plural countable) 
np(pl, np( N))  -->  ng(pl,c, N). 
% linguistics, money, meat (singular non-countable) 
np(sg, np( N))  -->  ng(sg,nc, N). 
% a cold beer 
% the students of Tartu 
np(Num, np(Det, N, PP))  -->  detp(Num, Det), ng(Num,_, N), pp(PP). 
% he, they 
np(Num, np(PersPron))  -->  pers_pron(Num, PersPron). 
% (he saw) her reading 
np(Num, np(Det, N, V))  -->  detp(Num, Det), noun(Num, _, N), verb(_, _, part1, V). 

% Noun Group 
% student, beer, town 
ng(Num,C, ng(N))  -->  noun(Num, C, N). 
% linguistics student, beer town 
ng(Num,C, ng(N1, N2))  -->  noun(_, _, N1), noun(Num, C, N2). 

%Determiner Phrase 
% a, the, this 
detp(Num, detp(Det))  -->  det(Num,Det). 
% my, his 
detp(Num, detp(Pron))  -->  poss_pron(Num,Pron). 
% one, two, four 
detp(Num, detp(NDet)) -->  num_det(Num,NDet). 
% those four 
detp(Num, detp(Det, NDet))  --> det(Num, Det), num_det(Num, NDet). 
% all the 
detg(Num, detg(QDet, Det))  -->  quant_det(QDet), det(Num, Det). 

% Verb Phrase 
% goes, were, is sleeping 
vp(Num, vp(V))  --> vg(Num, _, V). 
% give a book 
vp(Num, vp(V, NP)) --> vg(Num, _, V), np(_, NP). 
% give the book to the teacher 
p(Num, vp(V, NP, PP))  -->  vg(Num, _, V), np(_, NP), pp(PP). 
% give her a book for birthday 
vp(Num, vp(V, NP1, NP2, PP)) -->  vg(Num, _, V), np(_, NP1), np(_, NP2), pp(PP). 
% give her a book for birthday on Monday 
vp(Num, vp(V, NP, PP1, PP2))  --> vg(Num, _, V), np(_, NP), pp(PP1), pp(PP2). 

%Verb Group 
% visits, bought, go 
vg(Num, _, vg(V))  --> verb(Num, _, fin, V). 

% Auxiliary Phrase 
% is visiting, were bought 
vg(Num, _, vg(Auxgr, V)) --> auxgr(Num, Pers, _, _, NextForm, Auxgr), verb( Num, Pers, NextForm, V). 
% will be visited 
auxgr(Num, Pers, Form, Preced, EndForm, Str) --> aux(Num, Pers, Form, EndForm, Preced, Aux), { Str =.. [auxgr, Aux] }. 
% could have been visited 
auxgr(Num, Pers, Form, Preced, EndForm, Str) --> aux(Num, Pers, Form, NextForm, Preced, Aux), auxgr(_, _, NextForm, NextPreced, EndForm, Auxgr), { Preced < NextPreced, Str =.. [auxgr, Aux, Auxgr] }. 

% Predicative Phrase 
% (he) is a student 
vg(Num, _, vg(V, COP_NP)) -->  verb(Num, _, cop, V), cop_np(COP_NP). 
% (he) is ready to go 
vg(Num, _, vg(V, PRP))  -->  verb(Num, _, cop, V), prp(PRP). 
% (he) is student 
cop_np(np(N)) --> noun(sg, _,N). 
% (he) is an interesting teacher 
cop_np(cop_np(NP))  -->  np(_, NP). 
% (beer) is cold 
prp(A)  --> adj(A). 
% (he) is interesting 
prp(A) --> adjv(A). 

% Prepositional Phrase 
% to the mountains 
pp(pp(P, NP))  -->  prep(P), np(_, NP).  

% Adjective Phrase 
% ready to go 
adjv(adjv(A,InfMark,V)) -->  adj(A), inf_mark(InfMark), verb(_, _, base, V). 

adj --> [A], {w_a([A],_);w_as([A],_)}.

% imparitive(P) --> verb_phrase(X, P1).
:-op(100,fx,+).

s(s(NP,VP))-->np(NP,VP).
np(np(Det,Noun))-->det(Det),noun(Noun).
vp(vp(Verb,NP))-->verb(Verb),np(NP).
det(det(each))-->[each].
det(det(a))-->[a].
noun(noun(man))-->[man].
noun(noun(woman))-->[woman].
verb(verb(loves))-->[loves].

sentence(P) --> noun_phrase(X, P1, P), verb_phrase(X, P1).


noun_phrase(X, P2, P) -->
	determiner(X, P2, P1, P),
	adjective(X, P3, P2, P1), 
	noun(X, P4), 
	rel_clause(X, P4, P3).

noun_phrase(X, P1, P) -->
        adjective(X, P2, P1, P), 
	noun(X, P3), 
	rel_clause(X, P3, P2).

noun_phrase(X, P1, P) -->
        determiner(X, P2, P1, P), noun(X, P3), rel_clause(X, P3, P2).
noun_phrase(X, P, P) --> name(X).

verb_phrase(X, P) --> trans_verb(X, Y, P1), noun_phrase(Y, P1, P).
verb_phrase(X, P) --> intrans_verb(X, P).

rel_clause(X, P1, P1&P2) --> [that], verb_phrase(X, P2).
rel_clause(_, P, P) --> [].

adjective(X,P1, P2, ATTRIB:(P1=>P2))--> [ADJ], 
	{att(ATTRIB,ADJ,X)}.

att(attrib(blue,X),blue,X):-!.
att(attrib(ADJ,X),ADJ,X):-w_a([ADJ],_).


determiner(X, P1, P2, all_known(X):(P1=>P2) ) --> [Y], 
	{ member(Y,[all,every])}.

determiner(X, P1, P2, do_exists(X):(P1&P2) ) --> [a].
determiner(X, P1, P2, do_exists(X):(P1&P2) ) --> [an].
determiner(X, P1, P2, do_exists(X):(P1&P2) ) --> [the].

determiner(X, P1, P2, some_of(X):(P1&P2) ) --> [some].
determiner(X, P1, P2, some_of(X):(P1&P2) ) --> [many].
determiner(X, P1, P2, some_of(X):(P1&P2) ) --> [most].
determiner(X, P1, P2, some_of(X):(P1&P2) ) --> [].

noun(X, man(X) ) --> [man].
noun(X, woman(X) ) --> [woman].
noun(X, Test ) --> [Y], {Test =.. [Y,X], w_n([Y],_)}.

name(john) --> [john].

trans_verb(X, Y, loves(X,Y) ) --> [loves].
trans_verb(X, Y, TV) --> [V], {TV=..[V,X,Y],w_v([V],_)}.
intrans_verb(X, lives(X) ) --> [lives].
intrans_verb(X, ITV ) --> [V], {ITV=..[V,X],w_v([V],_)}.

*/

to_surface(CHARS,Formula):-
         sentenceToList(CHARS,S),
         sentence(G,S,[]),!,tologic(G,F), 
         fixExistentials(F,SKIF),!,
         getMooTermFromSurface(SKIF,Formula).


known_verb_to_predicate(LogicalPredicate,present,SingPlur,LogicalPredicate):-nonvar(LogicalPredicate),quick_search('Q'(LogicalPredicate,_,_)).
known_class(LogicalClass,sngular,LogicalClass):-nonvar(LogicalClass),quick_search('instance'(LogicalClass,'Class')).

quick_search(Goal):-!,fail.

quick_search(Goal):-
%         add_explaination_recording_args(Goal,ExplainationIn,ExplainationO,Goal2),
         add_complete_search_args(Goal,2,DepthOut,Goal3),
         add_explaination_recording_args(Goal3,ExplainationIn,ExplainationO,Goal4),
        !, Goal4,!.

% ==========================================
% BELIEF
% ==========================================

:-dynamic(complete_goal/1).

:-multifile(expireOptimizationsInContext/3).

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).


%end_of_file.




% ===================================================================
% File 'moo_api.pl'
% Maintainer: Douglas Miles
% Contact: dmiles@users.sourceforge.net ;
% Version: 'moo_api.pl' 1.0.0
% Revision:             $Revision: 1.1 $
% Revised At:   $Date: 2002-11-16 04:41:12 $

% ===================================================================
% PURPOSE
% ===================================================================
% This file meets the needs of an external agent working for the needs of eigther an automated or human user
% Interfacea with Java with XML to display explaination trees and variable bindings
% It defines the default settings most users will use and gives a starting expected state.
% Ask a Context, tell to a Context, retract from a Context, consult the user (this function is currently treated by ua_command/2, but it is planned to separate it),
% Report status to Moo, initialization of the LE, and file-handling routines
% ===================================================================

% ===================================================================
% EXPORTS   (Called  only by XSB Java server beans)
% ===================================================================
/*
:-module(moo_api,
            [
	    processRequest/1
/*
            ua_ask/3,        % handles user invoked request
            uaInsert/4,         % handles user invoked assertions
            ua_retract/4,    % handles user invoked retractions
            ua_command/2, %allows user to define new terms, and handles consultation with user

            define_theory/1,  %selects user's choice of a theory to load
            rename_theory/1,  %allows server to rename a theory
            reconstitute_theory/1,  %allows server to redefine the location of a theory
            delete_theory/1,  %allows server to delete a theory from the IE

            establish_status/1,
            establish_status/2,  %loads and unloads theorys, reports status to server,

            verify_status/1,
            verify_status/2,  %only reports status of theorys,

            server_startup_status/1,  %presets multiple theorys to be loaded at startup of IE,
            theory_startup_status/1,  %presets a single theory to be loaded at startup of IE,

            ua_read/2 % -- (to be dropped) loads a single theory
	    */
            ]).
     */

% :-include('moo_header.pl').

% ===================================================================
% Other major predicates:
% agentConsultation/3 (called by writeIfOption in moo_response.P, also by writeUAEvent, and by command_proc/3, by any predicate marked for consultation)
% ===================================================================

% ===================================================================
% DEBUG PREDICATES
% ===================================================================

fme2:-ua_ask("(?P2 ?A1 ?2)", 'GlobalContext', [opt_theory='PrologMOOAddition',disp_debug=true,disp_note_user=true,disp_notes_nonuser=true]).
fme3:-ua_ask("(?P3 ?A1 ?A2 ?A3)", 'GlobalContext', [opt_theory='PrologMOOAddition',disp_debug=true,disp_note_user=true,disp_notes_nonuser=true]).
gme2:-ua_ask("(genls ?X ?Y)").

% ===================================================================
% IMPORTS
% ===================================================================


% Stored persistantly as  theory_make_status_start(theory(Name,CanFileLocal)=StartupStatus)  in moo_persist.wfs


% ===================================================================
%  BOOTUP MOO SERVER
% ===================================================================

% This Function when called from outside does the Embeding the Logic Engine into the XSB Server
initializeMooServerData :-!,
     % findall(L,library_directory(L),Library_directory),
      sendNote(user,logicEngine,'Initializing and Embedding Moo Logic Engine',['architecture=',Architecture,Host_cpu,Version,Release_date,Scheduling_strategy]),
      establish_startup_state,
      sendNote(debug,logicEngine,'Contexts are now loaded by contentManager',' '),
      ensureMooContext('MooKernel','GlobalContext'),!.

%% :-include('moo_header.pl').

% ===========================================================
% CONVERSE WITH JAVA
% ===========================================================

processRequest(OptionsIn):-
                logOnFailure(fixOptionsFromForeign(OptionsIn,Options)),
                logOnFailure(setMooOption(Options)),
                ensureMooOption(client,html,ResponseType),
                logOnFailure(invokeRequest(Options)),!.


fixOptionsFromForeign([],[]):-!.

fixOptionsFromForeign([context=Value|List],[opt_ctx_assert=Value,opt_ctx_request=Value|ARGS]):-     %TODO Sepatate Context/Ctx
          fixOptionsFromForeign(List,ARGS).
fixOptionsFromForeign([ctx=Value|List],[opt_ctx_assert=Value,opt_ctx_request=Value|ARGS]):-     %TODO Sepatate Context/Ctx
          fixOptionsFromForeign(List,ARGS).
fixOptionsFromForeign([sf=AValue|List],[sf=AValue|ARGS]):-atom(AValue),!,
          logOnFailure(fixOptionsFromForeign(List,ARGS)).
fixOptionsFromForeign([sf=String|List],[sf=AValueClean|ARGS]):-is_list(String),
          logOnFailure(string_to_atom(String,AValueClean)),!,
          logOnFailure(fixOptionsFromForeign(List,ARGS)).
fixOptionsFromForeign([From=AValue|List],[To=DValue|ARGS]):-
          transform_option(From,To),!,
          logOnFailure(decodeRequestAtom(AValue,DValue)),
          fixOptionsFromForeign(List,ARGS).
fixOptionsFromForeign([AName=AValue|List],[DName=DValue|ARGS]):-
          logOnFailure(decodeRequestAtom(AName,DName)),
          logOnFailure(decodeRequestAtom(AValue,DValue)),
          logOnFailure(fixOptionsFromForeign(List,ARGS)).
fixOptionsFromForeign([AName|List],[DName|ARGS]):-
          decodeRequestAtom(AName,DName),
          logOnFailure(fixOptionsFromForeign(List,ARGS)).

% transform_option(From,To)
transform_option(author,user).
transform_option(theory,opt_theory).
transform_option(language,interp).
transform_option(timeLimit,opt_timeout).
transform_option(bindingLimit,opt_answers_max).
transform_option(depthLimit,opt_backchains_max).


invokeRequest(Options):-memberchk(cmd='Halt LE',Options),halt.
invokeRequest(Options):-memberchk(cmd='Rebuild',Options),write('Rebuilding Moo').


%invokeRequest(Options):-memberchk(command=html,Options),!,

invokeRequest(Options):-memberchk(client=soap,Options),!,
        parse_moo_soap(Options).

invokeRequest(Options):-memberchk(client=moo_xml,Options),!,
        parse_moo_soap(Options).

% ===========================================================
% Surface Returns External TN
% ===========================================================
invokeRequest(Options):-
   %attach_console,trace,
      memberchk(submit=tn_find,Options),!,
        ensureMooOption(opt_ctx_assert,'GlobalContext',Ctx),
        ensureMooOption(opt_theory,'PrologMOO',Context),
        ensureMooOption(client,'java',CLIENT),
        ensureMooOption(sf,surf,Assertion),
        atom_codes(Assertion,Assertion_Chars),
        ensureMooOption(user,'Web',User),
         logOnFailure(getCleanCharsWhitespaceProper(Assertion_Chars,Show)),!,
         logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
         logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
         write_out_kif_tn(Assertion_Chars,NEWFORM,Vars,Ctx,Context,Maintainer),!.

write_out_kif_tn(Assertion_Chars,computed(comment(_)),Vars,Ctx,Context,Maintainer):-
         writeFmt('Syntax Error: Unmatched parentheses in "~s"\n',[Assertion_Chars]).
write_out_kif_tn(Assertion_Chars,comment(_),Vars,Ctx,Context,Maintainer):-
         writeFmt('Syntax Error: Unmatched parentheses in  "~s"\n',[Assertion_Chars]).
write_out_kif_tn(Assertion_Chars,NEWFORM,Vars,Ctx,Context,Maintainer):-
        copy_term((NEWFORM),(CNF)),
        numbervars(CNF,'$VAR',0,_),
        mooCache(PredR,surface,CNF, _, Context, TN, Maintainer, O),
        mooCache(PredR,surface,OF, _, Context, TN, Maintainer, O),
        numbervars(OF,'$VAR',0,_),
        OF == CNF,!,
        writeFmt('~w\n',[TN]),!.
write_out_kif_tn(Assertion_Chars,NEWFORM,Vars,Ctx,Context,Maintainer):-
         writeFmt('Not found in ~w of ~w "~s"\n',[Ctx,Context,Assertion_Chars]).

% ===========================================================
% Detroys an External TN
% ===========================================================
invokeRequest(Options):-memberchk(submit=tn_delete,Options),!,
        ensureMooOption(opt_ctx_assert,'GlobalContext',Ctx),
        ensureMooOption(opt_theory,'PrologMOO',Context),
        ensureMooOption(client,'java',CLIENT),
        ensureMooOption(tn,0,TN),
        ensureMooOption(sf,surf,Assertion),
        atom_codes(Assertion,Assertion_Chars),
        ensureMooOption(user,'Web',User),
        destroyTN(Context,TN,Ctx),
        saveMooCache.

destroyTN(Context,TN,Ctx):-
        retractall(mooCache(Literal,_,Context,TN)),  %Facts
        retractall(mooCache(Literal,AnteLiteral,_,Context,TN)),   %Rules
        retractall(mooCache(Surface,CLF,Flags,Vars,Context,TN,Maintainer,TMResult)).

destroyContext(Context):-
        retractall(mooCache(Context,_)),
        retractall(mooCache(Context,_,_)),
        retractall(mooCache(Context,_,_,_)),
        retractall(mooCache(Literal,_,Context,TN)),  %Facts
        retractall(mooCache(Literal,AnteLiteral,_,Context,TN)),   %Rules
        retractall(mooCache(Surface,CLF,Flags,Vars,Context,TN,Maintainer,TMResult)),
        saveMooCache.

% ===========================================================
% Shows whats known about an External TN
% ===========================================================
invokeRequest(Options):-memberchk(submit=tn_show,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(client='java',CLIENT),
        ensureMooOption(tn=0,TN),
        ensureMooOption(sf=surf,Assertion),
        writeKnownFormsTN(_,Context:TN).

writeKnownFormsTN(Ctx,Context:Word):-(atom(Word)),!,
        writeKnownFormsAboutTerm(Ctx,Context:Word).

writeKnownFormsAboutTerm(Ctx,Context:Word):-
        mooCache(PredR,Fact,Pre,Type,true,Context,P),
        contains_const((Fact,Pre),Word),
        flag(explaination_linenumber,LN,1),
        once(writeObject(P,_)),
        write('<hr>'),
        fail.

writeKnownFormsAboutTerm(Ctx,Context:Word):-
        mooCache(PredR,Fact,Type,true,Context,P),
        contains_const(Fact,Word),
        flag(explaination_linenumber,LN,1),
        once(writeObject(P,_)),
        write('<hr>'),
        fail.

writeKnownFormsAboutTerm(Ctx,Context:Word).

contains_const(Fact,Word):-
        getConstants(atomic,Fact,List,_,_),!,
        memberchk(Word,List).

writeKnownFormsTN(Ctx,Context:TN):-
        writeFmt('\n</pre><H3><br>Compiled Forms</H3><pre>\n',[]),fail.

writeKnownFormsTN(Ctx,Context:TN):-
        flag(indent,_,0),
        mooCache(Surface,CLF,Flags,Vars,Context,TN,Maintainer,TMResult),
        once(tam(Surface,Vars)),fail.
/*
writeKnownFormsTN(Ctx,Context:TN):-
        flag(indent,_,0),
        mooCache(Surface,CLF,Flags,Vars,Context,TN,Maintainer,TMResult),
        once(writeObject(writeq(mooCache(Flags,Vars,Context,TN,Maintainer,TMResult)),Vars)),fail.

writeKnownFormsTN(Ctx,Context:TN):-
        flag(indent,_,0),
        mooCache(Surface,CAN,Flags,Vars,Context,TN,Maintainer,TMResult),
        flag(clause_id,_,0),
        tam(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result),fail.
*/
writeKnownFormsTN(Ctx,Context:TN):-
        writeFmt('\n</pre><H3><br>Active Forms</H3><pre>\n',[]),fail.

writeKnownFormsTN(Ctx,Context:TN):-
        flag(clause_id,CLID,CLID),
        format('<hr>Clauses: ~w',[CLID]),fail.

writeKnownFormsTN(Ctx,Context:TN):-
        mooCache(Fact,Pre,Cost,Context,TN),
        list_to_and(Pre,Ands),
        flag(indent,_,0),
        once(writeObject('<hr>',Vars)),
        once(writeObject(writeq(Fact:Pre),Vars)),
        once(writeObject(nl,Vars)),
        once(writeObject('Context |= '(Ands,Fact),Vars)),fail.

writeKnownFormsTN(Ctx,Context:TN):-
        mooCache(Fact,Cost,Context,TN),
        flag(indent,_,0),
        once(writeObject('<hr>',Vars)),
        once(writeObject(Fact,Vars)),fail.

/*
writeKnownFormsTN(Ctx,Context:TN):-
        isMooOption(opt_debug=on),
        writeKnownFormsTN_used(Ctx,Context:TN).
*/
writeKnownFormsTN(Ctx,Context:TN):-writeFmt('</pre>').

writeKnownFormsTN_used(Ctx,Context:TN):-
        writeFmt('\n</pre><H3><br>Belief Forms</H3><pre>\n',[]),
        retractall(request_theory(X)),
        asserta(request_theory(Context)),
        mooCache(PredR,Fact,Ctx,Context:TN:_^Vars),
        t_ado_cache(PredR,_,Fact, Vars, Context, TN, Surf, on),
        writeFmt('\n<hr>'),fail.

writeKnownFormsTN_used(Ctx,Context:TN):-
        mooCache(PredR,Fact, Ctx, Pre, Context:TN:_^Vars),
        toMarkUp(html,formula(entails(Pre,Fact)),Vars,O),
        writeFmt('\n~w<hr>',[O]),fail.


% ===========================================================
% Ask
% ===========================================================
invokeRequest(Options):-memberchk(submit=ask,Options),!, make,
        ensureMooOption(opt_ctx_request='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(sf=surf,Askion),
        atom_codes(Askion,Askion_Chars),
        ensureMooOption(user='Web',User),
        ensureMooOption(interp='kif',Interp),
        logOnFailure(getCleanCharsWhitespaceProper(Askion_Chars,Show)),!,
        logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
        logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
        logOnFailure(invokeOperation(quiet,request(NEWFORM),Ctx,TrackingAtom,Context,User,Vars)).


% ===========================================================
% Add
% ===========================================================
invokeRequest(Options):-memberchk(submit=tn_sync,Options),!,
       %  writeFmt(user_error,'ua: ~w\n',[Options]),flush_output(user_error),
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(tn=_,EXTID),
        ensureMooOption(user='Web',User),
        ensureMooOption(sf=surf,Assertion),
        logOnFailure(atom_codes(Assertion,Codes)),
        getSurfaceFromChars(Codes,STERM,Vars),
        getMooTermFromSurface(STERM,Surface),
        destroyTN(Context,EXTID,_),
        once(invokeInsert([trusted,canonicalize],surface,Surface,Ctx,EXTID,Context,Vars,User)),!.

invokeRequest(Options):-memberchk(submit=tn_form_update,Options),!,
       %  writeFmt(user_error,'ua: ~w\n',[Options]),flush_output(user_error),
        ensureMooOption(tn=_,EXTID),
        ensureMooOption(user='Web',User),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(sf=surf,Assertion),
        logOnFailure(atom_codes(Assertion,Codes)),
        getSurfaceFromChars(Codes,STERM,Vars),
        getMooTermFromSurface(STERM,Surface),
        logOnFailure(retract(mooCache(PredR,surface,OldSurf,_,Context,EXTID,_,_))),
        destroyTN(Context,EXTID,_),
        once(invokeInsert([trusted,canonicalize],surface,Surface,Ctx,EXTID,Context,Vars,User)),!.

invokeRequest(Options):-memberchk(submit=canonicalize,Options),!,
        ensureMooOption(opt_theory='PrologMOO',Context),
        once(invokeContextCompilerProcess(Context)),write_ln('canonicalizing.\n').

invokeRequest(Options):-memberchk(submit=blank_theory,Options),!,
        ensureMooOption(opt_theory='PrologMOO',Context),
        destroyContext(Context),
        saveMooCache.


invokeRequest(Options):-memberchk(submit=removeTheoryNameSpace,Options),!,
        ensureMooOption(opt_theory='PrologMOO',Context),
        destroyContext(Context),
        retractall(mooCache(instance,surface,'instance'(Context,'KnowledgeBase'),'$VAR'(0),'MooKernel','GlobalContext',TN1,'WebUser',gaf)),
        retractall(mooCache(instance,surface,'instance'(Ctx,'Context'),'$VAR'(0),Context,'GlobalContext',TN2,'WebUser',gaf)),
        retractall(mooCache(instance,surface,'instance'('GlobalContext','Context'),'$VAR'(0),Context,'GlobalContext',TN2,'WebUser',gaf)),
        retractall(mooCache(instance,surface,'sourcefile-of'(Context,Filename),'$VAR'(0),'MooKernel','GlobalContext',TN3,'WebUser',gaf)),
        !.

% ===========================================================
% Verify Surface Returns SUO-KIF
% ===========================================================
invokeRequest(Options):-memberchk(submit=verify_assert,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(client='java',CLIENT),
        ensureMooOption(sf=surf,Assertion),
        atom_codes(Assertion,Assertion_Chars),
        ensureMooOption(user='Web',User),
         logOnFailure(getCleanCharsWhitespaceProper(Assertion_Chars,Show)),!,
         logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
         logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
         write_out_kif(Assertion_Chars,NEWFORM,Vars,Ctx,Context,Maintainer).

write_out_kif(Assertion_Chars,computed(comment(_)),Vars,Ctx,Context,Maintainer):-
         writeFmt('Syntax Error: Unmatched parentheses in "~s"',[Assertion_Chars]).
write_out_kif(Assertion_Chars,comment(_),Vars,Ctx,Context,Maintainer):-
         writeFmt('Syntax Error: Unmatched parentheses in "~s"',[Assertion_Chars]).
write_out_kif(Assertion_Chars,NEWFORM,Vars,Ctx,Context,Maintainer):-
        logOnFailure(getTruthCheckResults(tell,[untrusted],surface,NEWFORM,Ctx,STN,Context,Vars,Maintainer,Result)),
        (Result=accept(_) ->
                        (toMarkUp(kif,NEWFORM,Vars,Out),writeFmt('~w\n',[Out]),!)
                        ;
                        (
                        Result=notice(FormatStr,Args),
                        writeFmt('error:\n',[]),
                        writeFmt(FormatStr,Args)
                        )
        ),!.

% ===========================================================
% Draw Context DAG in HTML
% ===========================================================
invokeRequest(Options):-memberchk(submit=show_dag,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(user='Web',User),
        writeFmt('<pre>\n',[]),
        retractall(drawn(_)),
        draw_context_dag(Ctx,Context,0),!,
        writeFmt('</pre>\n',[]).

tcdag(C):-retractall(drawn(_)),draw_context_dag('PrologMOO',C,0).

:-dynamic(drawn/1).

draw_context_dag(Context,N):-
        assert(drawn(Ctx)),
        make_space(N,O),
        writeFmt('~w<strong>~w</strong>\n',[O,Ctx]),
        NN is N + 1,!,
        show_subs(Context,NN).

show_subs(Context,8):-!.
%show_subs(Top,Context,Top,_):-!.

show_subs(Context,NN):-
        context_dag(Context,Sub),
        not(drawn(Sub)),
        draw_context_dag(Context,Sub,NN),
        fail.
show_subs(Context,NN):-!.


make_space(1,' ->'):-!.
make_space(0,''):-!.
make_space(N,O):-
        NN is N -1,
        make_space(NN,M),
        atom_concat('   ',M,O),!.



% ===========================================================
% Insert
% ===========================================================
invokeRequest(Options):-memberchk(submit=assert,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(sf=surf,Assertion),
        atom_codes(Assertion,Assertion_Chars),
        ensureMooOption(user='Web',User),
        ensureMooOption(interp='kif',Interp),
        logOnFailure(ensureMooOption(tn=_,TN)),
        logOnFailure(getCleanCharsWhitespaceProper(Assertion_Chars,Show)),!,
        logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
        logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
        logOnFailure(invokeOperation(verbose,assert(NEWFORM),Ctx,TN,Context,User,Vars)).


% ===========================================================
% Start Canonicalizer
% ===========================================================
invokeRequest(Options):-memberchk(submit=canonicalize,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        logOnFailure(invokeContextCompilerProcess(Context)).


% ===========================================================
% Create Knowledge Base (New)
% ===========================================================
invokeRequest(Options):-memberchk(submit=register_theory,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(client='java',CLIENT),
        ensureMooOption(user='Web',User),
        saveMooCache,
        getDefaultImageFilepath(IF),
        open(IF,append,Handle,[close_on_abort(false),buffer(full)]),
        assert(save_can_to_file(Context,Handle)),
        !.

:-dynamic(save_can_to_file/2).

% ===========================================================
% Retract
% ===========================================================
invokeRequest(Options):-memberchk(submit=retract,Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(sf=surf,Retraction),
        atom_codes(Retraction,Retraction_Chars),
        ensureMooOption(user='Web',User),
        ensureMooOption(interp='kif',Interp),
        writeDebugWindow,
         getCleanCharsWhitespaceProper(Retraction_Chars,Show),!,
         logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
         logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
              once(( NEWFORM=comment(_) ->
                     (do_chars(Show),!,FORM=_) ;(!,
                     logOnFailure(invokeOperation(verbose,retract(NEWFORM),Ctx,TN,Context,User,Vars))
                     ))).


% ===========================================================
% Delete Assertion
% ===========================================================
invokeRequest(Options):-memberchk(submit='Delete Assertion',Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),
        ensureMooOption(asid=_,AID),
        ensureMooOption(user='Web',User),
        ensureMooOption(interp='kif',Interp),
        writeFmt('<H3><Font Color=Red>Deleted....</Font></H3>',[]),
        delete_assertion(AID).

delete_assertion(AID):-
        retract(mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,_)),
        delete_assertion_disp(Form,SURF,Vars,Context,AID,Maintainer),
        fail.

delete_assertion(AID):-writeFmt('<H3><Font Color=Red>Done Deleting.</Font></H3>',[]).

delete_assertion_disp(Form,SURF,Vars,Context,AID,Maintainer):-
        toMarkUp(html,SURF,Vars,SAtom),
        writeFmt('<IMG src="pixmaps/bullet.gif" asrtid=~w><nobr>',[AID]),
        writeFmt('<b>~w</b> ID<font color=red>~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font>',[Form,AID,Context,Maintainer]),
        %format_o('&nbsp;&nbsp;~w&nbsp;Enabled&nbsp;&nbsp;<br>',chectheoryox(AID,OnOff)),
        writeFmt('~w<br>',[SAtom]),!.

invokeRequest(Options):-
        memberchk(cmd='Show Cache',Options),!,
        writeFmt('<H3><Font Color=Red>Listing Cache Assertions...</Font></H3><PRE>',[]),
        listing(mooCache),
        writeFmt('</PRE><BR><B>Done.</B>',[]),!.


listingt(NH):-catch((string_to_atom(NH,AA),listing(AA)),_,true).
%listingt(NH):-listing(NH),!.

% ===========================================================
% Invoke Prolog Command
% ===========================================================
invokeRequest(Options):- %memberchk(interp='prolog',Options),!,
        memberchk(submit=command,Options),!, make,
        ensureMooOption(sf=surf,Prolog),
        ignore(parse_prolog_cmd(Prolog)).

parse_prolog_cmd(Prolog):-
        writeDebugWindow,
	writeFmtFlushed('<pre>') ,
        catch(atom_to_term(Prolog,CMD,Vars),E,
        (message_to_string(E,S),writeFmt('\nCall "~w" could not be read.  \nError: ~s\n',[Prolog,S]))),!,
        callFromWeb(Prolog,CMD,Vars),!.
parse_prolog_cmd(Prolog):-writeFmt('\nCall "~w" failed',[Prolog]),!.
callFromWeb(Prolog,CMD,Vars):-var(CMD),!.
callFromWeb(Prolog,CMD,Vars):-
        getThread(Id),
        ensureMooOption('$socket_out',user_output,Out),
        ensureMooOption('$socket_in',user_input,In),
        invokePrologCommandRDF(Id,In,Out,CMD,Vars,Results),
        writeFmt('\n       Results: ~w\n',[Results]),!.




% ===========================================================
% Logical Form Display
% ===========================================================
invokeRequest(Options):-memberchk(logicforms=logicforms,Options),!,
       parse_moo_lf(Options).


% ===========================================================
% Un-Canonicalize on Context/Ctx
% ===========================================================

invokeRequest(Options):-
        memberchk(cmd='Un-Canonicalize',Options),!,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),!,
        (unsetMooOption(opt_surface_check=_)),
        (setMooOption(opt_surface_check=untrusted)),
        (unsetMooOption(opt_tracking_number=_)),
        (setMooOption(opt_tracking_number=supplied)),!,
        (unsetMooOption(opt_canonicalizer=_)),
        (setMooOption(opt_canonicalizer=byrd)),!,
        writeFmt('<H2>Un-Canonicalizing  Context:~w Ctx:~w.  This process may take several minutes.. Do not navigate away.</H2>',[Context,Ctx]),
        mark_all_surface_to_uncanonicalized(Context,Ctx),!.

% ===========================================================
% Invoke Load SContext on Context/Ctx (POST)
% ===========================================================

invokeRequest(Options):-
                memberchk(context='Load SContext',Options),!,
                (unsetMooOption(opt_theory=_)),
                (setMooOption(opt_theory=Context)),
                ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
                ensureMooOption(opt_theory='PrologMOO',Context),!,
                fmtString(FileChars,'C:/mool/SUO/~w.can',[Context]),!,string_to_atom(FileChars,Filename),!,
                (unsetMooOption(opt_surface_check=_)),
                (setMooOption(opt_surface_check=trusted)),
                idGen(TN1),
                idGen(TN2),
                idGen(TN3),
                idGen(TN4),
                retractall(mooCache(PredR,_,_,_,Context,_,_,_)),
                assertaClean(mooCache(instance,surface,'instance'(Context,'KnowledgeBase'),'$VAR'(0),'MooKernel','GlobalContext',TN1,'WebUser',gaf)),
                assertaClean(mooCache(instance,surface,'instance'(Ctx,'Context'),'$VAR'(0),Context,'GlobalContext',TN4,'WebUser',gaf)),
                assertaClean(mooCache(instance,surface,'instance'('GlobalContext','Context'),'$VAR'(0),Context,'GlobalContext',TN2,'WebUser',gaf)),
                assertaClean(mooCache('sourcefile-of',surface,'sourcefile-of'(Context,Filename),'$VAR'(0),'MooKernel','GlobalContext',TN3,'WebUser',gaf)),
                load_kif_to_theory_ctx(Context,Filename,'GlobalContext','MooWeb').

% ===========================================================
% load_from_can_file (Knowledge Base File)
% ===========================================================
invokeRequest(Options):-memberchk(cmd='Load SContext',Options),!,
                ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
                ensureMooOption(opt_theory='PrologMOO',Context),!,
                fmtString(FileChars,'C:/mool/SUO/~w.can',[Context]),!,string_to_atom(FileChars,Filename),!,
                (unsetMooOption(opt_surface_check=_)),
                (setMooOption(opt_surface_check=trusted)),
                idGen(TN1),
                idGen(TN2),
                idGen(TN3),
                idGen(TN4),
                retractall(mooCache(PredR,_,_,Context,_,_,_)),
                assertaClean(mooCache(instance,surface,'instance'(Context,'KnowledgeBase'),'$VAR'(0),'MooKernel','GlobalContext',TN1,'WebUser',gaf)),
                assertaClean(mooCache(instance,surface,'instance'(Ctx,'Context'),'$VAR'(0),Context,'GlobalContext',TN4,'WebUser',gaf)),
                assertaClean(mooCache(instance,surface,'instance'('GlobalContext','Context'),'$VAR'(0),Context,'GlobalContext',TN2,'WebUser',gaf)),
                assertaClean(mooCache('sourcefile-of',surface,'sourcefile-of'(Context,Filename),'$VAR'(0),'MooKernel','GlobalContext',TN3,'WebUser',gaf)),
                load_kif_to_theory_ctx(Context,Filename,'GlobalContext','MooWeb').


% ===========================================================
% Invoke Canonicalizer on Context/Ctx (GET)
% ===========================================================
invokeRequest(Options):-
        memberchk(cmd='Canonicalize',Options),!,%true,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),!,
        (unsetMooOption(opt_surface_check=_)),
        (setMooOption(opt_surface_check=untrusted)),
        (unsetMooOption(opt_tracking_number=_)),
        (setMooOption(opt_tracking_number=supplied)),!,
        (unsetMooOption(opt_canonicalizer=_)),
        (setMooOption(opt_canonicalizer=byrd)),!,
        writeFmt('<H2>Canonicalizing  Context:~w Ctx:~w.  This process may take several minutes.. <br>This process must be done once and should not be interupted<br>Wait until this page is completely loaded before clicking <br>any links and do not navigate away.</H2>',[Context,Ctx]),
        logOnFailure(canonicalizeMooContextHTML(Context,Ctx)),!.

% ===========================================================
% Invoke Canonicalizer on Context/Ctx (POST)
% ===========================================================
invokeRequest(Options):-
        member(Context='Canonicalize',Options),!,
        (unsetMooOption(opt_theory=_)),
        (setMooOption(opt_theory=Context)),
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        (unsetMooOption(opt_surface_check=_)),
        (setMooOption(opt_surface_check=untrusted)),
        (unsetMooOption(opt_tracking_number=_)),
        (setMooOption(opt_tracking_number=supplied)),!,
        (unsetMooOption(opt_canonicalizer=_)),
        (setMooOption(opt_canonicalizer=byrd)),!,
        writeFmt('<H2>Canonicalizing  Context:~w Ctx:~w.  This process may take several minutes.. <br>This process must be done once and should not be interupted<br>Wait until this page is completely loaded before clicking <br>any links and do not navigate away.</H2>',[Context,Ctx]),
        logOnFailure(canonicalizeMooContextHTML(Context,Ctx)),!.


% ===========================================================
% Invoke Surface Checker on Context/Ctx
% ===========================================================
invokeRequest(Options):-
        memberchk(cmd='Surface Check',Options),!,%true,
        ensureMooOption(opt_ctx_assert='GlobalContext',Ctx),
        ensureMooOption(opt_theory='PrologMOO',Context),!,
        logOnFailure(surface_check_entire_theory_ctx(Context,Ctx)),!,
        writeFmt('<hr>Done Surface Check\n',[]).

% ===========================================================
% Invoke Prolog Command
% ===========================================================
invokeRequest(Options):- %memberchk(interp='prolog',Options),!,
        memberchk(submit='Clean Slate',Options),!,halt.

% ===========================================================
% Invoke Prolog Command
% ===========================================================
invokeRequest(Options):- %memberchk(interp='prolog',Options),!,
        memberchk(cmd='Compile Demo',Options),!,autoload,
        (unsetMooOption(client=html)),qsave_program('moo_server',[goal=(initializeMooServerData,cs)]),(setMooOption(client=html)).

build_exe_and_halt:- !,autoload,
        (unsetMooOption(client=html)),qsave_program('moo_server',[goal=(initializeMooServerData,cs)]).

invokeRequest(Options):-invokeBrowserRequest(Options),!.



% ===========================================================
% Backup Moo
% ===========================================================
invokeRequest(Options):-memberchk(cmd='Save Image',Options),!,saveMooCache.

% ===========================================================
% Define New context
% ===========================================================
invokeRequest(Options):-memberchk(client='command',Options),memberchk(submitbuttonUp='Create',Options),!,
                        ensureMooOption(newCtxName='GlobalContext',Ctx),
                        ensureMooOption(theory='PrologMOO',Context),
                        ensureMooOption(user='Web',User),
                        idGen(TN2),
                        assertaClean(mooCache(instance,surface,'instance'(Ctx,'Context'),'$VAR'(0),Context,'GlobalContext',TN2,User,on)).


% ===========================================================
% Context/Ctx ComboBoxs
% ===========================================================
show_available_contexts:-
        findall(Atom,
                (mooCache(PredR,surface,('instance'(Ctx,'Context'):_), Context,_, _, _, _),concat_atom([Context,':',Ctx],Atom)),
                List),
        writeq(List),nl.


getCtxListForContext(Context,['GlobalContext'|Sorted]):-
        findall(Ctx,mooCache(_,_,_, _, Context, _, _, _),UList),!,sort(UList,Sorted).
getCtxListForContext(Context,['GlobalContext']):-!.

show_available_contexts_in_combobox(Context,null):-
        getCtxListForContext(Context,List),
        toMarkUp(html,select(ctx,List),_,Out),write(Out).

show_available_contexts_in_combobox(Context,Selected):-
        getCtxListForContext(Context,List),
        toMarkUp(html,select(ctx,[Selected|List]),_,Out),write(Out).


getListOfContext(ContextList):-
        findall(Context,mooCache(_,_,_, _, Context, _, _, _),UList),!,sort(UList,ContextList).

show_available_theorys_in_combobox(Out):-
                findall(Context,mooCache(PredR,surface,('instance'(Context,'KnowledgeBase'):_), 'MooKernel',_, _, _, _),List),
                toMarkUp(html,select(theory,List),_,Out).

% =================================================
% Useragent Control Panel
% =================================================
invokeRequest(Options):-memberchk(client='controlpanel',Options),
        memberchk(killable=_,Options),!,
        member(killable=ID,Options),
        catch(prolog_thread_signal(ID,prolog_thread_exit(user_killed(ID))),_,true),
        invokeRequest([client='controlpanel']).


invokeRequest(Options):-memberchk(client='controlpanel',Options), !,
        showMooProcessHTML.

% ===========================================================
% TQ HOOK
% ===========================================================
invokeRequest(Options):-memberchk(client='tqsystem',Options),!,ignore(invokeTestSystem(Options)).

% ===========================================================
% FALLBACKS
% ===========================================================

invokeRequest(Options):-memberchk(client=command,Options),!.

invokeRequest(Options):-%true,
   writeFmt('
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<meta name="Keywords" content="PROLOG Artificial Intelligence Ontology AI MOO Linguistics Philosophy DARPA Doulgas Miles">
<meta name="Description" content="PROLOG Artificial Intelligence Ontology AI MOO Linguistics Philosophy DARPA">
<title>LogicMOO request ~q</title>
<LINK REL="stylesheet" TYPE="text/css" HREF="http://msdn.microsoft.com/msdn-online/shared/css/ie4.css" />
</head>

<body>
',[Options]),
%showMooProcessHTML,
write('
<pre>
                               _)\\.-.
              .-.__,___,_.-=-. )\\`  a`\\_
          .-.__\\__,__,__.-=-. `/  \\     `\\
          {~,-~-,-~.-~,-,;;;;\\ |   \'--;`)/
           \\-,~_-~_-,~-,(_(_(;\\/   ,;/
            &quot;,-.~_,-~,-~,)_)_)\'.  ;;(               W E L C O M E
              `~-,_-~,-~(_(_(_(_\\  `;\\                   t o
        ,          `&quot;~~--,)_)_)_)\\_   \\               J a M U D
        |\\              (_(_/_(_,   \\  ;
        \\ \'-.       _.--\'  /_/_/_)   | |
         \'--.\\    .\'          /_/    | |
             ))  /       \\      |   /.\'
            //  /,        | __.\'|  ||
           //   ||        /`    (  ||           the java-based mud in
          ||    ||      .\'       \\ \\\\           T E C H N I C O L O R
          ||    ||    .\'_         \\ \\\\	       (Web Interface)
           \\\\   //   / _ `\\        \\ \\\\__
     jgs    \'-\'/(   _  `\\,;        \\ \'--:,
             `&quot;`  `&quot;` `-,,;         `&quot;`&quot;,,;</pre>
<form method="GET" action="login">
Player Name:&nbsp;&nbsp;<input type="text" name="username" size="20">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
Password:&nbsp;&nbsp;<input type="text" name="password" size="20">&nbsp;&nbsp;&nbsp;
<input type="submit" value="Login" name="loginbutton">
</form>
</body>

</html>
'),   showMooStatisticsHTML,writeDebugWindow.



% ===========================================================
% EDITOR WINDOW
% ===========================================================

writeEditorLogicWindow:-!,
        ensureMooOption(sf='(isa ?X ?Y)',Formula),
        writeFmt('<textarea rows=6 cols=90 name="sf">~w</textarea><br>',[Formula]),
        writeFmt('<br><INPUT type=submit name=submit value="Update Source"></INPUT><hr>',[]),
        writeFmt('<INPUT type=radio name="interp" value="kif" checked>KIF</INPUT>',[]),
        writeFmt('<INPUT type=radio name="interp" value="ace">ACE</INPUT>',[]).

writeDebugWindow:-!,
        ensureMooOption(sf='(isa ?X ?Y)',Formula),
	writeFmt('<hr><FORM name="theForm" ID="theForm"  METHOD="GET">
		<textarea rows="5" cols="70" name="sf">~w</textarea><br>
		<INPUT type="hidden" name="interp" value="kif" checked>
		<INPUT type="submit" name="submit" value="command"></INPUT></form>',[Formula]).


% ===================================================================================================
%  End of moo_useragent.P
% ===================================================================================================

getTheoryStatus('MooKernel'):-writeFmt('Browse Only\n',[]),!.
getTheoryStatus(Context):-
        isContextCompilerProcess(Context,Progress),
        writeFmt('<A href=controlpanel.jsp?theory=~w><font color=green>Canonicalizing</font></a>\n',[Context]),!.

getTheoryStatus(Context):-
        isUncanonicalized(Context),
        invokeContextCompilerProcess(Context),
        isContextCompilerProcess(Context,Progress),
        writeFmt('<A href=controlpanel.jsp?theory=~w><font color=green>Canonicalizing</font></a>\n',[Context]),!.

getTheoryStatus(Context):-
        isUncanonicalized(Context),
        isContextCurrentlyInUse(OtherContext,Status),!,
        writeFmt('<font color=orange>Waiting for ~w</font>\n',[OtherContext]).

getTheoryStatus(Context):-
        isContextCurrentlyInUse(Context,Status),
        writeFmt('<font color=orange>Busy ~w</font>\n',[Status]).

getTheoryStatus(Context):-
        isTheoryUntransfered(Context),
        writeFmt('<A href=stheory_to_prolog.jsp?theory=~w><font color=red>Update</font></a>\n',[Context]),!.

getTheoryStatus(Context):-
        isSourceNewerThenImage(Context),
        writeFmt('<A href=stheory_to_prolog.jsp?theory=~w><font color=red>Needs Update</font></a>\n',[Context]),!.

getTheoryStatus(Context):-isKnowledgeBaseLoaded(Context,_),writeFmt('<A href="askInsert.jsp?theory=~w">Ask/Insert</A>\n',[Context]),!.

getTheoryStatus(Context):-writeFmt('Unknown\n',[]),!.

% ===================================================================
%  INVOKE REQUEST INTERFACE USED BY REQUEST AGENTS
% ===================================================================

%% :-include('moo_header.pl').

% =======================================================================================

invokeRequestAndWriteUserAgent(Formula,Ctx,TrackingAtom,Context,User,Vars,CPU):-
         invokeRequestToBuffer(Formula,Ctx,TrackingAtom,Context,User,Vars,CPU),
         writeUserAgentBuffer.


% ===========================================================
% Cite Buffer
% ===========================================================
writeUserAgentBuffer:-%true,
        retract(requestBuffer_db(UResultsSoFar,Result,Explaination,Status)),
        once(writeAnswersUserAgent(UResultsSoFar,Result,Explaination,Status)),fail.

% Call to write Summary
writeUserAgentBuffer:-
        final_answer(Logic:How),
        writeDebug(final_answer(Logic:How)),
        writeAnswersUserAgent(How, ['Summary'=Logic|_G14093],final_answer(Logic:How),final_answer(Logic:How) ).

writeUserAgentBuffer:-!.


% ===========================================================
% Send to debugger
% ===========================================================
writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status):-
        ((once(writeDebug(writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status))),fail)).

% ===========================================================
% Hide certain returns
% ===========================================================
writeAnswersUserAgent(-1,Result,Explaination,Status).

writeAnswersUserAgent(0, ['Result'=none|A], 'Unproven', done(possible:searchfailed)).
writeAnswersUserAgent(_, ['Result'=true|A], found(_), done(true:_)).

% ===========================================================
% Write Summaries
% ===========================================================
writeAnswersUserAgent(_, ['Summary'=true|_G5892], _, final_answer(Logic:NA)):-
        writeObject('$spacer',Vars), retain_yes,
        request_total_time(Total),
        writeObject(nv([' Yes. (Found ',NA,Logic,' in ',Total,' seconds.)']),['Total'=Total,'Answers'=NA,'Logic'=Logic]),!.

writeAnswersUserAgent(Explaination, ['Summary'=false|_G5282], final_answer(Logic:Request:P), _):-
        writeObject('$spacer',Vars), retain_no,
        request_total_time(Total),
        writeObject(nv([' No. (Found ',Logic,' in ',Total,' seconds.)']),['Total'=Total,'Answers'=NA,'Logic'=Logic]),!.

writeAnswersUserAgent(searchfailed, ['Summary'=Logic|_G4695], final_answer(possible:searchfailed), final_answer(possible:searchfailed)):-
        writeObject('$spacer',Vars), retain_unproven,
        request_total_time(Total),
        writeObject(nv([' Unproven. (Found no answers in ',Total,' seconds.)']),['Total'=Total,'Answers'=NA,'Logic'=Logic]),!.

% ===========================================================
% Write Answers
% ===========================================================
:-dynamic(isMooOption(show_all_explainations,true)).


/*
writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status):-
        format('<b>~q.</b>',writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status)),!.
*/

writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status):-not(isMooOption(show_all_explainations,true)),
        writeObject('$spacer',Vars),
        %writeObject(writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status),Vars),nl,
        writeObject(getPrologVars(Result),Vars),
        length_explaination(InExplaination,InLength),
        findall(Length-Explaination,
                (retract(requestBuffer_db(_,Result,Explaination,_)),
                 length_explaination(Explaination,Length)
                 ),KeyList),
        keysort([(InLength-InExplaination)|KeyList],[(_-ChoiceExplaination)|_]),
        writeObject(explaination(ChoiceExplaination),Result).

writeAnswersUserAgent(UResultsSoFar,Result,InExplaination,Status):-isMooOption(show_all_explainations,true),
        writeObject('$spacer',Vars),
        writeObject(getPrologVars(Result),Vars),!,
        writeObject(explaination(InExplaination),Vars),!.

retain_no:-retain_answer('No'),retain_answer('no'). %,retain_answer('Unproven').
retain_yes:-retain_answer('Yes'),retain_answer('yes'). % ,retain_answer('Unproven').
retain_unproven:-retain_answer('Unproven'),retain_answer('unproven'). % ,retain_answer('Unproven').



length_explaination(List,Len):-length(List,Len),!.
length_explaination(deduced,3):- !.
length_explaination(P * Explaination,Length):- !,
        length_explaination(P,PLength),
        length_explaination(Explaination,ExplainationLength),
        Length is PLength + ExplainationLength,!.
length_explaination(_,1):- !.


unset_promiscuous:-
                setMooOption(opt_deduce_domains='off').
set_promiscuous:-
                setMooOption(opt_deduce_domains='on').


% ===================================================================
% EXPORTS
% ===================================================================

register_belief_module(_ModuleName).


/*
Loads and compiles a Maintainerial KIF file
agentLoadKif(+Filename,+GlobalContext,+DefiningMaintainer).
*/

agentLoadKif(Filename):-
        set_automation,
        agent_load_kif(Filename,Filename,Filename).

agentLoadKif(Filename,GlobalContext,User):-
        set_automation,
        agent_load_kif_quiet(Filename,GlobalContext,User).


/*
Saves state of a Contet
agentSave(+FileName,+GlobalContext)
*/



/*

Loads the saved state (crypted or not)  (adds assertions) they were originally stored with a context
interfaceLoad(+FileName)
Clears a context (Leave unbound to clear all contexts)
u_clear(?Context)
We still have some discussion on how contexts are linked together so right now they are all active..
Mainly it gives us a way to do bulk load/unloads and separation user data from general system's like STANDARD.

*/



/* Assertion
agentInsert(+KIFCharsIn,+Ctx,+Context,+User).
KIFCharsIn = "(instance virginia Computer)"
Ctx = 'Computers and Things'
Context = 'PrologMOO' currently must be set to 'PrologMOO'
*/

agentInsert(KIFCharsIn,Ctx,Context,User):-
        set_automation,
        agentInsert(KIFCharsIn,Ctx,TN,Context,User).


/*
Now the predicates that you most want
Invokes a request
agentRequest(+KIFCharsIn,+Ctx,+Context,+User,-UResultsSoFar,-Result,-Explaination,-Status).

Input variables:
KIFCharsIn = "(instance ?What Computer)"
Ctx = 'Computers and Things'  % Any legal Atom that helps you book keep
Context = 'PrologMOO' currently must be set to 'PrologMOO'
User = ''  There are times when error messages about redundant assertions happen.. and for bookkeeping all assertions have an author atom.. perhaps you can even use the source file name it came from.

output variables:
UResultsSoFar = 0 indexed value of answer number.. +1 would mean it is a repeated answer with a different explaination.. you could choose not to display answers with negative numbers
Result = Is the Prolog Variable Vector like ['What'=virginia|_] (can be written with writeObject(Verbose,getPrologVars(Result),Result))
Explaination = A explaination object that can be printed with writeObject(Verbose,explaination(Explaination),Result)
Status = is either 'true' or '!' ... true = more results.. '!' means no more results
(Status is optional.. if you completely remove this argument and it will fail at the next call after the first solution returning !)
*/




/*
% Lets you discover any errors that were created durring any operation
popError(Message)
+Will fail if no errors are in this buffer
+When any of the above commands are first invoked the error buffer is cleared
+Whenever there were errors and you read this buffer each one is deleted while it is read
+Messages are stored as printable objects writeObject(Verbose,Message)  we can discuss a more programmatic approach to formats later based on how we want to use them.
*/
:-dynamic(mooErrorBuffer/1).
popError(Message):-retract(mooErrorBuffer(Message)).

/*
Term Writting
writeObject(Verbose,+Object).
writeObject(Verbose,+Object,+Vars).
Allows easy printing of variables and objects
*/


/*
Belief Variables

Set Belief Optional Variable
setMooOption(VariableName=NewValue).
*/

/*
Retrive Belief Optional Variable
isMooOption(VariableName=CurrentValue).
*/

/*
The defualts are shown here
opt_timeout=5  The request system will try for 5 seconds before stopping (RealNumber in seconds)
opt_answers_min=1 The system will at minumum try to come up with 1 answer
opt_answers_max=99 The system will at maximun will try to come up with 99 answers
opt_backchains_max=50 will try 50 prolog backchains aprocimately 12 authorial backchains on each deduction
opt_deductions_max=100 The system will try to come up with 100 non unique answers before stooping
*/

set_automation:-
                retractall(mooErrorBuffer(_)),
               !.
               % (unsetMooOption(client=_)),
                %(setMooOption(client=automata)).


% ===================================================================
%  BATCH INTERFACE
% ===================================================================

invokeOperation(Verbose,surf,Ctx,Tracking,Context,User,Vars):-!.
invokeOperation(Verbose,Fml,Ctx,TN,Context,User,Vars):-!,
                once(invokeOperationProc(Verbose,Fml,Ctx,TN,Context,User,Vars)),!.

invokeOperationProc(Verbose,TERM,Ctx,TN,Context,User,Vars):-TERM =..[note|T],!,
                assert(title(T)),
                WT=..['note '|T],
                writeObject(Verbose,WT,Vars),!,
                writeObject(Verbose,'\n\n;; Assertions \n\n',Vars),!,
                clear_moo_memory,set_promiscuous,!.

invokeOperationProc(Verbose,TERM,Ctx,TN,Context,User,Vars):-TERM =..[answer|T],!,batch_answer(T).

invokeOperationProc(Verbose,TERM,Ctx,TN,Context,User,Vars):-TERM =..[abort],!,assert(tq_ignored).
invokeOperationProc(Verbose,'deduce-domains'(on),Ctx,TN,Context,User,Vars):-!,set_promiscuous,!.
invokeOperationProc(Verbose,'deduce-domains'(true),Ctx,TN,Context,User,Vars):-!,set_promiscuous,!.
invokeOperationProc(Verbose,'deduce-domains'(false),Ctx,TN,Context,User,Vars):-!,unset_promiscuous,!.
invokeOperationProc(Verbose,'deduce-domains'(off),Ctx,TN,Context,User,Vars):-!,unset_promiscuous,!.

invokeOperationProc(Verbose,end_of_file,Ctx,TN,Context,User,Vars):-!.

invokeOperationProc(Verbose,'file_comment'(C),SourceCtx,SourceTN,Context,User,Vars):-!,nl,write(C),!.
invokeOperationProc(Verbose,'browser-only'(_),SourceCtx,SourceTN,Context,User,Vars):-!.
invokeOperationProc(Verbose,'execute-prolog'(Code),SourceCtx,SourceTN,Context,User,Vars):-!,
once(((%                writeq(Code),nl,
                atom_codes(Code,Codes),
%               writeq(Codes),nl,
                getUnquotedCodes(Codes,Chars),
%               writeq(Chars),nl,
                atom_codes(Atom,Chars),
                atom_to_term(Atom,Term,V)

                );writeFmt('could not parse ~w\n',[Code])),once(((once(catch(Term,_,fail)),writeFmt('Exec Suceeded',[]));writeFmt('Exec Failed',[])))).
invokeOperationProc(Verbose,'load-theory'(Filename),SourceCtx,SourceTN,Context,User,Vars):-!,fail,agent_load_kif_quiet(Filename,'GlobalContext','Anonymous').
invokeOperationProc(Verbose,'load-theory-show'(Filename),SourceCtx,SourceTN,Context,User,Vars):-!,
        agent_load_kif(Filename,'GlobalContext','Anonymous').

invokeOperationProc(Verbose,retract(nil),Ctx,TN,Context,User,Vars):-!.

invokeOperationProc(Verbose,request(nil),Ctx,TN,Context,User,Vars):-!.

invokeOperationProc(Verbose,(nil),Ctx,TN,Context,User,Vars):-!.

invokeOperationProc(Verbose,tell(nil),Ctx,TN,Context,User,Vars):-!.

invokeOperationProc(Verbose,assert(end_of_file),Ctx,TN,Context,User,Vars):- !.

invokeOperationProc(Verbose,assert(NEWFORM),Ctx,TN,Context,User,Vars):-  !,
        invokeOperationProc(Verbose,assert([trusted,canonicalize,to_mem],NEWFORM),Ctx,TN,Context,User,Vars).

invokeOperationProc(Verbose,assert(Flags,NEWFORM),Ctx,TN,Context,User,Vars):-  !,
        flag('Axioms Compiled',AC,AC+1),
        LN is AC + 1,
        flag(explaination_linenumber,_,LN),
        writeObject(Verbose,nl,Vars),
        writeObject(Verbose,NEWFORM,Vars),
        writeObject(Verbose,nl,Vars),
        logOnFailure(invokeInsert(Flags,surface,NEWFORM,Ctx,TN,Context,Vars,User)),
        ignore((getMooOption(opt_debug=off,on),Verbose=verbose,writeKnownFormsTN(Ctx,Context:TN))).


invokeOperationProc(Verbose,retract(Fml),Ctx,TN,Context,User,Vars):-
         flag('Axioms Compiled',AC,AC+1),
         writeObject(Verbose,nl,Vars),
         writeObject(Verbose,retract(Fml),Vars),
         writeObject(Verbose,nl,Vars),
         retract_pterm(Fml,Ctx,TN,Context,User,Vars).

invokeOperationProc(Verbose,canonicalize(Q),Ctx,TN,Context,User,Vars):-!,
         writeObject(Verbose,nl,Vars),
         writeObject(Verbose,canonicalize(Q),Vars),
         invokeRequestWithTime(canonicalize(Q),_,Ctx,TN,Context,User,Vars,CPU1), assert(findings(CPU1)).

invokeOperationProc(Verbose,request(Q),Ctx,TN,Context,User,Vars):-!,
         writeObject(Verbose,'\n\n\n;; Request \n\n',Vars),
         writeObject(Verbose,'request '(Q),Vars),
         writeObject(Verbose,nl,Vars),
         invokeRequestWithTime(request(Q),Ctx,TN,Context,User,Vars,CPU1), assert(findings(CPU1)).

invokeOperationProc(Verbose,request(N,Q),Ctx,TN,Context,User,Vars):-!,
         writeObject(Verbose,'\n\n\n;; Timed Request \n\n',Vars),
         writeObject(Verbose,'request '(Q),Vars),
         writeObject(Verbose,nl,Vars),
         invokeRequestWithTime(request(N,Q),Ctx,TN,Context,User,Vars,CPU1), assert(findings(CPU1)).

invokeOperationProc(Verbose,requestyn(Q),Ctx,TN,Context,User,Vars):-!,
         writeObject(Verbose,'\n\n\n;; Yes/No Request \n\n',Vars),
         writeObject(Verbose,'request '(Q),Vars),
         writeObject(Verbose,nl,Vars),
         invokeRequestWithTime(requestyn(Q),Ctx,TN,Context,User,Vars,CPU1), assert(findings(CPU1)).


invokeOperationProc(Verbose,Fml,Ctx,TN,Context,User,Vars):-               % Default Left-over
             toFSCK(Fml,Ctx,TN,Assertion,SourceCtx,SourceTN),
             invokeOperation(Verbose,assert(Assertion),SourceCtx,SourceTN,Context,User,Vars).

invokeRequestWithTime(Q,Ctx,TN,Context,User,Vars,CPU):-
                invokeRequestAndWriteUserAgent(Q,Ctx,TN,Context,User,Vars,CPU),
                assert(request_time(CPU)).


% ===============================================================
% AGENT REQUEST (Chars)
% ===============================================================

tkq1:-agentRequest("(isa Joe ?Class)",'GlobalContext','PrologMOO','Dmiles',U,R,P).
tkq2:-agentRequest("(isa on Relation)",'GlobalContext','PrologMOO','Dmiles',U,R,P).


agentRequest(KIFCharsIn,Ctx,Context,User,UResultsSoFar,Result,Explaination):-
        agentRequest(KIFCharsIn,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status),
        (Status = done(_) -> ! ; true).


agentRequest(KIFCharsIn,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status):-
        isCharCodelist(KIFCharsIn),!,
        string_clean(KIFCharsIn,KIFChars),
        logOnFailure(ask_parse_chars(KIFChars,FmlInOpen,Vars)),!,
        agentRequest(KIFCharsIn,FmlInOpen,Vars,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status).


agentRequest(KIFCharsIn,FmlInOpen,Vars,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status):-
        ((
        retractall(answer_found(_)),
        retractall(t_answer_found(_)),
        retractall(tabled_f(_)),
        retractall(mooCache(deduceInstanceTable(Context,Class,Set))),
        ignore(findall(_,expireOptimizationsInContext(_,_,_),_)),
        retractall(table_g(_)),
        retractall(cpuend(_)),
        retractall(tabled_t(_)),
        retractall(table_g(_)),
        retractall(proving(_)),
        getMooOption(opt_theory,QContext),!,ignore((Context=QContext)),!,
        get_default_request_context(QCTX),!,ignore((Ctx=QCTX)),!,
        logOnFailure(ensureMooContext(Context,Ctx)),!,
        flag('$Returned Answers',_,0),
        flag('$UAnswers',_,0))),
        TN = User, % Tracks request based on 'User'
        destroyTN(Context,TN,_Ctx),  % Removes previous Request
        getOpenVariablesWFF(FmlInOpen,Vars,ChaseVars),
        getPrologVars(ChaseVars,QVars,_,_),
        RequestPrototype=..[request|QVars],
        ((not(not((
                getAssertionClauses(Context,'<=>'(FmlInOpen,RequestPrototype),CAN,Vars,Flags),
                assert(mooCache(FmlInOpen,CAN,Flags,Vars,Context,TN,User,Result)),!,
                (recanonicalizeTN(Context,TN)),    % Compile Belief
                assert(tq_attempted_request),
                writeDebug(blue,'Stage 1 - Compilation ':CAN:Flags)))))),!,
        agentRequestEach(FmlInOpen,RequestPrototype,ChaseVars,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status),
        commitCleanExplaination(Explaination,ExplainationOut).


% ======================================================
% REQUEST PROC POSITIVE/NEGATIVE
% ======================================================

% Check For Undefines
agentRequestEach(KIFCharsIn,Formula,Vars,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status):-  fail,
                once(getConstants(atomic,Formula,UsedConstants,_,_)),
                logOnFailure(checkAllConstantsHaveTypes(Formula,UsedConstants,UnDefinedList)),
                UnDefinedList=[_|_],!,writeObject(undefined_constants(UnDefinedList),_),!,fail.

% Check For Theorem
agentRequestEach(FmlInOpen,URequest,UVars,Ctx,Context,User,1,['Result' = 'True'],formula(instance(FormulaIN,'Theorem')),done(true:thereom)):-
        resetTableFlags,
        writeDebug(purple,'Stage 2 - Theorem Check ':FmlInOpen),
        isTheorem(FmlInOpen,_),!,
        retain_yes,sendNote('(theorem)'),!.

% Call Belief
agentRequestEach(FmlInOpen,URequest,UVars,Ctx,Context,User,UA, UVars,Explaination,Result):-
        agentBelief(FmlInOpen,URequest,UVars,Ctx,Context,User,UA, UVars, Explaination,Result).

% Request Failed
agentRequestEach(FmlInOpen,URequest,UVars,Ctx,Context,User,0,['Result'='none'|_],'Unproven',done(possible:searchfailed)):-
        flag('$UAnswers',UA,UA),UA<1,!.

% Request Succeeded
agentRequestEach(FmlInOpen,URequest,UVars,Ctx,Context,User,UA,['Result'='true'|_],found(UA),done(true:UA)):-!,
        flag('$UAnswers',UA,UA).


% ======================================================
% ======================================================
commitCleanExplaination(deduced,deduced):-!.
commitCleanExplaination(Explaination * deduced,ExplainationOut):-!,commitCleanExplaination(Explaination,ExplainationOut).
commitCleanExplaination(deduced * Explaination,ExplainationOut):-!,commitCleanExplaination(Explaination,ExplainationOut).
commitCleanExplaination(Explaination * '$VAR'(_),ExplainationOut):-!,commitCleanExplaination(Explaination,ExplainationOut).
commitCleanExplaination('$VAR'(_) * Explaination,ExplainationOut):-!,commitCleanExplaination(Explaination,ExplainationOut).
commitCleanExplaination(Explaination1 * Explaination2,ExplainationOut1 * ExplainationOut2):-!,
        commitCleanExplaination(Explaination1,ExplainationOut1),!,
        commitCleanExplaination(Explaination2,ExplainationOut2),!.
commitCleanExplaination(Explaination,Explaination):-!.


getRequestDefaults(URequest,OAnswers,BackchainsMax,Deductions):-
        ((
        (getMooOption(opt_backchains_max=BackchainsMax)),
        (getMooOption(opt_deductions_max=Deductions)),!,
        ignore((ground(URequest) -> Answers=1 ; Answers=PAnswers)),
        (getMooOption(opt_answers_max=Answers)),!,
        ignore(BackchainsMax=30),ignore(Answers=60),OAnswers is Answers,!)).

set_quit_time(Num):-
        ((
        (getMooOption(opt_timeout=QuitTime)),!,ignore(QuitTime=5),!,
        retractall(cpuend(_)),
        getCputime(Now),
        Then is Now + QuitTime*Num,
        asserta(cpuend(Then)),!)).

:-dynamic(noexistencials/0).

%edify_vars(X,X):-!.
edify_vars(Var,Var):-var(Var),!.
edify_vars([],[]):-!.
edify_vars([N=V|T],[N=RV|NT]):-
            eval_lr(V,RV),!,retain_answer(RV),
            edify_vars(T,NT),!.
edify_vars([H|T],[H|NT]):-
            edify_vars(T,NT),!.


% ===================================================================
%  INVOKE REQUEST STANDARD
% ===================================================================


:-dynamic(final_answer/1).
:-dynamic(addToResultBuffer/4).
:-dynamic(requestBuffer_db/4).
:-dynamic(request_start_time/1).
:-dynamic(request_total_time/1).


invokeRequestToBuffer(findall(V,Formula),Ctx,TrackingAtom,Context,User,Vars,CPU):-!,
        invokeRequestToBuffer(Formula,Ctx,TrackingAtom,Context,User,Vars,CPU).
invokeRequestToBuffer(request(Formula),Ctx,TrackingAtom,Context,User,Vars,CPU):-!,
         invokeRequestToBuffer(Formula,Ctx,TrackingAtom,Context,User,Vars,CPU),!.
invokeRequestToBuffer(requestyn(Formula),Ctx,TrackingAtom,Context,User,Vars,CPU):-!,
         invokeRequestToBuffer(Formula,Ctx,TrackingAtom,Context,User,Vars,CPU),!.

invokeRequestToBuffer(canonicalize(Formula),Ctx,TrackingAtom,Context,User,Vars,CPU):-!,
        retractall(requestBuffer_db(_,_,_,_)),
        retractall(final_answer(_)),
        getAssertionClauses(PreQ,Context,Formula,Out,Vars,P),
        retain_answer(Out),
        writeObject('$spacer',Vars),
        asserta(tq_passed),
        asserta(tq_attempted_request),
        asserta(tq_least_one_answer),
        writeObject_conj(Out,Vars).


invokeRequestToBuffer(Formula,Ctx,TrackingAtom,Context,User,Vars,CPU):-
        getCputime(Start),!,
        logOnFailure(createRequestResponseBuffer_proc(Formula,Ctx,TrackingAtom,Context,User,Vars)),
        getCputime(End),ignore(Start=0),ignore(End=0),
        retractall(request_total_time(_)),
        CPU is End - Start,!,ignore(CPU=0),!,
        assert(request_total_time(CPU)),!.


createRequestResponseBuffer_proc(FmlInOpen,Ctx,TrackingAtom,Context,User,Vars):-
        assert(tq_attempted_request),
        retractall(requestBuffer_db(_,_,_,_)),
        retractall(final_answer((_))),
        agentRequest(KIFCharsIn,FmlInOpen,Vars,Ctx,Context,User,UResultsSoFar,Result,Explaination,Status),
        ignore(logOnFailure(retain_answer(Result))),
        writeDebug(addToResultBuffer(UResultsSoFar,Result,Explaination,Status)),
        addToResultBuffer(UResultsSoFar,Result,Explaination,Status),!. % Buffer Calls Itteration via failure

createRequestResponseBuffer_proc(FmlInOpen,Ctx,TrackingAtom,Context,User,Vars):-!.


% ===========================================================
% Buffer Results
% ===========================================================
addToResultBuffer(UResultsSoFar,Result,Explaination,Status):-var(Explaination),!,fail.

addToResultBuffer(UResultsSoFar,Result,Explaination,done(How)):-
        numbervars((UResultsSoFar,Result,Explaination,Status),'$VAR',0,_),
        assert(requestBuffer_db(UResultsSoFar,Result,Explaination,done(How))),
        assert(final_answer(How)),!.    %Finalize on done/1.

addToResultBuffer(UResultsSoFar,Result,Explaination,Status):-
        once((numbervars((UResultsSoFar,Result,Explaination,Status),'$VAR',0,_),
        assert(requestBuffer_db(UResultsSoFar,Result,Explaination,Status)))),
        fail.


% ==========================================
% BELIEF
% .+user nick #channel Ident 
% ==========================================

% :-include('moo_header.pl').
:-dynamic(complete_goal/1).
:-multifile(expireOptimizationsInContext/3).
% :-ensure_loaded(library(occurs)).
       


agentBelief(FmlInOpen,Literal,VarsRequested,Ctx,Context,User,PA, VarsRequested,found(PA),answer(true:PA)):-
	resetTableFlags, 
	flag('$UAnswers',_,0),
	writeDebug(green,'Stage 3 - Positive ':FmlInOpen ),  
	mooBeliefCallTopP(VarsRequested,Literal),
	flag('$UAnswers',UA,UA+1),
	flag('$UAnswers',PA,PA).

agentBelief(FmlInOpen,NLiteral,VarsRequested,Ctx,Context,User,PA, VarsRequested,found(NA),done(false:NA)):-%true,
	flag('$UAnswers',PA,PA),PA<1,
	(NLiteral=..[TopFunctor|Args],(atom_concat('~',FN,TopFunctor);atom_concat('~',TopFunctor,FN))),!,Literal=..[FN|Args],
	writeDebug(red,'Stage 4 - Negative ':not(FmlInOpen)),
	mooBeliefCallTopN(VarsRequested,Literal),
	flag('$UAnswers',UA,UA+1),
	flag('$UAnswers',NA,NA).


				

% =========================================================
% Body Clause Connectives
% =========================================================
mooBeliefCallTopP(VarsRequested,Literal):-
	%call_with_depth_limit(
	mooBeliefLiteral(5,[VarsRequested^[]],Literal).
	%60000,N),
	%N \= depth_limit_exceeded,
	%writeq(N),nl.

mooBeliefCallTopN(VarsRequested,Literal):-
	call_with_depth_limit(mooBeliefLiteral(2,[VarsRequested^[]],Literal),60000,N),
	N \= depth_limit_exceeded,
	writeq(N),nl.
	


:-index(mooBeliefLiteral(0,1,1)).
	
% =========================================================
% Literals Are Called Here
% =========================================================

% ---------------------------------------------------------
% BuiltIns
% ---------------------------------------------------------

mooBeliefLiteral(Depth,PreviousVarSeek,'$fail'(_)):-!,fail.

mooBeliefLiteral(Depth,PreviousVarSeek,equal(CPos1,CPos2)):-!,
	unify_with_occurs_check(CPos1,CPos2).
mooBeliefLiteral(Depth,PreviousVarSeek,'~equal'(CPos1,CPos2)):-!,
	not(mooBeliefLiteral(Depth,PreviousVarSeek,equal(CPos1,CPos2))).

mooBeliefLiteral(Depth,PreviousVarSeek,'~instance'(O,'$Class'(Base))):-!,
				ground(O),O=..[T,A,ToB],not((member(Base,ToB));atom_concat('$',Base,T)),!.

mooBeliefLiteral(Depth,PreviousVarSeek,'$existential'(X,Y,Formula)):-!,ignore(unify_with_occurs_check(X,Y)),!.

mooBeliefLiteral(Depth,SubVarSeek,Goal):-functor(Goal,'~holds',_),!,fail.
				   
%mooBeliefLiteral(Depth,SubVarSeek,instance(O,'$Class'(C)),TopFunctor,FreeVs):-
%	ground(O),writeq(O),nl,arg(2,O,L),!,miclass(L,C).

miclass(L,C):-last(C,L),!. miclass(L,C):-member(C,L).
	
     	
% ---------------------------------------------------------
% Ensure only ONE-CALL however this means that a table 'should be prebuilt'
%    And is one First Call to Predicate Hash
% ---------------------------------------------------------

/*
TopFunctor(S) -> PrototypeRef(S) -> complete(Depth) 
				 -> Anwser(S)
				 -> Derived: sub(PrototypeRef(S))

A Derived PrototypeRef:
		  When we unnumbervars PrototypeRef
		  Unify it to the 'Rules' ProtoType Model since Every Rule has a descriptor to what it can prove (VarIOs)
*/


mooBeliefLiteral(Depth,SubVarSeek,Goal):-mooCache(Goal,_,Context,TN). 

mooBeliefLiteral(Depth,SubVarSeek,subclass('$Class'(S),'$Class'(C))):-!,
	mooCache(A, B, deduceSingleSubclassPathList(S, 'Entity', List)),
	writeq(List),nl,
	member(C,List).

mooBeliefLiteral(Depth,SubVarSeek,domain('$Relation'(R,_),'$Quantity'(N,_),'$Class'(C))):-!,
	mooCache(Context, A, domain_vector(R, N, List,_)),
	nth1(N,List,C).
	
                       
mooBeliefLiteral(Depth,SubVarSeek,Goal):-	
	functor(Goal,TopFunctor,Arity),
	mooBeliefLiteral(TopFunctor,Arity,Depth,SubVarSeek,Goal).
	

mooBeliefLiteral(TopFunctor,Arity,Depth,SubVarSeek,Goal):-noBackchainFunctors(TopFunctor),!,
	noBackchainFunctorsCall(TopFunctor,Arity,Depth,SubVarSeek,Goal).
	
noBackchainFunctorsCall(TopFunctor,Arity,Depth,SubVarSeek,Goal):-!,fail. %mooCache(Goal,_,Context,TN). 
%mooCache(Goal,Ante,ExplainationID:KRVars:KR,Context,TN).	
	
% Blocked preds including all .*On (just backchaining)
noBackchainFunctors(disjointDecomposition). noBackchainFunctors(domain). 
noBackchainFunctors(subclass). 
noBackchainFunctors(copy). 
noBackchainFunctors(version). 
noBackchainFunctors(subrelation). 
noBackchainFunctors(function).
noBackchainFunctors(holds).
noBackchainFunctors(A):-atom(A),(atom_concat(_,'On',A);atom_concat('~',_,A)).



mooBeliefLiteral(TopFunctor,Arity,Depth,SubVarSeek,Goal):-
	free_variables(Goal,FreeVs),
	ensureProtoRef(TopFunctor,GoalPrototype,Goal,PrototypeRef,NumVars),
	mooBeliefCompleteAndRetunTable(PrototypeRef,Depth,SubVarSeek,
		TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype).

% =========================================================
% Find or Define the PrototypeRef for GoalPrototype
% =========================================================

ensureProtoRef(TopFunctor,GoalPrototype,Goal,PrototypeRef,NumVars):-
	% ----------------------------------------------------------------------------------------
	% Condition: GoalPrototype Supplied
	% ----------------------------------------------------------------------------------------
	(nonvar(GoalPrototype) ->
	% ----------------------------------------------------------------------------------------
	% Action: Confirm Access Structures 
	% ----------------------------------------------------------------------------------------
	recorded(TopFunctor,GoalPrototype:NumVars,PrototypeRef) ;
	% ----------------------------------------------------------------------------------------
	% Exception: GoalPrototype not Supplied
	% ExAction: Create GoalPrototype and Next Create PrototypeRef
	% ---------------------------------------------------------------------------------------- 
	(       copy_term(Goal,GoalPrototype),
		numbervars(GoalPrototype,'$VAR',1,NumVars),
		% ----------------------------------------------------------------------------------------
		% Condition: Ref Already Known
		% ----------------------------------------------------------------------------------------
		(recorded(TopFunctor,GoalPrototype:NumVars,PrototypeRef) -> 
		% ----------------------------------------------------------------------------------------
		% Action: Return Known
		% ---------------------------------------------------------------------------------------- 
		true; 
		% ---------------------------------------------------------------------------------------- 
		% Exception: GoalPrototype Not Identical To Previous Request (Ref Not Known)
		% ExAction: Create it, Find SubLinks and Find Parent Links
		% ---------------------------------------------------------------------------------------- 
		 % make a PrototypeRef For Goal
		 (      writeDebug(creating(GoalPrototype)),
			recorda(TopFunctor,GoalPrototype:NumVars,PrototypeRef),
			% Discover stable Model
			% true,
			stableModel(TopFunctor,PrototypeRef,Goal,GoalPrototype))))),!.
	

% Model Mainted Already
stableModel(TopFunctor,PrototypeRef,Pattern,GoalPrototype):-
	recorded(PrototypeRef,complete(0)),!.



% Discover Family Rules
stableModel(TopFunctor,PrototypeRef,Pattern,GoalPrototype):-
	mooCache(Pattern,A,ExplainationID:KRVars:KR,Context,TN),
	once(ensureProtoRef(TopFunctor,_,Pattern,RulePrototypeRef,_)),
	not(RulePrototypeRef=PrototypeRef),
	writeDebug(linking(Pattern,GoalPrototype)),
	(not(Pattern=GoalPrototype) -> 
		stableLink(PrototypeRef,RulePrototypeRef);
		stableLink(RulePrototypeRef,PrototypeRef)),
	fail.
	
% Discover Previously Built Tables?
% Set PrototypeRef Discovery Complete (Depth 0 = complete)
stableModel(TopFunctor,PrototypeRef,Pattern,GoalPrototype):-recorda(PrototypeRef,complete(0)),!.
			
stableLink(SuperPrototypeRef,SubPrototypeRef):-
	(recorded(SuperPrototypeRef,subRef(SubPrototypeRef));recorda(SuperPrototypeRef,subRef(SubPrototypeRef))),!,
	(recorded(SubPrototypeRef,superRef(SuperPrototypeRef));recorda(SubPrototypeRef,superRef(SuperPrototypeRef))),!	.


% =========================================================
% Complete And Retun Table
% =========================================================


mooBeliefCompleteAndRetunTable(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	logOnFailure(mooBeliefCompleteTableLevel(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype)),!,
	mooBeliefReturnTable(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype).


% =========================================================
% Return Tables of More Specific Clauses *FIRST*
% Then Table of PrototypeRef
% =========================================================
mooBeliefReturnTable(PrototypeRef,0,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-!,fail.

% ----------------------------------------------------------------------------------------
% Showall In PrototypeRef 
% ----------------------------------------------------------------------------------------
mooBeliefReturnTable(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	recorded(PrototypeRef,Goal),
	writeDebug(blue,Goal).

% ----------------------------------------------------------------------------------------
% Iterate And Table More Specific Clauses
% ----------------------------------------------------------------------------------------
mooBeliefReturnTable(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	recorded(PrototypeRef,subRef(SubPrototypeRef)),
	recorded(SubPrototypeRef,Goal),
	writeDebug(blue,Goal).
	


% =========================================================
% Record Tables
% =========================================================
mooBeliefRecordBindings(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	(not(recorded(PrototypeRef,Goal)) ->
		(recorda(PrototypeRef,Goal),writeDebug(green,Goal));
		writeDebug(pink,Goal)).

/*
% ----------------------------------------------------------------------------------------
% Iterate And *NOT* Table More General Tables
% ----------------------------------------------------------------------------------------
mooBeliefReturnTable(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	recorded(PrototypeRef,superRef(SuperPrototypeRef)),
	writeDebug(superOf(Goal)),
	mooBeliefReturnTable(SuperPrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype).
*/
	
% =========================================================
% Complete Tables To A Depth
% =========================================================

% ----------------------------------------------------------------------------------------
% Level '0' is always considered complete (Exit)
% ----------------------------------------------------------------------------------------
mooBeliefCompleteTableLevel(PrototypeRef,(0),SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-!.
	
% ----------------------------------------------------------------------------------------
% Highest Level Completed >= Level Requested  (Exit)
% ----------------------------------------------------------------------------------------
mooBeliefCompleteTableLevel(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	% ----------------------------------------------------------------------------------------
	% Condition: Depth is complete therefore All lowers depths *should be*
	% ----------------------------------------------------------------------------------------
	recorded(PrototypeRef,complete(CompletedTableDepth)),
	CompletedTableDepth >= DepthToExplore,
	% ----------------------------------------------------------------------------------------
	% Action: Exit Deterministically
	% ----------------------------------------------------------------------------------------
	!.

% ----------------------------------------------------------------------------------------
% Condition: Depth is not complete therefore All lowers must be complete first before we can proceed
% ----------------------------------------------------------------------------------------
mooBeliefCompleteTableLevel(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	% ----------------------------------------------------------------------------------------
	% Find The greatest completed Depth
	% ----------------------------------------------------------------------------------------
	recorded(PrototypeRef,complete(CompletedTableDepth)),
	% ----------------------------------------------------------------------------------------
	% Get Next Depth
	% ----------------------------------------------------------------------------------------
	NextDepth is CompletedTableDepth + 1,
	% ----------------------------------------------------------------------------------------
	% Build Table for this Next Depth
	% ----------------------------------------------------------------------------------------
	mooBeliefBuildTableLevel(PrototypeRef,NextDepth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype),!,
	% ----------------------------------------------------------------------------------------
	% Try Again to Table to 'DepthToExplore'
	% ----------------------------------------------------------------------------------------
	mooBeliefCompleteTableLevel(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype).

% =========================================================
% Build Tables At A Specific Depth
% =========================================================


mooBeliefBuildTableLevel(PrototypeRef,ThisNextDepth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	% ----------------------------------------------------------------------------------------
	% true to debugger
	% ----------------------------------------------------------------------------------------
	writeDebug(mooBeliefBuildTableLevel(ThisNextDepth,Goal,GoalPrototype,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity)),
	% ----------------------------------------------------------------------------------------
	% Not special predicate blocked for backchaining
	% ----------------------------------------------------------------------------------------
	not(noBackchainFunctors(TopFunctor)),  % could be moved higher up for speed increase?
	% ----------------------------------------------------------------------------------------
	% Not Free Holds Arg1 ( % could enum plug in Relations if it was varibiable? )
	% ----------------------------------------------------------------------------------------
	(TopFunctor='holds' -> (arg(1,Goal,V),ground(V)) ; true), % SHOULD STRIP HOLDS?!?
	% ----------------------------------------------------------------------------------------
	findall(SubPrototypeGoal,
	((
	% ----------------------------------------------------------------------------------------
	% Action: Search for More specific SubPrototypeRef links *first*
	% ----------------------------------------------------------------------------------------
	recorded(PrototypeRef,subRef(SubPrototypeRef)),
	recorded(TopFunctor,SubPrototypeGoal:SubNumVars,SubPrototypeRef),
	writeDebug(subTabling(ThisNextDepth:SubPrototypeGoal)),
	unnumbervars(SubPrototypeGoal,SubGoal),
	% ----------------------------------------------------------------------------------------
	% Action: Bring SubPrototypeRef up to Date (for ThisNextDepth)
	% ----------------------------------------------------------------------------------------
	mooBeliefCompleteTableLevel(SubPrototypeRef,ThisNextDepth,SubVarSeek_,TopFunctor,SubNumVars,_,Arity,SubGoal,SubPrototypeGoal)
	% ----------------------------------------------------------------------------------------
	% Action: Force Next
	% ----------------------------------------------------------------------------------------
	 )),SolvedSubPrototypes),
	 writeDebug(SolvedSubPrototypes),
	% ----------------------------------------------------------------------------------------
	% Finally BELIEF!
	% ----------------------------------------------------------------------------------------
	% Not Too many Free Variables Before rule test
	% ----------------------------------------------------------------------------------------
	% NumVars<6, % could be moved higher up for speed increase? 
	% ----------------------------------------------------------------------
	% Look in Rulebase:
	%      Should *only* 
	%       	less general protoypes,
	%		more general prototypes,
	%		or exact protoypes 
	%		be used?
	% ----------------------------------------------------------------------
	% Lower Depth for calling anteceedants
	% ----------------------------------------------------------------------
	NextLowerDepth is ThisNextDepth -1,
	% ----------------------------------------------------------------------
	mooCache(Goal,Ante,ExplainationID:KRVars:KR,Context,TN), 
	% ----------------------------------------------------------------------
	% Not already Figured from sub prototypes
	% ----------------------------------------------------------------------
	not(memberchk(Goal,SolvedSubPrototypes)),
	% ----------------------------------------------------------------------
	% Find survied Heads vars 
	% ----------------------------------------------------------------------
	free_variables(Goal,NewFreeVs),
	% ----------------------------------------------------------------------
	% See if variables are too deeply used 
	% ----------------------------------------------------------------------
	deepenCheck(4,FreeVs,Lits), % Note: NextLowerDepth is used but may not be appropriate
	% ----------------------------------------------------------------------
	% If they survived the deepen check, Deepen them. ( 'Lits' now holds their aliases. )
	% ----------------------------------------------------------------------
	deepenEach(Lits),
	% ----------------------------------------------------------------------
	% Invoke Rule that upon deterministic (good or bad) the 'Lits' should have been undeepened.
	% ----------------------------------------------------------------------
	mooBeliefLiteralTryLitVars(PrototypeRef,NextLowerDepth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
		Ante,ExplainationID:KRVars:KR,Context,TN,Lits),
	% ----------------------------------------------------------------------
	% Fail forces more solutions to be found
	% ----------------------------------------------------------------------
	fail.
	 
mooBeliefBuildTableLevel(PrototypeRef,ThisNextDepth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype):-
	% ----------------------------------------------------------------------
	% Give Deterministic Exit to build
	% ----------------------------------------------------------------------
	recorda(PrototypeRef,complete(ThisNextDepth)),!.


% Deterministically Find 'Body Belief Mechanism' and call it non deterministicly
mooBeliefLiteralTryLitVars(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	Ante,ExplainationID:KRVars:KR,Context,TN,Lits):-
	mooBeliefLiteralTryBodyMechanism(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Ante,ExplainationID:KRVars:KR,Context,TN,Lits).     
	
% fullfills obligation above: " 'Lits' should have been undeepened"
mooBeliefLiteralTryLitVars(PrototypeRef,DepthToExplore,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	_Ante,ExplainationID:KRVars:KR,Context,TN,Lits):-undeepenEach(Lits),!,fail.

% =========================================================
% Body Belief Mechanisms
% =========================================================
:-index(mooBeliefLiteralTryBodyMechanism(0,0,0,0,0,0,0,0,1,0,0,0,0,0)).
	
% ----------------------------------------------------------------------
% DEBUGGING HACK BLOCK ALL ~HEADS  (Negated Goal Literals)
% ----------------------------------------------------------------------
mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	Ante,ExplainationID:KRVars:KR,Context,TN,Lits):-
	% Write Ante to debugger
	writeDebug(Ante),
	% No negs
	functor(Ante,AF,_),
	atom_concat('f~',_,AF),!,fail.


% ----------------------------------------------------------------------
% Condition: The body is constructed exclusvely from Head Varibles (HVs)
% Action: Find all unique sets of HVs
% Exception: Except when Head is for a Negated Literal
% ExAction: Definite failure (hack for now)
% ----------------------------------------------------------------------
mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~Head'(BodyGoal,HeadV,BodyV,HV),ExplainationID:KRVars:KR,Context,TN,Lits):-
	buildVarSeek(HV^[],PreviousVarSeek,BodyVarSeek,BodyGoal,NewBodyGoal),!,
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,BodyGoal).

% ----------------------------------------------------------------------
% Condition: The body is not related to head in any way
% Action: Find one UB set that exists for the Head
% Exception: Except when Head is for a Negated Literal
% ExAction: Definite failure (hack for now)
% ----------------------------------------------------------------------
mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~Univb'(BodyGoal,HeadV,BodyV,UB),ExplainationID:KRVars:KR,Context,TN,Lits):-!,
	buildVarSeek([]^UB,PreviousVarSeek,BodyVarSeek,BodyGoal,NewBodyGoal),!,
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,BodyGoal),!.

	
% ----------------------------------------------------------------------
% Condition: Head Vars (HVs), but all body exclusive (UBs) are disjoint from each other
% Action: Find only one ground UB set that exists for each unique HV set
% Exception: Except when Head is for a Negated Literal
% ExAction: Definite failure (hack for now)
% ----------------------------------------------------------------------

mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~HeadUnivb'(BodyGoal,HeadV,BodyV,HV,UB),ExplainationID:KRVars:KR,Context,TN,Lits):-
	arg(1,BodyGoal,G),%arg(1,G,P),
	arg(1,G,[_|_]),!,fail.

mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~HeadUnivb'(BodyGoal,HeadV,BodyV,HV,[UB]),ExplainationID:KRVars:KR,Context,TN,Lits):-!,
	writeDebug(red,bagof(UB,BodyGoal,HV)),!,
	bagof(UB,
		mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,
			TopFunctor,NumVars,FreeVs,Arity,Goal,
			GoalPrototype,Context,Lits,ExplainationID,TN,BodyGoal),Ignored).

mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~HeadUnivb'(BodyGoal,HeadV,BodyV,HV,UB),ExplainationID:KRVars:KR,Context,TN,Lits):-!,
	buildVarSeek(HV^UB,PreviousVarSeek,BodyVarSeek,BodyGoal,NewBodyGoal),!,
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,BodyGoal).


% ----------------------------------------------------------------------
% Condition: Head Vars (HVs), and all body connected (BCs) no disjoint Body variables
% Action: Find each unique HV set with one ground BC set
% Exception: Except when Head is for a Negated Literal
% ExAction: Definite failure (hack for now)
% ----------------------------------------------------------------------
mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~HeadBodyc'(BodyGoal,HeadV,BodyV,HV,BC),ExplainationID:KRVars:KR,Context,TN,Lits):-!,
	buildVarSeek(HV^BC,PreviousVarSeek,BodyVarSeek,BodyGoal,NewBodyGoal),!,
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,BodyGoal).

% ----------------------------------------------------------------------
% Condition: Head Vars (HVs), and all body connected (BCs) and some disjoint Body variables (UBs)
% Action: Find each unique HV set with one ground BC set and ignore UBs
% Exception: Except when Head is for a Negated Literal
% ExAction: Definite failure (hack for now)
% ----------------------------------------------------------------------
mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	't~HeadBodycUnivb'(BodyGoal,HeadV,BodyV,HV,BC,UB),ExplainationID:KRVars:KR,Context,TN,Lits):-!,
	buildVarSeek(HV^BC^UB,PreviousVarSeek,BodyVarSeek,BodyGoal,NewBodyGoal),!,
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,BodyGoal).
	
% Sanity Check
mooBeliefLiteralTryBodyMechanism(PrototypeRef,Depth,PreviousVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,
	Unk,ExplainationID:KRVars:KR,Context,TN,Lits):-
	writeDebug(unknownMechanism:mooBeliefLiteralTryBodyMechanism(Unk)),!,fail.


% =========================================================
% Call Body Conjunctions
% =========================================================
:-index(mooBeliefCallBodyJunctions(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)).

% First/Then
mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,
	(CPos1,CPos2)):-!,
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,CPos1),
	mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,CPos2).

% disjoint eigther/or
mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,
	or(CPos1,CPos2)):-!,
	(mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,CPos1),!);
	(mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,CPos2),!).

% clean of further junctions
mooBeliefCallBodyJunctions(HeadV,BodyV,PrototypeRef,Depth,BodyVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,ExplainationID,TN,
	CPos):-%true,
	mooBeliefPropositionMechanism(HeadV,BodyV,PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,CPos).


% =========================================================
% Propostional Control Mechanisms
% =========================================================
:-index(mooBeliefPropositionMechanism(0,0,0,0,0,0,0,0,0,0,0,0,0,1)).

/* built as
	
	ConditionalClass=..[Sign,Conditional,HeadV,BodyVars,
		CUniversalBody,CBodyOnlyConected,CHeadVSingleInBody,CSplitHeadVar].
 */


% Only Universal Body Vars in this Proposition
mooBeliefPropositionMechanism(HeadV,BodyV,PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,
	't~'(LiteralGoal,CUniversalBody,[],[],[])):-!,
	once(mooBeliefCallProposition(PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,LiteralGoal)).


% Only Body Vars in this Proposition
mooBeliefPropositionMechanism(HeadV,BodyV,PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,
	't~'(LiteralGoal,CUniversalBody,CBodyOnlyConected,CHeadVSingleInBody,CSplitHeadVar)):-!,
	selectMech(CUniversalBody,CBodyOnlyConected,CHeadVSingleInBody,CSplitHeadVar,HeadV,BodyV,LiteralGoal,ClauseVarSeek,NewLiteralGoal),!,
	mooBeliefCallProposition(PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,NewLiteralGoal).

selectMech(  []  ,  []  ,  []  ,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,'$once'(LiteralGoal)).
	
selectMech(  []  ,  []  ,  []  ,[CSplitHeadVar],
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,if_then('$oneGround'([CSplitHeadVar|HeadV]),LiteralGoal)).
	
selectMech(  []  ,  []  ,  []  ,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,if_then('$oneGround'(CSplitHeadVar),LiteralGoal)).


selectMech(  []  ,  []  ,CHeadVSingleInBody,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
	
selectMech(  []  ,  []  ,CHeadVSingleInBody,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(  []  ,CBodyOnlyConected,  []  ,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(  []  ,CBodyOnlyConected,  []  ,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(  []  ,CBodyOnlyConected,CHeadVSingleInBody,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(  []  ,CBodyOnlyConected,CHeadVSingleInBody,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,  []  ,  []  ,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,  []  ,  []  ,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,  []  ,CHeadVSingleInBody,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,  []  ,CHeadVSingleInBody,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,CBodyOnlyConected,  []  ,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,CBodyOnlyConected,  []  ,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,CBodyOnlyConected,CHeadVSingleInBody,  []  ,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).
selectMech(CUniversalBody,CBodyOnlyConected,CHeadVSingleInBody,CSplitHeadVar,
	HeadV,BodyV,LiteralGoal,ClauseVarSeek,LiteralGoal).


% Only Body Vars in this Proposition
mooBeliefPropositionMechanism(HeadV,BodyV,PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,
	't~'(LiteralGoal,CUniversalBody,CBodyOnlyConected,[],[])):-!,
	oneGround(HeadV),
	mooBeliefCallProposition(PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,LiteralGoal).

mooBeliefPropositionMechanism(HeadV,BodyV,PrototypeRef,Depth,ClauseVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Lits,
	Ante):-	true,
	writeDebug(unkown:HeadV:BodyV:Ante),fail.

oneGround([]).
oneGround([_]).
oneGround([A,B]):-!,ground(A);ground(B).
oneGround([A,_,B]):-ground(A);ground(B).
oneGround([_,A,_|B]):-!,ground(A);ground(B).


% =========================================================
% Call An Anteceedant
% 	Loops back into starting a new table 
% =========================================================

mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,
	'$oneGround'(Vars)):-!,oneGround(Vars),!.

mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,
	'$once'(Goal)):-
	mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,
	Goal),!.

mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,
	'$findAll'(Vs,Goal)):-
	findall(Vs,mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,
	Goal),VsU),sort(VsU,VsS),!,member(Vs,VsS).
	
mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,
	if_then(Condition,LiteralGoal)):-
	mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,
		TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,Condition),!,
	mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,
		TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,LiteralGoal).

mooBeliefCallProposition(PrototypeRef,Depth,SubVarSeek,TopFunctor,NumVars,FreeVs,Arity,Goal,GoalPrototype,Context,NewLiteralGoal):-
	mooBeliefLiteral(Depth,SubVarSeek,NewLiteralGoal).

% =========================================================
% Var Seeking Utility Can manipulate A Goal in such a way that only productive vars ar sought after
% It also rebuilds the seekage afterwards
% =========================================================
buildVarSeek(_,PreviousVarSeek,PreviousVarSeek,Goal,Goal):-!.
%true,!.

willFindSeek(_,PreviousVarSeek,PreviousVarSeek,Goal,Goal):-!.

% =========================================================
% Variable iterative deepening Utility (globally shared between all tables)
% =========================================================
deepenCheck(Max,[],[]):-!.
deepenCheck(Max,[V|Vs],[VN|VNs]):-
	deepenCheckV(Max,V,VN),!,
	deepenCheck(Max,Vs,VNs).
	
deepenCheckV(Max,V,Vn):-
	term_to_atom(V,Vn),
	flag(Vn,D,D), D < Max.
		
deepenEach([]):-!.
deepenEach([Vn|Vs]):-flag(Vn,D,D+1),deepenEach(Vs),!.

undeepenEach([]):-!.
undeepenEach([Vn|Vs]):-flag(Vn,D,D-1),undeepenEach(Vs),!.









/*

:-index(mooBeliefLiteral(0,0,1,1,1,0,0,0,1)).

mooBeliefLiteral(Depth,PreviousVarSeek,Term,Major,'t~',Rest,Body,GoalTemplate,More):-!, 
	Depth>0,
	free_variables(PreviousVarSeek,UVarSeek),
	free_variables(More,FreeVarsBody),
	set_partition(UVarSeek,FreeVarsBody,Collected,NewInBody,Carried),
	writeq(('<font color=green>':Depth,carriedN:Carried,newInBodyN:NewInBody,collectedN:Collected:'</font>')),nl,!,
	deepenCheck(4,Carried,LitCarried),!,
	deepenEach(LitCarried),!,
	mooBeliefCallVD(LitCarried,Depth,[FreeVarsBody|UVarSeek],Goal,TopFunctor,Arity,Two,Rest,Body,NewInBody,Carried).


mooBeliefCallVD(LitCarried,Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,NewInBody,Carried):-
	mooBeliefCallV(Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,NewInBody,Carried).
mooBeliefCallVD(LitCarried,Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,NewInBody,Carried):-
	undeepenEach(LitCarried),!.
	
% Some Carried and new in body (fail)
mooBeliefCallV(Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,[_|_],[_|_]):-fail,
	Depth2 is Depth-2,
	mooBeliefLiteral(Depth2,
		PreviousVarSeek,Body).

% None Carried no new in body (Expansion)
mooBeliefCallV(Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,[],[]):-!,
	Depth2 is Depth+1,
	mooBeliefLiteral(Depth2,
		PreviousVarSeek,Body).

% Some Carried no new in body (Shorten Depth)
mooBeliefCallV(Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,[],[_|_]):-
	Depth2 is Depth-1,
	mooBeliefLiteral(Depth2,
		PreviousVarSeek,Body).

% None Carried new in body (Shorten Depth)
mooBeliefCallV(Depth,PreviousVarSeek,Goal,TopFunctor,Arity,Two,Rest,Body,[_|_],[]):-!,
	Depth2 is Depth-1,
	mooBeliefLiteral(Depth2,
		PreviousVarSeek,Body).


mooBeliefLiteral(Depth,PreviousVarSeek,Term,Major,'f~',Rest,Body,GoalTemplate,More):-!,fail,
	Depth>0,
	free_variables(PF,UVarSeek),free_variables(Body,FreeVarsBody),
	set_partition(UVarSeek,FreeVarsBody,Collected,NewInBody,Carried),
	writeq(('<font color=red>':Depth,carriedN:Carried,newInBodyN:NewInBody,collectedN:Collected:'</font>')),nl,!,
	deepenCheckW(3,Carried,LitCarried),!,
	deepenEach(LitCarried),!,
	mooBeliefCallVD(LitCarried,Depth,[FreeVarsBody,PF|OVarSeek],Goal,TopFunctor,Arity,Two,Rest,Body,Collected,NewInBody,Carried).

mooBeliefLiteral(Depth,_,'$grInstance'(Term),'$grInstance',_,Rest,Body,GoalTemplate,More):-!,
		mooBeliefLiteral(Depth,PreviousVarSeek,instance(Term,_)).

mooBeliefLiteral(Depth,_,'$grDomain'(P,N,Goal),'$grDomain',_,Rest,Body,GoalTemplate,More):-!,
		mooCache(domain(P,N,Goal),_,Context,TN).


mooBeliefLiteral(Depth,PreviousVarSeek,Goal,'Z_Uvar_',Two,Rest,Body,SingleUVar,[]):-!,
	once((mooBeliefLiteral(Depth,PreviousVarSeek,Body),tground(SingleUVar))).
	
mooBeliefLiteral(Depth,PreviousVarSeek,Goal,'Z_Uvar_bodyConnectedVar_',Two,Rest,Body,SingleUVar,[BodyConnectedVar]):-!,
	once((mooBeliefLiteral(Depth,PreviousVarSeek,Body),tground(SingleUVar))).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,'Z_Uvar_singleHeadVar_',Two,Rest,Body,SingleUVar,[SingleHeadVar]):-!,
	once((mooBeliefLiteral(Depth,PreviousVarSeek,Body),tground(SingleUVar))).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,'Z_Uvar_amulitHeadVar_',Two,Rest,Body,SingleUVar,[MulitHeadVar]):-!,
	findall(MulitHeadVar:SingleUVar,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar:SingleUVar,AnsS).

tground(X):-ground(X).


	
mooBeliefLiteral(Depth,_,Goal,Major,Two,Rest,Body,GoalTemplate,More):-writeq(Goal),nl,fail. 

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,bodyConnectedVar_,Two,Rest,Body,MulitHeadVar,More):-!,
	mooBeliefLiteral(Depth,PreviousVarSeek,Body).
  
mooBeliefLiteral(Depth,PreviousVarSeek,Goal,amulitHeadVar_singleHeadVar_bodyConnectedVar_,Two,Rest,Body,MulitHeadVar,[S,BCV]):-!,
	findall(MulitHeadVar:S,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar:S,AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,amulitHeadVar_singleHeadVar_,Two,Rest,Body,MulitHeadVar,[S]):-!,
	findall(MulitHeadVar:S,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar:S,AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,amulitHeadVar_,Two,Rest,Body,MulitHeadVar,More):-!,
	findall(MulitHeadVar,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar,AnsS).
	
mooBeliefLiteral(Depth,PreviousVarSeek,Goal,amulitHeadVar_bodyConnectedVar_,Two,Rest,Body,MulitHeadVar,More):-!,
	findall(MulitHeadVar,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar,AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,singleHeadVar_,Two,Rest,Body,MulitHeadVar,More):-!,
	findall(MulitHeadVar,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar,AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,singleHeadVar_bodyConnectedVar_,Two,Rest,Body,MulitHeadVar,More):-!,
	findall(MulitHeadVar,mooBeliefLiteral(Depth,PreviousVarSeek,Body),Ans),
	sort(Ans,AnsS),!,
	member(MulitHeadVar,AnsS).	


mooBeliefLiteral(Depth,_,'$unifyCheck'(Term1,Term2,_),'$unifyCheck',_,Rest,Body,GoalTemplate,More):-!,
		Term1=Term2.
		
mooBeliefLiteral(Depth,_,Term,_,'$g',Rest,Body,GoalTemplate,More):-!,ground(Term).

mooBeliefLiteral(Depth,PreviousVarSeek,Goal,Major,Two,Rest,Body,GoalTemplate,More):-mooCache(Goal,_,Context,TN). % ExplainationID:KRVars:KR
		   */     										

si(TopFunctor,X):-
	prolog_frame_attribute(TopFunctor,X,Y),writeq(Y),nl,
	!.

si(X):-
	prolog_current_frame(TopFunctor), R=R,
	prolog_frame_attribute(TopFunctor,X,Y),writeq(Y),nl,
	!.


	
writeColor(Color,Thing,Vars):-
	ignore(writeObject(colourize(Color,Thing),Vars)),!.
writeColor(Color,Thing):-
	ignore(writeObject(colourize(Color,Thing),_)),!.


		    /*

mooBeliefLiteral(Depth,PreviousVarSeek,('t~UnivHead'(Body, HeadTemplate, UniV,HeadVars))):- !,
	once((mooBeliefLiteral(Depth,(HeadTemplate,PreviousVarSeek),Body),ground(Univ))),!.

mooBeliefLiteral(Depth,PreviousVarSeek,('t~UnivDouble'(Body, HeadTemplate, UniV,HeadVars))):- !,
	once((mooBeliefLiteral(Depth,(HeadTemplate,PreviousVarSeek),Body),ground(Univ))),!.

mooBeliefLiteral(Depth,PreviousVarSeek,('t~HeadBody'(Body, HeadTemplate,HeadVars,BodyV))):- !,
	findall(HeadVars,(mooBeliefLiteral(Depth,(HeadTemplate,PreviousVarSeek),Body),ground(BodyV)),Ans),!,
	sort(Ans,AnsS),!,
	member(HeadVars,AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,('t~HeadBodyDouble'(Body, HeadTemplate,HeadVars,BodyV,HeadVarsDouble))):- !,
	findall(HeadVars^HeadVarsDouble,(mooBeliefLiteral(Depth,(HeadTemplate,PreviousVarSeek),Body),ground(BodyV)),Ans),!,
	sort(Ans,AnsS),!,
	member((HeadVars^HeadVarsDouble),AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,('t~UnivHeadBody'(Body, HeadTemplate,UniV,HeadVars,BodyV,HeadVarsDouble))):- !,
	findall(HeadVars^HeadVarsDouble,(mooBeliefLiteral(Depth,(HeadTemplate,PreviousVarSeek),Body),ground((UniV,BodyV))),Ans),!,
	sort(Ans,AnsS),!,
	member((HeadVars^HeadVarsDouble),AnsS).

mooBeliefLiteral(Depth,PreviousVarSeek,('t~Headtest'(Body,HeadTemplate,HeadVars))):- !,ground(HeadVars),
	once((mooBeliefLiteral(Depth,(HeadTemplate,PreviousVarSeek),Body))),!.
			       */




/*
t_CPosDVars_('$v'(A),
	 '$existential'(A, 
	 [63, 79, 82, 71, 65, 78, 73, 83, 77],
	  instance([63, 79, 82, 71, 65, 78, 73, 83, 77], 'Organism')and part(B, [63, 79, 82, 71, 65, 78, 73, 83, 77])),
	  '$v'(B))

*/
	
	
%	'$v'(_G273), 
%	'$existential'(_G273, [63, 80, 85, 66], instance([63, 80, 85, 66], 'Publication')and agent([63, 80, 85, 66], _G313)and patient([63, 80, 85, 66], _G328)), 
		
%        '$v'(_G313, _G328),  % Discontected getPrologVars
%	holds('$Relation'(publishes, ['Predicate', 'BinaryPredicate']), '$Object'(_G358, ['Agent'|_G362]), '$Class'(_G364, _G365)))







write_int(Body,RealLiteral):-
	unwrapPatterns(RealLiteral,URealLiteral),writeq(URealLiteral),nl.


mcf1 :- mcf(instance(X,Y)).
mcf2 :- mcf(subclass(X,Y)).
 
mcf(URealLiteral):-mcf(URealLiteral,6).


wrapPatternArgs(URealLiteral,RealLiteral):-!,
	mapOnConj(unwrapPatternsProc,RealLiteral,URealLiteral).
	

mcf(URealLiteral,Bm):-
	resetTableFlags,%true,		 
	wrapPatternArgs(URealLiteral,RealLiteral),!,
	getCputime(B),
     %   findall(URealLiteral,(deduceCanGoal(Context,RealLiteral,Bm),write(URealLiteral),nl),Total),
        findall(URealLiteral,(deduceDepthBoundGoal(RealLiteral,Context,[],Bm,O),write(URealLiteral:O),nl),Total),
	getCputime(E),
	sort(Total,Sorted),
	length(Total,N),
	length(Sorted,SortedN),
	write(Sorted),nl,
	T is E-B,
	write(found:N:unique:SortedN:T:seconds),nl.


% ===================================
% Export to prolog file
% ===================================

exportToProlog(Context):-
	tell(Context),fail.
	
exportToProlog(Context):-
	format(':-include(''moo_header.pl'').\n\n'),
	mooCache(Goal,ExplainationID:KRVars:KR,Context,TN),
	format('~q.\n\n',[Goal:-accessed(ExplainationID,KRVars,KR,TN)]),
	fail.
exportToProlog(Context):-
	mooCache(Goal,A,ExplainationID:KRVars:KR,Context,TN),
	format('~q :-\n\t\t\t~q.\n\n',[Goal,(mooBeliefLiteral(Depth,PreviousVarSeek,A),accessed(ExplainationID,KRVars,KR,TN))]),
	fail.
	
exportToProlog(Context):-
	told,[Context].


accessed(ExplainationID,KRVars,KR,TN).


:-index(deduceInCurrentModel(0,0,0,1,0)).

deduceInCurrentModel(Context,P,[],P):-!.
deduceInCurrentModel(Context,P,prove(_),_):-!,fail.
deduceInCurrentModel(Context,P,ifThen(_,_),_):-!,fail.
deduceInCurrentModel(Context,P,impossible(_),_):-!,fail.
deduceInCurrentModel(Context,P,and(_,_),_):-!,fail.
deduceInCurrentModel(Context,P,not(_),_):-!,fail.
deduceInCurrentModel(Context,P,TopFunctor,P):-functor(TopFunctor,function,_),!,fail. %%ground(TopFunctor).
deduceInCurrentModel(Context,P,'$existential'(v(_,V,_),Y,TopFunctor),[TopFunctor|P]):-!,ignore(unify_with_occurs_check(TopFunctor,V)),!.
deduceInCurrentModel(Context,P,(A,Literal),O):-!,deduceInCurrentModel(Context,P,A,M),deduceInCurrentModel(Context,M,Literal,O).
deduceInCurrentModel(Context,P,Literal,[TN|P]):-
	isDeducedOrKnown(Literal,TN).

isNotAvailable(P,Literal):-fail.
isDeducedOrKnownEitherWay(L,P):-isDeducedOrKnown(L,P).


deduceDepthBoundGoal([],Context,P,Bm,P):-!.
deduceDepthBoundGoal([Body|Second],Context,P,Bm,O):-!, 
       % not(usedAtLeastEver(TN)),
	deduceDepthBoundGoal(Body,Context,P,Bm,M),
	Bn is Bm -1,
	deduceDepthBoundGoal(Second,Context,M,Bn,O).

%deduceDepthBoundGoal(Literal,Context,P,Bm,P):-writeDebug(deduceDepthBoundGoal(Literal,Context,P,Bm)),fail.
deduceDepthBoundGoal(Literal,Context,P,Bm,P):-Bm <1,!,deduceInCurrentModel(Context,_Ctx,P,Literal,O).

deduceDepthBoundGoal(and(Body,Second),Context,P,Bm,O):-!,
       % not(usedAtLeastEver(TN)),
	deduceInCurrentModel(Context,[TN:KRVars|P],Body,M),
	Bn is Bm -1,
	deduceDepthBoundGoal(Second,Context,M,Bn,O).

deduceDepthBoundGoal(not(Body),Context,P,Bm,O):-!,
	deduceDepthBoundGoal(impossible(Body),Context,P,Bm,O).

deduceDepthBoundGoal(Literal,Context,P,Bm,O):-
	(deduceInCurrentModel(Context,_Ctx,P,Literal,O);
			(mooCache(Literal,Body,TN:KRVars:_,Context,_Ctx,_),
			((length(KRVars,Goal),(Goal<Bm))),
			not((memberchk(TN:KRVars,P),numbervars(Literal,'$VAR',0,_),isDeducedOrKnownEitherWay(Literal,_))),
			writeDebug(deduceUsageOfRule(Body,Bm,TN,KRVars,P,Literal)),
			deduceUsageOfRule(Context,TN,KRVars,P,Literal,Body,Bm,O))).
			% Was Asserted
			
/*
deduceUsageOfRule(Context,TN,KRVars,P,Literal,Body,0,O):-!,
	deduceInCurrentModel(Context,P,Body,O).
*/

deduceUsageOfRule(Context,TN,KRVars,P,Literal,unoptimized(Body),D,O):-!,fail.

deduceUsageOfRule(Context,TN,KRVars,P,Literal,[],Bm,P).

deduceUsageOfRule(Context,TN,KRVars,P,Literal,ifThen(findall(Vars,Firstly),Second),Bm,[O|M]):-!,
       % not(usedAtLeastEver(TN)),
	Bn is Bm -1,
	findall(Vars,
		(deduceDepthBoundGoal(Firstly,Context,[TN:KRVars|P],Bn,M),stableGround(Vars)),List),
	sort(List,ListS),
	writeDebug(green,getPrologVars(Vars)),
	member(Vars,ListS),
	deduceDepthBoundGoal(Second,Context,P,Bn,O),
	putDeducedNew(Literal,O,[M,O]).
	

deduceUsageOfRule(Context,TN,KRVars,P,Literal,'$existential'(v(_,V,_),Y,TopFunctor),Bm,[TN:TopFunctor|P]):-!,ignore(unify_with_occurs_check(TopFunctor,V)),!.

deduceUsageOfRule(Context,TN,KRVars,P,Literal,ifThen(Firstly,Second),Bm,[O|M]):-!,
       % not(usedAtLeastEver(TN)),
	Bn is Bm -1,
	deduceDepthBoundGoal(Firstly,Context,[TN:KRVars|P],Bn,M),
	stableGround(Firstly),
	deduceDepthBoundGoal(Second,Context,P,Bn,O),
	putDeducedNew(Literal,O,[M,O]).


deduceUsageOfRule(Context,TN,KRVars,P,Literal,prove(Body),D,O):-!,
	 not(memberchk(TN:KRVars,P)),!,
	D2 is D -1,
	deduceDepthBoundGoal(Body,Context,[TN:KRVars|P],D2,O),
	putDeducedNew(Literal,O).

/*
	deduceInCurrentModel(Context,[r(TN,Body,KRVars)|P],Body,O),!,
	putDeducedNew(Literal,O).
  */

deduceUsageOfRule(Context,TN,KRVars,P,Literal,Body,D,O):-ground(Literal),!,
       % not(usedAtLeastEver(TN)),
	deduceInCurrentModel(Context,[r(TN,Body,KRVars)|P],Body,O),!,
	putDeducedNew(Literal,O).
	

deduceUsageOfRule(Context,TN,KRVars,P,Literal,Body,D,O):-
	D2 is D -1,
	deduceDepthBoundGoal(Body,Context,[TN:KRVars|P],D2,O),
	putDeducedNew(Literal,O).


isNotAvailableBackChain(_,_):-fail.

isDeducedOrKnown(Lit,Explaination):-
	(mooCache(Lit,_, Context, Ctx, Explaination);recorded(Lit,Lit:Explaination)).
putDeduced(Lit,Explaination):-(isDeducedOrKnown(Lit,_);recorda(Lit,Lit:Explaination)),!,writeDebug(green,learned(Lit)).
putDeducedNew(Lit,Explaination):-recorda(Lit,Lit:Explaination).


memberchk_cnj(Lit,(Lit,_)).	
memberchk_cnj(Lit,(Lit)).	
memberchk_cnj(Lit,(_,A)):-memberchk_cnj(Lit,A).


/*
mooCache(holds(v('Abstract', modalProperty, ['Relation', 'Predicate', 'BinaryPredicate'|A]), v('Physical', B, ['Object', 'ContentBearingObject', 'LinguisticExpression', 'Phrase', 'Clause', 'Sentence', 'Formula'|Goal]), v('Abstract', D, ['Attribute', 'NormativeProperty'|E])), prove([holds(v('Abstract', modalProperty, ['Relation', 'Predicate', 'BinaryPredicate'|TopFunctor]), v('Physical', G, ['Object', 'ContentBearingObject', 'LinguisticExpression', 'Phrase', 'Clause', 'Sentence', 'Formula'|H]), v('Abstract', D, ['Attribute', 'NormativeProperty'|E])), entails(v('Physical', G, ['Object', 'ContentBearingObject', 'LinguisticExpression', 'Phrase', 'Clause', 'Sentence', 'Formula'|H]), v('Physical', B, ['Object', 'ContentBearingObject', 'LinguisticExpression', 'Phrase', 'Clause', 'Sentence', 'Formula'|Goal]))]), 
	110343:['FORMULA1'=G, 'PROP'=D, 'FORMULA2'=B]:entails(and(modalProperty(G, D), entails(G, B)), modalProperty(B, D))

	, 'PrologMOO', 'QUALITIES', 7453).
*/


:-index(deduceGoal(0,0,1,1,0,1,1)).

deduceGoal(Context,ExplainationIn,MaxVars,(H,T),ExplainationOut):-
	deduceGoal(Context,ExplainationIn,MaxVars,H,ExplainationMid),
	deduceGoal(Context,ExplainationMid,MaxVars,T,ExplainationOut).

/*
deduceGoal(Context,ExplainationIn,MaxVars,not NLiteral,Refs):-!,% true,
	NLiteral=..[TopFunctor|Args],(atom_concat('~',FN,TopFunctor);atom_concat('~',TopFunctor,FN)),!,
		not(Literal=..[FN|Args],!,deduceGoal(Context,ExplainationIn,MaxVars,Literal,Refs)),!.
*/

deduceGoal(Context,ExplainationIn,MaxVars,\+ Literal,ExplainationIn):-!,not(deduceGoal(Context,[neg|ExplainationIn],MaxVars,Literal,_)),!.



	
deduceGoal(Context,ExplainationIn,MaxVars,'$existential'(v(_,TopFunctor,_),A,TopFunctor),_):-!,ignore(V=TopFunctor). %,numbervars(TopFunctor,'skolem',0,_),!.

/*
deduceGoal(Context,ExplainationIn,MaxVars,Literal,ExplainationOut):-
		Literal=..[TopFunctor|Args],deduceGoalF(Context,ExplainationIn,MaxVars,TopFunctor,Literal,Args,ExplainationOut).

deduceGoalF(Context,ExplainationIn,MaxVars,holds,Literal,[v(_,TopFunctor,_)|Args],Ref):-
	atom(TopFunctor),!,NewGoal=..[TopFunctor|Args],deduceGoalDB(Context,ExplainationIn,MaxVars,NewGoal,Ref).
deduceGoalF(Context,ExplainationIn,MaxVars,holds,Literal,[TopFunctor|Args],Ref):-!,
	atom(TopFunctor),NewGoal=..[TopFunctor|Args],deduceGoalDB(Context,ExplainationIn,MaxVars,NewGoal,Ref).
deduceGoalF(Context,ExplainationIn,MaxVars,TopFunctor,Literal,Args,Ref):-
	NewGoal=..[holds,TopFunctor|Args],deduceGoalDB(Context,ExplainationIn,MaxVars,NewGoal,Ref).
deduceGoalF(Context,ExplainationIn,MaxVars,TopFunctor,Literal,Args,Ref):-
	NewGoal=..[holds,v(_,TopFunctor,_)|Args],deduceGoalDB(Context,ExplainationIn,MaxVars,NewGoal,Ref).


mooRulebase(RealLiteral,Body,TN:KRVars):-
	mooCache(RealLiteral,guard(RFVH,FVH,Body,CLID,KRVars,RuleVars,UnivLiteral,BodyUniv,
	BodySelfConnected,Shared,PrivLiteral,FakeLiteral),Key,Context,TN).


finishgaf(Literal,Bm):-
        mooCache(Lit,_, Context, Ctx, TN),
        memberchk_cnj(Lit,Body),
        mooRulebase(Literal,Body,RN),    %%  true,
	deduceCanGoal(Context,Literal,Body,0).
	

deduceCanGoal(Context,'$existential'(v(_,V,_),Y,TopFunctor)):-!,ignore(unify_with_occurs_check(TopFunctor,V)),!.
deduceCanGoal(Context,(A,Literal)):-!,
	deduceCanGoal(Context,A),deduceCanGoal(Context,Literal).
deduceCanGoal(Context,Literal):-mooCache(Literal,_, Context, Ctx, TN).

deduceCanGoal(Context,Literal,Bm):-
	deduceCanGoal(Context,Literal);
	( Bm>0, 
        mooRulebase(Literal,Body,RN,Goal),
	Goal<Bm,     %true,
	Bn is Bm -1,
	deduceCanGoal(Context,Literal,Body,Bn)).
	
deduceCanGoal(Context,Literal,Body,Bn):-ground(Literal),!,deduceCanGoal(Context,Body,Bn),!,not(mooCache(Literal,_, Context, Ctx, _)).
deduceCanGoal(Context,Literal,Body,0):-!,deduceCanGoal(Context,Body).
deduceCanGoal(Context,Literal,Body,N):-deduceCanGoal(Context,Body,N).

memberchk_cnj(Lit,(Lit,_)).	
memberchk_cnj(Lit,(Lit)).	
memberchk_cnj(Lit,(_,A)):-memberchk_cnj(Lit,A).

mooRulebase(RealLiteral,Body,TN,N):-
		mooRulebase(RealLiteral,Body,TN:KRVars),length(KRVars,N).

mooRulebase(RealLiteral,Body,TN:KRVars):-
	mooCache(RealLiteral,guard(RFVH,FVH,Body,CLID,KRVars,RuleVars,UnivLiteral,BodyUniv,
	BodySelfConnected,Shared,PrivLiteral,FakeLiteral),Key,Context,TN).
	
								    */


	%,ground(RealLiteral))).
	%deduceCanGoal(Context,Body,Bn).

/*
mcf(URealLiteral,Bm):- Bn is Bm +1,
	unwrapPatterns(RealLiteral,URealLiteral),
	%mooCache(Lit,_, Context, Ctx, TN),
*/
/*
	memberchk_cnj(Lit,Body),
	%not((ground(RealLiteral),deduceCanGoal(Context,Body))),
	deduceCanGoal(Context,Body),
	write_int(Body,RealLiteral),fail.
%	memberchk_cnj(Lit,Body),(ground(MG) -> (write(RealLiteral),nl,fail) ; ).
*/
	






	


createLocalDistrict(Econ):-
	resetTableFlags,
	mooCache(RealLiteral,guard(RFVH,FVH,Body,CLID,KRVars,RuleVars,UnivLiteral,
		BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral),Key,Context,TN),
	createMerchant(Econ,TN,FakeLiteral,RealLiteral,Body,RuleVars),fail.
createLocalDistrict(Econ):-!.



solveLiteral(Lit):-
%	createFreeEconomy(Econ),
%	resetTableFlags,
	Econ=1,
	createBuyer(Econ,Buyer,Lit), true,
	setBuyerDemand(Econ,Buyer,Lit),
	giveCash(Econ,Buyer,200),!,
	researchShopping(Econ,Buyer,[Cost-Best|TodoList]),!,
	startBuyingAllYouCan(Econ,BestTodoList,Have),
	returnLits(Buyer,Have,Lit).
	
returnLits(Buyer,Have,Have):-retract(sup(Have)).

startBuyingAllYouCan(Econ,BestTodoList,Have).
	
	
researchShopping(Econ,Buyer,BestTodoList):-
	findall(Result,(
		recorded(Buyer,wants(Lit)),
		recorded(Econ,advertises(Merchant,Lit)),
		not(recorded(Merchant,wants(Lit))),
		getEstimate(Econ,Buyer,Lit,Merchant,Result)
		),Merchants),
		keysort(Merchants,BestTodoList). % Puts cheapest first
		
getEstimate(Econ,Buyer,PrimaryProduct,Merchant,(Markup-Merchant)):-
	recorded(Merchant,recipee(Needs,PrimaryProduct),_),
	researchShoppingForMerchant(Econ,Merchant,Needs,Lit,Cost),
	supply(Lit),
	Markup is Cost +1,!.
	
researchShoppingForMerchant(Econ,Merchant,(A,B),Lit,Cost):-!,
	researchShoppingForMerchant(Econ,Merchant,(A),Lit,Cost1),!,
	researchShoppingForMerchant(Econ,Merchant,(B),Lit,Cost2),
	supply(Lit),
	Cost is Cost1+Cost2,!.
	
researchShoppingForMerchant(Econ,Merchant,(B),Lit,0):-
	recorded(Merchant,inventory(B),_),!.

researchShoppingForMerchant(Econ,Merchant,(B),Lit,Cost):-
	comodity(Merchant,Econ,Lit,Cost),
	findall(N,(comodity(Merchant,Econ,Lit,_),recorda(Merchant,inventory(Lit)),supply((Lit))),List),List=[_|_],!.
		

supply(X):-asserta(sup(X)).

		

%comodity(Buyer,Econ,'$existential'(v(_,V,_),_,TopFunctor),2):-ignore(V=TopFunctor),!.
comodity(Buyer,Econ,Lit,1):-
	mooCache(Lit,_, Context, Ctx, TN),
	once(flag(TN,X,X+1)),X<6.


	
researchShoppingForMerchant(Econ,Merchant,Lit,Lit,Resale):-
	recorda(Merchant,wants(Lit),Ref),
	findall(Result,(
		recorded(Econ,advertises(Other,Lit)),
		%not((recorded(Other,wants(Lit)))),
		not((recorded(Other,wants(_)))),
		not((recorded(Econ,consumes(Other,Lit)))),
		getEstimate(Econ,Merchant,Lit,Other,Result)
		),Merchants),
		erase(Ref),!,keysort(Merchants,[Cost-Best|TodoList]),!,
		Resale is Cost+1.

		
getMerchant(Econ,Merchant,WishList,Forsale,Cash,Recipee):-
	recorded(Econ,merchant(Name,Catagory),Merchant),
	not(recorded(Econ,outlawed(Catagory),_)),
	not(recorded(Econ,busted(Name),_)),
	getMerchantInfo(Econ,Merchant,WishList,Forsale,Cash,Recipee).
	
getMerchantInfo(Econ,Merchant,WishList,Forsale,Cash,recipee(Needs,PrimaryProduct)):-
	flag(Merchant,Cash,Cash), 
	findall(Wants,recorded(Econ,consumes(Merchant,Wants)),WishList),
	findall(Sells,recorded(Econ,advertises(Merchant,Sells)),Forsale),!,
	recorded(Merchant,recipee(Needs,PrimaryProduct),_).
	
	

%shoppingSpree(Buyer,Lit,Econ):-
startBuying(Econ,Buyer,Lit,BestTodoList):-
	getFirstErrand(Buyer,Goal,Errand),
	getCash(Econ,Buyer,Cash),
	cheapest(Econ,Errand,Cost),
	Cost < Cash -> 
			% Can afford
			(buyErrand(Buyer,Errand,Cost),!,
			sellUneededExtra(Buyer,Econ),!,
			calculateMostGoodsForCash(Cash,Lit,BestTodoList),!,
			startBuying(Econ,Buyer,Lit,BestTodoList)
			);
			% Can't afford
			(putOnWishlist(BestTodoList,Buyer,Errand,NewBestTodoList),!,
			startBuying(Econ,Buyer,Lit,NewBestTodoList)).
	


createMerchant(Econ,Name,Catagory,PrimaryProduct,Needs,Coupons):-
	recorda(Econ,merchant(Name,Catagory),Merchant),!,
	recorda(Econ,advertises(Merchant,PrimaryProduct)),!,
	createConsumption(Econ,Merchant,Needs),
	flag(Merchant,_,1), % One Dollar
	createRecipe(Econ,Merchant,Needs,PrimaryProduct),
	recorded(Econ,coupons(Coupons)),!.

createConsumption(Econ,Merchant,(A,B)):-!,
	createConsumption(Econ,Merchant,A),	
	createConsumption(Econ,Merchant,B).
createConsumption(Econ,Merchant,A):-!,
	recorda(Econ,consumes(Merchant,A)),!.

createRecipe(Econ,Merchant,Needs,PrimaryProduct):-
	recorda(Merchant,recipee(Needs,PrimaryProduct),_),!.

getDeadbeatBuyer(Econ,Buyer,WishList,Forsale):-
	recorded(Econ,buyer(Lit),Buyer),
	flag(Buyer,X,X),X<1,
	getTrade(Buyer,WishList,Forsale).
	



createFreeEconomy(Econ):-Econ is random(50),!.

createBuyer(Econ,Buyer,Lit):-
	recorda(Econ,buyer(Lit),Buyer),!.	
	
setBuyerDemand(Econ,Buyer,Lit):-
	recorda(Buyer,wants(Lit)).

setBuyerSurplus(Econ,Buyer,Lit):-
	recorda(Buyer,sells(Lit)).

getFreeStuff(Econ,FreeStuff):-
	recorded(Econ,free(FreeStuff)),
	not(recorded(Econ,outlawed(FreeStuff),_)).

	


	
giveCash(Econ,Buyer,Cash):-
	flag(Buyer,X,X+Cash),!.

takeCash(Econ,Buyer,Cash):-
	flag(Buyer,X,X-Cash),!.
	

inventory(Stack,Literal):-member(gaf(Literal),Stack).


getConsumersOfLiteral(Stack,Literal,WhoList):-findall(Who,member(req(Literal,Who),Stack),WhoList).

supplyLiteralToWhoListFree(Stack,Literal,WhoList):-findall(Who,member(req(Literal,Who),Stack),WhoList).

getSuppliersMenu(Stack,Literal,SuppliersMenu):-
		findall(Who,member(req(Literal,Who),Stack),WhoList).


		       
/*
deduceGoal(Context,[consumer(TN,Goal,)|ExplainationIn],MaxVars,g(RealLiteral,ImportantVars),[sm(Literal,TN)|ExplainationIn]):-
		mooCache(RealLiteral,_, Context, Ctx, TN),
		(not(ground(ImportantVars)) -> ! ; true ). %,not(member(TN,Refs)).
  */
  
% Ignored Stuff  i(ignored), 
% Stable Table for st(instance($0,'Class')). as sm(instance('Attribute','Class')).
% Delay calls to d(instance(X,'Class')). 




deduceGoal(Context,[Consumer|ExplainationIn],MaxVars,g(RealLiteral,ImportantVars),ExplainationOut):-MaxVars>0,
	ignore(tn(bogus,PVars,RealLiteral) = Consumer),
	ignore(MaxVars=PVars),NMaxVars is MaxVars - 1,
	ensureKey(RealLiteral,CallLiteral,Depth,HashKey),	
	mooCache(RealLiteral,guard(RFVH,FVH,Body,CLID,KRVars,RuleVars,UnivLiteral,BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral),Key,Context,TN),
	copy_term(Body,BodyInstanceCopy),numbervars(BodyInstanceCopy,'$',0,NBodyVarsLeft),
	compare(CmpPrevious,PVars,NBodyVarsLeft),
	writeq(mooCacheCall(RealLiteral,CallLiteral,CmpPrevious,MaxVars,PVars,NBodyVarsLeft)),nl,
	mooCacheCall(CmpPrevious,[Consumer|ExplainationIn],MaxVars,PVars,NBodyVarsLeft,
		RealLiteral,CallLiteral,BodyInstanceCopy,RFVH,FVH,Body,CLID,KRVars,RuleVars,
		UnivLiteral,BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral,Key,Context,TN,ExplainationOut).



ensureKey(Literal,Key,Depth,HashKey):-
	copy_term(Literal,Proto),
	unwrapPatterns(Proto,Key),
	numbervars(Key,'$',0,Depth),
	hash_term(Key,HashKey),!.

unwrapPatterns(Term,OTerm):-
	mapOnConj(unwrapPatternsProc,Term,OTerm).
	

unwrapPatternsProc(Term,OTerm):-nonvar(Term),!,
 	Term=..[TopFunctor|Args],
	getArgsd(Args,New),!,
 	OTerm=..[TopFunctor|New].

unwrapPatternsProc(Term,OTerm):-
 	OTerm=..[TopFunctor|New],
	getArgsdr(Args,New),
 	Term=..[TopFunctor|Args],!.

getArgsd([],[]).
getArgsd([v(_,v,_)|T],['$'|TT]):-!,getArgsd(T,TT).
getArgsd([v(_,A,_)|T],[A|TT]):-!,getArgsd(T,TT).
getArgsd(['$'|T],['$'|TT]):- !,getArgsd(T,TT).
getArgsd([H|T],[H|TT]):- !,getArgsd(T,TT).

getArgsdr([],[]).   getArgsdr([v(_,V,_)|T],[V|TT]):-!,getArgsdr(T,TT).


% When a GAF is not found and we need to backchain:

% First we examine the backhain 'Goal' Literal .. exmaples are:

% instance(v(_,X,_),v(_,'Class',_)) And which Bindings they to actually know

% for example if they are just asking for arg 2 of instance  then we want to cut on first solution
% in this case the prototype is g(instance(v(_,X,_),v(_,'Class',_),['Class'])

% if they want X then we must find all uniue binding of X
% so the prototype of the head is  g(instance(v(_,X,_),v(_,'Class',_),[X])

% if they want X and Y in g(instance(v(_,X,_),v(_,Y,_),[X,Y]).

% we first make a session prototype:  g(instance(v(_,X,_),v(_,Y,_),[X,Y]) -> g(instance(v(_,$VAR,_),v(_,$VAR,_),[$VAR(1),$VAR(2)])

% Tries to give table (Must have been at least prevoius calls as well (A B Goal))
deduceGoalCall(>,[A,B,Goal|ExplainationIn],MaxVars,PVars,NBodyVarsLeft,
	RealLiteral,CallLiteral,BodyInstanceCopy,RFVH,FVH,Body,CLID,KRVars,RuleVars,
	UnivLiteral,BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral,Key,Context,TN,[did(RealLiteral),A,B,Goal|ExplainationIn]):-
	writeq(tryingToGiveOneAnswer(CallLiteral)),recorded(TN,RealLiteral),!,
	writeq(did(RealLiteral)),nl,!.   % Give Table only if have it

% Tries to give stack but likely will fail.
/*
mooCacheCall(>,Previous,MaxVars,PVars,NBodyVarsLeft,
	RealLiteral,CallLiteral,BodyInstanceCopy,RFVH,FVH,Body,CLID,KRVars,RuleVars,
	UnivLiteral,BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral,Key,Context,TN,[preproved(CallLiteral)|ExplainationOut):-!,
	member(RealLiteral,Previous),member(preproved(CallLiteral)).
*/

mooCacheCall(_,Previous,MaxVars,PVars,NBodyVarsLeft,
	RealLiteral,CallLiteral,BodyInstanceCopy,RFVH,FVH,Body,CLID,KRVars,RuleVars,
	UnivLiteral,BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral,Key,Context,TN,[gave(RealLiteral)|Previous]):-
	recorded(TN,CallLiteral,Ref),!, % Known call table
	writeq(tryingToGiveAllAnswers(CallLiteral)),
	recorded(TN,RealLiteral),   % Give Full Table
	writeq(gave(RealLiteral)).
	
mooCacheCall(_,Previous,MaxVars,PVars,NBodyVarsLeft,
	RealLiteral,CallLiteral,BodyInstanceCopy,RFVH,FVH,Body,CLID,KRVars,RuleVars,
	UnivLiteral,BodyUniv,BodySelfConnected,Shared,PrivLiteral,FakeLiteral,Key,Context,TN,ExplainationOut):-
	recorda(TN,CallLiteral,Ref),!, % Table the call
	writeq((slide:TN:NVars: (<):PVars:(<):MaxVars:PTN)),nl,
	findall(Shared,((
	     %   call_with_depth_limit(
				deduceGoal(Context,_Ctx,[tn(TN,NVars,Body),PIN|ExplainationIn],NMaxVars,Body,ExitP) %,ground(Shared)   %
	      %  ,90,DL),ground(Shared)
			)),Sols),
			list_to_set(Sols,SolsS),
			length(SolsS,N),!,
	N>0,
	%true,
	write(TN:returned:N),
	member(Shared,SolsS),
	recorda(TN,RealLiteral:Body).



/*
		%,write(Explaination).
	

		%ground(UnivLiteral), % Makes sure this is valid
		%not(Functor=not(_)),
	erase(Ref),%true,

	%copy_term(RFVH,Session),
	%numbervars(Session,'$',0,_),
	
%	=(RFVH,FVH), %unifies list of 'real' prolog variables
%        not(recorded(TN,RuleVars,Ref)),
 %       copy_term(RuleVars,Session),
	%numbervars(FVH,'$VAR',0,_),
  %      recorda(TN,Session,Ref),


deduceGoal(Context,ExplainationIn,MaxVars,Literal,Ref):-Literal=..[TopFunctor|Args],!,
	not(member(Literal,Ref)),
	deduceGoalF(Context,ExplainationIn,MaxVars,TopFunctor,Literal,Args,[Literal|Ref]).
	
deduceGoalF(Context,ExplainationIn,MaxVars,holds,Orig,Args,Ref):-!,fail.
deduceGoalF(Context,ExplainationIn,MaxVars,TopFunctor,Orig,Args,Ref):-
	Literal=..[holds,TopFunctor|Args],
	deduceGoal(Context,ExplainationIn,MaxVars,Literal,Ref).

*/




igi:-igi('Relation').


igi(Class):-
	ig(X,instance(v(_,X,_),v('Abstract', Class,_))).

ig(X):-ig(X,X).

ig(Y,X):-
	resetTableFlags,
       findall(Y,(deduceGoalD(Context,[tn(0,55,request)],50,X,Out),write(Y),nl),L),
       nl,nl,writeq(L),nl,
       length(L,N),
       sort(L,LS),
       length(LS,LN),
       write(num:N:u:LN),nl.
       

epc1:-
	call_with_depth_limit(epc(X=Y,instance(X,Y)),30,_).
	

epc(PreviousVarSeek,Goal):-
	resetTableFlags,
       findall(PreviousVarSeek,(mooBeliefLiteral(5,PreviousVarSeek,Goal),writeColor(green,Goal)),L),
       length(L,N),
       sort(L,LS),
       length(LS,LN),
       write(num:N:u:LN),nl.
	
	
isAtLeastOne([_|_]).

/*
get_forms_with_atom(A,TNs)
keep_forms_with_atom(TNsIn,A,TNsOut)
remove_forms_with_atom(TNsIn,A,TNsOut)
get_forms_with_structure(S,TNs)
keep_forms_with_structure(TNsIn,S,TNsOut)
remove_forms_with_structure(TNsIn,S,TNsOut)
return_forms(TNs)
return_forms_to_html(TNs)
*/

%:-module(moo_browser,[invokeBrowserRequest/1]).

% :-include(moo_header).


% ==============================================
% Enable or Disable Prolog Memory
% ==============================================

% Assertions have these states

% Surface (on/disabled)
% Can #1 (on/disabled) (in_mem/out_mem)
% Can #2 (on/disabled) (in_mem/out_mem)

% A user makes an assertion into an inactive Context
% Surface (on)
% Can #1 (on) (out_mem)
% Can #2 (disabled) (out_mem)

% A user makes an assertion into an active Context
% Surface (on)
% Can #1 (on) (in_mem)
% Can #2 (disabled) (out_mem)

/*

So ... this means we have Three States of any Canonical assertion...  on/in_mem/disabled

*/


% ===========================================================
% Search For Constant (Atom)
% ===========================================================
invokeBrowserRequest(Options):-memberchk(show='find',Options),!,
	getMooOption(word='instance',Word),
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	disp_word_to_surface(Word,Context,Out),
	draw_update_enable(Context,Out).

disp_word_to_surface(Word,Context,_Ctx,Out):-
	retractall(pkids(_)),
	mooCache(PredR,SurfaceTODO,SURF,PROLOG,Context,AID,Maintainer,OnOff),
	getConstants(atomic,SURF,Atoms,_,_),memberchk(Word,Atoms),  
	writeAssertion(SurfaceTODO,SURF,PROLOG,Context,AID,Maintainer,OnOff),
	fail.	

disp_word_to_surface(Word,Context,Out):-!,setof(retract(pkids(INTID)),Out).

% ===========================================================
% Search For Tracking Number
% ===========================================================
invokeBrowserRequest(Options):-(memberchk(submit=editaid,Options);memberchk(dispasid=dispasid,Options)),!,  
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	retractall(pkids(_)),!,
	disp_tn_to_surface(Context,AID,Out),
	draw_update_enable(Context,Out),!.
	
disp_tn_to_surface(Context,bogus,Out):-!.

disp_tn_to_surface(Context,TN,Out):-
	mooCache(PredR,Format,SURF,Prolog,Context,TN,Maintainer,OnOff), 
	writeAssertion(Format,SURF,Prolog,Context,TN,Maintainer,OnOff),
	fail.	

disp_tn_to_surface(Context,Out):- %isMooOption(disp_notes_nonuser=on),
	mooCache(PredR,Format,SURF,Prolog,Context,TN,Maintainer,OnOff),  
	writeAssertion(Format,SURF,Prolog,Context,TN,Maintainer,OnOff),
	fail.	

disp_tn_to_surface(Context,_,Out):-!,setof(retract(pkids(INTID)),Out).

aid_to_number(Number,Number):-number(AID),!.
aid_to_number(AID,Number):- atom_to_term(AID,Number,_),!.


% ===========================================================
% Search For State (Atom) (rejected,on,gaf).. etc
% ===========================================================
invokeBrowserRequest(Options):-memberchk(show='state',Options),!,
	getMooOption(word='disabled',Word),
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	disp_word_to_surface(Word,Context,Out),
	draw_update_enable(Context,Out).

disp_status_to_surface(Status,Context,Out):-
	retractall(pkids(_)),
	mooCache(PredR,SurfaceTODO,SURF,Prolog,Context,AID,Maintainer,Status),
	writeAssertion(SurfaceTODO,SURF,Prolog,Context,AID,Maintainer,Status),
	fail.	

disp_status_to_surface(Status,Context,Out):-!,setof(retract(pkids(INTID)),Out).

% ===========================================================
% Search Disabled Assertion
% ===========================================================
invokeBrowserRequest(Options):-
	memberchk(cmd='Show Disabled',Options),!,
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	writeFmt('<H3><Font Color=Red>Listing Disabled Assertions...</Font></H3>',[]),!,
	show_disabled_assertions(Context,Ctx),!.
	
show_disabled_assertions(Context,Ctx):-
	mooCache(PredR,Form,Formula,Prolog,Context,AID,Maintainer,OnOff),not(OnOff=on),not(OnOff=uncanonicalized),
	writeAssertion(Form,Formula,Prolog,Context,AID,Maintainer,OnOff),
	fail.
	
show_disabled_assertions(Context,Ctx):-writeFmt('<H3><Font Color=Red>Done.</Font></H3>',[]).




% ===========================================================
% Show Assertion Updater
% ===========================================================
draw_update_enable(Context,[]):- writeFmt('Search yielded no Results.\n',[]).
draw_update_enable(Context,As):-!,
	format_o(
		'<HR>~w&nbsp;<INPUT type=submit name=submit value="Change"/>',select(ue,['Enable','Disable','Delete'])),!,
       %show_available_contexts_in_combobox(destination,[],Out),!,writeFmt('<BR><input type=radio name=CopyOrTransfer checked value=Transfer><B>Transfer</B></input>&nbsp;<input type=radio name=CopyOrTransfer value=Copy><B>Copy</B></input> selected assertions to ~w <input type=submit name=move value=Submit>',[Out]),!.
       	writeFmt('&nbsp;&nbsp;&nbsp;&nbsp;<A href="askInsert.jsp?theory=~w">Return to Ask/Insert</A>',[Context]).
		

% ===========================================================
% Show Assertions (Surface)
% ===========================================================

writeAssertion(surface,SURF,Vars,Context,AID,Maintainer,OnOff):- !,
	assert(pkids(INTID)),
	toMarkUp(html,SURF,Vars,SAtom),
	%toMarkUp(kif,SURF,Vars,KIF),
	%setMooOption(sf=KIF),
	on_to_check(on,OnOff,Checked),
	writeFmt('<hr><A HREF="askInsert.jsp?theory=~w&asid=~w&t=ea" title="Edit Assertion"><IMG border=0 src="pixmaps/cyan.gif" asrtid=~w></A><input type=chectheoryox class=assertionChecks  name=~w ~w/><nobr>',[Context,AID,AID,Checked]),
	writeFmt('<b>Surface</b> ID<font color=red>~w:~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font> Status: <font color=puple>~w</font>',[AID,Context,Maintainer,OnOff]),
	writeFmt('~w',[SAtom]),!.
	
% ===========================================================
% Show Assertions (HL)
% ===========================================================

writeAssertion(surface,WFS,Vars,Context,AID,Maintainer,OnOff):- %isMooOption(disp_notes_nonuser=on),
	assert(pkids(INTID)),
	toMarkUp(html,formula(WFS),Vars,SAtom),
	%toMarkUp(kif,SURF,Vars,KIF),
	%setMooOption(sf=KIF),
	on_to_check(on,OnOff,Checked),
	writeFmt('<hr><A HREF="askInsert.jsp?theory=~w&submit=editaid&asid=~w&t=ea" title="Show Source"><IMG border=0 src="pixmaps/purple.gif" asrtid=~w></A><input type=chectheoryox class=assertionChecks  name=~w ~w/><nobr>',[Context,AID,AID,Checked]),
	writeFmt('<b>~w</b> ID<font color=red>~w:~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font> Status: <font color=puple>~w</font>',['Surface',AID,Context,Maintainer,OnOff]),
	writeFmt('~w',[SAtom]),!.
/*
writeAssertion(skolem,WFS,Vars,Context,AID,Maintainer,OnOff):- %isMooOption(disp_notes_nonuser=on),
	assert(pkids(INTID)),
	toMarkUp(html,formula(WFS),Vars,SAtom),
	%toMarkUp(kif,SURF,Vars,KIF),
	%setMooOption(sf=KIF),
	on_to_check(on,OnOff,Checked),
	writeFmt('<hr><A HREF="askInsert.jsp?theory=~w&submit=editaid&asid=~w&t=ea" title="Show Source"><IMG border=0 src="pixmaps/purple.gif" asrtid=~w></A><input type=chectheoryox class=assertionChecks  name=~w ~w/><nobr>',[Context,AID,AID,Checked]),
	writeFmt('<b>~w</b> ID<font color=red>~w:~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>   Status: <font color=puple>~w</font>',['Skolem',AID,Context,OnOff]),
	writeFmt('~w',[SAtom]),!.
*/
writeAssertion(Head,Tail,Vars,Context,AID,Maintainer,OnOff):- %isMooOption(disp_notes_nonuser=on),
	assert(pkids(INTID)),
	toMarkUp(html,formula((Head:-Tail)),Vars,SAtom),
	%toMarkUp(kif,SURF,Vars,KIF),
	%setMooOption(sf=KIF),
	on_to_check(on,OnOff,Checked),
	writeFmt('<hr><A HREF="askInsert.jsp?theory=~w&submit=editaid&asid=~w&t=ea" title="Show Source"><IMG border=0 src="pixmaps/purple.gif" asrtid=~w></A><input type=chectheoryox class=assertionChecks  name=~w ~w/><nobr>',[Context,AID,AID,Checked]),
	writeFmt('<b>~w</b> ID<font color=red>~w:~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Status: <font color=puple>~w</font>',['Heuristic',AID,Context,OnOff]),
	writeFmt('~w',[SAtom]),!.


on_to_check(OnOff,OnOff,'Checked').
on_to_check(_,_,' ').






% ===============================================
% Read Chectheoryoxes and Make Calls
% ===============================================


% Disables
invokeBrowserRequest(Options):-     
		memberchk(submit='Change',Options),
		memberchk(ue='Disable',Options),  %true,
		findall(N,(member(N=on,Options),number(N)),List),
		do_each_disable(List).

	do_each_disable([]):-!.
	do_each_disable([H|T]):-!,
		do_each_disable_id(H),
		do_each_disable(T),!.
	
	do_each_disable_id(ID):-mooCache(PredR,ID,surface,_,_,_,_,SurfNumber,_,_),!,disable_surf_number(SurfNumber).
	do_each_disable_id(ID):-mooCache(PredR,ID,wfs,_,_,_,_,_,_,_),!,disable_can_number(ID).


% Enables
invokeBrowserRequest(Options):-   
		memberchk(submit='Change',Options),
		memberchk(ue='Enable',Options),   %true,
		findall(N,(member(N=on,Options),number(N)),List),
		do_each_enable(List).


	do_each_enable([]):-!.
	do_each_enable([H|T]):-!,
		do_each_enable_id(H),
		do_each_enable(T),!.
	
	do_each_enable_id(ID):-mooCache(PredR,ID,surface,_,_,_,_,SurfNumber,_,_),!,enable_surf_number(SurfNumber).
	do_each_enable_id(ID):-mooCache(PredR,ID,wfs,_,_,_,_,_,_,_),!,enable_can_number(ID).
	do_each_enable_id(ID):-!.

% ==============================================
% Enable + Canonizlize an Existing Surface Number
% ==============================================
enable_surf_number(SurfNumber):-
	 (mooCache(PredR,surface,Surf,Vars,Context,SurfNumber,Maintainer,OnOff)),!,
	 retractall(mooCache(PredR,wfs,_,_,Context,SurfNumber,_,_)),
	 logOnFailure(moo_invoke_accept_surface(tell,[canonicalize,untrusted],surface,Surf,Ctx,SurfNumber,Context,Vars,Maintainer,accept('Previous Assertion being Recanonicalized'))).


% ==============================================
% Disable and De-Canonizlize an Existing Surface Number
% ==============================================
disable_surf_number(SurfNumber):-
	 retract(mooCache(PredR,N,surface,Surface,Vars,Context,SurfNumber,Maintainer,OnOff)),!,
	 assert(mooCache(PredR,N,surface,Surface,Vars,Context,SurfNumber,Maintainer,disabled)),!,
	 disable_each_can_with_surf_id(SurfNumber).
	 
disable_each_can_with_surf_id(SurfNumber):-
	 mooCache(PredR,CanNumber,wfs,UCL,PROLOG,Context,SurfNumber,Maintainer,_),
	 once(disable_can_number(CanNumber)),fail.
disable_each_can_with_surf_id(SurfNumber):-!.

% ==============================================
% Enable or CAN ID and reflect in Prolog Memory
% ==============================================

enable_can_number(CanNumber):-
	 mooCache(PredR,CanNumber,wfs,UCL,PROLOG,Context,TN,Maintainer,on_mem).	 
	 
enable_can_number(CanNumber):-
	 mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,on),
	 isKnowledgeBaseLoaded(Context,Ctx),!,
	 enable_can_conj(PrologFormS).

enable_can_number(CanNumber):-
	 (mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,Off)),
	 isKnowledgeBaseLoaded(Context,Ctx),!,
	 retract(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,Off)),
	 assert(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,on_mem)),
	 enable_can_conj(PrologFormS).

enable_can_number(CanNumber):-
	 mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,on),
	 not(isKnowledgeBaseLoaded(Context,Ctx)),!.
	 
enable_can_number(CanNumber):-
	 retract(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,_)),
	 not(isKnowledgeBaseLoaded(Context,Ctx)),!,
	 assert(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,on)).


enable_can_number(CanNumber):-
	 mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,on_mem),
	 not(isKnowledgeBaseLoaded(Context,Ctx)),!. %TODO Problem
	 
enable_can_number(CanNumber):-!.

enable_can_conj(true):-!.
enable_can_conj((Prolog,Form)):-!,
	enable_can_conj(Prolog),
	enable_can_conj(Form),!.
enable_can_conj(PrologForm):-
	enable_can(PrologForm).

enable_can(PrologFormS):-
	logOnFailure(assert(PrologFormS,AssertID)).

	 
% ==============================================
% Disable CAN ID and reflect in Prolog Memory
% ==============================================

disable_can_number(CanNumber):-
	 retract(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,on)),
	 assert(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,disabled)),
	 sendNote(user,contentMananger,'Details of Disable',mooCache(PredR,CanNumber,wfs,UCL,prolog_code,Context,TN,Maintainer,disabled)),
	 disable_can_conj(PrologFormS).

disable_can_number(CanNumber):-
	 retract(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,State)),
	 assert(mooCache(PredR,CanNumber,wfs,UCL,PrologFormS,Context,TN,Maintainer,disabled)),
	 disable_can_conj(PrologFormS).
disable_can_number(CanNumber):-!.
	 
disable_can_conj(true):-!.
disable_can_conj((Prolog,Form)):-!,
	disable_can_conj(Prolog),
	disable_can_conj(Form),!.
disable_can_conj(PrologForm):-
	disable_can(PrologForm).
	 
	 
disable_can(PrologFormS):-catch(erase(AssertID),_,true),fail.
disable_can(PrologForm):-!.

	
% ===========================================================
% Disable Assertion
% ===========================================================
invokeBrowserRequest(Options):-memberchk(submit='Disable Assertion',Options),!,
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	writeFmt('<H3><Font Color=Red>Disabling....</Font></H3>',[]),
	disable_assertion(AID).
	
disable_assertion(AID):-
	retract(mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,on)),
	disable_assertion_disp(Form,SURF,Vars,Context,AID,Maintainer),
	assertaClean(mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,disabled)),fail.
	
disable_assertion(AID):-writeFmt('<H3><Font Color=Red>Done.</Font></H3>',[]).

disable_assertion_disp(Form,SURF,Vars,Context,AID,Maintainer):-
	toMarkUp(html,SURF,Vars,SAtom),
	writeFmt('<IMG src="pixmaps/bullet.gif" asrtid=~w><nobr>',[AID]),
	writeFmt('<b>~w</b> ID<font color=red>~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font>',[Form,AID,Context,Maintainer]),
	%format_o('&nbsp;&nbsp;~w&nbsp;Enabled&nbsp;&nbsp;<br>',chectheoryox(AID,OnOff)),
	writeFmt('~w<br>',[SAtom]),!.

show_disable_assertions(Form,SURF,Vars,Context,AID,Maintainer,OnOff):-
	toMarkUp(html,SURF,Vars,SAtom),
	writeFmt('<IMG src="pixmaps/bullet.gif" asrtid=~w><nobr>',[AID]),
	writeFmt('~w <b>~w</b> ID<font color=red>~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font>',[OnOff,Form,AID,Context,Maintainer]),
	%format_o('&nbsp;&nbsp;~w&nbsp;Enabled&nbsp;&nbsp;<br>',chectheoryox(AID,OnOff)),
	writeFmt('~w<hr>',[SAtom]),!.

% ===========================================================
% Enable Assertion
% ===========================================================
invokeBrowserRequest(Options):-memberchk(submit='Enable Assertion',Options),!,
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	writeFmt('<H3><Font Color=Red>Enabling....</Font></H3>',[]),
	enable_assertion(AID).
	
enable_assertion(AID):-
	retract(mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,_)),
	enable_assertion_disp(Form,SURF,Vars,Context,AID,Maintainer),
	assertaClean(mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,on)),fail.
	
enable_assertion(AID):-writeFmt('<H3><Font Color=Red>Done.</Font></H3>',[]).

enable_assertion_disp(Form,SURF,Vars,Context,AID,Maintainer):-
	toMarkUp(html,SURF,Vars,SAtom),
	writeFmt('<IMG src="pixmaps/bullet.gif" asrtid=~w><nobr>',[AID]),
	writeFmt('<b>~w</b> ID<font color=red>~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font>',[Form,AID,Context,Maintainer]),
	%format_o('&nbsp;&nbsp;~w&nbsp;Enabled&nbsp;&nbsp;<br>',chectheoryox(AID,OnOff)),
	writeFmt('~w<br>',[SAtom]),!.
		

show_enable_assertions:-
	mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,on),
	show_enable_assertions(Form,SURF,Vars,Context,AID,Maintainer,OnOff),
	fail.
	
show_enable_assertions:-writeFmt('<H3><Font Color=Red>Done.</Font></H3>',[]).

show_enable_assertions(Form,SURF,Vars,Context,AID,Maintainer,OnOff):-
	toMarkUp(html,SURF,Vars,SAtom),
	writeFmt('<IMG src="pixmaps/bullet.gif" asrtid=~w><nobr>',[AID]),
	writeFmt('~w <b>~w</b> ID<font color=red>~w</font> in Context: <font color=green>~w</font>  CTX: <font color=green>~w</font>  Maintainer: <font color=green>~w</font>',[OnOff,Form,AID,Context,Maintainer]),
	%format_o('&nbsp;&nbsp;~w&nbsp;Enabled&nbsp;&nbsp;<br>',chectheoryox(AID,OnOff)),
	writeFmt('~w<hr>',[SAtom]),!.

% ===========================================================
% Edit Assertion
% ===========================================================
invokeBrowserRequest(Options):-memberchk(t='ea',Options),!,
	getMooOption(opt_ctx_assert='GlobalContext',Ctx),
	getMooOption(opt_theory='PrologMOO',Context),
	getMooOption(asid=_,AID),
	getMooOption(user='Web',User),
	getMooOption(interp='kif',Interp),
	mooCache(PredR,Form,SURF,Vars,Context,AID,Maintainer,_),
	%retractall(mooCache(PredR,_,_,_,Context,AID,_,_)),
	toMarkUp(kif,SURF,Vars,Formula),
	writeFmt('<textarea rows=6 cols=90 name="sf">~w</textarea><br>',[Formula]),
	writeFmt('<br>&nbsp;&nbsp;<INPUT type=submit name=submit value="Update Source">&nbsp;<input type=hidden name=editid value="~w">',[AID	]),
	writeFmt('&nbsp;&nbsp;&nbsp;&nbsp;<INPUT type=radio name="interp" value="kif" checked>KIF</INPUT><INPUT type=radio name="interp" value="ace" DISABLED>ACE</INPUT>&nbsp;&nbsp;<A href="askInsert.jsp?theory=~w">Cancel</a>',[Context]).



% ================================================================================
% consultation(Request_Compiled(i),Consultation_Type(?),ResultSingle_bindings(o),Truth(o),How(o))
% Request_Compiled = WFS Format
% ResultSingle_bindings = XSB_Compiled_Format
% Consultation_Type = member of [consult_truth,consult_facts,consult_single_bindings]
% Truth = Real Number or tabled_true or not_proved
% How = Explaination Used
% ================================================================================
% :-include('moo_header.pl').

% ==========================================================
%  Consultation
% ==========================================================

:- dynamic consultation_gafs/1.

'moo-consultation'(Context_atom,ConsultationRequestP,ListOfGafsAsserted):-
         agentConsultation(Context_atom,ConsultationRequestP,ListOfGafsAsserted),!,
         member(ConsultationRequest,ListOfGafsAsserted).

'user-believes'(ConsultationRequestP):-
         agentConsultation('GlobalContext',ConsultationRequestP,ListOfGafsAsserted),!,
         member(ConsultationRequest,ListOfGafsAsserted).

agentConsultation(Context_atom,ConsultationRequest,ListOfGafsAsserted):-
                     %member(Method,[consult_single_bindings,consult_facts,consult_truth]),!,
                     retractall(consultation_gafs(_)),
                     write_direct_l(['<Consult>',nl]),
                     ConsultationRequest=.. STERM,
                     agentConsult_want(Context_atom,STERM),
                     write_direct_l(['</Consult>',nl]), 
                     once(agentConsult_get_results(Context_atom,ListOfGafsAsserted)).

                     
agentConsult_want(Context_atom,[ConsultationPred|RequestArgs]):-
                     length(RequestArgs,Arity) ,
                     write_direct_l(['<Want pred="',ConsultationPred,'" arity="',Arity,'" ctxt="',Context_atom,'">',nl]),
                     agentConsult_args(Context_atom,ConsultationPred,1,RequestArgs),                                          
                     write_direct_l(['</Want>',nl]).
                             
agentConsult_args(_Context_atom,_Consultation,_Num,[]):-!.                                          
agentConsult_args(Context_atom,ConsultationPred,_Num,[Head|Tail]):-!,   %true,
                     once(agentConsult_one_arg(ConsultationPred,Context_atom,_Num,Head)),
                     Next_Num is _Num +1,
                     agentConsult_args(Context_atom,ConsultationPred,Next_Num,Tail).

agentConsult_one_arg(Context_atom,ConsultationPred,_Num,Head):- (var(Head);member(Head,['-','?','+','#'])), !,
                  write_direct_l(['<arg argn="',_Num,'"']),
                  %ignore((theory(Context_atom,['surface-domain',ConsultationPred,_Num,ArgDomain]),write_direct_l([' domain="',ArgDomain,'"']))),
                  write_direct_l([' state="need"/>',nl]).
         
agentConsult_one_arg(Context_atom,ConsultationPred,_Num,Head):-!,
                  write_direct_l(['<arg argn="',_Num,'"']),
                  %ignore((theory(Context_atom,['surface-domain',ConsultationPred,_Num,ArgDomain]),write_direct_l([' domain="',ArgDomain,'"']))),
                  write_direct_l([' state="bound">',Head,'</arg>',nl]).

agentConsult_get_results(Context_atom,(PSurface,CSurface,WFS,CFORM,NextTerm)):-  
                        once(((xsbRequestStream(Stream),conv_readS(Stream,Assert_chars,STerm,_Vars));conv_readS(Assert_chars,STerm,_Vars))),

                        once((
                           member(STerm,[[continue],[abort]])
                            ;
                              ((
                               ignore((           
                                          once(tell_retract_parse_chars(Assert_chars,Pterm,Vars)),
                                          source_compile(Pterm,Ctx,TN,Context,CM,Vars,PSurface,CSurface,WFS,CFORM),
                                          do_to_conjuncts(CSurface,assert_prolog_tm),!,
                                          do_to_conjuncts(CFORM,assert_prolog_tm),!
                                       )), 
                              agentConsult_get_results(Context_atom,NextTerm),
                              
                              ignore(NextTerm=end_of_file)
                             ))
                        )).

                        %,!,findall(GafAsserted,consultation_gafs(GafAsserted),ListOfGafsAsserted).



consultation(PredicateI,PProtoArgs,PArgs,_Cxt):- 
       pterm_to_sterm(PProtoArgs,ProtoArgs),
       pterm_to_sterm(PArgs,Args),
               consultation_match_list(Args,ProtoArgs,ConsultTemplate),
            %   writeIfOption(rt,[want,[PredicateI|Args],asking,[PredicateI|ConsultTemplate]]),
               once((
                     ((moo_K_scenario(_Cxt,[PredicateI|ConsultTemplate]),!))
                     ;
                     (( 
                       
                        agentConsultation(_Cxt,[PredicateI|ConsultTemplate],_ListOfGafsAsserted),
                        assert(moo_K_scenario(_Cxt,[PredicateI|ConsultTemplate]))
                     ))
               )).

%'AssignmentFn'(Pred,ARGS,Ctx):-abort('AssignmentFn'(Pred,ARGS,Ctx)).


               
%ignore((_Often=once,fail,retract(_,[consultation_prototype,once,PredicateI,ProtoArgs])))


consultation_match_list(ARGS,ARGSP,ARGSP):- ARGS == ARGSP,!.
consultation_match_list([ARG|ARGS],[PROTO|PROTOS],[Suggestion|Suggestions]):-
      consultation_match(ARG,PROTO,Suggestion),
      consultation_match_list(ARGS,PROTOS,Suggestions).

consultation_match(ARG,PROTO,PROTO):- ARG==PROTO,!.
consultation_match(ARG,must_be_bound_before_call,ARG):- ground(ARG),!.
consultation_match(ARG,(+),ARG):- ground(ARG),!.
consultation_match(ARG,[+],ARG):- ground(ARG),!.
consultation_match(ARG,must_be_unbound_before_call,ARG):- var(ARG),!.
consultation_match(ARG,(-),ARG):- var(ARG),!.
consultation_match(ARG,[-],ARG):- var(ARG),!.
consultation_match(Var,consultation_must_bind_without_suggestion,Var):-var(Var),!.
consultation_match(_,consultation_must_bind_without_suggestion,_).
consultation_match(ARG,consultation_must_bind,ARG).
consultation_match(ARG,(-),ARG).
consultation_match(ARG,(?),ARG).
consultation_match(ARG,(#),ARG).


:- include('moo_header.pl').

% ===================================================================
% IMPORTS
% ===================================================================
%% :-include('moo_header.pl').

%S=(instance(A, 'BodyJunction')=>exists(B, exists(C, connected(A, C)and connected(A, B)and instance(C, 'AnatomicalStructure')and instance(B, 'AnatomicalStructure')and not equal(C, B)))),

cons:- !,
      %catch(cd('../../knowledge_bases/'),_,true),
      pwd,
      repeat, %told,seen,
      (unsetMooOption(client=html)),
      once(console_loop(C)),
      fail.

writeMooMenu:-
         writeFmt('ask - switches to ask mode \ntell - switches back to tell mode\n '),
         writeFmt('other cmds: prolog_statistics, ls, halt, contexts \n'),!.



:-dynamic(console_mode/1).
:-assert_new(console_mode(ask)).

console_loop(C):- console_mode(M),!,
      console_loop(M ,C).

console_loop(tell,SOURCEFORM):- 
            once(console_read('Insert> ',SOURCEFORM,Vars)),    
            invokeOperation(verbose,assert(SOURCEFORM),'GlobalContext',TN,'PrologMOO',CM,Vars).

console_loop(ask,SOURCEFORM):- 
            once(console_read('Ask> ',SOURCEFORM,Vars)),
            invokeOperation(verbose,request(SOURCEFORM),Ctx,TN,Context,CM,Vars).
      
console_loop(cmd,SOURCEFORM):- 
            once(console_read('Command> ',SOURCEFORM,Vars)),
            invokeOperation(verbose,cmd(SOURCEFORM),Ctx,TN,Context,CM,Vars).

console_read(P,FORM,Vars):-
         nl,write(P),cons_read(Askion_Chars),
         logOnFailure(getCleanCharsWhitespaceProper(Askion_Chars,Show)),!,
         logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
         logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
              catch(once(( NEWFORM=comment(_) -> 
                     (ignore(do_chars(Show)),!,FORM=_) ;(!,
		     FORM=NEWFORM      ))),_,fail).

cons_read(Chars):-repeat,told,seen,readKIF(Chars),Chars=[_,_|_].

lpInsert(Insert_chars):-
      tell(Insert_chars,Ctx,TN,Context,CM).

lpInsert_file(File):-lp_file(File).

lp_list:-
      writeFmt('Listing of the current assertions:\n',[]),
      listing(mooCache),
      writeFmt('Done.\n',[]).

lp_clear:-do_clear.

lp_save(FileName):-!.

lp_ask(Chars):-ask(Chars,_Cxt,Context).

   
cons_help:-!.

do_chars([59|Chars]):-!,do_chars(Chars).
do_chars(Chars):-tokenize3(Chars,Tokens),!,do_tokens(Tokens).

 

do_tokens([(;)|Toks]):-!,do_tokens(Toks).
do_tokens([tell]):-writeFmt('% Entering tell mode.\n',[]),retractall(console_mode(_)),assert(console_mode(tell)).
do_tokens([ask]):- writeFmt('% Entering ask mode.\n',[]),retractall(console_mode(_)),assert(console_mode(ask)).
do_tokens([cmd]):- writeFmt('% Entering command mode.\n',[]),retractall(console_mode(_)),assert(console_mode(cmd)).
do_tokens([clear]):- clear_moo_memory.
do_tokens([list]):- lp_list.
do_tokens([load,Filename]):- do_tokens([load,Filename,'GlobalContext']).
do_tokens([load,Filename,Ctx]):- ctxFromFile(Ctx,Filename,'PrologMOO').

%do_chars(X):-string_concat(";find ",Word,X),find_word(Word).
do_tokens([make]):- make.
do_tokens([help]):- writeMooMenu.
do_tokens([halt]):- halt.
do_tokens([bye]):- abort.
%do_chars([116,109|Number]):-catch((number_codes(Value,Number),set_tm_level(Value)),_,show_tm_level).
do_tokens([prolog]):- writeFmt('Type ""cons"" to return to Logic Engine.\n ',[]),abort.
do_tokens([can,X]):-canonicalizeMooContextHTML('PrologMOO',X).
do_tokens([can,X]):-canonicalizeMooContextHTML('PrologMOO',X).
do_tokens([can]):-do_tokens([can,'GlobalContext']).
do_tokens(L):-P=..L,once(P),!.
do_tokens(X):-writeFmt('could not parse: ~q.\n',[X]).
%do_chars(PCHARS):- atom_codes(Atom,PCHARS),catch(atom_to_term(Atom,Term,Vars),_,fail),!,catch(my_call(Term,Vars),_,fail).



theory_define(Context):-invokeInsert(forall,surface,'instance'(Context,'KnowledgeBase'),'GlobalContext',TN,Context,Vars,Maintainer),
                     invokeInsert(forall,surface,'instance'('GlobalContext','Context'),'GlobalContext',TN2,Context,Vars,Maintainer),
                     ensureMooContext(Context,'GlobalContext').

ctx_define(Ctx):-invokeInsert(forall,surface,'instance'(Ctx,'Context'),'GlobalContext',TN,SContext,Vars,Maintainer),ensureMooContext(Context,Ctx).

set_ctx(Context):-ensureMooContext(KnowledgeBase,Context).
set_theory(KnowledgeBase):-ensureMooContext(KnowledgeBase,'GlobalContext').

my_call(fol,_):-retractall(version_tag(_)),assert(version_tag(fol)),writeFmt('% Entering FOL mode.\n',[]),!.
my_call(theoryl,_) :-retractall(version_tag(_)),assert(version_tag(theoryl)),writeFmt('% Entering ContextL mode.\n',[]),!.

my_call(cd(Term),_Vars):-cd(Term),pwd.

my_call(file(Term),_Vars):-lp_file(Term),writeFmt('% Entering ask mode.\n',[]),retractall(console_mode(_)),assert(console_mode(ask)).
my_call(file(Term),_Vars):- writeFmt('% Entering ask mode.\n',[]),retractall(console_mode(_)),assert(console_mode(ask)).

my_call(Term,_Vars):-once(Term).


do_chars(Show):-%,catch(fmtString(Atom,'"~s"',[Show]),_,ignore(Atom=surf)),
	sendNote(user,'kifParser','KIF Unreadable (Syntax error: Unbalanced parentheses  )',Atom).


call_nth_times(Number,Prolog):-
                     retractall(call_count(_)),assert(call_count(Number)),repeat,
                     (Prolog),
                     ignore((retract(call_count(Q)),QQ is Q -1,
                     assert(call_count(QQ)))),
                     call_count(0).

test_batch_stdout(FileName):- test_batch_stdout(FileName,CM,CPU,RESULT,Title).

test_batch_stdout(FileName,CM):- test_batch_stdout(FileName,CM,CPU,RESULT,Title).


% ===================================================================
% File 'moo_arg_domains.pl' 
% Maintainers: Douglas Miles
% Contact: dmiles@users.sourceforge.net
% ===================================================================
  
% :-include('moo_header.pl').



assertzRE(X):-assertz(X),writeSTDERR(assertzRE(X)).
assertaRE(X):-asserta(X),writeSTDERR(assertaRE(X)).
	  
/*
Rule Matrix Examples:


Example:

 (=>
          (instance ?OBJ Object) 
          (exists
             (?TIME1 ?TIME2) 
             (and
                (instance ?TIME1 TimePoint) 
                (instance ?TIME2 TimePoint) 
                (before ?TIME1 ?TIME2) 
                (forall
                   (?TIME) 
                   (=>
                      (and
                         (beforeOrEqual ?TIME1 ?TIME) 
                         (beforeOrEqual ?TIME ?TIME2) ) 
                      (time ?OBJ ?TIME) ) ) ) ) )
		      

  (=>
          (instance ?FUNCTION UnaryConstantFunctionQuantity) 
          (and
             (domain ?FUNCTION 1 ConstantQuantity) 
             (range ?FUNCTION ConstantQuantity) ) )
	     


 (=>
          (and
             (domain ?REL1 ?NUMBER ?CLASS1) 
             (domain ?REL2 ?NUMBER ?CLASS2) 
             (disjoint ?CLASS1 ?CLASS2) ) 
          (disjointRelation ?REL1 ?REL2) )


 (=>
          (and
             (subrelation ?PRED1 ?PRED2) 
             (domain ?PRED2 ?NUMBER ?CLASS2) 
             (domain ?PRED1 ?NUMBER ?CLASS1) ) 
          (subclass ?CLASS1 ?CLASS2) )

Items:
 
	Varible clasification:
	
	Term classes
	
	Term:  HV(n) SV(n) DV(n)
	
	a(H1,H2):-
		v(H1,v(S1)),v(H2,v(S2,v(DV,_))),
		b(H1,S1),
		c(H2,S1),
		d(S2,D1),
		e(D2).


	a(H1,H2):-
		b(H1,S1),
		c(H2,S1),
		d(S2,D1),
		e(D2).
		
	H1-1
	H2-1
	S1-2
	D1-3
	D2-Infinate
	
	   cost ordered
	(H1,H2),(S1),D1
	$2(	
	
	----------
	  |	  |
	H1-S1-H2
	      |
	     D1	   D2
	
	
	headvar plus a variables shared with another headvar

	headvar plus a variables shared with another headvar
	
	

	HeadSlots
	
	Universal in term with no head getPrologVars  

 
*/

% :-include('moo_header.pl').


isMooReadyForEdits:-isContextCompilerProcess(Context,Progress),!,write_ln(false).
isMooReadyForEdits:-write_ln(true).


isUncanonicalized(Context):-fail.	%TODO
isSourceNewerThenImage(Context):-fail.	%TODO
isKnowledgeBaseLoaded(Context,Ctx):-mooCache(_, _, _,_,Context, _, _, _),!.
isTheoryUntransfered(Context):-not(isKnowledgeBaseLoaded(Context,_)).
isTheoryLoading(Context,Status):-isMooProcess(ID,loadContextfromSource(Context,GlobalContext)),!.

isContextCompilerProcess(Context,LastPercent):-isMooProcess(ID,canonicalizeMooContextHTML(Context,GlobalContext)),!,
			flag('$last_written_percent',LastPercent,LastPercent).

isContextCurrentlyInUse(Context,unloaded):-nonvar(Context),isTheoryUntransfered(Context),!,fail.
isContextCurrentlyInUse(Context,canonicalizing(Progress)):-isContextCompilerProcess(Context,Progress),!.
isContextCurrentlyInUse(Context,loading(Status)):-isTheoryLoading(Context,Status),!.
isContextCurrentlyInUse(Context,_):-!,fail.

invokeContextCompilerProcess(Context):-!.
invokeContextCompilerProcess(Context):-not(isUncanonicalized(Context)),!.
invokeContextCompilerProcess(Context):-
	mooProcessCreate(canonicalizeMooContextHTML(Context,GlobalContext),
	canonicalizeMooContextHTML(Context,GlobalContext),ID,[detatched(true)]),!.

% =================================================
% Divide Fact and Rules	(Mine logic and create explaination node)
% =================================================
testrcan:-recanonicalizeMooContext('PrologMOO').

setOperationLock(Obj,Locker):-!.
setOperationUnlock(Obj,Locker):-!.



expireTN(Context,TN):-
	logOnFailureIgnore(retractallSpecial(mooCache(Literal,_,Context,TN))),  %Facts
	logOnFailureIgnore(retractallSpecial(mooCache(Literal,AnteLiteral,_,Context,TN))).

changeSurfaceStatusX(Context,TN,Before,After):-
	expireTN(Context,TN),!,
	changeSurfaceStatus(Context,TN,Before,After).

changeSurfaceStatus(Context,TN,Before,After):-
	retract(mooCache(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Before)),
	assertzRE(mooCache(Surface,CAN,Flags,Vars,Context,TN,Maintainer,After)),fail.
changeSurfaceStatus(Context,TN,Before,After):-!.
		


canonicalizeMooContextHTML(Context):-!.
canonicalizeMooContextHTML(Context):-
	tell('errors.html'),
	saveMooCache,
	logOnFailure(canonicalizeMooContext(Context)),
	saveMooCache,
	told.
canonicalizeMooContextHTML(Context):-!.


:-dynamic(canonicalizerWarnings(Context,_,_)).

clearCanonicalizerWarnings(Context):-retractallSpecial(canonicalizerWarnings(Context,_,_)),!.

sendCanonicalizerWarning(Warning,Data,Surface,Rule,CLID,Flags,KRVars,Context,TN,Anontate,Matrix,
	[(canonicalizerWarning(Warning,Data):-true)]):-
       % writeq(Warning:Data),nl,
       \+ ( \+ (canonicalizerWarnings(Context,Warning,Data)))  -> ifInteractive(write(','));
	(assertzRE(canonicalizerWarnings(Context,Warning,Data)),
	ifInteractive(writeObject(nv([nl,Warning,nl,writeq(Data),nl,Surface,nl,nl]),KRVars))),!.



rct:-canonicalizeMooContextReal('PrologMOO').

canonicalizeMooContext(Context):-!.
canonicalizeMooContextReal(Context):-
	clearCanonicalizerWarnings(Context),
	writeDebug(starting(canonicalizeMooContext(Context))),
	flag(explaination_id,_,1),
	recanonicalizeTN(Context,TN),
	writeDebug(done(canonicalizeMooContext(Context))),!.


recanonicalizeTN(Context,TN):-
	(retractallSpecial(mooCache(Literal,_,Context,TN))),  %Facts
	(retractallSpecial(mooCache(Literal,AnteLiteral,_,Context,TN))),	 %Rules 
	fail.
	
recanonicalizeTN(Context,TN):-
	flag('$sofar',_,1),
	countAssertions(mooCache(_,_,_,_,Context,TN,_,_),Total),
	ifInteractive((writeFmt('\Compiling ~w surface clauses in ~w\n',[Total,Context]),writePercentAndTimeReset)),
	ignore((mooCache(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result),  
	once((
	%	numbervars((Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result),'$VAR',0,_),!,
		canonicalizeClause(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result,AssertList),
		assertAll(AssertList),
	        ifInteractive((
			flag('$sofar',SoFar,SoFar+1),
			writePercentAndTime('\n ~1f% complete.  Estimated cpu "priority" seconds remaining: ~1f\n ',SoFar,Total,8)
			))
		)),fail)),
	ifInteractive((
		flag(explaination_id,ExplainationID,ExplainationID),
		countAssertions(mooCache(_,_,Context,TN),Facts),
		countAssertions(mooCache(_,_,_,Context,TN),Rules),
		writeFmt('\n100% complete.  Examined ~w internal lemma structures for ~w. Facts:~w  Rules:~w  \n',[ExplainationID,Context,Facts,Rules]))),!.
	
writePercentAndTimeReset:-
	((flag('$last_written_percent',_,1),getCputime(Now),!,flag('$cputime_percent_start',_,Now))).
	
writePercentAndTime(Format,SoFar,Total,Steps):-
        ((
		flag('$last_written_percent',LastPercent,LastPercent),
	        NewPercent is (SoFar/Total * 100),
		NextPercent is LastPercent + Steps, 
		writePercentAndTime(Format,SoFar,Total,NextPercent,NewPercent))).
		
writePercentAndTime(Format,SoFar,Total,NextPercent,NewPercent):- NextPercent > NewPercent,!,write(.).
writePercentAndTime(Format,SoFar,Total,NextPercent,NewPercent):-
				flag('$last_written_percent',_,NewPercent),
				getCputime(Now),flag('$cputime_percent_start',Start,Start),
				TimeLeft is (Total-SoFar)*2*((Now-Start)/SoFar),
				writeFmt(Format,[NewPercent,TimeLeft]),!.
				



ifInteractive(G):-ignore((getThread(Id),(number(Id);(G,flush_output)),!)).

                                    
recanonicalizeTN(Context,TN):-!.
	
deduceLegalToCan(Surface,_):-
	once(getConstants(atomic,Surface,Consts,_,_)),
	member(Word,Consts),
	deduceDisabledSurfaceConst(Word),!,fail.

deduceLegalToCan(Surface,_):-!.
	
:-dynamic(deduceDisabledSurfaceConst/1).

%deduceDisabledSurfaceConst('graphPart'). deduceDisabledSurfaceConst('NormativeAttribute').

% In Moo DB we have 3 types of Vars
% var(Var)
% Var='$VAR'(_).
% Var=..['$existential',V|Body],var(V)

% isSlot(X):-var(Var).


% ================================================================
% Convert Forms to AssertionList
% ================================================================
canonicalizeClause(Surface,true,Flags,Vars,Context,TN,Maintainer,Result,[]):-!.
canonicalizeClause(Surface,not(true),Flags,Vars,Context,TN,Maintainer,Result,[]):-!.
canonicalizeClause(Surface,Var,Flags,Vars,Context,TN,Maintainer,Result,[]):-isSlot(Var),!.

% Context |= CAN1 & CAN2
canonicalizeClause(Surface,and(CAN1,CAN2),Flags,Vars,Context,TN,Maintainer,Result,AssertionList):-!,
	(canonicalizeClause(Surface,CAN1,Flags,Vars,Context,TN,Maintainer,Result,AssertList1)),
	(canonicalizeClause(Surface,CAN2,Flags,Vars,Context,TN,Maintainer,Result,AssertList2)),!,
	append(AssertList1,AssertList2,AssertionList).     

canonicalizeClause(Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result,AssertList):-
	unnumbervars((Surface,CAN,Flags,Vars,Context,TN,Maintainer,Result),
			   (USurface,UCAN,UFlags,UVars,UContext,UCtx,UTN,UMaintainer,UResult)),
	canonicalizeRule(USurface,UCAN,UFlags,UVars,UContext,UCtx,UTN,UMaintainer,UResult,AssertList),!.

      
% =============================================================

ruleToPrologHeadBodyList(entails(Ante,Cons),Cons,Ante):-!.	
ruleToPrologHeadBodyList(Cons,Cons,true).      
	
% =============================================================
	
canonicalizeRule(Surface,Rule,Flags,KRVars,Context,TN,Maintainer,Result,Assertions):-!,
	ruleToPrologHeadBodyList(Rule,Cons,Ante),	
	conjunctsToList(Ante,NewAnteLA),!,
	%removeCompilables(Cons,NewAnteLA,NewAnteLA,NewAnteRM),!,
	removeCompilables(Cons,NewAnteLA,NewAnteLA,NewAnteR),!,
	canonicalizeLemme(Surface,Rule,Cons,Ante,NewAnteR,Flags,KRVars,Context,TN,Maintainer,Result,Assertions),!.


% =============================================================

deNeg(not Item,Item):-!.  deNeg(Item,Item).

% =============================================================


canonicalizeLemme(Surface,Rule,Cons,Ante,NewAnteR,Flags,KRVars,Context,TN,Maintainer,Result,[]):-
	member(Item,NewAnteR), deNeg(Item,NItem), nonvar(NItem),
	functor(NItem,F,_),(memberchkSpecial(F,['$taut',request])),
	ifInteractive(writeObject(implied(Rule),KRVars)),!.


% =============================================================

canonicalizeLemme(Surface,Rule,Cons,Ante,NewAnteR,Flags,KRVars,Context,TN,Maintainer,Result,Assertions):-
	getPrologVars(Cons,HeadSlots,_,_),
	adjustSkolemOrder(HeadSlots,NewAnteR,NewAnteL),!,
	nonWrappedCan(HardCoded),
	convertToHolds([holds|HardCoded],Cons,EntailedHead),!,
	convertBodyToHolds(NewAnteL,ConditionalBody),!,
	selectSign(EntailedHead,Sign),!,
	copy_term(EntailedHead,USeed),
	convertNegations(lit,USeed,ProtoType,_),
	numbervars(ProtoType,('$'),0,_),
	selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,EntailedHead,ConditionalBody,Matrix),!,
	flag(clause_id,CLID,CLID+1),
	setMooOption(putAttributeStructures,(Surface,Rule,CLID,Flags,KRVars,Context,Ctx,TN)),!,
	catch(putAttributeStructures(Context,Flags,Matrix,EmbededArgs),
		mooException(argDomains,Type,Details,DebugOnError),
		(set_prolog_flag(debug_on_error, DebugOnError),
		sendCanonicalizerWarning(Type,Details,Surface,Rule,CLID,Flags,KRVars,
								Context,TN,Ctx,Matrix,EmbededArgs))),!,
	convertNegations(lit,EmbededArgs,LiteralMatrix,_),
	createFunctionalClauses(':'(Rule,KRVars),LiteralMatrix,Clauses),
	mergeClauses(ProtoType,Clauses,Rule,CLID,Flags,KRVars,Context,TN,Assertions),!.


% =============================================================

adjustSkolemOrder(HeadSlots,[],[]):-!.
adjustSkolemOrder(HeadSlots,['$existential'(Var,Name,Form)|Rest],[VT|RestPlus]):-
	once((getPrologVars(Form,FormVars,_,_),set_partition(FormVars,HeadSlots,_,_,MustBeGround))),
	MustBeGround=[_|_], VT=..['$groundVars'|MustBeGround],!,
	adjustSkolemOrder(HeadSlots,Rest,RestS),
	append(RestS,['$existential'(Var,Name,Form)],RestPlus),!.
adjustSkolemOrder(HeadSlots,Other,Other):-!.

% =============================================================

mergeClauses(ProtoType,[],KR,CLID,Flags,KRVars,Context,TN,Assertions).
mergeClauses(ProtoType,[Matrix|Rest],KR,CLID,Flags,KRVars,Context,TN,Assertions):-!,
	getAssertMatrix(ProtoType,Matrix,KR,CLID,KRVars,Context,TN,HL),!,
	mergeClauses(ProtoType,Rest,KR,CLID,Flags,KRVars,Context,TN,SubAssertions),
	append(HL,SubAssertions,Assertions),!.

% =============================================================

getAssertMatrix(ProtoType,(C:-true),KR,CLID,KRVars,Context,TN,[mooCache(C,(ExplainationID,KRVars,KR),Context,TN)]):-
	flag(explaination_id,ExplainationID,ExplainationID+1).

getAssertMatrix(ProtoType,(C:-A),KR,CLID,KRVars,Context,TN,[mooCache(C,A,(ExplainationID,KRVars,KR),Context,TN)]):-
	flag(explaination_id,ExplainationID,ExplainationID+1).
getAssertMatrix(ProtoType,C,KR,CLID,KRVars,Context,TN,[mooCache(C,(ExplainationID,KRVars,KR),Context,TN)]):-
	flag(explaination_id,ExplainationID,ExplainationID+1).
		 
% =============================================================

createFunctionalClauses(Rule,[],[]).
createFunctionalClauses(Rule,[(C:-true)|More],[C|Clauses]):-!,
	createFunctionalClauses(Rule,More,Clauses).
createFunctionalClauses(Rule,[(C:-A)|More],Clauses):-!,
	createFunctionalClauses(Rule,(C:-A),SomeClauses),!,
	createFunctionalClauses(Rule,More,MoreClauses),
	append(SomeClauses,MoreClauses,Clauses),!.
createFunctionalClauses(Rule,[C|More],Clauses):-!,
	createFunctionalClauses(Rule,C,SomeClauses),!,
	createFunctionalClauses(Rule,More,MoreClauses),
	append(SomeClauses,MoreClauses,Clauses),!.

/*
createFunctionalClauses(Rule,C:-A,[C:-Body]):-
	getMostGeneralSubsumption(C,A,TF,UnsignedC,Variant),Variant=[_|_],!,
	%copy_term(Variant,Copy),numbervars(Copy,'$',0,_),
       %  nl,writeq(Rule),nl,writeq(Variant),nl,nl,
	Body=..[TF,A,Variant].
*/

%createFunctionalClauses(Rule,C:-A,[C:-Body]):-!,writeq(A),
	
createFunctionalClauses(Rule,C,[C]).


% =============================================================

getMostGeneralSubsumption((C), Term,'table_',C,VL):- !,
	findall(Variant,getMostGeneralSubsumptionI((C), Term,(Variant)),VL),!.

/*
getMostGeneralSubsumption(not C, Term,'f_t',C,Variant):-!,
	getMostGeneralSubsumptionI((C), (Term),Variant).

getMostGeneralSubsumption(C, Term,'t_f',C,Variant):-
	getMostGeneralSubsumptionI(not(C), Term,not(Variant)),!.
*/
getMostGeneralSubsumptionI(X, Term,_):-not(compound(Term)),!,fail.
%getMostGeneralSubsumptionI(X, Term,_):-functor(Term,F,_),atom_concat('$',_,F),!,fail.
getMostGeneralSubsumptionI(X, Term,Term) :-%functor(X,F,Arity),functor(Term,F,Arity),!,
				not(not((X=Term))),!.
getMostGeneralSubsumptionI(X, Term,Variant) :-
	arg(_, Term, Arg),
	getMostGeneralSubsumptionI(X, Arg,Variant).

	
% =============================================================

nonWrappedCan([holdsDuring,entails,'include-context',instance,request,'$existential',false,true,domain,equal,subclass,subrelation,disjointDecomposition]).

% =============================================================

removeCompilables(Cons,Rule,[],[]).
removeCompilables(Cons,Rule,[EQ|AnteLA],AnteL):-Cons==EQ,!,
	removeCompilables(Cons,Rule,AnteLA,AnteL),!.
removeCompilables(Cons,Rule,[New|AnteLA],[New|AnteL]):-!,
	removeCompilables(Cons,Rule,AnteLA,AnteL),!.

/*
removeCompilables(Cons,Rule,[instance(Var,Atom)|AnteLA],AnteL):-isSlot(Var),atom(Atom),!,
	removeCompilables(Cons,Rule,AnteLA,AnteL).
removeCompilables(Cons,Rule,[instance(Var,'$Class'(Atom,Fixed))|AnteLA],AnteL):-isSlot(Var),atom(Atom),!,
	removeCompilables(Cons,Rule,AnteLA,AnteL),!.
removeCompilables(Cons,Rule,[subclass(Var1,Var2)|AnteLA],AnteL):-unify_with_occurs_check(Var1,Var2),!,
	removeCompilables(Cons,Rule,AnteLA,AnteL),!.
removeCompilables(Cons,Rule,[domain(Pred,N,Class)|AnteLA],['$grDomain'(Pred,N,Class)|AnteL]):-
	removeCompilables(Cons,Rule,AnteLA,AnteL),!.
*/

% =============================================================

mapOnConj(Goal,LogAnte,ConditionalBody):-var(LogAnte),var(ConditionalBody),!,
	Goal=..[F|Args],append([F|Args],[LogAnte,ConditionalBody],CallL),
	Call=..CallL,!,call(Call).
mapOnConj(Goal,[LogAnte],[ConditionalBody]):-var(LogAnte),var(ConditionalBody),!,
	Goal=..[F|Args],append([F|Args],[LogAnte,ConditionalBody],CallL),
	Call=..CallL,!,call(Call).

mapOnConj(_,[],[]):-!.
mapOnConj(Goal,[Log|Ante],[Conditional|Body]):-!,
	mapOnConj(Goal,Log,Conditional),
	mapOnConj(Goal,Ante,Body).
mapOnConj(Goal,LogAnte,ConditionalBody):-nonvar(LogAnte),
	compound(LogAnte),LogAnte=..[Connective,L|IST],isBodyConnective(Connective),!,
	mapOnConj(Goal,[L|IST],ConditionalBodyList),
	ConditionalBody=..[Connective|ConditionalBodyList],!.
mapOnConj(Goal,LogAnte,ConditionalBody):-nonvar(ConditionalBody),
	compound(ConditionalBody),ConditionalBody=..[Connective,L|IST],isBodyConnective(Connective),!,
	mapOnConj(Goal,LogAnteL,[L|IST]),
	LogAnte=..[Connective|LogAnteL],!.
mapOnConj(Goal,LogAnte,ConditionalBody):-!,
	Goal=..[F|Args],append([F|Args],[LogAnte,ConditionalBody],CallL),
	Call=..CallL,
	call(Call).
	
% =============================================================

convertBodyToHolds(LogAnte,ConditionalBody):-!,
	((convertNegations(not,LogAnte,NottedLogAnte,_),
	nonWrappedCan(Nowrap),
	convertToHolds([holds|Nowrap],NottedLogAnte,ConditionalBody))).

convertToHolds(Flags,Mid,Term):-
	%
	(mapOnConj(convertToHoldsProp(Flags),Mid,Term)),!.
	
convertToHoldsProp(Flags,(Term),(Term)):-isSlot(Term),!.
convertToHoldsProp(Flags,not(Mid),not(Term)):-!,convertToHolds(Flags,Mid,Term).
convertToHoldsProp(Flags,Mid,'$eval'(Term)):-Mid=..[F|Args],atom(F),atom_concat(_,'Fn',F),!,Term=..[F|Args].
convertToHoldsProp(Flags,(Term),(Term)):-functor(Term,F,_),atom_concat('$',_,F),!.

convertToHoldsProp(Flags,Mid,(Term)):-Mid=..[holds,F|Args],atom(F),atom_concat(_,'Fn',F),!,Term=..[function,F|Args].
convertToHoldsProp([_|Flags],Mid,Term):-Mid	=..[F|Args],memberchkSpecial(F,Flags),!,Term=..[F|Args].
convertToHoldsProp(Flags,Mid,Mid):-not(not(memberchkSpecial(Mid,Flags))),!.
convertToHoldsProp([orig|_],Mid,Mid):-!.
convertToHoldsProp([Wrap|_],Mid,Term):-Mid=..[Wrap,F|Args],atom(F),!,Term=..[F|Args],!.
convertToHoldsProp([Wrap|_],Term,Term):-!.

% =============================================================

containsSkolems(Flags,EntailedHeadLiteral):-
	((getPrologVars(EntailedHeadLiteral,Vars,_,_),!,member(Each,Vars),member(replaceConsVar(Each,_),Flags),!)).

	
selectBestRuleMatrix(Sign,HeadSlots,Flags,_,EntailedHead,[],[ (EntailedHead:-guarded_(EntailedHead)) ]):-!.
selectBestRuleMatrix(Sign,HeadSlots,Flags,_,EntailedHead,[true],[EntailedHead]):-!.
selectBestRuleMatrix(Sign,HeadSlots,Flags,[],EntailedHead,Body,[ (EntailedHead:-novars_(Body)) ]):-!.
selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,EntailedHead,ConditionalBody,[( EntailedHead:-NewBodListGuarded) ]):-
	getPrologVars(EntailedHead:ConditionalBody,AllVars,_,_),
	getPrologVars(ConditionalBody,BodyVars,BodyVarsSingleMaybeHead,BodyVarsConnectedAndMaybeHead),
	set_partition(HeadSlots,BodyVars,PrivateHead,PrivateBody,AllSharedHB),!,
	set_partition(HeadSlots,BodyVarsConnectedAndMaybeHead,UsedMoreThenOnceHeads,BodyOnlyConected,SplitHeadVar),!,
	set_partition(HeadSlots,BodyVarsSingleMaybeHead,UsedOnceHeads,UniversalBody,HeadSlotsSingleInBody),!,
	reorderAnteListAddPropositionalMechanisms(Sign,ConditionalBody,PrivateHead,PrivateBody,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,NewBodListWrappedL),!,
	sort(NewBodListWrappedL,NewBodListWrappedS),
	list_to_comma(NewBodListWrappedS,BodListWrappedC),
	Inner =.. [Sign,BodListWrappedC,PrivateHead,PrivateBody],
	selectBestBodyMechanism(Inner,HeadSlots,BodyOnlyConected,UniversalBody,NewBodListGuarded),!.
	%VarInfClause =.. ['$v'],
	%NewBodListGuarded=..[Major,BodListWrappedC|VarINF].
	%prologPartitionList(NewBodListWrappedS,Item,sharedVars(Item,HeadSlots),Shared,Unshared),
	%list_to_comma(Shared,SharedT),
	%list_to_comma(Unshared,UnsharedT),
	%selectRule(Sign,ConjPosNegFA,DiscPosNegFA,NewBodListGuarded),!.%true.*/
	

% =============================================================
%			  uVar			  Hv				Bv		     CH
% =============================================================

intersectionMath(Start,Scale,L1,L2,L12,New):-set_partition(L1,L2,_,_,L12),!,
	length(L12,Length),!,New is (Length * Scale) + Start.

reorderAnteListAddPropositionalMechanisms(Sign,List,HeadSlots,BodyVars,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,Result):-
	reorderAnteListAddPropositionalMechanismEach(Sign,List,HeadSlots,BodyVars,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,KeyedResult),!,
	keysort(KeyedResult,SortedResult),%true,
	removeKeys(SortedResult,Result),!.
	
removeKeys([],[]).
removeKeys([K-I|KRest],[I|Rest]):-
	  removeKeys(KRest,Rest),!.
removeKeys([I|KRest],[I|Rest]):-
	  removeKeys(KRest,Rest),!.
	  

reorderAnteListAddPropositionalMechanismEach(Sign,[],HeadSlots,BodyVars,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,[]).
reorderAnteListAddPropositionalMechanismEach(Sign,[Conditional|Body],HeadSlots,BodyVars,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,[Cost-ConditionalClass|BodyList]):-
	getPrologVars(Conditional,CVars,_,_),
	intersectionMath(0,1000,UniversalBody,CVars,CUniversalBody,Cost1), %U Irealivant
	intersectionMath(Cost1,100,BodyOnlyConected,CVars,CBodyOnlyConected,Cost2), %X Transfer
        intersectionMath(Cost2,10,HeadSlotsSingleInBody,CVars,CHeadSlotsSingleInBody,Cost3), %H  Head
        intersectionMath(Cost3,1,SplitHeadVar,CVars,CSplitHeadVar,Cost), %S split head over cluases
	selectBestPropositionMechanism(Sign,HeadSlots,BodyVars,Conditional,ConditionalClass,CUniversalBody,CBodyOnlyConected,CHeadSlotsSingleInBody,CSplitHeadVar),
	reorderAnteListAddPropositionalMechanismEach(Sign,Body,HeadSlots,BodyVars,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,BodyList).	

%CUniversalBody,CBodyOnlyConected,CHeadSlotsSingleInBody,CSplitHeadVar
selectBestPropositionMechanism(Sign,HeadSlots,BodyVars,Conditional,ConditionalClass,
	CUniversalBody,CBodyOnlyConected,CHeadSlotsSingleInBody,CSplitHeadVar):-!,
	ConditionalClass=..[Sign,Conditional,CUniversalBody,CBodyOnlyConected,CHeadSlotsSingleInBody,CSplitHeadVar].
	
			/*

% Works but is unused now
selectBestPropositionMechanism(Sign,Conditional,CVars,HeadSlots,ConditionalClass,
			CUniversalBody,CBodyOnlyConected,CHeadSlots):-
	appendFunctInf(''(Conditional),'U',CUniversalBody,Conditional1),!,
	appendFunctInf(Conditional1,'B',CBodyOnlyConected,Conditional2),!,
	appendFunctInf(Conditional2,'H',CHeadSlots,ConditionalClassEF),!,
	removeEmptyFunct(Sign,ConditionalClassEF,ConditionalClass).
			  */
selectBestBodyMechanism(Seed,HeadSlots,BodyOnlyConected,UniversalBody,VarClause):-!,
	appendFunctInf(Seed,'Head',HeadSlots,Next1),	
	appendFunctInf(Next1,'Bodyc',BodyOnlyConected,Next2),
	appendFunctInf(Next2,'Univb',UniversalBody,VarClauseEF),!,	
	removeEmptyFunct(VarClauseEF,VarClause).


removeEmptyFunct(''(VarClause),VarClause):-!.
removeEmptyFunct(VarClause,VarClause):-!.

removeEmptyFunct(_,''(VarClause),VarClause):-!.
removeEmptyFunct(Sign,VarClause,VarClauseO):-
	VarClause=..[BF|Args],atom_concat(Sign,BF,New),
	VarClauseO=..[New|Args].
	
% =============================================================

appendFunctInf(In,_,[],In).
appendFunctInf(In,F,VarList,Out):-
	In=..[PF|Rest],
	atom_concat(PF,F,NF),
	append(Rest,[VarList],OArgs),
	Out=..[NF|OArgs],!.

appendFunct(In,_,[],In).
appendFunct(In,F,_,Out):-
	In=..[PF|Rest],
	atom_concat(PF,F,NF),
	Out=..[NF|Rest],!.

appendFunctV(In,_,[],In).
appendFunctV(In,F,VL,Out):-
	VC=..['$v'|VL],
	In=..[PF|Rest],
	atom_concat(PF,F,NF),
	append(Rest,[VC],NewL),!,
	Out=..[NF|NewL],!.

       
% =============================================================

wFrame:-
	prolog_current_frame(Frame),!,
	prolog_frame_attribute(Frame, goal,Value),!,
	writeq(Value),nl.
     
	
fc_cmp(not X,not(Y),'f-f'):-!,too_eq(X,Y),!. 
fc_cmp(not X, Y,'f-t'):-!,too_eq(X,Y),!.
fc_cmp( X,not Y,'t-f'):-!,too_eq(X,Y),!.
fc_cmp( X, Y,'t-t'):-too_eq(X,Y),!.
	
too_eq(X,Y):-compareVariant(X,Y,U,Dif),!,
	nonvar(U), (Dif < (1)).
			   

selectSign(not NHead,'f~'):-!.
selectSign(NHead ,'t~'):-!.


	
selectRule(Sign,[],[],Sign).

selectRule(Sign,[],DiscPosNeg,Body):-
	DiscPosNeg=..[F|PosNegL],
	concat_atom([Sign,F,'_'],RH),!,
	Body=..[RH|PosNegL].

selectRule(Sign,ConjPosNeg,[],Body):-
	ConjPosNeg=..[F|PosNegL],
	concat_atom([Sign,F,'_'],RH),
	Body=..[RH|PosNegL],!.

selectRule(Sign,ConjPosNegFA,DiscPosNegFA,Body):-
	ConjPosNegFA=..[C|OnjPosNegFAL],
	DiscPosNegFA=..[D|IsjPosNegFAL],
	concat_atom([Sign,C,D,'_'],RH),
	append(OnjPosNegFAL,IsjPosNegFAL,BArgs),!,
	Body=..[RH|BArgs],!.
	
				
selectConjPosNegFA(AllSharedHB,FindPos,FindNeg,ConjPosNegFA):-
	selectConjPosNeg(FindPos,FindNeg,ConjPosNeg),
	selectConjPosNegVars(AllSharedHB,ConjPosNeg,ConjPosNegFA),!.


selectConjPosNeg([],[],[]).
selectConjPosNeg([],FindNeg,'CNeg'(FindNegC)):-list_to_comma(FindNeg,FindNegC).
selectConjPosNeg(FindPos,[],'CPos'(FindPosC)):-list_to_comma(FindPos,FindPosC).
selectConjPosNeg(FindPos,FindNeg,'Con'(FindPosC,FindNegC)):-
	list_to_comma(FindNeg,FindNegC),list_to_comma(FindPos,FindPosC),!.

selectConjPosNegVars([],ConjPosNeg,ConjPosNeg).
selectConjPosNegVars(AllSharedHB,[],'CVars'(Shared)):-Shared=..['$v'|AllSharedHB].
selectConjPosNegVars(AllSharedHB,ConjPosNeg,ConjPosNegFA):-
	Shared=..['$v'|AllSharedHB],
	ConjPosNeg=..[F|Args],
	ConjPosNegFA=..[F,Shared|Args].


selectDiscPosNegFA(AllSharedHB,FindPos,FindNeg,DiscPosNegFA):-
	selectDiscPosNeg(FindPos,FindNeg,DiscPosNeg),
	selectDiscPosNegVars(AllSharedHB,DiscPosNeg,DiscPosNegFA),!.

selectDiscPosNeg([],[],[]).
selectDiscPosNeg([],FindNeg,'DNeg'(FindNegC)):-list_to_comma(FindNeg,FindNegC).
selectDiscPosNeg(FindPos,[],'DPos'(FindPosC)):-list_to_comma(FindPos,FindPosC).
selectDiscPosNeg(FindPos,FindNeg,'Dis'(FindPosC,FindNegC)):-list_to_comma(FindNeg,FindNegC),list_to_comma(FindPos,FindPosC).

selectDiscPosNegVars([],DiscPosNeg,DiscPosNeg).
selectDiscPosNegVars(AllSharedHB,[],'DVars'(Shared)):-Shared=..['$v'|AllSharedHB].
selectDiscPosNegVars(AllSharedHB,DiscPosNeg,DiscPosNegFA):-
	Shared=..['$v'|AllSharedHB],
	DiscPosNeg=..[F|Args],
	DiscPosNegFA=..[F,Shared|Args].

                                                         

/*
replaceConsVar(xB, '$existential'([63, 84, 73, 77, 69, 50], exists(xC, and(instance(xC, 'TimePoint'), and(instance([63, 84, 73, 77, 69, 50], 'TimePoint'), and(before(xC, [63, 84, 73, 77, 69, 50]), forall(D, =>(and(beforeOrEqual(xC, D), beforeOrEqual(D, [63, 84, 73, 77, 69, 50])), time(A, D))))))))), 
replaceConsVar(xC, '$existential'([63, 84, 73, 77, 69, 49], and(instance([63, 84, 73, 77, 69, 49], 'TimePoint'), and(instance(xB, 'TimePoint'), and(before([63, 84, 73, 77, 69, 49], xB), forall(D, =>(and(beforeOrEqual([63, 84, 73, 77, 69, 49], D), beforeOrEqual(D, xB)), time(A, D))))))))], 

entails(not(instance(xC, 'TimePoint')), not(instance(A, 'Object')))
   
Prolog:  impossible(instance(_, 'Object')) :- \+ searchable(instance(_, 'TimePoint'))


entails(not(instance(xB, 'TimePoint')), not(instance(A, 'Object'))) 

Prolog: impossible(instance(_, 'Object')) :- impossible(instance(_, 'TimePoint'))


entails(not(before(xC, xB)), not(instance(A, 'Object'))), 

Prolog: impossible(instance(_, 'Object')) :- impossible(before(_,_))
 


*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,EntailedHead,
		SharedPos,UnsharedPos,
		SharedNeg,UnsharedNeg,
	[(impossible(EntailedHead) :- impossible(Negs))],
		HeadSlots,BodyVars,VAllShare,SharedPosV,SharedNegV,
		PrivateHead,PrivateBody,UnsharedPos,UnsharedNeg):-!.

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,[],[not(Negs)],not(EntailedHead),
	[(impossible(EntailedHead) :- impossible(Negs))],
		HeadSlots,BodyVars,
		PrivateHead,PrivateBody,
		SharedPos,SharedNeg,[]/*No shared Vars*/):-!.
	
selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,EntailedHead,
		SharedPos,UnsharedPos,
		SharedNeg,UnsharedNeg,
		Matrix,
		HeadSlots,BodyVars,VAllShare,SharedPosV,SharedNegV,
		PrivateHead,PrivateBody,UnsharedPos,UnsharedNeg):-!.




/*

entails(not(domain(A, 1, 'ConstantQuantity')), not(instance(A, 'UnaryConstantFunctionQuantity'))),

Prolog: impossible(instance(A, 'UnaryConstantFunctionQuantity')):- impossible(domain(A, 1, 'ConstantQuantity'))


entails(not(range(A, 'ConstantQuantity')), not(instance(A, 'UnaryConstantFunctionQuantity'))), 

Prolog: neg(instance(A, 'UnaryConstantFunctionQuantity')):- neg(range(A, 'ConstantQuantity'))
 
*/
					       % no possitives
selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,[],[not(Negs)],not(EntailedHead),
	[(impossible(EntailedHead) :- impossible(ConditionalBody))],
		HeadSlots,BodyVars,
		[],[],	% No varables private on head or body /*All shared Vars*/
		SharedPos,SharedNeg,AllSharedHB):-!.

/*
replaceConsVar(xB, '$existential'([63, 84, 73, 77, 69, 50], exists(xC, and(instance(xC, 'TimePoint'), and(instance([63, 84, 73, 77, 69, 50], 'TimePoint'), and(before(xC, [63, 84, 73, 77, 69, 50]), forall(D, =>(and(beforeOrEqual(xC, D), beforeOrEqual(D, [63, 84, 73, 77, 69, 50])), time(A, D))))))))), 
replaceConsVar(xC, '$existential'([63, 84, 73, 77, 69, 49], and(instance([63, 84, 73, 77, 69, 49], 'TimePoint'), and(instance(xB, 'TimePoint'), and(before([63, 84, 73, 77, 69, 49], xB), forall(D, =>(and(beforeOrEqual([63, 84, 73, 77, 69, 49], D), beforeOrEqual(D, xB)), time(A, D))))))))], 

entails(and(not(time(A, D)), and(beforeOrEqual(D, xB), instance(A, 'Object'))), not(beforeOrEqual(xC, D))), 

Prolog: neg(beforeOrEqual(xC, D)) :- beforeOrEqual(D, xB),  instance(A, 'Object'),  not(time(A, D))


entails(and(not(time(A, D)), and(beforeOrEqual(xC, D), instance(A, 'Object'))), not(beforeOrEqual(D, xB))))))))), 

Prolog: neg(beforeOrEqual(D, xB)) :- beforeOrEqual(xC, D),  instance(A, 'Object'),  not(time(A, D))
*/


selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,Pos,Negs,EntailedHead,
	[(impossible(EntailedHead):- prove(ifThen([Item|Rest],Negs)))],
		HeadSlots,BodyVars,
		PrivateHead,PrivateBody,
		[Shared|PosV],SharedNeg,[S|Hared]  /*One Or More shared Vars*/):-!.

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,ConditionalBody,not(EntailedHead),
	[(impossible(EntailedHead):- prove(ifThen([Item|Rest],Negs)))],
	HeadSlots,BodyVars,PrivateHead,PrivateBody,[S|Hared]):-
	splitNegations(ConditionalBody,Pos,Negs), Pos=[_|_],   % At least one possitive
	prologEach(Negs,Item,sharedVars(Item,EntailedHead)),   % All negated body variables are shared with head
	prologAtLeastOne(Pos,Item,sharedVars(Item,EntailedHead)),!, % At least one positive item is shared
	subtractProp(Item,Pos,Rest),!. % we'll move that item first
	

/*


entails(and(not(subclass(E, D)), and(domain(A, C, E), domain(B, C, D))), not(subrelation(A, B)))

Prolog: neg(subrelation(A, B)):-  domain(A, C, E), domain(B, C, D), neg(subclass(E, D)).


entails(and(not(subclass(E, D)), and(subrelation(A, B), domain(A, C, E))), not(domain(B, C, D)))

Prolog: neg(domain(B, C, D)):- neg(subclass(E, D)), subrelation(A, B), domain(A, C, E)


entails(and(not(subclass(E, D)), and(subrelation(A, B), domain(B, C, D))), not(domain(A, C, E)))))),
 
Prolog: neg(domain(A, C, E)):- neg(subclass(E, D)), subrelation(A, B), domain(B, C, D)
 

entails(and(not(disjointRelation(A, D)), and(disjoint(C, E), domain(D, B, E))), not(domain(A, B, C))), 

Prolog: neg(domain(A, B, C)) :- disjoint(C, E), domain(D, B, E),  neg(disjointRelation(A, D))


and(entails(and(not(disjointRelation(A, D)), and(disjoint(C, E), domain(A, B, C))), not(domain(D, B, E))), 

Prolog: neg(domain(D, B, E)) :- disjoint(C, E), domain(A, B, C),  neg(disjointRelation(A, D))


entails(and(not(disjointRelation(A, D)), and(domain(A, B, C), domain(D, B, E))), not(disjoint(C, E)))))), 

Prolog: impossilbe(disjoint(C, E)) :- domain(A, B, C), domain(D, B, E), neg(disjointRelation(A, D)).

*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,Pos,Negs,EntailedHead,
		Matrix,
		HeadSlots,BodyVars,
		PrivateHead,PrivateBody,
		SharedPos,SharedNeg,AllSharedHB):-!.


selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails((Body),not(EntailedHeadLiteral)),
		[(impossible(EntailedHeadLiteral) :- ifThen(findall(Shared,Passed),Unshared))]):-
	notSkolemFlags(Flags),
	splitNegations(Body,Pos,[]),
	prologPartitionList(Pos,Item,sharedVars(Item,EntailedHeadLiteral),Passed,Unshared),
	sharedVars(Passed,EntailedHeadLiteral,Shared),!.

/*
replaceConsVar(xB, '$existential'([63, 84, 73, 77, 69, 50], exists(xC, and(instance(xC, 'TimePoint'), and(instance([63, 84, 73, 77, 69, 50], 'TimePoint'), and(before(xC, [63, 84, 73, 77, 69, 50]), forall(D, =>(and(beforeOrEqual(xC, D), beforeOrEqual(D, [63, 84, 73, 77, 69, 50])), time(A, D))))))))), 
replaceConsVar(xC, '$existential'([63, 84, 73, 77, 69, 49], and(instance([63, 84, 73, 77, 69, 49], 'TimePoint'), and(instance(xB, 'TimePoint'), and(before([63, 84, 73, 77, 69, 49], xB), forall(D, =>(and(beforeOrEqual([63, 84, 73, 77, 69, 49], D), beforeOrEqual(D, xB)), time(A, D))))))))], 

entails(instance(A, 'Object'), before(xC, xB))

Prolog: before(xC, xB) :- findall(A,instance(A, 'Object'))
	   searchable(before(_, _)):-searchable(instance(_, 'Object')).


entails(instance(A, 'Object'), instance(xC, 'TimePoint'))), 

Prolog: instance(xC, 'TimePoint') :- findall(A,instance(A, 'Object'))
	   searchable(instance(_,'TimePoint')):-searchable(instance(_, 'Object')).
	   

entails(instance(A, 'Object'), instance(xB, 'TimePoint'))), 

Prolog: instance(xB, 'TimePoint') :- findall(A,instance(A, 'Object'))
	   searchable(instance(_,'TimePoint')):-searchable(instance(_, 'Object')).
	   

*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails([true],EntailedHeadLiteral),
		[(EntailedHeadLiteral :- ( NewAnte,
		 searchable(EntailedHeadLiteral)))]):-
	containsSkolems(Flags,EntailedHeadLiteral),
	getPrologVars(EntailedHeadLiteral,ConVars,_,_),
	add_skolems_to_body(Flags,true,EntailedHeadLiteral,ConVars,NewAnte),
%	skolemizeVars(Flags,KRVars,EntailedHeadLiteral,SkolemizedHead),
	sharedVars(EntailedHeadLiteral,Thing,SharedVars).

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails(Thing,EntailedHeadLiteral),
		[(EntailedHeadLiteral :- ifThen(findall(SharedVars,Thing),NewAnte)),
		 (searchable(EntailedHeadLiteral):-searchable(Thing))]):-
	containsSkolems(Flags,EntailedHeadLiteral),
	getPrologVars(EntailedHeadLiteral,ConVars,_,_),
	add_skolems_to_body(Flags,true,EntailedHeadLiteral,ConVars,NewAnte),
%	skolemizeVars(Flags,KRVars,EntailedHeadLiteral,SkolemizedHead),
	sharedVars(EntailedHeadLiteral,Thing,SharedVars).
	

/*
replaceConsVar(xB, '$existential'([63, 84, 73, 77, 69, 50], exists(xC, and(instance(xC, 'TimePoint'), and(instance([63, 84, 73, 77, 69, 50], 'TimePoint'), and(before(xC, [63, 84, 73, 77, 69, 50]), forall(D, =>(and(beforeOrEqual(xC, D), beforeOrEqual(D, [63, 84, 73, 77, 69, 50])), time(A, D))))))))), 
replaceConsVar(xC, '$existential'([63, 84, 73, 77, 69, 49], and(instance([63, 84, 73, 77, 69, 49], 'TimePoint'), and(instance(xB, 'TimePoint'), and(before([63, 84, 73, 77, 69, 49], xB), forall(D, =>(and(beforeOrEqual([63, 84, 73, 77, 69, 49], D), beforeOrEqual(D, xB)), time(A, D))))))))], 

entails(instance(A, 'Object'), instance(xB, 'TimePoint')) 

Prolog:  searchable(instance(_, 'TimePoint')) :- searchable(instance(_, 'Object')).

*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails([true],not(Fact)),[impossible(EntailedHeadLiteral)]):-!.


selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails([true],(Fact)),[(NewCons)]):-!,
	skolemizeCons([],KRVars,Fact,Flags,NewCons).

			
selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails((ThingNotConnetedToHead),(EntailedHeadLiteral)),
		[(searchable(EntailedHeadLiteral) :- searchable(ThingNotConnetedToHead))]):-
	\+ (sharedVars(EntailedHeadLiteral,ThingNotConnetedToHead)),
	getPrologVars(ThingNotConnetedToHead,_,_,[]),!.
	

	
/*
replaceConsVar(xB, '$existential'([63, 84, 73, 77, 69, 50], exists(xC, and(instance(xC, 'TimePoint'), and(instance([63, 84, 73, 77, 69, 50], 'TimePoint'), and(before(xC, [63, 84, 73, 77, 69, 50]), forall(D, =>(and(beforeOrEqual(xC, D), beforeOrEqual(D, [63, 84, 73, 77, 69, 50])), time(A, D))))))))), 
replaceConsVar(xC, '$existential'([63, 84, 73, 77, 69, 49], and(instance([63, 84, 73, 77, 69, 49], 'TimePoint'), and(instance(xB, 'TimePoint'), and(before([63, 84, 73, 77, 69, 49], xB), forall(D, =>(and(beforeOrEqual([63, 84, 73, 77, 69, 49], D), beforeOrEqual(D, xB)), time(A, D))))))))], 

entails(and(not(time(A, D)), and(beforeOrEqual(xC, D), beforeOrEqual(D, xB))), not(instance(A, 'Object'))),

Near Prolog: neg(instance(A, 'Object')) :- beforeOrEqual(xC, D), beforeOrEqual(D, xB),  not(time(A, D)).

Prolog: impossible(instance(A, 'Object')) :- unionSpecial([D],searchable(beforeOrEqual(xC, D)), searchable(beforeOrEqual(D, xB))),  impossible(time(A, D)).

*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails((OnlyNegationsConnetedToHead),not(EntailedHeadLiteral)),
		[( impossible(EntailedHeadLiteral) :- (searchable(Pos),impossible(Negs)) )]):-
	splitNegations(OnlyNegationsConnetedToHead,Pos,Negs),
	sharedVars(Negs,EntailedHeadLiteral,_),
	\+ (sharedVars(Pos,EntailedHeadLiteral,_)),!.
	
/*
replaceConsVar(xB, '$existential'([63, 84, 73, 77, 69, 50], exists(xC, and(instance(xC, 'TimePoint'), and(instance([63, 84, 73, 77, 69, 50], 'TimePoint'), and(before(xC, [63, 84, 73, 77, 69, 50]), forall(D, =>(and(beforeOrEqual(xC, D), beforeOrEqual(D, [63, 84, 73, 77, 69, 50])), time(A, D))))))))), 
replaceConsVar(xC, '$existential'([63, 84, 73, 77, 69, 49], and(instance([63, 84, 73, 77, 69, 49], 'TimePoint'), and(instance(xB, 'TimePoint'), and(before([63, 84, 73, 77, 69, 49], xB), forall(D, =>(and(beforeOrEqual([63, 84, 73, 77, 69, 49], D), beforeOrEqual(D, xB)), time(A, D))))))))], 

entails(and(beforeOrEqual(xC, D), and(beforeOrEqual(D, xB), instance(A, 'Object'))), time(A, D)), 

Prolog: time(A, D) :- prove(instance(A, 'Object'),beforeOrEqual(xC, D),beforeOrEqual(D, xB)).

*/


selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails((Body),(EntailedHeadLiteral)),
		[ (EntailedHeadLiteral:- prove(Body) )]):-
	splitNegations(Body,Pos,[]),
	not(containsSkolems(Flags,EntailedHeadLiteral:Body)),
	prologEach(Pos,Item,sharedVars(Item,EntailedHeadLiteral)),!.
	
/*
	skolemizeVars(Flags,KRVars,Body,SkolemizedBody),
		
		skolemizeVars(Flags,KRVars,EntailedHeadLiteral,SkolemizedEntailedHeadLiteral),!.
  */



/*

entails(instance(A, 'UnaryConstantFunctionQuantity'), domain(A, 1, 'ConstantQuantity'))), 

Prolog: domain(A, 1, 'ConstantQuantity'):- instance(A, 'UnaryConstantFunctionQuantity').



entails(instance(A, 'UnaryConstantFunctionQuantity'), range(A, 'ConstantQuantity'))))

Prolog: range(A, 'ConstantQuantity') :- instance(A, 'UnaryConstantFunctionQuantity')



entails(and(subrelation(A, B), and(domain(A, C, E), domain(B, C, D))), subclass(E, D)) 

Prolog: subclass(E, D):- domain(A, C, E), domain(B, C, D), subrelation(A, B).

*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails((Body),(EntailedHeadLiteral)),
		[((EntailedHeadLiteral) :- prove(Body))]):-
	sharedVars(EntailedHeadLiteral,Body,ListOfShared),
	getPrologVars(EntailedHeadLiteral,EntailedHeadLiteralAll,_,_),
	getPrologVars(Body,BodyAll,_,_),
	allUnion(EntailedHeadLiteralAll,BodyAll),!.


/*

entails(and(disjoint(C, E), and(domain(A, B, C), domain(D, B, E))), disjointRelation(A, D)), 

Prolog: disjointRelation(A, D):- domain(A, B, C), domain(D, B, E), disjoint(C, E).

*/

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails((Body),(EntailedHeadLiteral)),
		[((EntailedHeadLiteral) :- ifThen(Passed,Failed))]):-
	splitNegations(Body,Pos,[]),
	prologPartitionList(Pos,Item,sharedVars(Item,EntailedHeadLiteral),Passed,Failed),!.



selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails(Body,not(Head)),[(impossible(Head) :- once(prove(NewAnte)))]):-
	getPrologVars(Head,ConVars,_,_),!,
	add_skolems_to_body(Flags,Body,Head,ConVars,NewAnte),!.

selectBestRuleMatrix(Sign,HeadSlots,Flags,KRVars,entails(Body,Head),[(Head:-unoptimized(NewAnte))]):-
	getPrologVars(Head,ConVars,_,_),!,
	add_skolems_to_body(Flags,Body,Head,ConVars,NewAnte),!.


notSkolemFlags(Flags):-not(member(replaceConsVar(_,_),Flags)).

splitNegations(List,Pos,Neg):-
	((prologPartitionList(List,Item,isNegation(Item),NegT,PosT),!,NegT=Neg,PosT=Pos)).
	
sharedVars(Item1,Item2):-
	((sharedVars(Item1,Item2,SharedVars,Item1Only,Item2Only),!,SharedVars=[_|_])).
	
sharedVars(Item1,Item2,SharedVars):-
	((sharedVars(Item1,Item2,SharedVars,Item1Only,Item2Only),!)).
	
sharedVars(Item1,Item2,SharedVars,Item1Only,Item2Only):-
	((getPrologVars(Item1,V1s,_,_),getPrologVars(Item2,V2s,_,_),!,
	set_partition(V1s,V2s,Item1Only,Item2Only,SharedVars),!)).

isNegation(Item):-((isSlot(Item);(Item=not(V),nonvar(V));(functor(Item,F,A),atom_concat(~,_,F)))).
	


	
getGoalProfile(Name,Time):-flag(Name,Time,Time).
profileGoalTime(Name,Goal):-
	getCputime(Start),
	call(Goal),
	getCputime(End),
	flag(Name,Time,Time),
	Average is (Time+(End-Start))/2,
	flag(Name,_,Average).	

normalizeProp(Flags,In,Out,Cons):-
	ifThenElse(
		(member(holds,Flags);member(orig,Flags)),
		(convertNegations(not,In,Notted,_),
		convertToHolds(Flags,Notted,Held)),
		Held=In),
	convertNegations(Flags,Held,Out,Cons).

convertRuleBodyWFS(Flags,Context,RuleHead,[],!).

convertRuleBodyWFS(Flags,Context,RuleHead,[Cons],Rewritten):-
	normalizeProp(Flags,Cons,Rewritten,Bare).

convertRuleBodyWFS(Flags,Context,RuleHead,[H|T],(RH,RT)):-!,
	convertRuleBodyWFS(Flags,Context,RuleHead,H,RH),
	convertRuleBodyWFS(Flags,Context,RuleHead,T,RT),!.

convertRuleBodyWFS(Flags,Context,RuleHead,(H,T),(RH,RT)):-!,
	convertRuleBodyWFS(Flags,Context,RuleHead,H,RH),
	convertRuleBodyWFS(Flags,Context,RuleHead,T,RT),!.

convertRuleBodyWFS(Flags,Context,RuleHead,and(H,T),(RH,RT)):-!,
	convertRuleBodyWFS(Flags,Context,RuleHead,H,RH),
	convertRuleBodyWFS(Flags,Context,RuleHead,T,RT),!.

convertRuleBodyWFS(Flags,Context,RuleHead,or(H,T),(RH,RT)):-!,
	convertRuleBodyWFS(Flags,Context,RuleHead,H,RH),
	convertRuleBodyWFS(Flags,Context,RuleHead,T,RT),!.

convertRuleBodyWFS(Flags,Context,RuleHead,Cons,(Rewritten)):-
	normalizeProp(Flags,Cons,Rewritten,Bare).



getPredicateKey((LogConsq),(Key)):-
		convertNegations((not),LogConsq,NC,_),!,
		getPredicateKey2((NC),(Key)).
getPredicateKey2(not(LogConsq),not(Key)):-nonvar(LogConsq),!,getPredicateKey2((LogConsq),(Key)).
getPredicateKey2((LogConsq),(Key)):-functor(LogConsq,Key,_),!.


deduceType(_,_):-fail.

convertListNotNeg(Var,holds('TruthFn',Var,'True')):-isSlot(Var),!.
convertListNotNeg(not(Var),holds('TruthFn',Var,'False')):-isSlot(Var),!.
convertListNotNeg([],[]):-!.
convertListNotNeg([not(X)|Y],[ (~ X)|YY]):-deduceType(F,negationByFailure),!,convertListNotNeg(Y,YY).
convertListNotNeg([not(X)|Y],[ (XX)|YY]):- not(isSlot(X)),!,
		X=..[F|Args],!, atom_concat('~',F,FN),
		XX=..[FN|Args],!,convertListNotNeg(Y,YY).
convertListNotNeg([(X)|Y],[(X)|YY]):-!,convertListNotNeg(Y,YY).

reorderAnteceedants([NConsq|List],List,All):-
	reorderAnteceedants(NConsq,List,List,All),!.

reorderAnteceedants(Head,Body,[],[]):-!.
reorderAnteceedants(Head,Body,[AProto],[AProto]):-!.
reorderAnteceedants(Head,Body,AProto,Ordered):-
	predsort(reorderAnteceedants(Head,Body),AProto,Ordered).

reorderAnteceedants(Head,Body,Result,T1,T2):-
	compareVariant(T1,T2,M,C1,C2),
	compare(Result,C2,C1),
	not(Result = (=)),!.
reorderAnteceedants(Head,Body,Result,T1,T2):-
	compareVariant(T1,Head,M,C1,H1),
	compareVariant(T2,Head,M,C2,H2),
	compare(Result,C2,C1),
	not(Result = (=)),!.
reorderAnteceedants(Head,Body,<,T1,T2).


set_partition([],Set2,[],Set2,[]):-!.
set_partition(Set1,[],Set1,[],[]):-!.
set_partition([H|S1],Set2,O1,O2,[H|Intersection]):-
	memberchkSpecial(H,Set2,NewSet2),!,
	set_partition(S1,NewSet2,O1,O2,Intersection).
%set_partition(Set2,[H|S1],O2,O1,[H|Intersection]):-
%	memberchkSpecial(H,Set2,NewSet2),
%	set_partition(S1,NewSet2,O1,O2,Intersection).
set_partition([H|S1],Set2,[H|O1],O2,Intersection):-
	set_partition(S1,Set2,O1,O2,Intersection).

memberchkSpecial(H,[HH|List],ListO):- 
	'=='(HH,H)
		-> ListO=List ; 
		(memberchkSpecial(H,List,ListM),ListO =  [HH|ListM]).

	
convertFactHeadWFS(Flags,Context,Cons,Rewritten):-
	normalizeProp(Flags,Cons,Rewritten,Bare).
	

convertNegations(Var,In,Out,Bare):-var(Var),!,convertNegations(keep,In,Out,Bare).	
convertNegations(Var,In,In,In):-isSlot(In),!.
convertNegations(Var,not(In),not(In),true(In)):-isSlot(In),!.

convertNegations(Flags,In,Out,Bare):-member(neg(Neg),Flags),!,convertNegations(Neg,In,Out,Bare).
convertNegations([Neg|_],In,Out,Bare):-atom(Neg),!,convertNegations(Neg,In,Out,Bare).
convertNegations(keep,PTerm,PTerm,Cons):-!,convertNegations(not,PTerm,_,Cons).

convertNegations(Neg,[Log|Ante],[Conditional|Body],[Bare|BBody]):-!,
	convertNegations(Neg,Log,Conditional,BLog),
	convertNegations(Neg,Ante,Body,BBody).

convertNegations(Neg,LogAnte,ConditionalBody,Connective):-
	compound(LogAnte),LogAnte=..[Connective|List],isBodyConnective(Connective),!,
	convertNegations(Neg,List,ConditionalBodyList,_),!,
	ConditionalBody=..[Connective|ConditionalBodyList],!.

convertNegations(Other,PTerm,PTerm,Cons):-
	PTerm=..[Other,Cons],!.
	
convertNegations(Neg,\+(In),Out,Bare):-!,convertNegations(Neg,not(In),Out,Bare).
convertNegations(Neg,'~'(In),Out,Bare):-!,convertNegations(Neg,not(In),Out,Bare).
convertNegations(Neg,In,Out,Bare):-
	In=..[NegF|Args],atom_concat('~',Pos,NegF),
	Mid=..[Pos|Args],!,convertNegations(Neg,not(Mid),Out,Bare).

convertNegations(lit,not(PTerm),Lit,PTerm):-
	PTerm=..[Pos|Args],
	atom_concat('~',Pos,F),!,
	Lit=..[F|Args].
convertNegations(Neg,not(Cons), Term,Cons):-
	Term=..[Neg,Cons].	
convertNegations(_,Cons,Cons,Cons).


/*
selectBestBodyMechanism(''(Seed),[],[],[],[],'Novars'(Seed)):-!.
selectBestBodyMechanism(''(Seed),UniversalBody,[],[],[],T):-!,T=..['Zall',Seed|UniversalBody].
selectBestBodyMechanism(''(Seed),[],HeadSlotsSingleInBody,[],[],T):-!,T=..['Headall',Seed|HeadSlotsSingleInBody].
selectBestBodyMechanism(''(Seed),[],[],BodyOnlyConected,[],T):-!,T=..['Bodyall',Seed|BodyOnlyConected].
selectBestBodyMechanism(''(Seed),[],[],[],SplitHeadVar,T):-!,T=..['HeadAll',Seed|SplitHeadVar].
selectBestBodyMechanism(Seed,UniversalBody,HeadSlotsSingleInBody,BodyOnlyConected,SplitHeadVar,VarClause):-!,
	appendFunctInf(Seed,'Univb',UniversalBody,Next1),	
	appendFunctInf(Next1,'Headb',HeadSlotsSingleInBody,Next2),	
	appendFunctInf(Next2,'Bodyc',BodyOnlyConected,Next3),
	appendFunctInf(Next3,'Doubleb',SplitHeadVar,VarClauseEF),!,
	removeEmptyFunct(VarClauseEF,VarClause).
*/


/* 
selectBestPropositionMechanism(Sign,Conditional,CVars,HeadSlots,ConditionalClass,
	CUniversalBody,CHeadSlotsSingleInBody,CBodyOnlyConected,CSplitHeadVar):-%true,
	appendFunct(''(Conditional),'Z_Uvar_',CUniversalBody,Conditional1),!,
	appendFunct(Conditional1,'amulitHeadVar_',CSplitHeadVar,Conditional2),
	appendFunct(Conditional2,'singleHeadVar_',CHeadSlotsSingleInBody,Conditional3),
	appendFunct(Conditional3,'bodyConnectedVar_',CBodyOnlyConected,ConditionalClass),!.
*/



/*
This File only exports one Predicate called: putAttributeStructures/4 and the rest of the predicates are helper to putAttributeStructures/2
                                                                                                                                                                
It does two things : Adds arg and predicate type checking .


ProtoType: putAttributeStructures(Surface,KRVars,Rule,Context,TN,CLID, ExplainationID,Anontate,Flags,IN_UnconstrainedFormua,OUT_UnconstrainedFormua)

1) if a variable is found in the head of a clause it confirms that it is contrained by a argument type checking

2) if a varaible is found in the predicate position (Head or Body) it rewrites the predicate to use functsymbol (list of Hiloged predicates) 

                                                                                  
Examples:
                                                                                  
   | ?- putAttributeStructures(Surface,KRVars,Rule,Context,TN,CLID, ExplainationID,Anontate,Flags,('instance'(R,agent) :-'instance'(R,human)),S).
   R = _h99
   S = ('instance'(_h99,agent) :- 'instance'(_h99,human))
   
   | ?- putAttributeStructures(Surface,KRVars,Rule,Context,TN,CLID, ExplainationID,Anontate,Flags,('instance'(R,agent):-performs(R,task1)),S).
   R = _h95
   S = ('instance'(_h95,agent) :- 'domain'(performs,1,_h95)  ','  performs(_h95,task1))
   
   | ?- putAttributeStructures(Surface,KRVars,Rule,Context,TN,CLID, ExplainationID,Anontate,Flags,('instance'(R,agent):-performs(R,Act)),S).
   R = _h95
   Act = _h141
   S = ('instance'(_h95,agent) :- 'domain'(performs,1,_h95)  ','  'domain'(performs,2,_h141)  ','  performs(_h95,_h141))

*/

% ===============================================
% putAttributeStructures: Has Two Phases
% ===============================================
	
putAttributeStructures(Context,Anontate,Flags,Formula,SlotStructure):-
		putPropositionAttributes(Context,Anontate,Flags,'=>',1,Formula,SlotStructure),!.



localCanonicalizerNotice(Type,Details):-
       getMooOption(putAttributeStructures,(Surface,Rule,CLID,Flags,KRVars,Context:Ctx,TN)),
       % writeq(Warning:Data),nl,
       ( \+ ( \+ (canonicalizerWarnings(Context,Type,Details)))  -> ifInteractive(write(','));
	(assertzRE(canonicalizerWarnings(Context,Type,Details)),
	ifInteractive(writeObject(nv([nl,Details,nl,Type,nl,Surface,nl,nl]),KRVars)))),!.


localCanonicalizerWarning(Type,Details):-
	localCanonicalizerNotice(Type,Details).

localCanonicalizerError(Type,Details):-
	throwMoo(argDomains,error:Type,Details).


putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,Var,Slot):-isVarProlog(Var),!,
	getDomainsForVar(Caller,ArgN,Var,Flags,Domains),
	getPutBestConstraintAttribute(Caller,ArgN,Context,Anontate,Var,Domains,Slot),!.

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,ArgIn):-isSlot(ArgIn),!.

/*
putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,'$existential'(ArgIn,Lit,Formula),SlotStructure):-!,
	getDomainsForVar(Caller,ArgN,ArgIn,Flags,[Caller:ArgN|Domains]),
	getPutBestConstraintAttribute(Caller,ArgN,Context,Anontate,'$existential'(Lit,Formula),Domains,SlotStructure),!.
*/
	

getDomainsForVar(Caller,ArgN,ArgIn,Flags,Domains):-!,member(domainV(Var,Domains),Flags),Var==ArgIn,!.
getDomainsForVar(Caller,ArgN,ArgIn,Flags,[]):-!,write(getDomainsForVar(Caller,ArgN,ArgIn,Flags,[])),true.

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,[],[]):-!.

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,[ArgIn|B],[AA|BB]):-!,
	putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,AA),
	putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,B,BB),!.

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,string(ArgIn),SlotStructure):-!,nonvar(ArgIn),!,
	 putStringAttribute(ArgIn,Caller,ArgN,SlotStructure),!.

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-atom(ArgIn),!,
	putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure),!.

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-number(ArgIn),!,
	deduceClassesForDomainVList([Caller:ArgN],Classes),!,
	sort(Classes,ClassesM), % removes duplicates
	delete(ClassesM,'Entity',ClassesMM), % Entity too general
	getListOfConstraintStructuresFromListOfClasses(ArgIn,ClassesMM,LCM),
	mostConstrainingAttribute(LCM,TightestFit),
	applyNumericFit(Caller,ArgN,TightestFit,ArgIn,SlotStructure),!.
	
		applyNumericFit(Caller,ArgN,TightestFit,ArgIn,SlotStructure):-TightestFit=[_,_,_,_|_],!,
			applyAttributeStructureToEntity(Caller,ArgN,ArgIn,TightestFit,SlotStructure),!.
			
		applyNumericFit(Caller,ArgN,_,ArgIn,SlotStructure):-!,
			applyAttributeStructureToEntity(Caller,ArgN,ArgIn,['Abstract','Quantity','Number'],SlotStructure).

putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,Term,OTerm):-
	Term=..[Funct|Args],
	putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,Args,OTerm),!.


% Connectives We deal with each argument	
putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,Args,OTerm):-
	(memberchkSpecial(Funct,[and,or,not,possible,searchable,impossible,absurd,proves,prove,xor,
	'<=>','=>',entails,(:-),',',';',ifThen]);
	atom_concat(_,'_',Funct)),!,
	putPropositionAttributes(Context,Anontate,Flags,and,1,Args,ArgsO),
	OTerm=..[Funct|ArgsO],!.

% Connectives We Skip all but the first argument
putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,[ArgIn|B],OTerm):-
	(atom_concat('t~',_,Funct);atom_concat('f~',_,Funct)),!,
	putPropositionAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,AA),
	OTerm=..[Funct,AA|B],!.

% Functors That we dont touch Any Arguments
putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,Args,OTerm):-
	(atom_concat('$',_,Funct);memberchkSpecial(Funct,['v','$existential','include-context'])),!,
	OTerm=..[Funct|Args],!.

% Functors That Are Variable Arity That we cannot hash the arg length
putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,Args,OTerm):-
	memberchkSpecial(Funct,[disjointDecomposition,exhaustiveDecomposition,partition]),!,
	putPropositionAttributes(Context,Anontate,Flags,Funct,1,Args,ArgsO),!,
	OTerm=..[Funct,ArgsO],!.

% Functors That Are Variable Arity That we *CAN* hash the arg length
putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,[Arg1|Args],OTerm):-
	memberchkSpecial(Funct,[holds,function,'AssignmentFn']),!,
	putPropositionAttributesArguments(Context,Anontate,Flags,Funct,1,[Arg1],[SlotedF]),!,
	putPropositionAttributesArguments(Context,Anontate,Flags,Arg1,1,Args,ArgsO),!,  
	OTerm=..[Funct,SlotedF|ArgsO],!.

putPropositionAttributesFunctor(Context,Anontate,Flags,Caller,ArgN,Funct,Args,TermO):-
	putPropositionAttributesArguments(Context,Anontate,Flags,Funct,1,Args,ArgsO),!,
	TermO=..[Funct|ArgsO].


putPropositionAttributesArguments(Context,Anontate,Flags,Caller,N,[],[]):-!.
putPropositionAttributesArguments(Context,Anontate,Flags,Caller,N,[Arg|ArgS],[ArgO|ArgsO]):-
	     putPropositionAttributes(Context,Anontate,Flags,Caller,N,Arg,ArgO),NN is N+1,
	     putPropositionAttributesArguments(Context,Anontate,Flags,Caller,NN,ArgS,ArgsO),!.

	
% ===============================================
% Slot Atom
% ===============================================

%:-dynamic(putAtomAttributeProc/6).

putAtomAttribute(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	var(ArgIn),write(putAtomAttribute(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure)),true,fail.

% Quoted Atom
putAtomAttribute(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-atom_concat('"',_,ArgIn),!,
	putStringAttribute((ArgIn),Caller,ArgN,SlotStructure),!.

/*
putAtomAttribute(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-atom(ArgIn),	
	mooCache(Context,Anontate,putAtomAttributeProc(ArgIn,SlotStructure)),!.

*/
putAtomAttribute(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure),!.
%	assertaRE(mooCache(Context,Anontate,putAtomAttributeProc(ArgIn,SlotStructure))),!.

       
% Class name
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,'$Class'(ArgIn)):-
	getClassesListFromContext(Rs,Ctx,Context),identical_member(ArgIn,Rs),!.
	
/*
	putClassEntityAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure),!.
	
% Classes use special wrapper
putClassEntityAttributes(Context,Anontate,Flags,Caller,ArgN,ArgIn,ArgIn):-!.

	getConstraintStructureForClass(ArgIn,'Class',Slot),!,
	%deduceSingleSubclassPathList(ArgIn,ArgIn,'Entity',SlotStructure)),!,
	%reverse(ReversedSlots,Slot),
	applyAttributeStructureToEntity(Caller,ArgN,ArgIn,['Abstract','Class'|_],SlotStructure),!.
*/
  
% Any Name
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	deduceClassFromEntity(Context,Anontate,ArgIn,Class),nonvar(Class),!,
	getConstraintStructureForClass(ArgIn,Class,Slot),
	applyAttributeStructureToEntity(Caller,ArgN,ArgIn,Slot,SlotStructure),!.
					 
% Function Name
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	getFunctionListFromContext(Rs,Ctx,Context),memberchkSpecial(ArgIn,Rs),!,
	deduceClassFromEntity(Context,Anontate,ArgIn,Class),nonvar(Class),!,
	getConstraintStructureForClass(ArgIn,Class,Slot),
	applyAttributeStructureToEntity(Caller,ArgN,ArgIn,Slot,SlotStructure),!.

% Predicate Name
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	getPredicatesListFromContext(Rs,Ctx,Context),memberchkSpecial(ArgIn,Rs),!,
	applyAttributeStructureToEntity(Caller,ArgN,ArgIn,['Abstract', 'Relation', 'Predicate'],SlotStructure).

% Attribute Name
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	getAttributeNamelistFromContext(Rs,Ctx,Context),memberchkSpecial(ArgIn,Rs),!,
	applyAttributeStructureToEntity(Caller,ArgN,ArgIn,[ 'Abstract', 'Attribute'],SlotStructure).

% Assume By Previous Holder Predicate

putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotStructure):-
	ground(ArgIn),
	mooCache(Context,Anontate,classFromWrap(ArgIn,Class)),!,
	getConstraintStructureForClass(ArgIn,Class,Slot),
	applyAttributeStructureToEntity(Caller,ArgN,ArgIn,Slot,SlotStructure),!.


% Assume By Holder Predicate
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,SlotedA):-
	ground(ArgIn),
	once(getPutBestConstraintAttribute(Caller,ArgN,Context,Anontate,ArgIn,[Caller:ArgN],SlotedA)),
	getClassFromWrap(SlotedA,Assumed),!,
	localCanonicalizerWarning('Assumed Term From Domain ','=>'(domain(Caller,ArgN,Assumed),instance(ArgIn,Assumed))),!,
	(ground(classFromWrap(ArgIn,Assumed)) ->assertaRE(mooCache(Context,Anontate,classFromWrap(ArgIn,Assumed))) ;true).

% Assume New Physical
putAtomAttributeProc(Context,Anontate,Flags,Caller,ArgN,ArgIn,'$Object'(ArgIn,_)):-nonvar(ArgIn),!,
	localCanonicalizerWarning('Assumed Term (No domain available) ',
		and(domain(Caller,ArgN,'?UNKNOWN'),instance(ArgIn,'Object'))),!.

	
putStringAttribute(Lit,Caller,ArgN,SlotStructure):-
	applyAttributeStructureToEntity(Caller,ArgN,string(Lit),['Physical','Object','ContentBearingObject'],SlotStructure),!.


deduceClassFromEntity(Context,Anontate,Entity,Class):-
%	deduceTransitiveClosure_PartialOrderingRelation(Context,Anontate,Agent3,subclass,M,Class,SCExplaination),
	deduceSurface_gaf(instance(Entity,Class),_UAgent,Context,Explaination),not(Class='InheritableRelation'),!.
	
getPutBestConstraintAttribute(Caller,ArgN,Context,Anontate,Var,Domains,SlotStructure):-
	deduceClassesForDomainVList(Domains,Classes),!,
	sort(Classes,ClassesM), % removes duplicates
	delete(ClassesM,'Entity',ClassesMM), % Entity too general
	getListOfConstraintStructuresFromListOfClasses(Var,ClassesMM,LCM),
	mostConstrainingAttribute(LCM,TightestFit),
	applyAttributeStructureToEntity(Caller,ArgN,Var,TightestFit,SlotStructure),!.

% getClassFromWrap(Slot,Class).

getClassFromWrap(ArgIn,'Entity'):-isPrologVar(ArgIN),!.
getClassFromWrap('$Class'(ArgIn),'Class'):-!.
getClassFromWrap(Slot,Class):-
	functor(Slot,F,A),atom_concat('$',_,F),
	arg(2,Slot,ClassesTerm),!,
	getClassBottemFromTerm(ClassesTerm,Class).
	
getClassBottemFromTerm(ClassesTerm,ClassO):-
	ClassesTerm=..[Class,Var], 
	(isPrologVar(Var) -> 
		ClassO = Class ;
		getClassBottemFromTerm(Var,ClassO)),!.
	
mostConstrainingAttribute([],[]):-!. % none
mostConstrainingAttribute([ArgIn],ArgIn):-!. %only one
mostConstrainingAttribute(List,Longest):-lengthSort(List,[Longest|_]),!.

% Put the longest list first
lengthSort(ListOfLists,LongestFirst):-	
	predsort(lengthSort,ListOfLists,LongestFirst),!.
lengthSort(Result,List1,List2):-
	length(List1,L1),
	length(List2,L2),
	compare(Result,L2,L1).

% ===============================================    
% Build Class Path
% ===============================================

getListOfConstraintStructuresFromListOfClasses(Orig,[],[]):-!.
getListOfConstraintStructuresFromListOfClasses(Orig,[Class|More],[Choice|Classes]):-
	getConstraintStructureForClass(Orig,Class,Choice),!,
	getListOfConstraintStructuresFromListOfClasses(Orig,More,Classes),!.


getConstraintStructureForClass(Orig,V,['Entity']):-var(V),!.

getConstraintStructureForClass(Orig,'UnionFn'(Class, _),Slot):-
	getConstraintStructureForClass(Orig,Class,Slot),!.

getConstraintStructureForClass(Orig,Class,Slot):-
	deduceSingleSubclassPathList(Orig,Class,'Entity',ReversedSlots),!,
	reverse(ReversedSlots,Slot).

getConstraintStructureForClass(Orig,Class,[]):-
	localCanonicalizerWarning('Problem: Class is not connected to Knowledgebase ontology',(Class)),!.
	

deduceSingleSubclassPathList(Entity,Origin,Destination,Path):-not(ground((Origin,Destination))),true,fail.

deduceSingleSubclassPathList(InheritableRelation, 'InheritableRelation', _, ['Abstract','Relation']):-!.

deduceSingleSubclassPathList(Entity,Origin,Destination,Path):-
		mooCache(Context,Anontate,deduceSingleSubclassPathList(Origin,Destination,Path)),!.

deduceSingleSubclassPathList(Entity,Origin,Destination,Path):-
	deduceSingleSubclassPathListProc(Entity,Origin,Destination,Path),
	assertaRE(mooCache(Context,Anontate,deduceSingleSubclassPathList(Origin,Destination,Path))).

deduceSingleSubclassPathListProc(Entity,Origin,Origin,[]):-!.
deduceSingleSubclassPathListProc(Entity,Origin,Destination,[Origin|O]):-
	deduceDirectSubclass(Origin,ClassMid),
	deduceSingleSubclassPathList(Entity,ClassMid,Destination,O).

deduceSingleSubclassPathListProc(Entity,Origin,ClassFinal,[]):-
	localCanonicalizerError('Problem with knowledgebase: Could not deduce ',(subclass(Origin,'?CLASS'))),!.
	
deduceDirectSubclass(Origin,ClassMid):-
	deduceSurface_easy(subclass(Origin,ClassMid),_,Ctx,_P),
	nonvar(Origin),not((ClassMid='InheritableRelation')),!.
	
% ===============================================
% Slot Entity
% ===============================================

argVar(Arg):-catch(arg(1,Arg,$),_,true).

% Wraps Entity
applyAttributeStructureToEntity(Caller,ArgN,ArgV,[V|L],ArgV):-var(V),!,
	localCanonicalizerError('Could not retrieve domains for',domain(Caller,ArgN,ArgV)).

applyAttributeStructureToEntity(Caller,ArgN,ArgV,[],ArgV):-!,
	localCanonicalizerNotice('Specialize for rule',domain(Caller,ArgN,'Entity')),!.
	
applyAttributeStructureToEntity(Caller,ArgN,ArgV,['Entity'],ArgV):-!,
	localCanonicalizerNotice('Specialize for rule',domain(Caller,ArgN,'Entity')),!.

applyAttributeStructureToEntity(Caller,ArgN,ArgV,['Abstract','Class'|_],'$Class'(ArgV)):-!.

applyAttributeStructureToEntity(Caller,ArgN,ArgV,[Class],'$IdentityFn'(ArgV,Slot)):-!,
	Slot=..[Class,_],localCanonicalizerNotice('Specialized for rule',domain(Caller,ArgN,Class)),!.
	
applyAttributeStructureToEntity(Caller,ArgN,ArgV,[Base,Class|Remainder],Slot):-!,
	atom_concat('$',Class,DClass),
	Slot=..[DClass,ArgV,Classes],
	makeClassNodeF(Remainder,Classes),!.

applyAttributeStructureToEntity(Caller,ArgN,ArgV,Class,ArgV):-!,
	localCanonicalizerError('Unknown Structure',domain(Caller,ArgN,Class)),!.

makeClassNodeF(V,V):-isSlot(V),!.
makeClassNodeF([],_):-!.
makeClassNodeF([Super|L],Class):-
	Class=..[Super,SubClass],
	makeClassNodeF(L,SubClass),!.

% ===============================================
% Convert [Pred1:N1,Pred2:N2,...] list to Domain List
% ===============================================

deduceClassesForDomainVList([],[]):-!.
deduceClassesForDomainVList([Pred:N|PredN],[Class|More]):-
	deduceClassForDomainV(Pred:N,Class),!,
	deduceClassesForDomainVList(PredN,More).

deduceClassForDomainV(Var:N,'Entity'):-var(Var),!.
deduceClassForDomainV('$instanceof':Class,Class):-!.

deduceClassForDomainV(Pred:N,Class):-deduceSurface(domain(Pred,N,Class),_,_,_),!.
deduceClassForDomainV(Pred:range,Class):-deduceSurface(range(Pred,Class),_,_,_),!.

deduceClassForDomainV(Pred:N,Class):-
		deduceSurfaceDomainVector(Arity,Pred,VectS,Agent,Context,Anontate,_),
		nth1(N,VectS,Class),!.

deduceClassForDomainV(Pred:N,Class):-deduceSurface(range(Pred,Class),_,_,_),!.
		%sendNote(currentUser,'Canonicalizer','Warning While Compiling Knowledgebase (using range) ',domain(Pred,N,Class)),!.

deduceClassForDomainV(Pred:range,Class):-deduceSurface_gaf(domain(Pred,4,Class),_,_,_),!.
deduceClassForDomainV(Pred:range,Class):-deduceSurface_gaf(domain(Pred,3,Class),_,_,_),!.
deduceClassForDomainV(Pred:range,Class):-deduceSurface_gaf(domain(Pred,2,Class),_,_,_),!.

deduceClassForDomainV(Pred:range,'Class'):-deduceSurface(rangeSubclass(Pred,Class),_,_,_),!.

deduceClassForDomainV(Pred:N,'Entity'):-isEntityref(Pred,_),number(N),!.
 		
deduceClassForDomainV(Pred:N,'Entity'):-!,
	localCanonicalizerWarning('Warning: No Predicate Domain ',domain(Pred,N,'Entity')),!.




%end_of_file.


import_ado_cache:-import_ado_cache('PrologMOO').
import_ado_cache(ContextName):-
	makeKnowledgeBase(ContextName,ContextName),
	showKnowledgeBase,
	getCurrentKnowledgeBase(Context),
	format('~nImporting ~w.~n~n',[Context]),!,
	before_ado_cache(ContextName,Context),
	import_ado_cache(ContextName,Context),
	after_ado_cache(ContextName,Context).


import_ado_cache_all_on:-
	   setMooOption(traceOutput,yes),
	   setMooOption(prover,decider),
	   setMooOption(translationMode,flatRelational),
	   setMooOption(decider,on).
	
import_ado_cache(ContextName,Context):-
	mooCache(_, surface, Axiom, Vars, ContextName, Context, Tracking, User, Status),%true,
	ado_cache_moo_assertKIF(Axiom,Tracking,Context,Context,ContextName),
	fail.
	
import_ado_cache(ContextName,Context):-
	format('~n% Done importing ~w.~n~n',[ContextName]),!.
	

before_ado_cache(ContextName,Context):-
	retractallSpecial(shown_template(_)),
	tell(footheory).

after_ado_cache(ContextName,Context):-
	listing(shown_template),
	told,
	predicate_property(shown_template(_), number_of_clauses(N)),
	format('~q clauses ~n',[N]).

ado_cache_moo_assertKIF(Axiom,Tracking,Context,Context,ContextName):-
	moo_assertKIF(Axiom,Tracking,Context,Context,ContextName),!.  % Puts it into MooHL % TODO

	
:-dynamic(shown_template/1).

show_template(Surface,Axiom,Result):-shown_template(Result),!.

show_template(Surface,Axiom,Result):-
	format('~nSurf: ~q~nResult:  ~q~n ~q~n~n',[Surface,Axiom,Result]),
	assertzRE(shown_template(Result)),!.       

make_template(Var,Var):-isSlot(Var),!.
make_template(Term,OTerm):-compound(Term),
	Term=..[P|List],
	hlPredicateAttribute(logicalConnective,P),!,
	maplist(make_template,List,OList),
	OTerm=..[P|OList],!.
make_template(Term,OTerm):-compound(Term),
	Term=..List,!,
	maplist(make_template,List,OList),
	OTerm=..OList,!.
make_template(P,P):-member(P,[holds,instance]),!.
make_template(P,Q):-predicate_table(P,Q),!.
make_template(P,Q):-
	flag(pred_num,X,X+1),
	atom_concat('p',X,Q),
	assertaRE(predicate_table(P,Q)),!.
	
write_cl_of2(Tracking,Axiom):-
	translate(Axiom,Clauses),
	format('~n% ~w  ~q~n',[Tracking,Axiom]),
	list_clauses_out(Clauses).

list_clauses_out([]).
list_clauses_out([H|T]):-
	list_clause_out(H),
	list_clauses_out(T).

list_clause_out(true).
list_clause_out(cl([H],[])):-format('fact(~q).~n',[H]).
list_clause_out(cl([],H)):-format('disj(~q).~n',[H]).
list_clause_out(H):-format('~q.~n',[H]).

cmp_is_a_fuction(X):-atom(X),atom_concat(_,'Fn',X).


moo_assertKIF(Axiom):-				   
	getCurrentKnowledgeBase(Context),
	moo_assertKIF(Axiom,Context).

moo_assertKIF(Axiom,Context):-
	idGen(Tracking),
	moo_assertKIF(Axiom,Tracking,[],ContextName).	

moo_assertKIF(Axiom,Context,Context):-
	idGen(Tracking),
	moo_assertKIF(Axiom,Tracking,[Context],ContextName).	


moo_assertKIF(Axiom,Tracking,Context,ContextName):-
	moo_assertKIF(Axiom,Tracking,Context,ContextName,ContextName).

% ===============================================================	
% moo_assertKIF(Axiom,Tracking,Context,ContextObj,ContextName)
% ===============================================================	

moo_assertKIF(Axiom,Tracking,Context,Context,ContextName):-
	preprocessAxiom(Axiom,AxiomO),!,
	moo_assertKIF2(AxiomO,Tracking,Context,Context,ContextName).


preprocessAxiom(Axiom,Axiom).  % TODO
'VariableArityRelation'(disjointDecomposition).
'VariableArityRelation'(exhaustiveDecomposition).
'VariableArityRelation'(partition).

 
% Uses Specialization

moo_assertKIF2(Axiom,Tracking,Context,Context,ContextName):-
	moo_assertKIF_implicit(Axiom),!.
moo_assertKIF2(Axiom,Tracking,Context,Context,ContextName):-
	moo_assertKIF_fast(Axiom,Tracking,Context,Context,ContextName),!.
moo_assertKIF2(Axiom,Tracking,Context,Context,ContextName):-
	moo_assertKIF_slow(Axiom,Tracking,Context,Context,ContextName),!.

moo_assertKIF2(Axiom,Tracking,Context,Context,ContextName):-
        numbervars(Surface,'$VAR',1,_),!,
	getAssertionClauses(Context,Axiom,Clauses,_,Flags),!,
	write_surf_axioms(Axiom,Clauses).

write_surf_axioms(Surface,and(A,B)):-!,
	write_surf_axioms(Surface,A),!,
	write_surf_axioms(Surface,B).
	
write_surf_axioms(Surface,CL):-!,
	flag(pred_num,_,0),
	retractallSpecial(predicate_table(_,_)),!,
	unnumbervars(Surface:CL,OSurface:OCL),	!,
	numbervars(OSurface:OCL,'$VAR',0,_),
	make_template(OCL,Template),!,
	show_template(OSurface,OCL,Template),!.



%        format('Uncompiled: ~q~n',[C]),
 %       ignore((C=[],write(Axiom),nl,nl)),

% ===============================================================	
% Fast/Slow Specializations
% ===============================================================      
moo_assertKIF_fast(KIF,Tracking,Context,Context,ContextName):-
	moo_assertKIF_mapping(KIF,Tracking,Context,Context,Mapped),
	invokeMapping(Mapped),!.

moo_assertKIF_mapping(KIF,Tracking,Context,Context,Mapped):-
	mapping_nt(KIF,Context,Context,Mapped).

mapping_nt(KIF,Context,Context,Mapped):-
	mapping_nt(KIF,Mapped).
	
invokeMapping(undefined).
invokeMapping([A|B]):-!,invokeMapping(A),invokeMapping(B).
invokeMapping((A,B)):-!,invokeMapping(A),invokeMapping(B).
invokeMapping((A;B)):-!,invokeMapping(A);invokeMapping(B).
invokeMapping('+'(Axiom)):-!,moo_assertKIF(Axiom).
invokeMapping(Slowmapped):-Slowmapped.

moo_assertKIF_slow(KIF,Tracking,Context,Context,ContextName):-
	moo_assertKIF_slowmapping(KIF,Tracking,Context,Context,Slowmapped),
	invokeMapping(Slowmapped),!.

moo_assertKIF_slowmapping(KIF,Tracking,Context,Context,Slowmapped):-
	slowmapping_nt(KIF,Context,Context,Slowmapped).

slowmapping_nt(KIF,Context,Context,Slowmapped):-
	slowmapping_nt(KIF,Slowmapped).


% ===============================================================	
% Mapped Specializations
% ===============================================================      

mapping_nt(KIF,Context,Context,Mapped):-
	mapping_nt(KIF,Mapped). % TODO 

% instance/2 
mapping_nt(instance(CName1,CName2),assert_ind(CName1,CName2)).

% subclass/2
mapping_nt(subclass(A, B),defprimconcept(A,[supers([B])])).

% disjoint/2
mapping_nt(disjoint(CName1,CName2),defprimconcept(CName2,not(CName1))).    

% subrelation/2	   %TODO unclear
mapping_nt(subrelation(A, B),defprimconcept(A,B)).

% range/2	   % TODO unclear
mapping_nt(range(A, B),(defprimrole(A,B),defprimrole(B))).

% rangeSubclass/2	   % TODO unclear
mapping_nt(range(A, B),defprimrole(A,B)).

% ===============================================================	
% Slowmapped Specializations
% ===============================================================      

slowmapping_nt(KIF,Context,Context,Slowmapped):-
	slowmapping_nt(KIF,Slowmapped). % TODO 

% inverse/2 for Functions
slowmapping_nt(inverse(CName1,CName2),defrole(CName1,inverse(CName2))):-cmp_is_a_fuction(CName1).

% inverse/2 for ELSE (Predicates)
slowmapping_nt(inverse(CName1,CName2),defprimconcept(CName1,inverse(CName2))).

% Not instance/2 
slowmapping_nt(not(instance(CName1,CName2)),assert_ind(CName1,not(CName2))).

% Catches mapping_info Functions
slowmapping_nt(Term,assert_ind(A,B,R)):-compound(Term),functor(Term,R,N),cmp_is_a_fuction(R),
	mapping_info_relation(R,N),
	Term=..[R,A,B].

% Catches mapping_info Predicates
slowmapping_nt(Term,assert_ind(A,B,R)):-compound(Term),functor(Term,R,N),
	mapping_info_relation(R,N),
	Term=..[R,A,B].

% Catches new Functions %TODO
slowmapping_nt(Term,assert_ind(A,B,R)):-compound(Term),functor(Term,R,N),cmp_is_a_fuction(R),
	assertzRE(mapping_info_relation(R,N)),
	Term=..[R,A,B].

% Catches new Relations %TODO
slowmapping_nt(Term,assert_ind(A,B,R)):-compound(Term),functor(Term,R,N),
	assertzRE(mapping_info_relation(R,N)),
	Term=..[R,A,B].

:-dynamic(mapping_info_relation/2).

mapping_info_relation(representsInLanguage,2).
mapping_info_relation(expressedInLanguage,2).
mapping_info_relation(equivalentContentInstance,2).
mapping_info_relation(subsumesContentClass,2).
mapping_info_relation(equivalentContentClass,2).


mapping_info_relation(documentation,2).
mapping_info_relation(age,2).
mapping_info_relation(publishes,2).
mapping_info_relation(authors,2).
mapping_info_relation(internalRelatedConcept,2).
mapping_info_relation(relatedInternalConcept,2).
mapping_info_relation(synonymousExternalConcept,2).
mapping_info_relation(subsumedExternalConcept,2).
mapping_info_relation(subsumingExternalConcept,2).
mapping_info_relation(subsumesContentInstance,2).
mapping_info_relation(starts,2).
mapping_info_relation(meetsTemporally,2).
mapping_info_relation(finishes,2).
mapping_info_relation(before,2).
mapping_info_relation(identityElement,2).
mapping_info_relation(trichotomizingOn,2).
mapping_info_relation(holdsDuring,2).
mapping_info_relation(deathTime,2).
mapping_info_relation(birthTime,2).
mapping_info_relation(agent,2).
mapping_info_relation(attribute,2).
mapping_info_relation(part,2).
mapping_info_relation(surface,2).
mapping_info_relation(patient,2).
mapping_info_relation(superficialPart,2).
mapping_info_relation(connected,2).
mapping_info_relation(orientation,2).
mapping_info_relation(between,2).
mapping_info_relation(containsInformation,2).
mapping_info_relation(employs,2).
mapping_info_relation(occupiesPosition,2).
mapping_info_relation(member,2).
mapping_info_relation(familyRelation,2).
mapping_info_relation(connectsEngineeringComponents,2).
mapping_info_relation(connectedEngineeringComponents,2).
mapping_info_relation(engineeringSubcomponent,2).
mapping_info_relation(hasPurpose,2).
mapping_info_relation(version,2).
mapping_info_relation(component,2).
mapping_info_relation(date,2).
mapping_info_relation(greaterThan,2).
mapping_info_relation(inhabits,2).
mapping_info_relation(effector,2).
mapping_info_relation(mother,2).
mapping_info_relation(father,2).
mapping_info_relation(siblings,2).
mapping_info_relation(parent,2).
mapping_info_relation(wants,2).
mapping_info_relation(inScopeOfInterest,2).
mapping_info_relation(time,2).
mapping_info_relation(result,2).
mapping_info_relation(instrument,2).
mapping_info_relation(origin,2).
mapping_info_relation(destination,2).
mapping_info_relation(length,2).
mapping_info_relation(path,2).
mapping_info_relation(subProcess,2).
mapping_info_relation(located,2).
mapping_info_relation(during,2).
mapping_info_relation(overlapsSpatially,2).
mapping_info_relation(meetsSpatially,2).
mapping_info_relation(properPart,2).
mapping_info_relation(fills,2).
mapping_info_relation(properlyFills,2).
mapping_info_relation(completelyFills,2).
mapping_info_relation(partiallyFills,2).
mapping_info_relation(hole,2).
mapping_info_relation(interiorPart,2).
mapping_info_relation(overlapsPartially,2).
mapping_info_relation(partlyLocated,2).
mapping_info_relation(connects,2).
mapping_info_relation(duration,2).
mapping_info_relation(lessThan,2).
mapping_info_relation(lessThanOrEqualTo,2).
mapping_info_relation(resource,2).
mapping_info_relation(cooccur,2).
mapping_info_relation(earlier,2).
mapping_info_relation(overlapsTemporally,2).
mapping_info_relation(temporallyBetweenOrEqual,2).
mapping_info_relation(beforeEq,2).
mapping_info_relation(temporallyBetween,2).
mapping_info_relation(temporalPart,2).
mapping_info_relation(frequency,2).
mapping_info_relation(monetaryValue,2).
mapping_info_relation(measure,2).			
mapping_info_relation(larger,2).
mapping_info_relation(pathLength,2).
mapping_info_relation(graphPart,2).
mapping_info_relation(greaterThanOrEqualTo,2).
mapping_info_relation(arcWeight,2).
mapping_info_relation(subGraph,2).
mapping_info_relation(links,2).
mapping_info_relation(element,2).
mapping_info_relation(subsetSpecial,2).
mapping_info_relation(uses,2).
mapping_info_relation(subPlan,2).
mapping_info_relation(realization,2).
mapping_info_relation(represents,2).
mapping_info_relation(possesses,2).
mapping_info_relation(crosses,2).
mapping_info_relation(penetrates,2).
mapping_info_relation(traverses,2).
mapping_info_relation(exactlyLocated,2).
mapping_info_relation(holdsObligation,2).
mapping_info_relation(confersObligation,2).
mapping_info_relation(capability,2).
mapping_info_relation(holdsRight,2).
mapping_info_relation(confersRight,2).
mapping_info_relation(hasSkill,2).
mapping_info_relation(exploits,2).
mapping_info_relation(entails,2).
mapping_info_relation(copy,2).
mapping_info_relation(distributes,2).
mapping_info_relation(reflexiveOn,2).
mapping_info_relation(equivalenceRelationOn,2).
mapping_info_relation(totalOrderingOn,2).
mapping_info_relation(partialOrderingOn,2).
mapping_info_relation(irreflexiveOn,2).
mapping_info_relation(closedOn,2).
mapping_info_relation(true,2).
mapping_info_relation(knows,2).
mapping_info_relation(believes,2).
mapping_info_relation(needs,2).
mapping_info_relation(manner,2).
mapping_info_relation(piece,2).

% ===============================================================	
% Undefined Specializations
% =============================================================== 

% successorAttributeClosure/2
mapping_nt(successorAttributeClosure(A, B),undefined).

% disjointDecomposition/N
mapping_nt(disjointDecomposition(Class,List),undefined).
% exhaustiveDecomposition/N
mapping_nt(exhaustiveDecomposition(Class,List),undefined).
% partition/N
mapping_nt(partition(Class,List),undefined).




% contraryProperty/2
mapping_nt(contraryProperty(A, B),undefined).

% subAttribute/2
mapping_nt(subAttribute(A, B),undefined).

% successorAttribute/2
mapping_nt(successorAttribute(A, B),undefined).

% domain/3
mapping_nt(domain(A, B, C),undefined).

% 'include-context'/1
mapping_nt('include-context'(A),undefined).

% domainSubclass/3
mapping_nt(domainSubclass(A, B, C),undefined).

% singleValued/2
mapping_nt(singleValued(A, B),undefined).

% range/2
mapping_nt(range(A, B),undefined).

% starts/2
mapping_nt(starts(A, B),undefined).

% equal/2
mapping_nt(equal(A, B),undefined).

% meetsTemporally/2
mapping_nt(meetsTemporally(A, B),undefined).

% finishes/2
mapping_nt(finishes(A, B),undefined).

% before/2
mapping_nt(before(A, B),undefined).

% internalRelatedConcept/2
mapping_nt(internalRelatedConcept(A, B),undefined).

% identityElement/2
mapping_nt(identityElement(A, B),undefined).

% trichotomizingOn/2
mapping_nt(trichotomizingOn(A, B),undefined).

% holdsDuring/2
mapping_nt(holdsDuring(A, B),undefined).

% deathTime/2
mapping_nt(deathTime(A, B),undefined).

% birthTime/2
mapping_nt(birthTime(A, B),undefined).

% agent/2
mapping_nt(agent(A, B),undefined).

% attribute/2
mapping_nt(attribute(A, B),undefined).

% member/2
mapping_nt(member(A, B),undefined).

% version/2
mapping_nt(version(A, B),undefined).

% greaterThan/2
mapping_nt(greaterThan(A, B),undefined).

% destination/2
mapping_nt(destination(A, B),undefined).

% length/2
mapping_nt(length(A, B),undefined).

% path/2
mapping_nt(path(A, B),undefined).

% subProcess/2
mapping_nt(subProcess(A, B),undefined).

% lessThan/2
mapping_nt(lessThan(A, B),undefined).

% lessThanOrEqualTo/2
mapping_nt(lessThanOrEqualTo(A, B),undefined).

% larger/2
mapping_nt(larger(A, B),undefined).

% greaterThanOrEqualTo/2
mapping_nt(greaterThanOrEqualTo(A, B),undefined).

% links/2
mapping_nt(links(A, B),undefined).

% element/2
mapping_nt(element(A, B),undefined).

% subsetSpecial/2
mapping_nt(subsetSpecial(A, B),undefined).

% subPlan/2
mapping_nt(subPlan(A, B),undefined).

% entails/2
mapping_nt(entails(A, B),undefined).

% copy/2
mapping_nt(copy(A, B),undefined).

% distributes/2
mapping_nt(distributes(A, B),undefined).

% reflexiveOn/2
mapping_nt(reflexiveOn(A, B),undefined).

% equivalenceRelationOn/2
mapping_nt(equivalenceRelationOn(A, B),undefined).

% totalOrderingOn/2
mapping_nt(totalOrderingOn(A, B),undefined).

% partialOrderingOn/2
mapping_nt(partialOrderingOn(A, B),undefined).

% irreflexiveOn/2
mapping_nt(irreflexiveOn(A, B),undefined).

% closedOn/2
mapping_nt(closedOn(A, B),undefined).

% valence/2
mapping_nt(valence(A, B),undefined).

% true/2
mapping_nt(true(A, B),undefined).

% ===============================================================	
% Implied Axioms
% ===============================================================
moo_assertKIF_implicit(Axiom):-fail.


% ===============================================================	
% Asking Axioms
% ===============================================================
moo_askKIF(Axiom).
moo_askKIF(Axiom,Context).
moo_askKIF(Axiom,Context,Context).


cmp_print(X):-atom(X),!,write(X).
cmp_print(X):-print(X).
cmp_write(X):-write(X).
cmp_writeq(X):-writeq(X).
cmp_nl:-nl.
cmp_format(X):-format(X).
cmp_format(X,Y):-format(X,Y).
cmp_format(S,X,Y):-format(S,X,Y).




'surface-macro'([arity, _G16941, _G16947], [valence, _G16941, _G16947]).

'surface-macro'([arityMax, _G16995, _G17001], [valence, _G16995, _G17001]).

'surface-macro'([arityMin, _G16995, _G17001], [valence, _G16995, _G17001]).

'surface-macro'([temporallySubsumes, _G17334, _G17340], [existant, _G17340, _G17334]).

'surface-macro'([isa, _G20410, 'ReflexiveBinaryPredicate'], [and, [valence, _G20410, 2], [and, [isa, _G20410, reflexive], [and, [isa, _G20410, 'Predicate'], [isa, _G20410, 'ReflexiveRelation']]]]).

'surface-macro'([evaluate, _G17133, _G17139], [equal, _G17133, _G17139]).

'surface-macro'([different, _G18215, _G18221], [not, [equal, _G18215, _G18221]]).

'surface-macro'([hasMembers, _G16872, _G16878], [member, _G16878, _G16872]).

'surface-macro'([negativeVestedInterest, _G17998, _G18004], [desires, _G17998, [attribute, _G18004, 'Dead']]).

'surface-macro'([residenceOfOrganization, _G17406, _G17412], [located, _G17406, _G17412]).

'surface-macro'([statementOfPurpose, _G22633, _G22645], [exists, _G22639, [and, [instance, _G22639, 'SocialInteraction'], [and, [agent, _G22639, _G22633], [and, [instance, _G22645, 'ContentBearingObject'], [patient, _G22639, _G22645]]]]]).

'surface-macro'([assertedFormula, _G17113], [knows, 'MooSystem', _G17113]).

'surface-macro'(['DateInSituationFn', 'CalendarDay', _G18949, _G18943], ['WhenFn', ['AdditionFn', ['BeginFn', _G18943], ['DayFn', _G18949, 0]]]).

'surface-macro'([relationInstanceExistsMany, _G17378, _G17366, _G17372], [_G17378, _G17366, _G17372]).

'surface-macro'([endingDate, _G18043, _G18049], [equal, ['EndFn', ['WhenFn', _G18043]], _G18049]).

'surface-macro'([startingDate, _G18082, _G18088], [equal, ['BeginFn', ['WhenFn', _G18082]], _G18088]).

'surface-macro'(['causes-SitProp', _G19466, _G19454], [exists, _G19460, [and, [causes, _G19466, _G19472], [refers, _G19454, _G19472]]]).

chain_mode(_G21459, must_be_bound_before_call(must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call, must_be_bound_before_call)).

'browser-only'(documentation).

'browser-only'(sharedNotes).

'browser-only'(exampleAssertions).

'browser-only'(exampleNATs).

'browser-only'(arg1Format).

'browser-only'(arg2Format).

'browser-only'(arg3Format).

'browser-only'(arg4Format).

'browser-only'(arg5Format).

'browser-only'(arg6Format).

'browser-only'(arg7Format).

'browser-only'(arg8Format).

'browser-only'(arg9Format).

'browser-only'(argFormat).

'browser-only'('STANDARD-BasedProject').

'browser-only'('STANDARDConstant').

'browser-only'('STANDARDExpression').

'browser-only'('STANDARDFormula').

'browser-only'('STANDARDIndexedTerm').

'browser-only'('STANDARDAssertionDirection').

'browser-only'('STANDARDlist').

'browser-only'(cyckifrovenotes).

'browser-only'('STANDARDlistsMt').

'browser-only'('STANDARDSystemAtom').

'browser-only'('STANDARDSystemInteger').

'browser-only'(prettyName).

'browser-only'('STANDARDSystemKeyword').

'browser-only'('STANDARDSystemList').

'browser-only'('STANDARDSystemRealNumber').

'browser-only'('STANDARDSystemString').

'browser-only'('STANDARDSystemSymbol').

'browser-only'('STANDARDTerm').

'browser-only'(constantID).

'browser-only'(constanprovename).

'browser-only'(substring).

'browser-only'(myCreationPurpose).

'browser-only'(myCreationSecond).

'browser-only'(myCreationTime).

'browser-only'(myCreator).

'browser-only'('substring-CaseInsensitive').

'browser-only'('SetTheFormat').

'browser-only'(evaluateAtEL).

'browser-only'(genFormat).

'browser-only'('Guest').

'browser-only'('HumanSTANDARDlist').

'browser-only'(genKeyword).

'browser-only'('DocumentationConstant').

'browser-only'('ELFormulaTemplate').

'browser-only'(elInverse).

'browser-only'('ELRelation').

'browser-only'('ELTemplate').

'browser-only'('equalStrings-CaseInsensitive').

'browser-only'(equalSymbols).

'browser-only'('EverythingPSC').

'browser-only'(genMassNoun).

'browser-only'(oldConstanprovename).

'browser-only'('PATR-Specification').

'browser-only'(genPreferredKeyword).

'browser-only'(comment).

'browser-only'('Format').

'browser-only'(indexicalReferent).

'browser-only'('BeliefPSC').

'browser-only'('LinguisticAVM').

'browser-only'(stringSubword).

'browser-only'('ListTheFormat').

'not-implemented'(fanOutArg).

'not-implemented'('GeneralizedIntersectionFn').

'not-implemented'('GeneralizedUnionFn').

'not-implemented'('IntersectionFn').

'not-implemented'('UnionFn').

'not-implemented'('DomainFn').

'not-implemented'('RangeFn').

'not-implemented'('AbstractionFn').

'not-implemented'('IntersectionFn').

'not-implemented'('AbsolutevalueFn').

'not-implemented'('AbsoluteValueFn').

'not-implemented'('MaxFn').

'not-implemented'('MinFn').

'not-implemented'('IdentityFn').

'not-implemented'('NullSet').

'not-implemented'('ComplementFn').

'not-implemented'('RelativeComplementFn').

'not-implemented'('AssignmentFn').

'not-implemented'('ExtensionFn').

'not-implemented'('IntensionFn').

'not-implemented'(equal).

'not-implemented'(exhaustiveDecomposition).

'not-implemented'('NonnegativeRealNumber').

'surface-word'('ScalarInterval', 'Quantity').

'surface-word'('STANDARDELVariable', 'Entity').

'surface-word'('STANDARDFormula', 'Formula').

'surface-word'('Country', 'Nation').

'surface-word'('DifferenceFn', 'SubtractionFn').

'surface-word'(trueFormula, 'clause-form').

'surface-word'(thereExists, exists).

'surface-word'('WagingWar', 'War').

'surface-word'(implies, =>).

'surface-word'(firstSubEvents, subProcess).

'surface-word'(equiv, <=>).

'surface-word'(equivalent, <=>).

'surface-word'('Equivalent', <=>).

'surface-word'('Implies', =>).

'surface-word'('And', and).

'surface-word'(arity, valence).

'surface-word'('Arity', valence).

'surface-word'(equivalenceRelation, equivalenceRelationOn).

'surface-word'(genls, subclass).

'surface-word'('subclass-of', subclass).

'surface-word'('instance-of', instance).

'surface-word'(domain, domain).

'surface-word'('nth-subclass', domainSubclass).

'surface-word'('nth-domain-subclass', domainSubclass).

'surface-word'('subrelation-of', subrelation).

'surface-word'('component-of', component).

'surface-word'('effector-of', effector).

'surface-word'('attribute-of', attribute).

'surface-word'(located, located).

'surface-word'(meets, meetsTemporally).

'surface-word'(refers, refers, refers).

'surface-word'(part, part).

'surface-word'('KIF-Formula', 'Formula').

'surface-word'('subAttribute-of', subAttribute).

'surface-word'('Unit-Of-Measure', 'UnitOfMeasure').

'surface-word'('Dollar-UnitedStates', 'DollarUnitedStates').

'surface-word'(deviceUsed, instrument).

'surface-word'('instrument-Generic', instrument).

'surface-word'('STANDARDSystemRealNumber', 'RealNumber').

'surface-word'('TemporalThing', 'TimeMeasure').

'surface-word'('STANDARDFormula', 'Formula').

'surface-word'('ScalarInterval', 'UnitOfMeasure').

'surface-word'('TemporalThing', 'TimeDuration').

'surface-word'(evaluate, equal).

'surface-word'(evaluate, equal).

'surface-word'(eval, equal).

'surface-word'(equals, equal).

'surface-word'('Equals', equal).

'surface-word'('Same', equal).

'surface-word'(same, equal).

'surface-word'(objectActedOn, experiencer).

'surface-word'('Or', or).

'surface-word'(thereExists, exists).

'surface-word'('ThereExists', exists).

'surface-word'('Exists', exists).

'surface-word'('ForEach', forall).

'surface-word'('ForAll', forall).

'surface-word'(all, forall).

'surface-word'(forAll, forall).

'surface-word'(genls, subclass).

'surface-word'(consistent, possible).

'surface-word'('Genls', subclass).

'surface-word'(argIsa, domain).

'surface-word'(isa, instance).

'surface-word'('Always', and).

'surface-word'('Never', not).

'surface-word'(never, not).

'surface-word'('Not', not).

'surface-word'(non, not).

'surface-word'(genlPreds, subrelation).

'surface-word'('Thing', 'Entity').

'surface-word'(entity, 'Entity').

'surface-word'(=, equal).

'surface-word'(termOfUnit, equal).

'surface-word'('TermOfUnit', equal).

'surface-word'(genlInverse, inverse).

'surface-word'(resultIsa, range).

'surface-word'('TemporalThing', 'TimeInterval').

'surface-word'(plus, 'AdditionFn').

'surface-word'('PlusFn', 'AdditionFn').

'surface-word'('MinusFn', 'SubtractionFn').

'surface-word'(minus, 'SubtractionFn').

'surface-word'('QuotentFn', 'DivisionFn').

'surface-word'('QuotientFn', 'DivisionFn').

'surface-word'('DivFn', 'DivisionFn').

'surface-word'('TimesFn', 'MultiplicationFn').

'surface-word'(sibling, siblings).

'surface-word'(nec, and).

'not-compiled'('Fn'(_G15951, _G15957)).

'surface-single-arity'(true).

'surface-single-arity'(request).

'surface-single-arity'(not).

'surface-multiple-arity'(=>).

'surface-multiple-arity'(<=>).

'surface-multiple-arity'('AdditionFn').

'surface-multiple-arity'('DivisionFn').

'surface-multiple-arity'('MultiplicationFn').

'surface-multiple-arity'('SubtractionFn').

'surface-multiple-arity'(and).

'surface-multiple-arity'(or).

'surface-multiple-arity'('Xor').

'surface-quantifier'(exists).

'surface-quantifier'(thereExists).

'surface-quantifier'(forall).

'surface-quantifier'(findall).

'surface-quantifier'(findAll).

'surface-quantifier'(some).

'surface-macro'(['PerFn', _G17165, _G17159], ['Fn', 'Division', _G17165, _G17159]).

'surface-macro'(['Percent', _G16831], ['DivisionFn', _G16831, 100]).

'surface-macro'(['RealNumber', _G16568], [number, _G16568]).

'surface-macro'(['RoundUpFn', _G16526], [floor, _G16526]).

'surface-macro'(['PositiveInteger', _G17688], [and, [integer, _G17688], [>, _G17688, 0]]).

'surface-macro'(['NonNegativeInteger', _G17826], [and, [integer, _G17826], [>=, _G17826, 0]]).

'surface-macro'(['NegativeInteger', _G17688], [and, [integer, _G17688], [<, _G17688, 0]]).

'surface-macro'(['RoundDownFn', _G16672], [floor, _G16672, 0]).

'surface-macro'(['RoundUpFn', _G16630], [floor, _G16630, 1]).

'surface-macro'(['RoundClosestFn', _G16901], [floor, _G16901, 0.5]).

'surface-macro'([<, =, _G16892, _G16886], [=>, _G16886, _G16892]).

'Arity'(_G16533, 1)and isa(_G16533, 'Function').

'Arity'(_G16554, 1)and isa(_G16554, 'Predicate').

'Arity'(_G16554, 2)and isa(_G16554, 'Predicate').

'Arity'(_G16533, 3)and isa(_G16533, 'Function').

'Arity'(_G16554, 3)and isa(_G16554, 'Predicate').

'Arity'(_G16554, 4)and isa(_G16554, 'Predicate').

'Arity'(_G16533, 5)and isa(_G16533, 'Function').

'Arity'(_G16554, 5)and isa(_G16554, 'Predicate').

genMt(_G15583, _G15589).

subrequest(_G15886, _G15892).

'surface-quantifier'(relationAllExists).

'surface-quantifier'(relationAllExistsCount).

'surface-quantifier'(relationAllExistsMax).

'surface-quantifier'(relationAllExistsMin).

'surface-quantifier'(relationAllInstance).

'surface-quantifier'(relationInstanceAll).

'surface-quantifier'(relationExistsAll).

'surface-quantifier'(relationExistsCountAll).

'surface-quantifier'(relationExistsMaxAll).

'surface-quantifier'(relationExistsMinAll).

isa(_G15492, 'Individgual').

skolemize(_G15339).

skolemize(_G15339).

'surface-macro'([followingIntervalType, _G18018, _G18024], ['subsequent-ordinal', _G18018, _G18024]).

'surface-macro'([followingValue, _G17880, _G17886], ['subsequent-ordinal', _G17880, _G17886]).

'surface-instance'(<=>, 'EquivalancyConnective').

'surface-instance'(=>, 'ImplicationConnective').

'surface-instance'(<=>, 'PropositionalConnective').

'surface-instance'(=>, 'PropositionalConnective').

'surface-instance'(request, 'PropositionalConnective').

'surface-instance'(requestyn, 'PropositionalConnective').

'surface-instance'(subrequest, 'PropositionalConnective').

'surface-instance'(ist, 'PropositionalConnective').

'surface-instance'(believe, 'PropositionalConnective').

'surface-instance'(iff, 'PropositionalConnective').

'surface-instance'(keStrongSuggestion, 'PropositionalConnective').

'surface-instance'(goals, 'PropositionalConnective').

'surface-instance'(forall, 'UniversalQuantifier').

'surface-instance'(no, 'UniversalQuantifier').

'surface-instance'(neg, 'NegConnective').

'surface-instance'(not, 'NegConnective').

'surface-instance'(no, 'NegConnective').

'surface-instance'(-, 'NegConnective').

'surface-instance'(not, 'NegConnective').

'surface-instance'(and, 'ConjunctiveConnective').

'surface-instance'(or, 'DisjunctiveConnective').

'surface-instance'(xor, 'DisjunctiveConnective').

'surface-instance'(exists, 'ExistentualQuantifier').

'surface-instance'(findall, 'ExistentualQuantifier').

'surface-instance'(findall, 'Quantifier').

'surface-instance'(some, 'ExistentualQuantifier').

'surface-instance'('DateInSituationFn', 'Function').

'surface-instance'(domain, 'DomainConstraintPredicate').

'surface-instance'(domainSubclass, 'DomainConstraintPredicate').

'surface-instance'(valence, 'DomainConstraintPredicate').

'surface-instance'(isa, 'InvolvedInDomainConstraintPredicate').

'surface-instance'(true, 'Predicate').

'surface-subclass'('BinaryConnective', 'Connective').

'surface-subclass'('Connective', 'Quantifier').

'surface-subclass'('ExistentualQuantifier', 'Quantifier').

'surface-subclass'('UniversalQuantifier', 'Quantifier').

'surface-subclass'('Connective', 'PropositionalConnective').

'surface-subclass'('Connective', 'NegConnective').

'surface-subclass'('Connective', 'ConjunctiveConnective').

'surface-subclass'('Connective', 'DisjunctiveConnective').

'surface-subclass'('Junctive', 'ConjunctiveConnective').

'surface-subclass'('Junctive', 'DisjunctiveConnective').

'surface-subclass'('Connective', 'ImplicationConnective').

'surface-subclass'('Connective', 'EquivalancyConnective').

'surface-subclass'('Predicate', 'DomainConstraintPredicate').

'surface-subclass'('Predicate', 'InvolvedInDomainConstraintPredicate').

'surface-subclass'('Function', 'ReifiableTerm').

'surface-class'('Class').

'surface-class'('Collection').

'surface-class'('TransitiveBinaryPredicate').

'surface-class'('VariableArityRelation').

'surface-class'('SymmetricBinaryPredicate').

'surface-class'('FixedArityRelation').

'surface-class'(natFunction).

'surface-class'('ExceptionRelation').

'surface-class'('EvaluatableFunction').

'surface-class'('EvaluatableRelationship').

'surface-class'('CollectionDenotingFunction').

'surface-class'('CommutativeRelation').

'surface-class'('AssociativeRelation').

'surface-class'('AntiSymmetricBinaryPredicate').

'surface-class'('AntiTransitiveBinaryPredicate').

'surface-class'('AsymmetricBinaryPredicate').

'surface-class'('BookkeepingPredicate').

'surface-class'('DistributingMetaKnowledgePredicate').

'surface-class'('DefaultMonotonicPredicate').

'surface-class'('RelationExpression').

'surface-class'('Relationship').

'surface-class'('ReifiableFunction').

'surface-class'(completeExtentKnown).

'surface-class'(completeCollectionExtent).

'surface-class'(extentCardinality).

'surface-class'(minimizeExtent).

'surface-class'('ReifiableNAT').

'surface-class'('ReifiableTerm').

'surface-macro'([argsIsa, _G17380, _G17374], [domain, _G17380, _G17386, _G17374]).

'surface-macro'([arg1Isa, _G17303, _G17297], [domain, _G17303, 1, _G17297]).

'surface-macro'([arg2Isa, _G17258, _G17252], [domain, _G17258, 2, _G17252]).

'surface-macro'([arg3Isa, _G17258, _G17252], [domain, _G17258, 3, _G17252]).

'surface-macro'([arg4Isa, _G17258, _G17252], [domain, _G17258, 4, _G17252]).

'surface-macro'([arg5Isa, _G17258, _G17252], [domain, _G17258, 5, _G17252]).

'surface-macro'([arg6Isa, _G17258, _G17252], [domain, _G17258, 6, _G17252]).

'surface-macro'([arg7Isa, _G17258, _G17252], [domain, _G17258, 7, _G17252]).

'surface-macro'([arg8Isa, _G17258, _G17252], [domain, _G17258, 8, _G17252]).

'surface-macro'([arg9Isa, _G17258, _G17252], [domain, _G17258, 9, _G17252]).

'surface-macro'([argsisa, _G17530, _G17524], [domainSubclass, _G17530, _G17536, _G17524]).

'surface-macro'([arg1isa, _G17258, _G17252], [domain, _G17258, 1, _G17252]).

'surface-macro'([arg2isa, _G17258, _G17252], [domain, _G17258, 2, _G17252]).

'surface-macro'([arg3isa, _G17258, _G17252], [domain, _G17258, 3, _G17252]).

'surface-macro'([arg4isa, _G17258, _G17252], [domain, _G17258, 4, _G17252]).

'surface-macro'([arg5isa, _G17258, _G17252], [domain, _G17258, 5, _G17252]).

'surface-macro'([arg6isa, _G17258, _G17252], [domain, _G17258, 6, _G17252]).

'surface-macro'([arg7isa, _G17258, _G17252], [domain, _G17258, 7, _G17252]).

'surface-macro'([arg8isa, _G17258, _G17252], [domain, _G17258, 8, _G17252]).

'surface-macro'([arg9isa, _G17258, _G17252], [domain, _G17258, 9, _G17252]).

'surface-macro'([argsGenls, _G17572, _G17566], [domainSubclass, _G17572, _G17578, _G17566]).

'surface-macro'([arg1Genl, _G17447, _G17441], [domainSubclass, _G17447, 1, _G17441]).

'surface-macro'([arg2genls, _G17468, _G17462], [domainSubclass, _G17468, 2, _G17462]).

'surface-macro'([arg2Genl, _G17447, _G17441], [domainSubclass, _G17447, 2, _G17441]).

'surface-macro'([arg3Genl, _G17447, _G17441], [domainSubclass, _G17447, 3, _G17441]).

'surface-macro'([arg4Genl, _G17447, _G17441], [domainSubclass, _G17447, 4, _G17441]).

'surface-macro'([arg5Genl, _G17447, _G17441], [domainSubclass, _G17447, 5, _G17441]).

'surface-macro'([arg6Genl, _G17447, _G17441], [domainSubclass, _G17447, 6, _G17441]).

'surface-macro'([arg7Genl, _G17447, _G17441], [domainSubclass, _G17447, 7, _G17441]).

'surface-macro'([arg8Genl, _G17447, _G17441], [domainSubclass, _G17447, 8, _G17441]).

'surface-macro'([arg9Genl, _G17447, _G17441], [domainSubclass, _G17447, 9, _G17441]).

'surface-macro'([interArgResultIsa, _G21128, 'ArgN', _G21116, _G21122], [and, [isa, _G21128, 'Function'], [=>, [valence, _G21128, 'Arity'], ['domain-related', _G21128, 'ArgN', 'Arity', _G21116, _G21122]]]).

'surface-macro'([interArgResultGenl, _G21128, 'ArgN', _G21116, _G21122], [and, [isa, _G21128, 'Function'], [=>, [valence, _G21128, 'Arity'], ['domain-related', _G21128, 'ArgN', 'Arity', _G21116, _G21122]]]).

'surface-macro'([interArgIsa, _G19770, _G19758, _G19746, _G19764, _G19752], ['domain-related', _G19770, _G19758, _G19764, _G19746, _G19752]).

'surface-macro'(['interArgIsa1-2', _G18539, _G18527, _G18533], ['domain-related', _G18539, 1, 2, _G18527, _G18533]).

'surface-macro'(['interArgIsa1-3', _G18539, _G18527, _G18533], ['domain-related', _G18539, 1, 3, _G18527, _G18533]).

'surface-macro'(['interArgIsa1-4', _G18539, _G18527, _G18533], ['domain-related', _G18539, 1, 4, _G18527, _G18533]).

'surface-macro'(['interArgIsa1-5', _G18539, _G18527, _G18533], ['domain-related', _G18539, 1, 5, _G18527, _G18533]).

'surface-macro'(['interArgIsa1-6', _G18539, _G18527, _G18533], ['domain-related', _G18539, 1, 6, _G18527, _G18533]).

'surface-macro'(['interArgIsa2-2', _G18539, _G18527, _G18533], ['domain-related', _G18539, 2, 2, _G18527, _G18533]).

'surface-macro'(['interArgIsa2-3', _G18539, _G18527, _G18533], ['domain-related', _G18539, 2, 3, _G18527, _G18533]).

'surface-macro'(['interArgIsa2-4', _G18539, _G18527, _G18533], ['domain-related', _G18539, 2, 4, _G18527, _G18533]).

'surface-macro'(['interArgIsa2-5', _G18539, _G18527, _G18533], ['domain-related', _G18539, 2, 5, _G18527, _G18533]).

'surface-macro'(['interArgIsa2-6', _G18539, _G18527, _G18533], ['domain-related', _G18539, 2, 6, _G18527, _G18533]).

'surface-macro'(['interArgIsa3-2', _G18539, _G18527, _G18533], ['domain-related', _G18539, 3, 2, _G18527, _G18533]).

'surface-macro'(['interArgIsa3-3', _G18539, _G18527, _G18533], ['domain-related', _G18539, 3, 3, _G18527, _G18533]).

'surface-macro'(['interArgIsa3-4', _G18539, _G18527, _G18533], ['domain-related', _G18539, 3, 4, _G18527, _G18533]).

'surface-macro'(['interArgIsa3-5', _G18539, _G18527, _G18533], ['domain-related', _G18539, 3, 5, _G18527, _G18533]).

'surface-macro'(['interArgIsa3-6', _G18539, _G18527, _G18533], ['domain-related', _G18539, 3, 6, _G18527, _G18533]).

'surface-macro'(['interArgIsa4-2', _G18539, _G18527, _G18533], ['domain-related', _G18539, 4, 2, _G18527, _G18533]).

'surface-macro'(['interArgIsa4-3', _G18539, _G18527, _G18533], ['domain-related', _G18539, 4, 3, _G18527, _G18533]).

'surface-macro'(['interArgIsa4-4', _G18539, _G18527, _G18533], ['domain-related', _G18539, 4, 4, _G18527, _G18533]).

'surface-macro'(['interArgIsa4-5', _G18539, _G18527, _G18533], ['domain-related', _G18539, 4, 5, _G18527, _G18533]).

'surface-macro'(['interArgIsa4-6', _G18539, _G18527, _G18533], ['domain-related', _G18539, 4, 6, _G18527, _G18533]).

'surface-macro'(['interArgIsa5-2', _G18539, _G18527, _G18533], ['domain-related', _G18539, 5, 2, _G18527, _G18533]).

'surface-macro'(['interArgIsa5-3', _G18539, _G18527, _G18533], ['domain-related', _G18539, 5, 3, _G18527, _G18533]).

'surface-macro'(['interArgIsa5-4', _G18539, _G18527, _G18533], ['domain-related', _G18539, 5, 4, _G18527, _G18533]).

'surface-macro'(['interArgIsa5-5', _G18539, _G18527, _G18533], ['domain-related', _G18539, 5, 5, _G18527, _G18533]).

'surface-macro'(['interArgIsa5-6', _G18539, _G18527, _G18533], ['domain-related', _G18539, 5, 6, _G18527, _G18533]).

'surface-macro'(['interArgReln1-2', _G17791, 'Relation'], ['nth-relation-exists', _G17791, 1, 2, 'Relation']).

'surface-macro'(['interArgReln1-3', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 1, 3, 'Relation']).

'surface-macro'(['interArgReln1-4', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 1, 4, 'Relation']).

'surface-macro'(['interArgReln1-5', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 1, 5, 'Relation']).

'surface-macro'(['interArgReln1-6', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 1, 6, 'Relation']).

'surface-macro'(['interArgReln2-2', _G18262, 'Relation'], ['nth-relation-exists', _G18262, 2, 2, 'Relation']).

'surface-macro'(['interArgReln2-3', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 2, 3, 'Relation']).

'surface-macro'(['interArgReln2-4', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 2, 4, 'Relation']).

'surface-macro'(['interArgReln2-5', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 2, 5, 'Relation']).

'surface-macro'(['interArgReln2-6', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 2, 6, 'Relation']).

'surface-macro'(['interArgReln3-2', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 3, 2, 'Relation']).

'surface-macro'(['interArgReln3-3', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 3, 3, 'Relation']).

'surface-macro'(['interArgReln3-4', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 3, 4, 'Relation']).

'surface-macro'(['interArgReln3-5', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 3, 5, 'Relation']).

'surface-macro'(['interArgReln3-6', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 3, 6, 'Relation']).

'surface-macro'(['interArgReln4-2', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 4, 2, 'Relation']).

'surface-macro'(['interArgReln4-3', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 4, 3, 'Relation']).

'surface-macro'(['interArgReln4-4', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 4, 4, 'Relation']).

'surface-macro'(['interArgReln4-5', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 4, 5, 'Relation']).

'surface-macro'(['interArgReln4-6', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 4, 6, 'Relation']).

'surface-macro'(['interArgReln5-2', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 5, 2, 'Relation']).

'surface-macro'(['interArgReln5-3', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 5, 3, 'Relation']).

'surface-macro'(['interArgReln5-4', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 5, 4, 'Relation']).

'surface-macro'(['interArgReln5-5', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 5, 5, 'Relation']).

'surface-macro'(['interArgReln5-6', _G17767, 'Relation'], ['nth-relation-exists', _G17767, 5, 6, 'Relation']).

% end_of_file.

% ;; ====================================================================================   
%  ;; As Kernel Predicates are Passed As they Are and only explored the surface-domains   
%  ;; ====================================================================================   
%          ( as-kernel prolog-equal 2 )  
'as-kernel'('prolog-equal', 2).

%   ( as-kernel identity-skolem 2 )  
'as-kernel'('identity-skolem', 2).

%   ( as-kernel resolve_skolem 2 )  
'as-kernel'(resolve_skolem, 2).

%   ( as-kernel true 0 )  
'as-kernel'(true, 0).

%   ( as-kernel false 0 )  
'as-kernel'(false, 0).

%   ( as-kernel fail 0 )  
'as-kernel'(fail, 0).

%   ( as-kernel succeed 0 )  
'as-kernel'(succeed, 0).

%   ( as-kernel true 0 )  
'as-kernel'(true, 0).

%   ( as-kernel atom 1 )  
'as-kernel'(atom, 1).

%   ( as-kernel integer 1 )  
'as-kernel'(integer, 1).

%   ( as-kernel number 1 )  
'as-kernel'(number, 1).

%   ( as-kernel atomic 1 )  
'as-kernel'(atomic, 1).

%   ( as-kernel constant 1 )  
'as-kernel'(constant, 1).

%   ( as-kernel functor 3 )  
'as-kernel'(functor, 3).

%   ( as-kernel arg 3 )  
'as-kernel'(arg, 3).

%   ( as-kernel var 1 )  
'as-kernel'(var, 1).

%   ( as-kernel nonvar 1 )  
'as-kernel'(nonvar, 1).

%   ( as-kernel call 1 )  
'as-kernel'(call, 1).

%   ( as-kernel = 2 )  
'as-kernel'(=, 2).

%   ( as-kernel \= 2 )  
%   ( as-kernel == 2 )  
'as-kernel'(==, 2).

%   ( as-kernel \== 2 )  
%   ( as-kernel =\= 2 )  
%   ( as-kernel > 2 )  
'as-kernel'(>, 2).

%   ( as-kernel < 2 )  
'as-kernel'(<, 2).

%   ( as-kernel >= 2 )  
'as-kernel'(>=, 2).

%   ( as-kernel =< 2 )  
'as-kernel'(=<, 2).

%   ( as-kernel dif 2 )  
'as-kernel'(dif, 2).

%   ( as-kernel is 2 )  
'as-kernel'(is, 2).

%   ( as-kernel max 3 )  
'as-kernel'(max, 3).

%   ( as-kernel min 3 )  
'as-kernel'(min, 3).

%   ( as-kernel display 1 )  
'as-kernel'(display, 1).

%   ( as-kernel write 1 )  
'as-kernel'(write, 1).

%   ( as-kernel nl 0 )  
'as-kernel'(nl, 0).

%   ( as-kernel deduce_by ?UNK )  
'as-kernel'(deduce_by, _G14243).

%   ( as-kernel search_cost ?UNK )  
'as-kernel'(search_cost, _G14315).

%   ( as-kernel test_and_decrement_search_cost ?UNK )  
'as-kernel'(test_and_decrement_search_cost, _G14771).

%   ( as-kernel equal ?UNK )  
'as-kernel'(equal, _G14171).

%   ( as-kernel identical_member ?UNK )  
'as-kernel'(identical_member, _G14435).

%   ( as-kernel unifiable_member ?UNK )  
'as-kernel'(unifiable_member, _G14435).

%   ( as-kernel inc_ncalls 0 )  
'as-kernel'(inc_ncalls, 0).

%   ( as-kernel axioms ?UNK )  
'as-kernel'(axioms, _G14195).

%   ( as-kernel anc_del ?UNK )  
'as-kernel'(anc_del, _G14219).

%    ( as-kernel anc_union ?UNK )  
'as-kernel'(anc_union, _G14279).

%    ( as-kernel anc_subset ?UNK )  
'as-kernel'(anc_subset, _G14303).

%       ;; ====================================================================================   
%  ;;  The compiler must know some taxonimic pairs   
%  ;; ====================================================================================   
%  (taxonomic-pair isa genls)  
'taxonomic-pair'(isa, genls).

%   (taxonomic-pair instance subclass)  
'taxonomic-pair'(instance, subclass).

%   (taxomonic-pair surface-instance surface-subclass)  
'taxomonic-pair'('surface-instance', 'surface-subclass').

%         ;; ========================================================   
%  ;; Compiler Macros   
%  ;; Some Reduction predicates to save Compiler Bandwidth    
%  ;; ========================================================   
%    ;;                                               ;;   
%  ;;                Declarations to Kernel Language         ;;   
%  ;;                                               ;;   
%  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;;;   KERNEL CORE   
%  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%    ;(Class context-atom)   
%  ;(Class resource-atom)   
%  ;(Class macro-atom)   
%  ;(Class belief-language-atom)   
%  ;(Class system-known-atom)   
%  ;(Class relational-atom)   
%                                                         ;(subclass context-atom resource-atom)   
%  ;(subclass resource-atom system-known-atom)   
%    ;; If Resource was an object   
%  ;; Resource.Name  as a Resource-atom   
%  ;; Resource.Location as a prolog_file, url_path, kif_file, etc   
%  ;; Resource.resource-state    
%  ;; Resource.availability    
%    ;(instance moo-kernel resource-atom)   
%  ;(instance moo-kernel kif-file-resource)   
%  ;(instance moo-kernel prolog-file-resource)   
%  ;(instance kernel-theory context-atom)   
%  ;(instance context-links-theory context-atom)   
%  ;(instance complier-theory context-atom)   
%  ;(instance default-context context-atom)   
%       ;; If Context was an object:   
%  ;;   
%  ;; Context.Name  as a Context-atom   
%  ;; Context.Resource as a Resource-path   
%  ;; Context.context-state as loaded-unchanged or loaded-change   
%  ;; Context.Parents as ListOf Contexts   
%  ;; Context.Children as ListOf Contexts   
%        ;(instance assert belief-language-atom)   
%  ;(instance retract belief-language-atom)   
%  ;(instance retractall belief-language-atom)   
%  ;(instance update belief-language-atom)   
%    ;( =>   
%  ;        (instance ?Atom belief-language-atom)   
%  ;        (relation-located ?Atom moo-kernel)   
%  ;   
%  ;)   
%                                                                                                           ;(instance macro-script relational-atom)   
%  ;(functsymbol macro-script 2)   
%  ;(domain macro-script 1 moo-prototype-argument)   
%  ;(domain macro-script 2 moo-expression)   
%       ;;(context-object ?Name ?Resource ?State ?Parents ?Children)   
%    ;;(instance Context.Name Context-atom)   
%  ;;(instance Context.FileName Resource-path)   
%    ;;(instance context-create ContextManagementMacro)   
%  ;;(subclass ContextManagementMacro ImmediateModeMacro)   
%                                                         ;( instance context-create macro-scripts)   
%  ;( instance use-kr macro-scripts)   
%  ;( instance assert macro-scripts)   
%  ;( instance request macro-scripts)   
%  ;( instance save-kr macro-scripts)   
%  ;( instance use-resource macro-scripts)   
%  ;( instance unuse-resource macro-scripts)   
%  ;( instance add-relation macro-scripts)   
%  ;( instance delete-relation macro-scripts)   
%  ;( instance info-relation macro-scripts)   
%  ;( instance list-kr macro-scripts)   
%    ;;;;;;;;;;;;;;;;;;;;;;RELATION LOCATED;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%    (relation-located prolog-equal 2 kernel  (SetFn ?h639  ?h641) prolog-equal  always )  
'relation-located'('prolog-equal', 2, kernel, 'SetFn'(_G16382, _G16388), 'prolog-equal', always).

%   (relation-located identity-skolem 2 kernel  (SetFn ?h639  ?h641) generic_skolem  always )  
'relation-located'('identity-skolem', 2, kernel, 'SetFn'(_G16490, _G16496), generic_skolem, always).

%   (relation-located prolog-eval 2 kernel  (SetFn ?h639  ?h641) prolog-eval  always )  
'relation-located'('prolog-eval', 2, kernel, 'SetFn'(_G16322, _G16328), 'prolog-eval', always).

%   (relation-located moo-consultation 3 kernel  (SetFn ?h639  ?h641 ?h643) moo-consultation always )  
'relation-located'('moo-consultation', 3, kernel, 'SetFn'(_G17061, _G17067, _G17073), 'moo-consultation', always).

%   (relation-located user-believes 1 kernel  (SetFn ?h639 ) user-believes always )  
'relation-located'('user-believes', 1, kernel, 'SetFn'(_G16003), 'user-believes', always).

%   (relation-located nnf 2 kernel  (SetFn ?h639 ?h639 ) nnf always )  
'relation-located'(nnf, 2, kernel, 'SetFn'(_G15922, _G15922), nnf, always).

%   (relation-located equal 2 kernel  (SetFn ?h639 ?h639 ) prolog-equal always )  
'relation-located'(equal, 2, kernel, 'SetFn'(_G16186, _G16186), 'prolog-equal', always).

%   ;(relation-located greaterThanOrEqualTo 2 kernel  (SetFn ?h639 ?h639 ) greaterThanOrEqualTo always )   
%  ;(relation-located lessThanOrEqualTo 2 kernel  (SetFn ?h639 ?h639 ) lessThanOrEqualTo always )   
%  ;(relation-located greaterThan 2 kernel  (SetFn ?h639 ?h639 ) greaterThan always )   
%  ;(relation-located lessThan 2 kernel  (SetFn ?h639 ?h639 ) lessThan always )   
%    ;(relation-located = 2 kernel  (SetFn ?h639 ?h639 ) prolog-equal always )   
%    ;(instance  the-user-name  consultation-predicate)   
%                                                             ;;(instance Context.State Context-state-atom)   
%  ;;(instance Context.State Context-state-atom)   
%       ;Rule.Context   
%  ;Rule.ExternalTrackingNumber   
%  ;Rule.CompliedForm   
%  ;Rule.Certainty   
%                                                   (  =>          (macro-script  (?Atom) ?Proposition)          (instance ?Atom macro-atom)  )  
'macro-script'(_G17106, _G17112)=>instance(_G17106, 'macro-atom').

%     (  =>          (macro-script  (?Atom ?1 ?2) ?Proposition)          (instance ?Atom macro-atom)  )  
'macro-script'(holds(_G17003, _G16991, _G16997), _G17009)=>instance(_G17003, 'macro-atom').

%     (  =>          (macro-script  (?Atom ?1 ?2 ?3) ?Proposition)          (instance ?Atom macro-atom)  )  
'macro-script'(holds(_G17247, _G17229, _G17235, _G17241), _G17253)=>instance(_G17247, 'macro-atom').

%     (  =>          (macro-script  (?Atom ?1 ?2 ?3 ?4) ?Proposition)          (instance ?Atom macro-atom)  )  
'macro-script'(holds(_G17491, _G17467, _G17473, _G17479, _G17485), _G17497)=>instance(_G17491, 'macro-atom').

%                                                                                                                                         (macro-script   (context-create ?Context-atom)          (and-then                  (assert  resources-theory (instance ?Context-atom  context-atom ) )                   (retractall  resources-theory  (context-state ?Context-atom  ?? ) )                   (assert  resources-theory  (context-state ?Context-atom  context-state-unloaded))           )  )  
'macro-script'('context-create'(_G24939), 'and-then'(assert('resources-theory', instance(_G24939, 'context-atom')), retractall('resources-theory', 'context-state'(_G24939, _G24951)), assert('resources-theory', 'context-state'(_G24939, 'context-state-unloaded')))).

%           (macro-script           (use-kr ?Context-atom ?Resource-Path)            (and-then                  (context-create ?Context-atom)                  (file-resource-create ?Resource-Path)          )  )  
'macro-script'('use-kr'(_G18925, _G18931), 'and-then'('context-create'(_G18925), 'file-resource-create'(_G18931))).

%                           (macro-script           (file-resource-create ?Resource-name ?Resource-path)                  (assert  resources-theory  (instance FileName  source-file-path))                   (assert  resources-theory  (context-exists-in-file NewContext-atom  FileName))   )  
'macro-script'('file-resource-create'(_G20745, _G20751), assert('resources-theory', instance('FileName', 'source-file-path')), assert('resources-theory', 'context-exists-in-file'('NewContext-atom', 'FileName'))).

%           

%       ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;;                                               ;;   
%  ;;                Bootstrap/INI file                        ;;   
%  ;;                                               ;;   
%  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%    ;(use-kr kernel-theory 'builtin\kernel-theory.kif')          ; That is here   
%  ;(use-kr compiler-theory 'builtin\compiler-theory.kif')   
%  ;(use-kr belief-theory 'builtin\belief-theory.kif')   
%  ;(use-kr context-links 'builtin\context-links.kif')   
%  ;;;(use-kr merged-ontology-theory 'builtin\merged-ontology-theory.kif')   
%  ;(use-kr universal-theory 'builtin\universal-theory.kif')   
%  ;(use-kr sample-theory 'builtin\sample-theory.kif')   
%  ;(use-kr resources-theory 'resources\resources-theory.kif')   
%  ;(use-resource moo-user-assisted-belief)   
%                 ;; Context/Rule Management   
%    ;; Imagine a context as an object:   
%    ;; It has these properties:   
%                (=>          (relation-located ?RelationName ?Valence kernel  ?ModeList ?RelationName ?Availabily )          (instance ?RelationName  kernel-atom))  
'relation-located'(_G18247, _G18253, kernel, _G18241, _G18247, _G18235)=>instance(_G18247, 'kernel-atom').

%     (=>          (relation-located ?RelationName ?Valence moo-user-assisted-belief  ?ModeList ?RelationName ?Availabily )          (instance ?RelationName  consultation-predicate))  
'relation-located'(_G18925, _G18931, 'moo-user-assisted-belief', _G18919, _G18925, _G18913)=>instance(_G18925, 'consultation-predicate').

%     (=>          (relation-located ?RelationName ?Valence moo-user-assisted-belief  ?ModeList ?RelationName always )          (instance ?RelationName  consultation-predicate-always))  
'relation-located'(_G18878, _G18884, 'moo-user-assisted-belief', _G18872, _G18878, always)=>instance(_G18878, 'consultation-predicate-always').

%     (=>          (relation-located ?RelationName ?Valence moo-user-assisted-belief  ?ModeList ?RelationName after-failure )          (instance ?RelationName  consultation-predicate-after-failure))  
'relation-located'(_G19214, _G19220, 'moo-user-assisted-belief', _G19208, _G19214, 'after-failure')=>instance(_G19214, 'consultation-predicate-after-failure').

%     ;;;;; A consultation predicate Assertion   
%  (relation-located           user-name 1           moo-user-assisted-belief (external-agent-must-bind)          get-user-name  once )  
'relation-located'('user-name', 1, 'moo-user-assisted-belief', 'external-agent-must-bind', 'get-user-name', once).

%     ;;;;   This means if ( user-name ?X ) is being sought by the belief engine    
%  ;;;;   Call the moo-user-assisted-belief is used with function call get-user-name and it must external-agent-must-bind  the argument   
%  ;;;;   This will only happen once per session   
%  ;;(functsymbol relation-located 5)   
%  ; ;;       ( domain relation-located 1 Relation-atom )   
%  ;  ;;      ( domain relation-located 2 Resource-Modules )   
%  ; ;       ( domainSubclass relation-located 3 Argument-Mode )   
%  ;  ;      ( domain relation-located 4 Relation-atom )   
%  ;        ( domain relation-located 5 Resource-Availabily )   
%      (subclass Argument-List Unmonitored-List)  
subclass('Argument-List', 'Unmonitored-List').

%           ;; Unmonitored lists are structures that only are understood by the predicate using them and cannot be optimally constrained (and therefore are never subject to backchaining or negation this is this is a simular to the understanding that integers are not entities as the same way these are ussualy 'flags' or 'properties' are never existencially quantifiable (DISPARAMS)   
%    ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;;( domain relation-located 2 Resource-Modules )   
%  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;; Five Code Implimented Resource-Modules   
%  ;;(Class Resource-Modules)   
%         ;; hardwired into prolog and cannot be changed   
%    ;;      (instance kernel Resource-Modules)   
%         ;; GAFS and Proven Assertions   
%    ;;      (instance local-assertions Resource-Modules)   
%         ;; Subsumes the above two but has Infenrece as well   
%   ;;       (instance local-belief Resource-Modules)   
%         ;; Built in Consultation with User or Agent    
%   ;;       (instance moo-user-assisted-belief Resource-Modules)   
%         ;; Built in Consultation with Resouces exported by a wrapped MOO Interface  (TODO)   
%   ;;       (instance moo-resource-module Resource-Modules)   
%            ;; Further one adds RDBMS's, Web Agents and Full Foriegn Applications   
%  ;; To do this:   
%  ;;    
%  ;;   Create a Small .P file    
%  ;;   In the XSB Prolog manual there are examples of linking the C/C++ or to an ODBC interface   
%  ;;   In the Prolog File Make only one Predicate that will access your resource   
%  ;;   
%  ;;   Put the file in the $BeliefEnginePath/resources the new file   
%  ;;   Assert into the Contexts that you would like to use the external resource:   
%  ;;   (functsymbol ?KRName-Predicate ?VALENCE)    ;;Valence assertions actually act as the only requried marker in a context   
%  ;;   (domain ?KRName-Predicate 1 ?Known-Class)   
%  ;;   (domain ?KRName-Prfedicate 2 ?Known-Class)   
%  ;;            ...etc...   
%  ;;   (relation-located ?KRName-Predicate ?VALENCE ?Name-of-resource ( ?Arg1Argument-Mode ?Arg2Argument-Mode ) ?'Predicate-Name-in-Resource' ?Resource-Availabily)   
%    ;;  Now into the $/resources/resources-theory.kif file add the lines:  (Or make sure MOO agent adds this assertion)   
%  ;;   (instance ?Name-of-resource Resource-Modules)   
%  ;;   (instance  ?KRName-Predicate Relation-atom)   
%  ;;   (resource-module ?Name-of-resource filesystem ?RelativePath) or (resource-module ?Name-of-resource moo-system ?RequestName)   
%  ;;   
%  ;;  The belief Engine is now considering the predicate but cannot use it until the final assertion (actually a call that results in an assertion)   
%  ;;  ( use-resource ?Name-of-resource )   
%  ;;  this will result in this assertion ( resource-state ?Name-of-resource load-defered )   
%  ;;  or possibly ( resource-state ?Name-of-resource cb_error )   
%  ;;   
%  ;;  Try out a call to the predicate    
%  ;;  the resources-theory should now have  ( resource-state ?Name-of-resource loaded )   
%  ;;   
%  ;;   From that point on it will stay loaded until you call  ( unuse-resource ?Name-of-resource )   
%  ;;   Now you will see no assertion of  (resource-state ... ...)   
%  ;;   
%                                                           ;;;;(relation-located between 2 ( at-least-one-other-arg-bound at-least-one-other-arg-bound )    
%      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;;;       Before Calling a Resource Is Used each Argument is checked for Single_bindings     ;;;   
%  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;; Four code implimented modes   
%       ;(Class Argument-Mode)   
%          ;;( instance must-be-bound-before-call Argument-Mode)   
%          ;;( instance external-agent-must-bind Argument-Mode)   
%          ;;( instance not-monitored Argument-Mode)   
%          ;;( instance at-least-one-other-arg-bound Argument-Mode)   
%      ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;;;       Resource Availablity Atoms                         ;;;;;;   
%  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;   
%  ;; Four code implimented modes   
%            ;;(Class Resource-Availabily)   
%          ;; Each Iteration Calls The Resource-Modules   
%          ;;( instance always Resource-Availabily)   
%                    ;; No Iteration Calls The Resource-Modules   
%          ;;( instance never Resource-Availabily)   
%                    ;; Only if the minimum Answers has not been reached call the Resource-Modules   
%          ;;( instance after-failure Resource-Availabily)   
%                    ;; Only if the minimum Answers has not been reached call the Resource-Modules (But Once you have received a disp_single_binding set do not ask resource again)   
%          ;; This is how to add a prolog style-cut into the real world!   
%          ;;( instance once Resource-Availabily)   
%                                                         ;;(=>   
%    ;;      (relation-located ?RelationName ?Valence kernel  ?ModeList ?RelationName ?Availabily )   
%   ;;       (functsymbol ?RelationName  ?Valence))   
%          (relation-located isa 2 deduceSurfaceer (external-agent-must-bind external-agent-must-bind) deduceSurface  always )  
'relation-located'(isa, 2, deduceSurfaceer, 'external-agent-must-bind'('external-agent-must-bind'), deduceSurface, always).





%:-module(moo_database,[]).

% :-include('moo_header.pl').

% =======================================================================================
% ACTIVATE CONTEXT DAG
% =======================================================================================

% on a dirty ctx/theory run remake_positive_cache(Context,Ctx)
% on a dirty ctx/theory run remake_negative_cache(Context,Ctx)




negative_fact_cache(Context,+X):-not(positive_fact_cache(Context,_,X)).
negative_fact_cache(Context,-X):-not(positive_fact_cache(Context,_,X)).

negative_rule_cache(Context,+X):-not(positive_rule_cache(Context,_,X)).
negative_rule_cache(Context,-X):-not(positive_rule_cache(Context,_,X)).

ambiguous_fact_cache(Context,+X):- (positive_fact_cache(Context,?,X)).
ambiguous_fact_cache(Context,-X):- (positive_fact_cache(Context,?,X)).

ambiguous_rule_cache(Context,+X):- (positive_rule_cache(Context,?,X)).
ambiguous_rule_cache(Context,-X):- (positive_rule_cache(Context,?,X)).


holds_wrapper(Context,R,X,Y):-nonvar(R),!,
        P=..[R,X,Y],
        all_predicate_cache(Context,+P).

holds_wrapper(Context,R,X,Y,Z):-nonvar(R),!,
        P=..[R,X,Y,Z],
        all_predicate_cache(Context,+P).

holds_wrapper(Context,R,X,Y,Z,Q):-nonvar(R),!,
        P=..[R,X,Y,Z,Q],
        all_predicate_cache(Context,+P).

holds_wrapper(Context,R,X,Y):-
        all_predicate_cache(Context,+P),
        P=..[R,X,Y].

holds_wrapper(Context,R,X,Y,Z):-
        all_predicate_cache(Context,+P),
        P=..[R,X,Y,Z].

holds_wrapper(Context,R,X,Y,Z,Q):-
        all_predicate_cache(Context,+P),
        P=..[R,X,Y,Z,Q].

not_holds_wrapper(Context,R,X,Y):-nonvar(R),!,
        P=..[R,X,Y],
        all_predicate_cache(Context,-P).

not_holds_wrapper(Context,R,X,Y,Z):-nonvar(R),!,
        P=..[R,X,Y,Z],
        all_predicate_cache(Context,-P).

not_holds_wrapper(Context,R,X,Y,Z,Q):-nonvar(R),!,
        P=..[R,X,Y,Z,Q],
        all_predicate_cache(Context,-P).

not_holds_wrapper(Context,R,X,Y):-
        all_predicate_cache(Context,-P),
        P=..[R,X,Y].

not_holds_wrapper(Context,R,X,Y,Z):-
        all_predicate_cache(Context,-P),
        P=..[R,X,Y,Z].

not_holds_wrapper(Context,R,X,Y,Z,Q):-
        all_predicate_cache(Context,-P),
        P=..[R,X,Y,Z,Q].

positive_rule_fact(Context,X):-
        positive_fact_cache(Context,X),
        positive_rule_cache(Context,X).

positive_rule_only(Context,X):-
        positive_rule_cache(Context,X),
        not(positive_fact_cache(Context,X)).

positive_fact_only(Context,X):-
        positive_fact_cache(Context,X),
        not(positive_rule_cache(Context,X)).


all_predicate_cache(Context,X):-
        positive_fact_cache(Context,X).
all_predicate_cache(Context,X):-
        positive_rule_cache(Context,X).

positive_fact_cache(Context,+X):-positive_fact_cache(Context,+,X).
positive_fact_cache(Context,-X):-positive_fact_cache(Context,-,X).
positive_fact_cache(Context,+X):-positive_fact_cache(Context,?,X).
positive_fact_cache(Context,-X):-positive_fact_cache(Context,?,X).
positive_rule_cache(Context,+X):-var(X),!,positive_rule_cache(Context,+,X).
 % Note that -X is missing from positive rule cache when its a X is a Var
positive_rule_cache(Context,+X):-positive_rule_cache(Context,+,X).
positive_rule_cache(Context,-X):-positive_rule_cache(Context,-,X).
positive_rule_cache(Context,+X):-positive_rule_cache(Context,?,X).
positive_rule_cache(Context,-X):-positive_rule_cache(Context,?,X).


all_predicate_fast_cache(Context,X):-positive_fact_cache(Context,X).
all_predicate_fast_cache(Context,X):-positive_rule_cache(Context,X).

all_predicate_slow_cache(Context,X):-positive_fact_cache(Context,X).
all_predicate_slow_cache(Context,X):-positive_rule_only(Context,X).




remake_positive_cache(Context,Ctx):-
        unmake_positive_cache(Context,Ctx),
        make_positive_cache(Context,Ctx),!.

unmake_positive_cache(Context,Ctx):-
        retractall((make_positive_cache(Context,Ctx):-!)).

make_positive_cache(Context,Ctx):-
        retractall(positive_fact_cache(_,_,_,_)),
        retractall(positive_rule_cache(_,_,_,_)),
        retractall(negative_fact_cache(_,_,_,_)),
        retractall(negative_rule_cache(_,_,_,_)),
        fail.

make_positive_cache(Context,Ctx):-
        mooCache(R,Cons, Ante, _, L, Context, Ctx, Explaination),
        add_positive_rule_cache(Context,L,R),
        fail.

make_positive_cache(Context,Ctx):-
        mooCache(R,Fact, _, L, Context, Ctx, Explaination),
        add_positive_fact_cache(Context,L,R),
        fail.

make_positive_cache(Context,Ctx):-
        asserta((make_positive_cache(Context,Ctx):-!)),!.


add_positive_fact_cache(Context,L,R):-
        get_arity_fast(Context,R,A),!,
        functor(P,R,A),
        not(positive_fact_cache(Context,?,P)),
                ((L=true  ->
                        ((
                        retract(positive_fact_cache(Context,-,P)) ->
                                asserta(positive_fact_cache(Context,?,P)) ;
                                assert_if_new(positive_fact_cache(Context,+,P))
                        ));
                        ((
                        retract(positive_fact_cache(Context,+,P)) ->
                                asserta(positive_fact_cache(Context,?,P)) ;
                                assert_if_new(positive_fact_cache(Context,-,P))
                        ))
                )),!.

add_positive_rule_cache(Context,L,R):-
        get_arity_fast(Context,R,A),!,
        functor(P,R,A),
        not(positive_rule_cache(Context,?,P)),
                ((L=true  ->
                        ((
                        retract(positive_rule_cache(Context,-,P)) ->
                                asserta(positive_rule_cache(Context,?,P)) ;
                                assert_if_new(positive_rule_cache(Context,+,P))
                        ));
                        ((
                        retract(positive_rule_cache(Context,+,P)) ->
                                asserta(positive_rule_cache(Context,?,P)) ;
                                assert_if_new(positive_rule_cache(Context,-,P))
                        ))
                )),!.


get_arity_fast(Context,R,A):-have_arity(R,Context,A),!.
get_arity_fast(Context,R,A):-
        mooCache(R,Cons, _, _, Context, Ctx, Explaination),
        functor(Cons,R,A),
        asserta(have_arity(R,Context,A)),!.
get_arity_fast(Context,R,A):-
        mooCache(R,Cons, _, _, _, Context, Ctx, Explaination),
        functor(Cons,R,A),
        asserta(have_arity(R,Context,A)),!.
get_arity_fast(Context,R,A):-
        mooCache(valence, _, valence(R,A), Vars, ContextName, Context, Tracking, User, Status),
        asserta(have_arity(R,Context,A)),!.
get_arity_fast(Context,R,2).


% ensureMooContext
% make_dead
% sync_memory

% should_be_loaded


%% :-include('moo_header.pl').

activate_context(KnowledgeBase:Context):-
                ensureMooContext(KnowledgeBase,Context).

getDefaultImageFilepath(X):-
        'LOGIC_ENGINE_RT'(Local),concat_atom([Local,'/','moo_image.data'],X).


save_ado_cache:-saveMooCache.
                                                                                                                         
                                                                                                                         
saveMooCache:-
                save_can_to_file(Context,Handle),close(Handle),
                retractall(save_can_to_file(Context,Handle)),
                getDefaultImageFilepath(IF),
                [IF],!.

saveMooCache:-
        ensure_all_compiled,
        get_time(T),convert_time(T,String),
        remove_all_but_logOnFailure_chars(String,FileName),
        %  concat_atom(['cp -f moo_image.P "',FileName,'.persist.P" '],ShellCmd),
        %ignore(shell(ShellCmd)),
        %sendNote(debug,contentManager,'Saving ADO Cache Was Succesfull',ShellCmd),
        getDefaultImageFilepath(IF),
        tell(IF),
        op(0,xfy,'=>'),
        %op(0,xfx,#),
        %op(0,xfx,'#'),
        %op(0,xfx,'@'),
        op(0,fy,not),    % negation
        op(0,xfy,and),   % conjunction
        op(0,xfy,or),   % disjunction
        %op(0,xfy,:),
        op(0,xfx, 'equal' ),
        op(0,xfx,'<='),
        op(0,xfx,'if'),
        op(0,xfy,'=>'),
        op(0,fy,known),  % Found in Model
        op(0,fy,consistent),  % Not In Model
        op(0,fy,after),  % Next time
        op(0,fy,then),  % Next time
        op(0,xfy,=>),  % implication
        op(0,xfy,<=>), % equivalence
        op(0,fy,always),  % Necessity, Always
        op(0,fy,possible),  % Possibly, Eventually
        op(0,fy,necessary),  % Necessity
        writeFmt('
:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).
%:-set_prolog_flag(double_quotes,string).
:-index(mooCache(1)).
:-index(mooCache(1,1)).
:-index(mooCache(1,1,1)).
:-index(mooCache(1,1,1,1)).
:-index(mooCache(1,1,1,1,0)).
:-index(mooCache(1,0,1,1,1,0)).
:-index(mooCache(1,1,0,0,1,1,0,0,0)).
:-dynamic(mooCache/1).
:-dynamic(mooCache/2).
:-dynamic(mooCache/3).
:-dynamic(mooCache/4).
:-dynamic(mooCache/5).
:-dynamic(mooCache/6).
:-dynamic(mooCache/9).

',[]),
        listing(mooCache),
        told,
/*
        retractall(mooCache(_)),
        retractall(mooCache(_,_)),
        retractall(mooCache(_,_,_)),
        retractall(mooCache(_,_,_,_)),
        retractall(mooCache(Literal,asserted,Context,surf(Context,TN,CLID,Vars))),  %Facts /5
        retractall(mooCache(Literal,deduced,Context,surf(Context,TN,CLID,Vars))),  %Facts /5
        retractall(mooCache(Literal,AnteLiteral,asserted,Context,surf(Context,TN,CLID,Vars))),         %Rules /6
        retractall(mooCache(Literal,AnteLiteral,deduced,Context,surf(Context,TN,CLID,Vars))),  %Rules /6
        retractall(mooCache(Surface,CLF,Flags,Vars,Context,TN,Maintainer,TMResult)),  %Surface /9
*/
        [IF],!,
        op(1000,xfy,'=>'),
        %op(500,xfx,'#'),
        %op(500,xfx,'@'),
        op(400,fy,not),    % negation
        op(500,xfy,and),   % conjunction
        op(600,xfy,or),   % disjunction
        %op(500,xfy,':'),
        op(0,xfx, 'equal' ),
        op(900,xfx,'<='),
        op(900,xfx,'if'),
        op(1000,xfy,'=>'),
        op(400,fy,known),  % Found in Model
        op(400,fy,consistent),  % Not In Model
        op(400,fy,after),  % Next time
        op(400,fy,then),  % Next time
        op(650,xfy,=>),  % implication
        op(700,xfy,<=>), % equivalence
        op(400,fy,always),  % Necessity, Always
        op(400,fy,possible),  % Possibly, Eventually
        op(400,fy,necessary).  % Necessity

save_each_theory([]).
save_each_theory([H|T]):-
        save_the_theory(H),!,
        save_each_theory(T),!.

save_the_theory(H):-!.
save_the_theory(H):-
        concat_atom(['moo_theoryimage_',H,'.pl'],FileName),
        safe_file_open(FileName,'w',OUTPUT),
%       writeFmt(OUTPUT,':-include(\'moo_header.P\').\n',[]),
        writeFmt(OUTPUT,':-index(mooCache(1 ,0,1, 0,0,0, 0,0, 1)).\n',[]),
        writeFmt(OUTPUT,'% ~w for ~w.\n',[FileName,H]),
        get_time(Time),convert_time(Time,String),
        writeFmt(OUTPUT,'% Created at ~w.\n',[String]),
        ignore(write_the_theory_now(OUTPUT,H)),
        writeFmt(OUTPUT,':-catch([moo_eval],_,true).\n',[]),
        close(OUTPUT).


write_the_theory_now(OUTPUT,KnowledgeBase):-
        mooCache(PredR,wfs,WFS,Prolog,KnowledgeBase,Context,AssertionID,Creator,on),
        writeFmt(OUTPUT,'~q.\n',[Prolog]),
        fail.
write_the_theory_now(OUTPUT,KnowledgeBase):-
        get_time(Time),convert_time(Time,String),
        writeFmt(OUTPUT,'% Finished at ~w.\n',[String]).


remove_all_but_logOnFailure_chars(String,FileName):-
        atom_codes(String,Codes),
        subtract(Codes,[32,58],CCodes),
        atom_codes(FileName,CCodes).

:-dynamic(is_up_to_date/2).

ensureMooContext(KnowledgeBase,Context):-
        is_up_to_date(KnowledgeBase,Context),!.

ensureMooContext(KnowledgeBase,Context):-
        asserta(is_up_to_date(KnowledgeBase,Context)),!.

%       concat_atom(['moo_theoryimage_',KnowledgeBase,'.pl'],FileName),
 %       ensure_loaded(FileName).

show_active_memory:-!.
show_active_memory:-listing('in-active-memory').





save_each_clause_in_buffer(KnowledgeBase,Context,(PRO,LOG)):-!,
                save_each_clause_in_buffer(KnowledgeBase,Context,PRO),
                save_each_clause_in_buffer(KnowledgeBase,Context,LOG).

save_each_clause_in_buffer(KnowledgeBase,Context,PROLOG):-
                not(not((numbervars(((KnowledgeBase,Context,PROLOG)),'$VAR',0,_),assert_if_new(storage_buffer(KnowledgeBase,Context,PROLOG))))).

assert_if_new(X):-X,!.
assert_if_new(X):-!,assert(X).

% ===================================================================
%  RESETING WORKING MEMORY
% ===================================================================

clear_moo_memory:-
                  sendNote(extreme_debug,constentManger,'Rebuilding working memory',' '),
                  clear_tq_db,!.

clear_tq_db:-
        mooCache(PredR,Form,USurface,UVars,Context,TN,Maintainer,Result),
        TN>20000,retractall(mooCache(PredR,_,_,_,_,_,TN,_,_)),fail.
clear_tq_db:-
        mooCache(PredR,Form,_,_,Context,surf(_,TN)),
        TN>20000,retractall(mooCache(PredR,Form,_,_,Context,surf(_,TN))),fail.
clear_tq_db:-
        mooCache(PredR,Form,_,_,_,Context,(surf(_,TN)*_)),
        TN>20000,retractall(mooCache(PredR,Form,_,_,_,Context,(surf(_,TN)*_))),fail.

clear_tq_db:-!.


/*
clear_tq_db:-
                        clear_tq_db(['K','L','M','N','O','P','Q','R','S']),
                  retractall(mooCache(PredR,_,_,_,_,_,_)),
                  retractall('in-active-memory'(_,_)),
                  clear_tq_db('instance',12),
                  clear_tq_db('subclass',12),
                  clear_tq_db('subrelation',12),
                  clear_tq_db('range',12),
                  clear_tq_db('domain',12),
                  clear_tq_db('domainSubclass',12),
                  clear_tq_db('RefexivePredicateTo',12),
                  clear_tq_db('equal',12).
*/

clear_tq_db([]).
clear_tq_db([A|As]):-clear_tq_db(A,22),!,clear_tq_db(As).
clear_tq_db(F,N):-atom_concat('int_',F,IRF),clear_tq_db1(IRF,N),!,atom_concat('int_~',F,NIRF),clear_tq_db1(NIRF,N),!,atom_concat('~',F,NRF),clear_tq_db1(NRF,N),!,clear_tq_db1(F,N).

clear_tq_db1(_F,0):-!.
clear_tq_db1(F,A):-functor(Term,F,A),catch(retractall(Term),_,true),AA is A -1,clear_tq_db1(F,AA).


% ===================================================================
%  SETTING WORKING MEMORY
% ===================================================================

establish_startup_state:-
         catch(
         (
         sendNote(debug,contentManager,'Moo Context startup states being loaded',' '),
         %adoConnect,
         %sync_ado_cache,
         clear_moo_memory
         ),E,sendNote(debug,contentManager,'Moo Context startup states insufficient for full support',E));sendNote(debug,contentManager,'Moo Context startup states insufficient for full support',E).

:-dynamic('in-active-memory'/2).


set_default_theory(X):-retractall(getMooOption(opt_theory,_)),assert(getMooOption(opt_theory,X)).
set_default_assertion_context(X):-retractall(get_default_assertion_context(_)),assert(get_default_assertion_context(X)).
set_default_request_context(X):-retractall(get_default_request_context(_)),assert(get_default_request_context(X)).


get_default_request_context('GlobalContext').
get_default_assertion_context('GlobalContext').

get_axioms_path(Path):-get_storage_file("moo_builtins.kif",Path).


%               actx_invoke_object(IPRset,'MoveNext',[],_).


%=================================================================
%  CONTEXT SYNC  PROCESSING
%=================================================================
/*

Defining Contexts

The Moo LE must record forall information required to make fully persistent the side-effects specified for these calls. Refer to the description under "startup_status/1," above, for details of the requirements for persistence.

These calls are used to create, delete and manipulate the Context definitions known within a given Moo LE:

- define_theory(Context_Designator)
  Define a new Context based on the specified Context_Designator, the theory_name must not be the name of a Context already known to the receiving LE.

- rename_theory(Context_Designator)
  Change the theory_name associated with the theory_source in the Context_Designator, which must be known to the receiving LE. [ TBD: Multiple Contexts using equal source file? ]

- reconstitute_theory(Context_Designator)
  Change the theory_source associated with the theory_name in the Context_Designator, which must be known to the receiving LE.

- delete_theory(Context_Designator)
  Remove and forget everything about the specified Context (i.e., perform the "FG" action and then forget any internal and / or persistent descriptor for the specified Context). [ TBD: "If the specified Context is in the startup list, should it be removed from there as well" ?? Probably "yes." ]


Context_Designator
Where I use the term "Context_Designator" I mean a Prolog term with one of the following structures:

        theory(theory_name, theory_source)
        theory(theory_name, Context_SOURCE)
        theory(Context_NAME, theory_source)
        theory(theory_name)

        Other forms may be added as needed.


Examples:
        theory('PrologMOO', file('/MooL/SUO/PrologMOO.can')
        theory('PrologMOO', url('http://jordan/stheory/exported/merge.can')

        % Acceptable If the location is known:
        theory('PrologMOO', _)

        % Also acceptable if the location is known:
        theory('PrologMOO')

        Future forms may include:

        theory('PrologMOO', ftp('jordan', 'anonymous', 'rs@cris.com', '/theorys/PrologMOO.can'))
        theory('PrologMOO', https('jordan', 8080, 'mysession', '/theorys/PrologMOO.can'))


theory_source is one of:

        file(local_file_name)
        url(file_url)
        url(http_url)

        (Other forms may be added as needed.)

Note: file_url and http_url are TBD and their implementation is yet to be scheduled.


Startup

When a Moo LE starts up it first establishes or initializes is basic functions. Once that initialization completes successfully, it must next re-establish the client-specified initial state.

Current state initialization centers on Context pre-loading and is described under "startup_status/1," above.

Since startup actions occur apart from any end-user action and thus have no "client" to which to return feedback, status or other diagnostics, the Moo LE must write to its log any noteworthy or erroneous events that occur while it performs its startup actions.


*/
% Defining and renaming Contexts

writeXMLTagged(moo:message,Goal):-
      write_response_begin,
      ignore(Goal),
      write_response_end.

define_theory(Var):-var(Var),!,
      verify_status(X),!,
      member((Var=_),X).

define_theory(theory(Name,Location)):-
         writeXMLTagged(moo:message,theory_startup_start(theory(Name,Location)=void)).

define_theory(_):-
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for define_theory/1 is define_theory(theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')).'),_)),
      write_response_end.

rename_theory(Var):-var(Var),!,
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for rename_theory/1 is rename_theory(theory(''NewName'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')).'),_)),
      write_response_end.

rename_theory(theory(Name,Location)):-
         writeXMLTagged(moo:message,(
                  sendNote(debug,logicEngine,'Debug Info',[rename_theory,theory(Name,Location)]),
                  retractall(theory_loaded(N)),
                  define_theory_proc(theory(Name,Location))
           )).

rename_theory(_):-
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for rename_theory/1 is rename_theory(theory(''NewName'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')).'),_)),
      write_response_end.

reconstitute_theory(Var):-var(Var),!,
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for reconstitute_theory/1 is reconstitute_theory(theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/the/new/path_to.can'')).'),_)),
      write_response_end.

reconstitute_theory(theory(Name,Location)):-
         writeXMLTagged(moo:message,(
               sendNote(debug,logicEngine,'Debug Info',[reconstitute_theory,theory(Name,Location)]),
               retractall(theory_loaded(Name)),
               define_theory_proc(theory(Name,Location))
               )).

reconstitute_theory(_):-
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for reconstitute_theory/1 is reconstitute_theory(theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/the/new/path_to.can'')).'),_)),
      write_response_end.

delete_theory(Var):-var(Var),!,
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for delete_theory/1 is delete_theory(theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')).'),_)),
      write_response_end.

delete_theory(theory(Name,Location)) :-theory_startup_status(theory(Name,Location)=unknown).

delete_theory(_):-
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for delete_theory/1 is delete_theory(theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')).'),_)),
      write_response_end.

delete_theory_proc(theory(Name,Location)) :-
         sendNote(debug,contentManager,'theory deletions',[deleting_theory,theory(Name,Location)]),
         retractall(theory_make_status_start(theory(Name,_)=_)),
         save_theory_statuses.


startup_status(ContextS_List):-
      write_response_begin,
      ignore(writeIfOption(disp_error,'predicate not found'('server_startup_status(Context_List) will is establish startup statuses and    theory_status( theory(Name,_)=Status ) will change a single Context status.'),_)),
      write_response_end.



% ===================================================================================================
% Status API
% These calls allow clients to ascertain Context load and currency status and to effect the loading and unloading of Contexts within an LE.
% ===================================================================================================

% ===================================================================================================
%  verify_status(ContextS_List)  Succeeds if every Context_Status in ContextS_List unifies with the current status for the WFS whose name equal the theory_name in that Context_Status.
% ===================================================================================================
verify_status(ContextS_List):-var(ContextS_List),!,   write('<LE></LE>'),whole_status_set(ContextS_List).

verify_status([theory(Context, Path) = Context_STATUS]):-
            var(Context),var(Path),var(Context_STATUS),          !,
            write('<LE></LE>'),whole_status_set(ContextS_List),
            member((theory(Context, Path) = Context_STATUS),ContextS_List).


whole_status_set(ContextS_List):-findall( Context=Status,theory_status(Context,Status),ContextS_List),!.

verify_status(ContextS_List):- write('<LE></LE>'),
                     whole_status_set(ContextS_ListO),
                     member(X,ContextS_List),member(X,ContextS_ListO).

verify_status_proc(ContextS_List):-nonvar(ContextS_List),

                                                setof( (theory(Name,Location)=Status),
                                                                  ((
                                                                   (member(theory(Name,Location)=_,ContextS_List);member(theory(Name,Location),ContextS_List)),
                                                                   theory_status(theory(Name,Location),Status)
                                                                    )),
                                                   ContextS_List).

% ===================================================================================================
% verify_status(ContextS_List, Status_Return)  Performs the actions of verify_status/1 and bind Status_Return to a list of actual status designators corresponding to the Context_Designators in the request list.
%  A Context_Status bearing a theory_name that is not known to the responding Moo LE will equal only with the status code "unknown" (or a variable).
% ===================================================================================================

verify_status(ContextS_List,OUT):-nonvar(ContextS_List),write('<LE>'),
                                                ignore(setof( (theory(Name,Location)=Status),
                                                                  ((
                                                                   (member(theory(Name,Location)=_,ContextS_List);member(theory(Name,Location),ContextS_List)),
                                                                   theory_status(theory(Name,Location),Status)
                                                                    ))),
                                                   OUT),write('</LE>').

% ===================================================================================================
% establish_status(ContextS_List)  Succeed if for every Context_Status in ContextS_List, the Context with the specified theory_name either already has the specified status or can be made to have that state by successfully carrying out the state transition action given in the table above.
% ===================================================================================================

establish_status(ContextS_List):-!,
                  writeXMLTagged(moo:message,establish_status_0(ContextS_List)).

establish_status_0([]):-!.
establish_status_0([First|REST]):-!,
      establish_status_1(First),!,
      establish_status_0(REST),!.
establish_status_0(theory(Name,Location)=RequestStatus):- !,
            establish_status_1(theory(Name,Location)=RequestStatus),!.

establish_status_1(theory(Name,Location)=S):-nonvar(S),S=unknown,!,
                  delete_theory_proc(theory(Name,Location)).

establish_status_1(theory(Name,Location)=RequestStatus):-
                  verify_status_proc([theory(Name,Location)=CurrentStatus]),!,
                  sendNote(debug,contentManager,'theory status establish',[establish,RequestStatus,from,CurrentStatus,theory(Name,Location)]),
                  ignore(make_status(theory(Name,Location),CurrentStatus,RequestStatus)),!.

% ===================================================================================================
% elevate_status(ContextS_List)  Succeed if for every Context_Status in ContextS_List, the Context with the specified theory_name either already has the specified status or can be elevated to that state by successfully carrying out the state transition action given in the table above never reducing.
% ===================================================================================================

elevate_status(ContextS_List):-!,
                  write('<LE>'),
                  ignore(elevate_status_0(ContextS_List)),!,
                 write('</LE>'),!.

elevate_status_0([]):-!.
elevate_status_0([First|REST]):-!,
      elevate_status_1(First),!,
      elevate_status_0(REST),!.
elevate_status_0(theory(Name,Location)=RequestStatus):- !,
            elevate_status_1(theory(Name,Location)=RequestStatus),!.

elevate_status_1(theory(Name,Location)=RequestStatus):-
                  verify_status_proc([theory(Name,Location)=CurrentStatus]),!,
                  sendNote(debug,contentManager,'theory status elevate',[elevate,RequestStatus,from,CurrentStatus,theory(Name,Location)]),
                  elev_status(theory(Name,Location),CurrentStatus,RequestStatus),!.

/*

establish_status([theory('PrologMOO',_) = current]).

- establish_status(ContextS_List, Status_Return)
  Perform the actions of establish_status/1 and bind Status_Return to a list of actual status designators corresponding to the Context_Designators in the request list.

Status Transition

The following tables indicates the actions to take to effect a transition from the status in the left-hand column to the status shown in the column headers along the top. The "file" is whatever external forms the Moo LE happens to be using currently (i.e., it's an unspecified external form meant to be used to facilitate Context loading by comparison to recompilation).

Current Desired Status:
Status          void    avail   old     stale   vol     current
_____           _____   _____   _____   _____   _____   _____
void             | --    CF      XX      XX      LF      CC
avail            | DS    --      XX      XX      DF      LF
old              | DS    SF      --      CF ?    CM      CC
stale           | DS    UL      DF      --      CM+DF   RF
volatile        | UL    SF+UL CM    SF+UL   --      SF
current        | FG    UL      XX      XX      DF      --

Actions:
        CF      Compile to File
        CM      Compile to Memory
        CC      Compile to Current (file and memory)
        LF      Load File into Memory
        RF      Reload File
        SF      Save Memory to File
        UL      Unload from Memory
        DF      Remove File
        DS      Dispose(Unload from Memory and Remove File)
        XX      Reject / fail
        --      Do Nothing (succeed w/o side-effects)


*/


:-dynamic(moo_file_loaded/1).

theory_status(theory(Name,Location),Status):- theory_make_status_start(theory(Name,Location)=_), lookup_theory_status(theory(Name,Location),Status).

lookup_theory_status(X,Y):- lookup_theory_status_array(X,Y),!.


lookup_theory_status_array(theory(Name,Location),void):- not((moo_file_loaded(p(Name)))),not(theory_p_file_current(Name)).
lookup_theory_status_array(theory(Name,Location),available):- not(moo_file_loaded(p(Name))),theory_p_file_current(Name).
lookup_theory_status_array(theory(Name,Location),old):- (moo_file_loaded(p(Name))),theory_modified(Name),not(theory_p_file_current(Name)).
lookup_theory_status_array(theory(Name,Location),stale):- (moo_file_loaded(p(Name))),theory_modified(Name),(theory_p_file_current(Name)). %should be stale
lookup_theory_status_array(theory(Name,Location),volatile):- (moo_file_loaded(p(Name))),not(theory_modified(Name)),not(theory_p_file_current(Name)).
lookup_theory_status_array(theory(Name,Location),current):- (moo_file_loaded(p(Name))),not(theory_modified(Name)),(theory_p_file_current(Name)).
lookup_theory_status_array(theory(Name,Location),unknown):-!,nonvar(Name),nonvar(Location).

:-dynamic(theory_loaded/1).
:-dynamic(theory_is_modified/1).

theory_modified(Name):-theory_is_modified(Name).

theory_p_file_current(Name):-safe_theory_info_db(Name,Location,_WFS,PFILE),file_newer(PFILE,Location).


/*
Status Codes For Moo LE-hosted WFSs

Where I use the term "StatusCode" I mean one of the atoms in the right-most column of this table:

Loaded  Memory    File *                 State
           Current    Current                Name

0               0               0               void
0               0               1               available
0               1               0               n/a
0               1               1               n/a
1               0               0               old
1               0               1               stale
1               1               0               volatile
1               1               1               current
-               -               -               unknown

* A missing file is deemed not current

*/

% theory_startup_status(theory('PrologMOO', '/cygdrive/c/Moo/SUO/PrologMOO.can')=available)

make_status(theory(Name,Location),_,unknown):-!,
                           sendNote(debug,contentManager,Name,[making,unknown,from,Location,'(=> deletion)']),
                           delete_theory_proc(theory(Name,Location)),!.

make_status(theory(Name,Location),_,available):-!,
                           sendNote(debug,contentManager,Name,[making,available,from,Location,'(compiled but not loaded)']),
                           source_to_p_file(Name),!.

make_status(theory(Name,Location),_,current):-!,
                           sendNote(debug,contentManager,Name,[making,current,from,Location]),
                           load_theory_file(Name),!.

elev_status(theory(Name,Location),_,available):-!,
                           sendNote(debug,contentManager,Name,[elevating,to,available,from,Location]),
                           source_to_p_file(Name),!.
elev_status(theory(Name,Location),_,current):-!,
                           sendNote(debug,contentManager,Name,[elevating,to,current,from,Location]),
                           load_theory_file(Name),!.

elev_status(theory(Name,Location),_,_):-!,
                           sendNote(debug,contentManager,Name,[elevating,has,no,effect]).

/*
  theory_startup_status(ContextS_List)
  The Moo LE that executes this call should record the specified Context status list as the status that the LE should attempt to establish upon startup. The specified ContextS_List must be fully ground and the status indicators should be permissible as target status codes. A Context_Designator with an unknown theory_name is only acceptable if its status indicator is "unknown." [ Is there any point in that special case? ]
  The information recorded to implement this call must be stored in a manner that is persistent in the face of forall known shutdown and restart mechanisms, whether controlled or uncontrolled (Prolog crash, system crash, power failure) and whether abortive (e.g. SIGTERM or SIGKILL) or cooperative (shutdown request).
  The means by which Moo LE achieves this persistence is unspecified (fully at its discretion).
  Succeeds if and only if the startup status designators are successfully recorded.

*/
theory_startup_status(Var):- var(Var),
            findall(Context,theory_make_status_start(Context),List),!,
            member(Var,List).

theory_startup_status(ContextDesignator=Status):-var(Status),!,theory_make_status_start(ContextDesignator=Status).
theory_startup_status(ContextDesignator=Status):-
      write_response_begin,
               theory_startup_status_0(ContextDesignator=Status),
               save_theory_statuses,
      write_response_end.

theory_startup_status(_):-
       writeXMLTagged(moo:message,writeIfOption(disp_error,'syntax error'('writeFmt for theory_startup_status/1 is theory_startup_status(theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')=current).'),_)).

theory_startup_status_0(ContextDesignator=unknown):-nonvar(ContextDesignator),!,delete_theory_proc(ContextDesignator).
theory_startup_status_0(ContextDesignator=Status):-nonvar(Status),nonvar(ContextDesignator),!,
               sendNote(debug,logicEngine,'Debug Info','Content Management'(set_theory_startup_status(ContextDesignator=Status))),
               nonvar(Status),
               retractall(theory_make_status_start(ContextDesignator=_)),
               assert(theory_make_status_start(ContextDesignator=Status)),
               ignore(elev_status(ContextDesignator,_,Status)).



% ===================================================================================================
%  verify_startup_status(ContextS_List)  Succeeds if every Context_Status in ContextS_List unifies with the current status for the WFS whose name equal the theory_name in that Context_Status.
% ===================================================================================================

verify_startup_status(Var):-var(Var),!,whole_startup_status_set(ContextS_List).

verify_startup_status([theory(Context, Path) = Context_STATUS]):-
            var(Context),var(Path),var(Context_STATUS),          !,
            write('<LE></LE>'),whole_startup_status_set(ContextS_List),
            member((theory(Context, Path) = Context_STATUS),ContextS_List).

verify_startup_status(ContextS_List):-write('<LE></LE>'),nonvar(ContextS_List),

                                                setof( (theory(Name,Location)=Status),
                                                                  ((
                                                                   (member(theory(Name,Location)=_,ContextS_List);member(theory(Name,Location),ContextS_List)),
                                                                   theory_make_status_start(theory(Name,Location)=Status)
                                                                    )),
                                                   ContextS_List).



% ===================================================================================================
%  server_startup_status(ContextS_List)  Succeeds if every Context_Status in ContextS_List unifies with the current status for the WFS whose name equal the theory_name in that Context_Status.
%  The Moo LE that executes this call should record the specified Context status list as the status that the LE should attempt to establish upon startup. The specified ContextS_List must be fully ground and the status indicators should be permissible as target status codes. A Context_Designator with an unknown theory_name is only acceptable if its status indicator is "unknown." [ Is there any point in that special case? ]
%  The information recorded to implement this call must be stored in a manner that is persistent in the face of forall known shutdown and restart mechanisms, whether controlled or uncontrolled (Prolog crash, system crash, power failure) and whether abortive (e.g. SIGTERM or SIGKILL) or cooperative (shutdown request).
%  The means by which Moo LE achieves this persistence is unspecified (fully at its discretion).
%  Succeeds if and only if the startup status designators are successfully recorded.
% ===================================================================================================
server_startup_status(ContextS_List):-var(ContextS_List),!,whole_startup_status_set(ContextS_List).

server_startup_status([theory(Context, Path) = Context_STATUS]):-
            var(Context),var(Path),var(Context_STATUS),          !,
            write('<LE></LE>'),whole_startup_status_set(ContextS_List),
            member((theory(Context, Path) = Context_STATUS),ContextS_List).

whole_startup_status_set(ContextS_List):-findall(Context,theory_make_status_start(Context),ContextS_List).

server_startup_status(LIST):-
      findall((theory(X,Y)=Status),member((theory(X,Y)=Status),LIST),Look),
      Look=LIST,!,
      write_response_begin,
         server_startup_status_0(LIST),
         save_theory_statuses,
      write_response_end.

server_startup_status(_):-!,
      write_response_begin,
      ignore(writeIfOption(disp_error,'syntax error'('writeFmt for server_startup_status/1 is server_startup_status([theory(''PrologMOOAddition'', ''/cygdrive/c/Moo/SUO/PrologMOOAddition.can'')=current,theory(''PrologMOO'', ''/cygdrive/c/Moo/SUO/PrologMOO.can'')=unknown]).'),_)),
      write_response_end.


server_startup_status_0([]):-!.
server_startup_status_0([Head|Tail]):-!,
         theory_startup_status_0(Head),
         server_startup_status_0(Tail).

establish_each([]):-!.
establish_each([ContextDesignator=Status|REST]):-!,once(make_status(ContextDesignator,_,Status)),
              establish_each(REST).



invokeTheoryLoading(Context):-isTheoryLoading(Context,Status),!.
invokeTheoryLoading(Context):-
        mooProcessCreate(loadContextfromSource(Context,GlobalContext),loadContextfromSource(Context,GlobalContext),ID,[detatched(false)]),
        assert(isMooProcess(ID,loadContextfromSource(Context,GlobalContext))).

loadContextfromSource(Context,Ctx):-
                getFilenameOfContextSource(Context,Filename),!,
                once(invokeKifFileChecking(Context,Filename,Ctx,User)).

getFilenameOfContextSource(Context,Filename):-
                fmtString(FileChars,'../moo-rt/work/~w.can',[Context]),!,
                string_to_atom(FileChars,Filename),!.



% ===========================================================
% Test Knowledge Base File (Currently only Test until browser integration)
% ===========================================================
loadKnowledgebaseSourcefile(Name,Filename):-  make,
                catch(atom_codes(Name,Codes),_,Codes=[]),
                length(Codes,L),L<3,
                file_base_name(Filename,BaseName),
                file_name_extension(Context,Extension,BaseName),
                writeFmt('<B color=red>No name was given, so a Knowledge Base called <font color=green>~w</font> is being created.<p>',[Context]),
                load_kif_to_theory_ctx(Context,Filename,'GlobalContext','MooWeb').

loadKnowledgebaseSourcefile(Context,Filename):-!,
                (unsetMooOption(opt_surface_check=_)),
                (setMooOption(opt_surface_check=trusted)),
                idGen(TN1),
                idGen(TN2),
                idGen(TN3),
                retractall(mooCache(PredR,_,_,Context,_,_,_,_)),
                assertaClean(mooCache(PredR,surface,'instance'(Context,'KnowledgeBase'),'$VAR'(0),'MooKernel','GlobalContext',TN1,'WebUser',gaf)),
                assertaClean(mooCache(PredR,surface,'instance'('GlobalContext','Context'),'$VAR'(0),Context,'GlobalContext',TN2,'WebUser',gaf)),
                assertaClean(mooCache(PredR,surface,'sourcefile-of'(Context,Filename),'$VAR'(0),'MooKernel','GlobalContext',TN3,'WebUser',gaf)),
                invokeKifFileChecking(Context,Filename,'GlobalContext','MooWeb').



invokeKifFileChecking(Context,Filename,Ctx,User):-!, make,tell(user_error),
        ignore(User='MooWeb'),
         get_default_assertion_context(DCtx), ignore((Ctx=DCtx)),
         ensureMooOption(opt_theory,_,Context),
         retractall(mooCache(PredR,_,_,_,Context,_,_,_)),!,
         saveMooCache,
         writeFmt(user_error,'Reading In ~w to ~w with a default context of ~w \n',[Filename,Context,Ctx]),
         flag('Axioms Compiled',_,0),
         safe_file_open(Filename,'r',INPUT),!,
         writeFmt(user_error,'~q\n',[safe_file_open(Filename,'r',INPUT)]),
         repeat,
                  compile_each_line(INPUT),
        at_end_of_stream(INPUT),
        close(INPUT),
        flag('Axioms Compiled',AX,AX),
         writeFmt('\n% Compiled ~w axioms.\n',[AX]),
         %(test_syntax_save_theory_ctx(Context,Filename)),
         ignore(retract(findings(CPU,RESULT))) ,
         ignore(findall(T,retract(title(T)),Title)).

compile_each_line(Stream):-
                sleep(1),
                once(readKIF_priv(Stream,RRAW)),
                once(getCleanCharsWhitespaceProper(RRAW,Trimed)),
                once(ltrim(Trimed,L_trimmed)),
                        catch(writeFmt(user_error,'"~s" \n',[L_trimmed]),_,true).

/*
                        source_from_stream(INPUT,Trimed,SOURCEFORM,Vars),nonvar(Trimed),
                        catch(writeFmt(user_error,'~s \n',[Trimed]),_,true),
                        rememberAxioms(Context,SOURCEFORM,Vars,User),!.

*/






%ttheory:-loadContextfromSource('PrologMOO','GlobalContext').
/*
skipKIFChar(Stream):-stream_property(Stream,position('$stream_position'(CharIndex, LineNo, LinePos)),
        NewI is CharIndex+1,
*/
/*
(pnf (documentation instance "An object is an &%instance a &%Class if

it is a member of that &%Class.  An individual may be an instance of many

classes, some of which may be subclasses of others.  Thus, there is no

assumption in the meaning of &%instance about specificity or uniqueness.")
 GlobalContext T-4)
(pnf (instance subclass PartialOrderingRelation)
 GlobalContext T-5)

*/




rememberAxioms(Context,file_comment(_),Vars,User):-!.
rememberAxioms(Context,surf,Vars,User):-!.
rememberAxioms(Context,SOURCEFORM,Vars,User):-!,
                global_increment('Axioms Compiled'),
                flag('Axioms Compiled',AssertionID,AssertionID),
                idGen(INTID),
                assert(mooCache(PredR,surface,SOURCEFORM,Vars,Context,AssertionID,User,uncanonicalized)).

test_syntax_save_theory_ctx(KnowledgeBase,Context,Filename):-
         safe_file_open(Filename,'w',OUTPUT),
         test_syntax_write_theory_ctx(KnowledgeBase,Context,OUTPUT),
         close(OUTPUT).

test_syntax_save_theory_ctx:-test_syntax_save_theory_ctx('PrologMOO','GlobalContext','C:/mool/SUO/MFixed.txt').


test_syntax_write_theory_ctx(KnowledgeBase,Context,OUTPUT):-
                mooCache(PredR,surface,Source,Vars,KnowledgeBase,Context,AssertionID,Creator,Status),
                once(catch((toMarkUp(kif,Source,Vars,OutChars),writeFmt(OUTPUT,'~w\n',[OutChars])),_,true)),
                fail.

test_syntax_write_theory_ctx(KnowledgeBase,Context,OUTPUT):-!,saveMooCache.




%:-module(moo_fileutils,[]).


% :-include('moo_header.pl').

% ===========================================================
% Context From File
% ===========================================================
ctxFromFile(BadCtxName,Filename,Context):-
                catch(atom_codes(BadCtxName,Codes),_,Codes=[]),
                length(Codes,L),L<3,
                file_base_name(Filename,BaseCtxName),
                file_name_extension(CtxName,Extension,BaseCtxName),
                writeFmt('<B color=red>No name was given, so a Context called <font color=green>~w</font> is being created.<p>',[CtxName]),
                load_kif_to_theory_ctx(CtxName,Filename,'GlobalContext','MooWeb').

ctxFromFile(CtxName,Filename,Context):-!,
                idGen(TN1),
                idGen(TN3),
                assertaClean(mooCache(PredR,surface,'instance'(CtxName,'Context'),'$VAR'(0),Context,'GlobalContext',TN1,'WebUser',on)),
                assertaClean(mooCache(PredR,surface,'sourcefile'(CtxName,Filename),'$VAR'(0),Context,'GlobalContext',TN3,'WebUser',on)),
                load_kif_to_theory_ctx(Context,Filename,CtxName,'MooWeb').




load_kif_to_theory_ctx(Context,FileName,Ctx,User):-!,
        ignore(User='MooWeb'),
        assert(telling_file),
%%         atom_concat(FileName,'.compiled.pl',DBG),
%%         tell(DBG),
         get_default_assertion_context(DCtx), !,ignore((Ctx=DCtx)),!,
         getMooOption(opt_theory,DContext), !,  ignore((Context=DContext)),!,

         writeFmt('Reading In ~w to ~w with a default context of ~w <p>',[FileName,Context,Ctx]),nl,
         flag('Axioms Compiled',_,0),
         safe_file_open(FileName,'r',INPUT),
         repeat,   %true,
                load_kif_to_theory_ctx_display(Context,User,INPUT),
                close(INPUT),
                flag('Axioms Compiled',AX,AX),
         writeFmt('\n% Compiled ~w axioms.\n',[AX]),
         ignore(retract(findings(CPU,RESULT))) ,
         ignore(findall(T,retract(title(T)),Title)),saveMooCache.



ado_to_prolog(FileName):-
        tell(FileName),
        mooCache(Pred, Head, Type, Logic,Context, Ctx, Explaination),
        w_ado_cache(Pred, Head, Type, Logic,Context, Ctx, Explaination),
        fail.

ado_to_prolog(FileName):-
        mooCache(Pred, Head, Cond,Type, Logic,Context, Ctx, Explaination),
        w_ado_cache(Pred, Head, Cond,Type, Logic,Context, Ctx, Explaination),
        fail.
ado_to_prolog(FileName):-told.

atom_to_prolog(FileName):-
        tell(FileName),
        atom_to_prolog(FileName),
        told.


atom_to_prolog:-
        mooCache(Pred, Head, Type, Logic,Context, Ctx, Explaination),
        a_ado_cache(Pred, Head, Type, Logic,Context, Ctx, Explaination),
        fail.

atom_to_prolog:-
        mooCache(Pred, Head, Cond,Type, Logic,Context, Ctx, Explaination),
        a_ado_cache(Pred, entails(Head, Cond),Type, Logic,Context, Ctx, Explaination),
        fail.

atom_to_prolog:-
        mooCache(atom(A)),
        format(' ~q ; ',[A]),fail.

atom_to_prolog.

a_ado_cache(argOf, Head, Type, true,Context, Ctx, Explaination):-!.
a_ado_cache(documentation, Head, Type, true,Context, Ctx, Explaination):-!.
a_ado_cache(Pred, FOO,Type, Logic,Context, Ctx, Explaination):-
        getConstants(atomic,FOO,List,_,_),
        assert_list(List).

assert_list([]):-!.
assert_list([A|L]):-!,
        assert_list_n(A),
        assert_list(L).


assert_list_n(A):-mooCache(atom(A)),!.
assert_list_n([]):-!.
assert_list_n('.'):-!.
assert_list_n(N):-number(N),!.
assert_list_n(A):-
        asserta(mooCache(atom(A))).





w_ado_cache(argOf, Head, Type, true,Context, Ctx, Explaination):-!.
w_ado_cache(documentation, Head, Type, true,Context, Ctx, Explaination):-!.

w_ado_cache(Pred, Head, Type, true,Context, Ctx, Explaination):-
        format('~q.~n',[Head]),!.
w_ado_cache(Pred, Head, Type, false,Context, Ctx, Explaination):-
        format('not_~q.~n',[Head]),!.
w_ado_cache(Pred, Head, Pre, Type, true,Context, Ctx, Explaination):-
        pre_to_b(Pre,B),
        format('~q:-~q.~n',[Head,B]),!.
w_ado_cache(Pred, Head, Pre, Type, false,Context, Ctx, Explaination):-
        pre_to_b(Pre,B),
        format('not_~q:-~q.~n',[Head,B]),!.

pre_to_b(B,var(B)):-isSlot(B),!.
pre_to_b(and(A,B),(AA,BB)):-!,pre_to_b(A,AA),pre_to_b(B,BB).
pre_to_b(not(B),BBO):-pre_to_b(B,BB),BB=..[F|A],atom_concat('not_',F,NF),BBO=..[NF|A].
pre_to_b(B,B).


load_kif_to_theory_ctx_display(Context,User,Stream):-at_end_of_stream(Stream),!.

load_kif_to_theory_ctx_display(Context,User,Stream):-
                      once((
                                source_from_stream(Stream,_,SOURCEFORM,Vars),
                                catch(
                                                (
                                                                        flag('Axioms Compiled',X,X+1),
                                                                        invokeInsert([trusted,nocanonicalize],surface,SOURCEFORM,Ctx,TN,Context,Vars,User)
                                                ),

                                        E,
                                        (line_count(Stream,Line),writeFmt('\nLine ~w  Uninterpretable "~q" (~q)\n',[Line,KIFSTERM,E]))
                                )
                      )),
                      fail.


% ===================================================================
%  Read Knowledge Representation File
% ===================================================================

% Example
lmerge:-tell_from_kif(forall,'c:/mooL/SUO/PrologMOO.can','PrologMOO','GlobalContext',Maintainer).

kif_file(File):-tell_from_kif(forall,File,File,'GlobalContext',Maintainer).

tell_from_kif(SourceFile):-!,tell_from_kif(forall,SourceFile,Context_Name,Ctx,SourceFile).

tell_from_kif(SourceFile,Context_Name):-!,tell_from_kif(forall,SourceFile,Context_Name,Ctx,SourceFile).

tell_from_kif(Driver,SourceFile,Context_Name,Ctx,Maintainer):-
            sendNote(debug,kifParser,['Loading Moo KIF/CAN file into ',Driver,' as',Context_Name,Ctx,from,SourceFile],' '),
            ignore(safe_theory_info_db(Context_Name,SourceFile,WFSFile,_)),
            ignore(Maintainer=SourceFile),
            safe_file_open(SourceFile,'r',INPUT),
            repeat,
               once((
                     once(readKIF(INPUT,CHARS)),
                     once(invokeInsert(Driver,chars,CHARS,Ctx,TN,Context_Name,Vars,Maintainer))
                     )),
            at_end_of_stream(INPUT),!,
            file_close(INPUT),
            garbage_collect,
            garbage_collect_atoms.

% ===================================================================
%  Read KIF File as Prolog
% ===================================================================


load_kif_as_prolog(SourceFile):-
         add_file_extension(".P",SourceFile,PLocation),
         file_newer(PLocation,SourceFile),!,
         sendNote(debug,kifParser,'Loading kif as if prolog.',[PLocation,from,SourceFile]),
         consult_as_dynamic(PLocation).


t6:-uaInsert("(pnx_nf (domain AssignmentFn 1 Function) GlobalContext T-536)").


load_kif_as_prolog(SourceFile):- !,
         add_file_extension(".P",SourceFile,PLocation),!,
         safe_file_open(SourceFile,'r',INPUT),
         safe_file_open(PLocation,'w',OUTPUT),
         sendNote(debug,kifParser,'Loading kif as if prolog.',[converting,SourceFile,to,PLocation]),
           repeat,
               once((once(readKIF(INPUT,Chars)),
                    %catch(writeFmt(OUTPUT,'\n% ~s  ',[Chars]),_,true),
                    tell_retract_parse_chars(Chars,PROLOG,_),
                     once((
                           PROLOG=comment(_)
                            ;
                          writeFmt(OUTPUT,'\n~q.\n',[PROLOG])
                            )))),
                     at_end_of_stream(INPUT), !,
            sendNote(debug,kifParser,'File Loaded',PLocation),
            file_close(OUTPUT),
            file_close(INPUT),
            consult_as_dynamic(PLocation).

% ===================================================================
%  Export Surface Forms as KIF (From a Context and Context)
% ===================================================================


export_kif_from_source(Context,DestFile):-
         export_kif_from_source(Context,DestFile,full_cmt).

export_kif_from_source(Context,DestFile):-
         export_kif_from_source(Context,DestFile,full_cmt).

export_kif_from_source(Context,DestFile,Fmt):-
         add_file_extension(".kif",DestFile,PLocation),
         safe_file_open(PLocation,'w',OUTPUT),
         sendNote(debug,kifParser,'Saving kif from Prolog.',[saving,to,PLocation]),
         export_kif_from_source_0(Fmt,Context,OUTPUT).

export_kif_from_source_0(Format,Context,OUTPUT):-
         get_store(forall,surface,(Surface:Vars),Context,TN,Maintainer),
         unnumbervars((Surface:Vars),(USurface:UVars)),
         toMarkUp(kif,USurface,UVars,Chars),
         ( Format=full_cmt -> writeFmt(OUTPUT,'\n; Context:~q  Ctx:~q  TN:~q  Auth:~q\n~s\n',[Context,TN,Maintainer,Chars]);
         ( Format=terse -> writeFmt(OUTPUT,'\n~s\n',[Chars]);
         ( Format=pnx_nf -> writeFmt(OUTPUT,'\n( pnx_nf ~s ~w ''~w'' )\n',[Chars,Ctx,TN])))),
         fail.

export_kif_from_source_0(Format,Context,OUTPUT):-!.

% ===================================================================


agent_load_kif_quiet(Filename,GlobalContext,User):-
        agent_load_kif_surface(Filename,Context,User,AX,quiet).

agent_load_kif(Filename,Ctx,User):-
        agent_load_kif_surface(Filename,Context,User,AX,loud).


agent_load_kif_surface(Filename,Context,User,AX,Verbose):-
        ignore(User='Automation'),
        (unsetMooOption(opt_surface_check=_)),
        (setMooOption(opt_surface_check=trusted)),
         get_default_assertion_context(DCtx), !,ignore((Ctx=DCtx)),!,
         getMooOption(opt_theory,DContext), !,  ignore((Context=DContext)),!,
        idGen(TN1),
        idGen(TN2),
        idGen(TN3),
        assertaClean(mooCache(PredR,surface,'instance'(Context,'KnowledgeBase'),'$VAR'(0),'MooKernel','GlobalContext',TN1,User,gaf)),
        assertaClean(mooCache(PredR,surface,'instance'('GlobalContext','Context'),'$VAR'(0),Context,'GlobalContext',TN2,User,gaf)),
        assertaClean(mooCache(PredR,surface,'sourcefile-of'(Context,Filename),'$VAR'(0),'MooKernel','GlobalContext',TN3,User,gaf)),
        writeFmt(user_error,'% Reading In ~w to ~w with a default context of ~w \n',[Filename,Context,Ctx]),
        flag('Axioms Compiled',_,0),
        safe_file_open(Filename,'r',INPUT),!,
           repeat,
               once((once(readKIF(INPUT,Chars)),
                  % say(Chars),
                    %catch(writeFmt(OUTPUT,'\n% ~s  ',[Chars]),_,true),
                    tell_retract_parse_chars(Chars,PROLOG,Vars),
                     once((
                           PROLOG=comment(_)
                            ;

                          remember_ado(PROLOG,Vars,Context,User,Verbose)
                            )))),
                     at_end_of_stream(INPUT), !,
        close(INPUT),
        flag('Axioms Compiled',AX,AX),
        writeFmt(user_error,'% Loaded ~w axioms.\n',[AX]),
        ignore(retract(findings(CPU,RESULT))),
        ignore(findall(T,retract(title(T)),Title)),!.

remember_ado(Surface,Vars,Context,User,quiet):-!,
        flag('Axioms Compiled',AX,AX+1),
        once(invokeInsert([untrusted,canonicalize],surface,Surface,Ctx,TN,Context,Vars,User)).

remember_ado(Surface,Vars,Context,User,_):-!,
        flag('Axioms Compiled',AX,AX+1),
        once(invokeInsert([untrusted,canonicalize],surface,Surface,Ctx,TN,Context,Vars,User)),
        ignore((writeObject(formula(Surface),Vars))),nl.

agentSave(FileName,Ctx):-
        tell(FileName),
%       writeFmt((':-include(\'moo_header.P\').\n'),[]),
        writeFmt(':-multifile(mooCache/6).\n',[]),
        writeFmt(':-multifile(mooCache/9).\n',[]),
        writeFmt(':-multifile(mooCache/5).\n',[]),
        writeFmt(':-retractall(mooCache(PredR,_,_,_,_,~q,_,_,_)).\n',[Ctx]),
        writeFmt(':-index(mooCache(1 ,0,1,0,0,1,0,0,1)).\n',[]),
        save_each_assertion_of(Ctx),
        told.


save_each_assertion_of(Ctx):-mooCache(PredR,Form,Surface,Vars,Context,EXTID,User,Status),
                writeFmt('~q.\n',[mooCache(PredR,Form,Surface,Vars,Context,EXTID,User,Status)]),fail.
save_each_assertion_of(Ctx):-!.

agentLoad(Filename) :-ensure_loaded(Filename).


% fguard(Template,RH,NVars,Explaination,Functor)
fguard(RH,NVars,surf(Context,TN,CID,[]),Functor):-!.

      %  not(recorded(Functor,Template,FRef)),
        %unify_with_occurs_check(Template,RH).


%guard(instance,instance(v(_G238, _G238, _G240), v('Abstract', _G238, ['Class'|_G247])):instance(v(_G238, _G238, _G240), v('Abstract', _G238, ['Class'|_G247])), [_G238, _G238, _G240, _G238, _G247]:[_G238, _G238, _G240, _G238, _G247], (subclass(v('Abstract', _G238, ['Class'|_G327]), v('Abstract', _G238, ['Class'|_G247])), instance(v(_G238, _G238, _G240), v('Abstract', _G238, ['Class'|_G327]))): (subclass(v('Abstract', _G238, ['Class'|_G361]), v('Abstract', _G238, ['Class'|_G247])), instance(v(_G238, _G238, _G240), v('Abstract', _G238, ['C
/*
guard(instance,
instance(v(_G235, _G236, _G237), v('Abstract', _G240, ['Class'|_G244])):instance(v(_G266, _G267, _G268), v('Abstract', _G271, ['Class'|_G275])),
 [_G235, _G236, _G237, _G240, _G244]:[_G266, _G267, _G268, _G271, _G275],
 (subclass(v('Abstract', _G317, ['Class'|_G321]), v('Abstract', _G271, ['Class'|_G275])),instance(v(_G266, _G267, _G268), v('Abstract', _G317, ['Class'|_G321]))),
  188, 3, ['SUBCLASS'=_G317, 'CLASS'=_G271, 'INST'=_G267], [_G267, _G271, _G317], [], [], [_G317], [_G267, _G271])
*/

                                         /*
guard(Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,KRVars,RuleVars,UnivHead,BodyUniv,BodySelfConnected,RealShared):-
        unify_with_occurs_check(RFVH,FVH), %unifies list of 'real' prolog variables
        recorded(TN,KRVars,Ref),!,
        writeDebugFast(bumping(KRVars)),!,
        catch(exit(Ref,cut),_,fail).
        %(catch(fail(Ref),_,(writeDebugFast(missing(Copy)),fail)),fail),write(bollk),nl.
%       catch(exit(Ref,previousCallMoreSpecific(KRVars,Copy)),_,fail),fail.
                                           */

'$existential'(v(_,V,_),A,F):-ignore(V=F).


guard(Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,KRVars,RuleVars,UnivHead,BodyUniv,BodySelfConnected,RealShared):-!,


%        not(Functor=not(_)),
        not(recorded(TN,KRVars,Ref)),
        %ground(UnivHead), % Makes sure this is valid
        unify_with_occurs_check(RFVH,FVH), %unifies list of 'real' prolog variables
        copy_term(KRVars,Session),
        numbervars(Session,'$VAR',0,_),
        recorda(TN,Session,Ref),
     %   recorda(Functor,RealHead,FRef),
        %stepQualifier(Ref,Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,KRVars,RuleVars,UnivHead,BodyUniv,BodySelfConnected,RealShared,Qualifier),
%findall(Body,call_with_depth_limit(block(Ref,callBody(Body,true),Result),47,_),Sols),!,
        findall(Body,call_with_depth_limit(Body,47,_),Sols),!,
        %findall(Body,Body,Sols),!,
        sort(Sols,SolsS),
        member(Body,SolsS).


        %(Result=cut -> !,),
        %catch(erase(Ref),_,writeDebugFast(missingRef(Vars))).
%       processResult(Result,TN,CID,F,KRVars,RB,Session,Ref),!,
%       ground(RealShared).

%processResult(Result,TN,CID,F,Vars,RB,Session,Ref):-var(Result),!, % normal completion

%processResult(previousCallMoreSpecific(Vars,Copy),TN,CID,F,KRVars,RB,Session,Ref):- % decendant aborted to here
        %catch(erase(Ref),_,writeDebugFast(missingRefInpreviousCallMoreSpecific(KRVars))),
 %       writeDebugFast(previousCallMoreSpecific(KRVars,Vars,Copy)). %,!,fail.



stepQualifier(Ref,Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,
        KRVars,RuleVars,UnivHead,[BodY|Univ],BodySelfConnected,RealShared,(ground(BodY),exit(Ref,bodyUnivBound))).


stepQualifier(Ref,Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,
        KRVars,RuleVars,UnivHead,BodYUniv,BodySelfConnected,RealShared,true).

%callBody(Body,true):-!,Body.
callBody((A,B),Qualifier):-
        callBody(A,Qualifier),Qualifier,
        callBody(B,Qualifier).
callBody(Body,Qualifier):-not(functor(Body,function,_)),Body.

unguard(TN,F,Vars,Session):-
        recorded(TN,Session,Ref),!,erase(Ref),!.

unguard(TN,F,Vars,Session):-
        writeDebugFast(somethingKilled(Session)).


mooCall(X):-
        mooCache(X, Cost,Context, Ctx,surf(Context,TN,CID,[])).

mooCall(X):-
        mooCache(X, Cost,Context, Ctx,surf(Context,TN,CID,[])).


mooCall(Flags,Context):-
        mooCache(Cons, Ante,Vars,Context, Ctx,TN).

guard(Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,KRVars,RuleVars,UnivHead,BodyUniv,BodySelfConnected,RealShared):-!,
%        not(Functor=not(_)),
        not(recorded(TN,KRVars,Ref)),
        %ground(UnivHead), % Makes sure this is valid
        unify_with_occurs_check(RFVH,FVH), %unifies list of 'real' prolog variables
        copy_term(KRVars,Session),
        numbervars(Session,'$VAR',0,_),
        recorda(TN,Session,Ref),
     %   recorda(Functor,RealHead,FRef),
        %stepQualifier(Ref,Functor,RealHead:Head,RFVH:FVH,Body,TN,CID,KRVars,RuleVars,UnivHead,BodyUniv,BodySelfConnected,RealShared,Qualifier),
%findall(Body,call_with_depth_limit(block(Ref,callBody(Body,true),Result),47,_),Sols),!,
        findall(Body,call_with_depth_limit(Body,47,_),Sols),!,
        %findall(Body,Body,Sols),!,
        sort(Sols,SolsS),
        member(Body,SolsS).


/*

        assertz((term_expansion(X,Y) :- catch((!,getTermExpansionLogged(X,Y)),E,fail))),
        told.
*/




:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).


ca:-compile_show('PrologMOO',instance,2,Debug).

cf:- compile_to_file(instance,2,'PrologMOO').


va:- compile_show('PrologMOO',valence,2,Debug).

ensure_all_compiled:-!.

ensure_all_compiled:-
        getAllMooContext(X),
        compileContext(X),fail.


getAllMooContext(X):-fail.

compileContext(Context):-!.
compileContext(Context):-
        compileInstanceSubclass(Context).



make_theory(Context):-
        retractall(mooCache(Context,_,_)),
        atom_concat(Context,'.prolog',PrologFile),
        tell(PrologFile),
        format('

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).

        '),
        image_to_prolog(Context),!,
        told,
        save_make_theory(PrologFile,Context,FeatureFile),
        atom_concat(Context,'.pl',OutputFile),
        concat_atom([cat,FeatureFile,PrologFile,'>',OutputFile],' ',Cmd),
        format('~n~w~n',[Cmd]).


save_make_theory(PrologFile,Context,FeatureFile):-
        atom_concat(Context,'.feature',FeatureFile),
        tell(FeatureFile),
        format('

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).

        '),
        save_features_theory(Context),
        told.

save_features_theory(Context):-
        format('~n~n% Predicates~n~n'),
        mooCache(Context,type(dynamic),Data),
        format(':-~q.~n',[dynamic(Data)]),fail.

save_features_theory(Context):-
        format('~n~n% Predicates~n~n'),
        mooCache(Context,type(dynamic),Data),
        format(':-~q.~n',[tabled(Data)]),fail.

/*
save_features_theory(Context):-
        format('~n~n% Tables~n~n'),
        mooCache(Context,type(tabled),Data),
        format(':-~q.~n',[tabled(Data)]),fail.
  */

/*
save_features_theory(Context):-
        format('~n~n% Not Tabled ~n~n'),
        mooCache(Context,type(dynamic),Data),
        not(mooCache(Context,type(tabled),Data)),
        format(':-~q.~n',[prolog(Data)]),fail.
*/

save_features_theory(Context):-
        format('~n~n% Rules~n~n'),
        mooCache(Context,type(rule),Data),
        format('~q.~n',[rules_for(Data)]),fail.

save_features_theory(Context):-
        format('~n~n% No Rules For~n~n'),
        mooCache(Context,type(dynamic),Data),
        not(mooCache(Context,type(rule),Data)),
        format('~q.~n',[no_rules_for(Data)]),fail.

save_features_theory(Context):-
        format('~n~n% Facts~n~n'),
        mooCache(Context,type(fact),Data),
        format('~q.~n',[facts_for(Data)]),fail.

save_features_theory(Context):-
        format('~n~n% No Facts~n~n'),
        mooCache(Context,type(dynamic),Data),
        not(mooCache(Context,type(fact),Data)),
        format('~q.~n',[no_facts_for(Data)]),fail.

save_features_theory(Context):-
        format('~n~n% No Rules/Facts~n~n'),
        mooCache(Context,type(dynamic),Data),
        not(mooCache(Context,type(fact),Data)),
        not(mooCache(Context,type(rule),Data)),
        format('~q.~n',[no_assertions_for(Data)]),fail.

save_features_theory(Context):-
        format('~n~n% Lemma Reqs:~n~n'),
        findall((F-C),mooCache(Context,type(F/A),(C/N)),Edges),
        keysort(Edges,Sorted),
        format('lemma_edges(~q).~n~n',[Sorted]),!.


image_to_prolog:-
        tell('PrologMOO.pl'),
        image_to_prolog(Context),
        told.


image_to_prolog(Context):-
        hardcoded(HardCoded),
        image_to_prolog([holds,neg(lit)|HardCoded],Context).

image_to_prolog(Flags,Context):-format(
'
:- op(400,fy,~~).
%:- op(500,xfy,:).
:- op(500,xfx,#).
%:- op(500,xfx,@).

:- op(400,fy,not).    % negation
:- op(500,xfy,and).   % conjunction
:- op(600,xfy,or).   % disjunction
%:- op(500,xfy,:).
:- op(0,xfx, equal ).
:- op(900,xfx,''<='').
:- op(900,xfx,if).
:- op(400,fy,known).  % Found in Model
:- op(400,fy,possible).  % Not In Model
:- op(400,fy,next).  % Next time
:- op(400,fy,after).  % Next time
:- op(400,fy,then).  % Next time
:- op(650,xfy,=>).  % implication
:- op(700,xfy,<=>). % equivalence
:- op(400,fy,always).  % Necessity, Always
:- op(400,fy,possible).  % Possibly, Eventually
:- op(400,fy,necessary).  % Necessity

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).

:-set_prolog_flag(unknown,fail).

'),fail.





/*
delayBody(TN,(B1,B2)):-
        delayBody(TN,B1),
        delayBody(TN,B2).

delayBody(TN,B2):-
        functor(B2,F,_),
        recorda(F,delayed).
*/


mcl1:-mcl(instance(X,Y)).

mcc(X):-
        resetTableFlags,X.


mcl2:-
        mcl(X,instance(v(_,X,_),v('Abstract', 'BinaryRelation',_))).



mcl(X):-
        resetTableFlags,
       findall(X,(X,writeq(X),nl),L),
       writeq(L),nl,
       length(L,N),
       write(num:N),nl.

mcl(X,Y):-
        resetTableFlags,
       findall(X,(Y,writeq(Y),nl),L),
       writeq(L),nl,
       length(L,N),
       write(num:N),nl.





image_to_prolog(Flags,Context):-
        mooCache(Cons, Cost,Context, Ctx,Explaination),
                convertPrologWFS(Flags,Context,Activation,Explaination,Cons,Prolog),
        writeAsProlog(Prolog),fail.


image_to_prolog(Flags,Context):-
        mooCache(Cons, Ante,Cost,Context, Ctx,Explaination),
        convertPrologWFS(Flags,Context,Activation,Explaination,(Cons:-Ante),Prolog),
        writeAsProlog(Prolog),fail.



image_to_prolog(Flags,Context):-!.



tabled_consult(File):-
        tell('tabling.log'),
        assertz((term_expansion(X,Y) :- catch((!,getTermExpansionLogged(X,Y)),E,fail))),
        consult(File),
        abolish(term_expansion/2),
        dynamic(term_expansion/2),
        multifile(term_expansion/2),!,
        told.

/*
ttheory(Context):-
        tell('tabling.log'),
        mooCache(Cons, Cost,Context, Ctx,Explaination),
        assertClauseTable(Context,Cons,Explaination),fail.

ttheory(Context):-
        mooCache(Cons, Ante,Cost,Context, Ctx,Explaination),
        assertClauseTable(Context,(Cons:-Ante),Explaination),fail.

ttheory(Context):-told.

*/

assertClauseTable(Context,WFS,Explaination):-
        convertPrologWFS(Flags,Context,assertClauseTable,Explaination,WFS,Prolog),
        getTermExpansionLogged(Prolog,Tabled),
        assertAll(Tabled),!.



tconsult(File):-
        tell('tabling.log'),
        see(File),
        repeat,
                read(X),
                catch((!,getTermExpansionLogged(X,Y)),E,(writeq(E),nl,fail)),
                once(assertAll(Y)),
           X==end_of_file,
        seen,
        told.

assertClauseTable(Context,WFS,Explaination):-
        convertPrologWFS(Flags,Context,assertClauseTable,Explaination,WFS,Prolog),
        getTermExpansionLogged(Prolog,Tabled),
        assertAll(Tabled).


getTermExpansionLogged(end_of_file,end_of_file):-!.
getTermExpansionLogged(X,Y):-
        slg_term_expansion(X,Y),
        log_term_expansion(X,Y).

log_term_expansion(X,Y):-X==Y,!,
        format('\n%no_expansion\n'),write_te_list(Y).
log_term_expansion(X,Y):-
        format('\n%~q~n',[X]),write_te_list(Y).

write_te_list([]):-nl,!.
write_te_list([X|T]):-!,write_te_list(X),write_te_list(Y).
write_te_list(X):-format('~q.\n',X).


convertPrologWFS(Flags,Context,Activation,surf(Context,TN,CID,KRVars),
        (C :- A),
        ((
        RealHead :-
                guard(Functor,(RealHead:Head),(RFVH:FVH),Body,TN,CID,KRVars,
                RuleVars,UnivHead,BodyUniv,BodySelfConnected,Shared)))):-!,
        functor(C,F,_),convertNegations((not),F,Functor,_),
        convertRuleHeadWFS(Flags,Context,Activation,C,Head,RuleHead),
        convertRuleBodyWFS(Flags,Context,Activation,RuleHead,A,Body),!,
        getPrologVars(KRVars,RuleVars,_,_),!,
        getPrologVars(Head,FVH,_,_),!,set_partition(RuleVars,FVH,_,_,HeadVars),
        getPrologVars(Body,FVB,BSingles,_),!,set_partition(RuleVars,FVB,_,_,BodyVars),
        set_partition(HeadVars,BodyVars,PrivHead,PrivBody,Shared),!,
        set_partition(PrivBody,BSingles,BodySelfConnected,_,BodyUniv),!,
        copy_term((Head,FVH,PrivHead),(RealHead,RFVH,UnivHead)).

convertPrologWFS(Flags,Context,Activation,Explaination,(C),(RH:- fguard(RH,NVars,Explaination,Functor))):-!,
        functor(C,F,_),convertNegations((not),F,Functor,_),
        convertFactHeadWFS(Flags,Context,Activation,C,RH),
        functor(RH,F,A),functor(Template,F,A),Template=..[F|NVars].



writeAsProlog([]):-format('\n\n'),!.
writeAsProlog([H]):-format('\n\t~q.~n',[C]),!.
writeAsProlog(':-'(Cons, Ante)):-format('\n ~q :-',[Cons]),writeAsProlog(Ante),!.
writeAsProlog('<-'(Cons,Ante)):-format('\n ~q <-',[Cons]),writeAsProlog(Ante),!.
writeAsProlog('<--'(Cons,Ante)):-format('\n ~q <--',[Cons]),writeAsProlog(Ante),!.
writeAsProlog('::-'(Cons,Ante)):-format('\n ~q ::-',[Cons]),writeAsProlog(Ante),!.
writeAsProlog((H,T)):-format('\n\t~q,',[H]),writeAsProlog(T),!.
writeAsProlog([H|T]):-format('\n\t~q,',[H]),writeAsProlog(T),!.
writeAsProlog(C):-format('\n\t ~q.~n',[C]),!.

recordIfNew(Activation,Context,Cons,Type):-!.

recordIfNew(Activation,Context,Cons,Type):-
        atom(Type),!,
        functor(Cons,Pred,Arity),
        recordIfNewCache(Context,Type,Pred/Arity),!.
recordIfNew(Activation,Context,Cons,Type):-
        functor(Type,T,A),
        functor(Cons,Pred,Arity),
        recordIfNewCache(Context,(T/A),(Pred/Arity)).

recordIfNewCache(Context,Type,Data):-
        mooCache(Context,type(Type),Data),!.
recordIfNewCache(Context,Type,Data):-
        assertz(mooCache(Context,type(Type),Data)),!.



/*

Subclasses of Physical

        Object
                SelfConnectedObject
                Collection
                ContentBearingObject
        Process

Subclasses of Abstract

         Quantity
                Number (how many)
                PhysicalQuantity (how much)
         Attribute
         Proposition
         Class
                Set
         Relation
                Predicate
                Function
               VariableArityRelation

   Other Disjoint CLasses like the new 'Graph'



*/





/*
compile_to_file(STANDARDPred,Arity,Context):-
        make_relation_profile(Context,STANDARDPred,Logic,Arity,N,Module,SourceInfo,Functor),
        open(SourceInfo, write, Stream, [buffer(full),type(text),alias(STANDARDPred)]),
        compile_show(STANDARDPred,Context,STANDARDPred,Arity,Debug),
        close(STANDARDPred).
*/
compile_to_file(STANDARDPred,Arity,Context):-
        make_relation_profile(Context,STANDARDPred,Logic,Arity,N,Module,SourceInfo,Functor),!,
        open(SourceInfo, write, Stream, [buffer(full),type(text),alias(STANDARDPred)]),
        compile_show(Stream,Context,STANDARDPred,Arity,Debug),!,
        close(Stream),!.

compile_show(Context,STANDARDPred,Arity,Debug):-
        current_output(Stream),!,
        compile_show(Stream,Context,STANDARDPred,Arity,Debug),!.


compile_show(Stream,Context,STANDARDPred,Arity,Debug):-
        ignore(Debug=no_debug),!,
        make_relation_profile(Context,STANDARDPred,Logic,Arity,N,Module,SourceInfo,Functor),
        mkImported(full,Functor,Arity,Logic,Vect,Ctx,ExplainationIn,Explaination,Imported),
        mkArgsAtom(Arity,ArgsAtom),
        mkHolds(STANDARDPred,Arity,Vect,Cons),
        mkIndex(Functor,N,Index),
        Dash = (Functor/N),
        format(Stream,'
/* <PRE face="Arial,Helvetica"><font face="Arial,helvetica"><font color=green>
File: "~w"

Maintainer:      dmiles@users.sourceforge.net [Douglas R. Miles]

Purpose:  Individual loading of Moo Context Predicates.

Exported:
        explaination_line/2,                                                                    % ExplainationIn of Explaination Formats
        full_~w(Logic, ~w, Ctx, ExplainationIn, Explaination),                                   % Basic Access
        bk_~w(Logic, ~w, Ctx,ExplainationIn, Explaination),                    % Backward Chain
        fw_~w(Logic, ~w, Ctx,ExplainationIn,Explaination),                % Forward Chain
        gaf_~w(Logic, ~w, Ctx,ExplainationIn,Explaination),                % Forward Chain

Uses: deduceTransitiveClosure_PartialOrderingRelation/6, fw_instance/5, fw/6.

Type of SourceInfo: predicate_module (generated runtime)
Module:   ~q
STANDARD:   ~q
Cons:   ~q
Context:   ~q
Debug:  ~q
</font>
*/

:-module(~q,
       [
        full_~w,
        bk_~w,
        gaf_~w,
        fw_~w
        ]).

:-include(\'moo_multifile.P\').

% =====================================================
% belief_module(Context,STANDARDPred,Cons,Imported,ConnectionType,SourceInfo,HowOften).
%       Context = The KnowedgeBase
%       Ctx = The Context
%       STANDARDPred = The Functor\'s STANDARD Name
%       Goal = Functors STANDARD Prototype       "goal(Logic,ExplainationIn,holds(STANDARDPred,A,B),Ctx,Context,ExplainationOut)"
%       Imported = Functor\'s Prolog Prototype
%       ConnectionType = \'prolog\'  meaning its compiled by consulting this file to memory.
%       SourceInfo = The connection parameters
%       HowOften = always,never,once
% =====================================================

:-index(belief_module(1,0,1,1,1,0,0,0)).


belief_module(
        ~q,_AllContexts,
        ~q,goal(Logic,ExplainationIn,holds(~q,~w),Ctx,~q,ExplainationOut),
        full_~w(Logic, ~w, Ctx, ExplainationIn, ExplainationOut),
        prolog, ~q,
        always).


% =====================================================
% index/dynamic All exported predicates
% =====================================================

:-index(full_~w).
:-index(fw_~w).
:-index(bk_~w).
:-index(gaf_~w).

:-dynamic(full_~w).
:-dynamic(fw_~w).
:-dynamic(bk_~w).
:-dynamic(gaf_~w).

',     [SourceInfo, % Comment SourceInfoname
        Functor,ArgsAtom,  % Comment full_Functor
        Functor,ArgsAtom,  % Comment bk_Functor
        Functor,ArgsAtom,  % Comment fw_Functor
        Functor,ArgsAtom,  % Comment gaf_Functor
        Module,STANDARDPred,Cons,Context,Debug, % Comments
        Module,Dash,Dash,Dash,Dash,  % module/2
        Context,STANDARDPred,STANDARDPred,ArgsAtom,Context,Functor,ArgsAtom,SourceInfo, % belief_module/5
        Index,Index,Index,Index,    % index/1
        Dash,Dash,Dash,Dash      % dynamic/1
        ]),!,
        create_entry_points(Stream,non_singleValued,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom),!,
        make_pred_data(Stream,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom),!.

mkArgsAtom(Arity,ArgsAtom):-
        length(Arglist,Arity),
        numbervars(Arglist,'$VAR',0,_),
        term_to_atom(Arglist,ArgListAtom),
        atom_codes(ArgListAtom,[_|ArgListAtomCodesRight]),
        append(ArgListAtomCodes,[93],ArgListAtomCodesRight),
        atom_codes(ArgsAtom,ArgListAtomCodes).

mkHolds(STANDARDPred,Arity,Vect,Cons):-
        Cons=..[holds,STANDARDPred|Vect],!.

mkImported(full,Module,Arity,Logic,Vect,Ctx,ExplainationIn,Explaination,Imported):-
        length(Vect,Arity),
        append([Module,Logic|Vect],[Ctx,ExplainationIn,ExplainationIn * Explaination],STANDARDPredList),
        Imported =.. STANDARDPredList,!.

mkIndex(STANDARDPred,Arity,Index):-
        interate_copy(Arity,IndexArgs),
        Index=..[STANDARDPred|IndexArgs],!.

interate_copy(N,[1,1,1,1|IndexArgs]):-
        NN is N - 4,
        length(IndexArgs,NN),
        put_in_n(NN,0,IndexArgs),!.

put_in_n(NN,Value,[]).
put_in_n(NN,Value,[Value|L]):-put_in_n(NN,Value,L).


create_head(Tag,Context,STANDARDPred,Logic,Args,Head):-
        concat_atom([Tag,Context,'_',STANDARDPred],Functor),
        Head=..[Functor|Args],!.


% ===============================================================
% make_relation_profile(-Context,-STANDARDPred,-Logic,-Arity,+N,+Module,+SourceInfo,+Functor)
% ===============================================================
make_relation_profile(Context,STANDARDPred,Logic,Arity,N,Module,SourceInfo,Functor):-!,
        ignore(Context='PrologMOO'),
        ignore(STANDARDPred='attribute'),
        ignore(Arity=2),
        is(N,(Arity + 4)),
        concat_atom([Context,'_',STANDARDPred],Module),
        concat_atom([Module,Arity],Functor),
        concat_atom(['pred_', Module, '.pl' ],SourceInfo),!.


create_entry_points(Stream,non_singleValued,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom):-
format(Stream,'
% ==================================================================================
% <B>Entry Points</B> for <font color=red>non_singleValued</font>   <font size=+1 color=green>~w/~w</font>
% ==================================================================================

% gaf hook
full_~w(Logic,~w, Ctx,ExplainationIn,(Explaination * ExplainationIn)):-
        gaf_~w(Logic,~w ,Ctx,ExplainationIn,Explaination),not_in(Explaination,ExplainationIn).

% fw hook
full_~w(Logic,~w, Ctx,ExplainationIn,(Explaination * ExplainationIn)):-
        fw_~w(Logic,~w ,Ctx,ExplainationIn,Explaination),not_in(Explaination,ExplainationIn).

% bk hook
full_~w(Logic,~w, Ctx,ExplainationIn,Explaination):-
        bk_~w(Logic,~w ,Ctx,ExplainationIn,Explaination).

',     [STANDARDPred,Arity, %Comment
        Functor,ArgsAtom,Functor,ArgsAtom,
        Functor,ArgsAtom,Functor,ArgsAtom,
        Functor,ArgsAtom,Functor,ArgsAtom
        ]),!. % never fails

make_pred_data(Stream,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom):-
format(Stream,'

% ================================================================================================================
% <B>Rules/Facts</B> for <font size=+1 color=green>~w/~w</font>
% ================================================================================================================<B>

',[STANDARDPred,Arity]),once((flag(rule_num,_,1),flag(explaination_linenumber,_,1))),fail.

write_rulenum(Stream,Explaination):-!,
        flag(rule_num,RN,RN+1),flag(explaination_linenumber,_,1),!,
        format(Stream,'~n/*Id: ~q */~n',[Explaination]),!.

make_head_t(true,STANDARDPred,N,Cons):-
                length(Args,N),
                Cons=..[STANDARDPred|Args],!.

make_head_t(false,STANDARDPred,N,Cons):-
                length(Args,N),
                atom_concat('~',STANDARDPred,STANDARDPredN),
                Cons=..[STANDARDPredN|Args],!.


getrule(STANDARDPred,Arity,Cons,Precond, Context, surf(Context,TN,CID),Vars):-
        make_head_t(true,STANDARDPred,Arity,Cons),
        mooCache(Cons, A1,A2,A3, Cost,Context, Ctx,surf(Context,TN,CID,Vars)),
        once((append(A1,A2,AM),
        append(AM,A3,Precond))).
getrule(STANDARDPred,Arity,Cons,Precond, Context, surf(Context,TN,CID),Vars):-
        make_head_t(false,STANDARDPred,Arity,Cons),
        mooCache(Cons, A1,A2,A3, Cost,Context, Ctx,surf(Context,TN,CID,Vars)),
        once((append(A1,A2,AM),
        append(AM,A3,Precond))).

% True GAFS
make_pred_data(Stream,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom):-
        make_head_t(true,STANDARDPred,Arity,Cons),
        mooCache(Cons, Precon, Context, TID),
        write_rulenum(Stream,TID),
        numbervars((Cons, Precon, Context, TID,Vars),'$VAR',15,_),
        submit_ado_cache(Stream,STANDARDPred,Cons, Precon, Context, TID,Vars),fail.

% False GAFS
make_pred_data(Stream,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom):-
        make_head_t(false,STANDARDPred,Arity,Cons),
        mooCache(Cons, Precon, Context, TID),
        write_rulenum(Stream,TID),
        numbervars((Cons, Precon, Context, TID,Vars),'$VAR',15,_),
        submit_ado_cache(Stream,STANDARDPred,Cons, Precon, Context, TID,Vars),fail.

% True then Fasle Rules
make_pred_data(Stream,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom):- %true,
        getrule(STANDARDPred,Arity,Cons,Precond, Context, TID,Vars), %true,
        write_rulenum(Stream,TID),
        close_list(Vars),
        numbervars((Stream,STANDARDPred,Cons,Precond, Context, TID,Vars),'$VAR',15,_),
        submit_ado_cache(Stream,STANDARDPred,Cons,Precond, Context, TID,Vars),fail.

       % toMarkUp(kif,DispExplaination,Vars,PrettyForm),
        %logOnFailure(format(Stream,'/*~n</B><font color=green>~n~nForms:~n~n~s~nFlags: ~w \n</font><B>*/',[PrettyForm,Flags])),
%       make_disp_explaination(Logic,TID,Vars,Cons,Ante,DispExplaination),
%       format(Stream,'~q. ~n~n',[explaination_line(TID,Vars,DispExplaination)])         %true,


% Write footer
make_pred_data(Stream,Functor,Context,STANDARDPred,Arity,N,Module,Debug,ArgsAtom):-
        getPrettyDateTime(String),
        format(Stream,'\n/* \n Last Saved: ~s</B></font>\n</PRE>*/\n\n\n',[String]),!.


%submit_ado_cache(Stream,STANDARDPred,Cons,_,_,Logic, Context, Ctx, Explaination * _):-true,fail.


% No antecedents flags
submit_ado_cache(Stream,STANDARDPred,Cons, [], Context, TID,Vars):-
        Cons=..[_|Arguments],
        append(Arguments,[Ctx,TID],Args),  !,
        create_head('gaf_',Context,STANDARDPred,true,Args,PrologHead),
        format(Stream,'~n~q.~n',[PrologHead]),!.

% With antecedents flags
submit_ado_cache(Stream,STANDARDPred,Cons,Ante, Context, TID,Vars):-
        Cons=..[_|Arguments],
        numbervars(SubCtx),
        append(Arguments,[Ctx,ExplainationIn,[explaination_line(TID,VarsRef)|ExplainationOut]],Args),
        create_head('bk_',Context,STANDARDPred,true,Args,PrologHead),
        format(Stream,'~n ~q :- \n',[PrologHead]),!,
        %format(Stream,'\t~q,~n',[not_near_member(TID,ExplainationIn)]), !,
      %  findall(Neg,member(-(Neg),Ante),NegS),
        % findall(Pos,member(+(Pos),Ante),PosS),
        %format(Stream,'\t~q,~n',[minor_interception(PosS,NegS,ExplainationIn,ExplainationMid)]),
        %write_std_flags(Stream,Context,Flags,(Cons:Ante)),!,
        format(Stream,'\t~q,~n',[subcontext(Ctx,SubCtx)]),
        write_prolog_body_clause(Stream,Ante,STANDARDPred,Cons,Ante,Context, SubCtx, TID,Vars,ExplainationIn,ExplainationOut),!,
        format(Stream,'\t~q.~n~n',[(ground(Vars),VarsRef=Vars)]),!.

write_std_flags(Stream,Context,Flags,Term):-
        write_lllist(Stream,Context,Flags),!.

write_lllist(Stream,Context,[]):-!.
write_lllist(Stream,Context,[Arg|List]):-
        format(Stream,'\tk~w_~q,~n',[Context,Arg]),
        write_lllist(Stream,Context,List),!.


/*

submit_ado_cache(Stream,STANDARDPred,Cons,Ante,Flags,Logic, Context, Ctx, TID * Vars):-
        write_prolog_rule(Stream,STANDARDPred,Cons,Ante,Flags,Logic, Context, Ctx, TID,Vars),!.

write_prolog_rule(Stream,STANDARDPred,Cons,Ante,Flags,Logic, Context, Ctx, TID,Vars):-
        format(Stream,' ~q. ~n',[explaination_line(TID,Vars,DispExplaination)]),
        Cons=..[_|Arguments],
        append(Arguments,[Ctx,ExplainationIn,(ExplainationOut * TID,Vars)],Args),
        create_head('bachchain_',Context,STANDARDPred,Logic,Args,PrologHead),
        format(Stream,' ~q :- ~n',[PrologHead]),
        write_prolog_body_start(Stream,Ante,STANDARDPred,Cons,Ante,Flags,Logic, Context, Ctx, TID,Vars,ExplainationIn,ExplainationMid),!,
        write_prolog_body_clause(Stream,Ante,STANDARDPred,Cons,Ante,Flags,Logic, Context, Ctx, TID,Vars,ExplainationMid,ExplainationOut),!.

*/
%       write_prolog_body_clause(Stream,Ante,STANDARDPred,Cons,Ante,Flags,Logic, Context, Ctx, TID,Vars,ExplainationMid,ExplainationOut),!.

write_prolog_body_clause(Stream,OrigAnte,STANDARDPred,Cons,[], Context, Ctx, TID,Vars,ExplainationIn,ExplainationOut):-!,
        format('\t~w,~n',[ExplainationIn=ExplainationOut]).

write_prolog_body_clause(Stream,OrigAnte,STANDARDPred,Cons,[Ante], Context, Ctx, TID,Vars,ExplainationIn,ExplainationOut):-!,%true,
        write_prolog_term(Stream,OrigAnte,Context,Flags,Caller,FlagsSTANDARDPred,Cons,Ante,Context, Ctx, TID,Vars,ExplainationIn,ExplainationOut),!.

write_prolog_body_clause(Stream,OrigAnte,STANDARDPred,Cons,[Ante|More], Context, Ctx, TID,Vars,ExplainationIn,ExplainationOut):-!,%true,
        write_prolog_term(Stream,OrigAnte,Context,Flags,Caller,FlagsSTANDARDPred,Cons,Ante,Context, Ctx, TID,Vars,ExplainationIn,ExplainationMid),
        write_prolog_body_clause(Stream,OrigAnte,STANDARDPred,Cons,More, Context, Ctx, TID,Vars,ExplainationMid,ExplainationOut),!.




check_end_flags(FlagsList,ExplainationIn,ExplainationOut):-ExplainationIn=ExplainationOut.
check_begin_flags(FlagsList,ExplainationIn,ExplainationOut):-ExplainationIn=ExplainationOut.



write_prolog_term(Stream,OrigAnte,Context,Flags,Caller,FlagsSTANDARDPred,Cons,Useless, Context, Ctx, TID,Vars,ExplainationIn,ExplainationIn):- useless(Useless),!.
write_prolog_term(Stream,OrigAnte,Context,Flags,Caller,FlagsSTANDARDPred,Cons,Ante, Context, Ctx, TID,Vars,ExplainationIn,ExplainationOut):-
        Ante=..[P|Arguments],
        append(Arguments,[Ctx,ExplainationIn,ExplainationOut],Args),
        create_head('fw_',Context,P,true,Args,PrologHead),
        format(Stream,'\t~q,~n',[PrologHead]),!.

useless(domainC(_,[])).
useless(domainA(_,[])).



make_disp_explaination(true,surf(Context,TID),Vars,Cons,Conds,via(entails(CondsO,Cons),Vars) * surf(Context,TID)):-fix_conds(Conds,CondsO),!.
make_disp_explaination(false,surf(Context,TID),Vars,Cons,Conds,via(entails(CondsO,not(Cons)),Vars) * surf(Context,TID)):-fix_conds(Conds,CondsO),!.
make_disp_explaination(true,surf(Context,TID,ID),Vars,Cons,Conds,via(entails(CondsO,Cons),Vars) * surf(Context,TID,ID)):-fix_conds(Conds,CondsO),!.
make_disp_explaination(false,surf(Context,TID,ID),Vars,Cons,Conds,via(entails(CondsO,not(Cons)),Vars) * surf(Context,TID,ID)):-fix_conds(Conds,CondsO),!.

fix_conds(Var,Var):-isSlot(Var),!.
fix_conds([],true):-!.
fix_conds([A],AA):-!,
        fix_conds(A,AA).
fix_conds(+Conds,Conds).
fix_conds(-Conds,not(Conds)).
fix_conds([A|B],and(AA,BB)):-!,
        fix_conds(A,AA),
        fix_conds(B,BB).






/**********************************************************************
 *
 * @(#) dynamicDef.pl 1.19@(#)
 *
 */


% !! Remember: Any changes to the following list should be carefully
%              reflected in     clearEnvironment
%                       and     saveEnvironment.

% The following predicates belong to the translated terminologial 
% axioms.
:- multifile(in/9).
:- dynamic(in/9).
:- multifile(kb_in/10).
:- dynamic(kb_in/10).
:- multifile(eq/9).
:- dynamic(eq/9).
:- multifile(constraint/8).
:- dynamic(constraint/8).
:- multifile(rel/5).
:- dynamic(rel/5).
% The following predicates are used for additional informations about
% the terminology and the world description.
:- multifile(axiom/3).
:- dynamic(axiom/3).
:- multifile(closed/5).
:- dynamic(closed/5).
:- multifile(compiledPredicate/2).
:- dynamic(compiledPredicate/2).
:- multifile(conceptElement/7).
:- dynamic(conceptElement/7).
:- multifile(conceptEqualSets/6).
:- dynamic(conceptEqualSets/6).
:- multifile(conceptHierarchy/3).
:- dynamic(conceptHierarchy/3).
:- multifile(conceptName/4).
:- dynamic(conceptName/4).
:- multifile(conceptSubsets/6).
:- dynamic(conceptSubsets/6).
:- multifile(environment/3).
:- dynamic(environment/3).
:- multifile(given_change/4).
:- dynamic(given_change/4).
:- multifile(given_inflLink/4).
:- dynamic(given_inflLink/4).
:- multifile(modalAxioms/7).
:- dynamic(modalAxioms/7).
:- multifile(roleAttributes/5).
:- dynamic(roleAttributes/5).
:- multifile(roleDefault/4).
:- dynamic(roleDefault/4).
:- multifile(roleDefNr/4).
:- dynamic(roleDefNr/4).
:- multifile(roleDomain/4).
:- dynamic(roleDomain/4).
:- multifile(roleElement/8).
:- dynamic(roleElement/8).
:- multifile(roleEqualSets/6).
:- dynamic(roleEqualSets/6).
:- multifile(roleHierarchy/3).
:- dynamic(roleHierarchy/3).
:- multifile(roleName/4).
:- dynamic(roleName/4).
:- multifile(roleNr/5).
:- dynamic(roleNr/5).
:- multifile(roleRange/4).
:- dynamic(roleRange/4).
:- multifile(roleSubsets/6).
:- dynamic(roleSubsets/6).
:- multifile(query/6).
:- dynamic(query/6).
:- multifile(sub/5).
:- dynamic(sub/5).
:- multifile(succ/5).
:- dynamic(succ/5).
% The following predicates are used during computations only.
:- multifile(abductiveDerivation/3).
:- dynamic(abductiveDerivation/3).
:- multifile(consistencyDerivation/3).
:- dynamic(consistencyDerivation/3).
:- multifile(hypothesis/1).
:- dynamic(hypothesis/1).
:- multifile(inconsistencyCheck/3).
:- dynamic(inconsistencyCheck/3).
:- multifile(nsub/5).
:- dynamic(nsub/5).
:- multifile(nsub3/2).
:- dynamic(nsub3/2).
:- multifile(sub3/2).
:- dynamic(sub3/2).
:- multifile(succ3/2).
:- dynamic(succ3/2).
:- multifile(valueOfCounter/2).
:- dynamic(valueOfCounter/2).
% Predicates which are no longer needed
%:- multifile(falsum/2).
%:- dynamic(falsum/2).
%:- multifile(numb/1).
%:- dynamic(numb/1).
:- op(1200,xfx,<-).
:- op(500,fx,~).
/**********************************************************************
 *
 * @(#) lib.pl 1.22@(#)
 *
 */

motel_member(X, [X|_]    ).
motel_member(X, [_|L]) :-
        motel_member(X, L).

/**********************************************************************
 *
 * COUNTER
 *
 */

/**********************************************************************
 *
 * setCounter(+Counter,+Value)
 * creates a new counter Counter with valueOfCounter Value.
 *
 */

setCounter(Counter,N) :-
        assertaRE(valueOfCounter(Counter,N)),
        !.

/**********************************************************************
 *
 * addCounter(+Counter,+Value)
 * adds Value to the current valueOfCounter of counter Counter.
 *
 */
 
addCounter(Counter,N) :-
        retract(valueOfCounter(Counter,M)),
        Sum is N + M,
        assertaRE(valueOfCounter(Counter,Sum)),
        !.

/**********************************************************************
 *
 * getCounter(+Counter,-Value)
 * retrieves the current valueOfCounter Value of counter Counter.
 *
 */

getCounter(Counter,N) :-
        valueOfCounter(Counter,N),
        !.

/**********************************************************************
 *
 * writes(+List)
 * put each character in List.
 *
 */

writes([]) :- !.
writes([H|T]) :- put(H), writes(T).

/***********************************************************************
 *
 * printTime(+G)
 * execute goal G and report the runtime the execution needed.
 * Only available for SICStus Prolog and Quintus Prolog.
 *
 */

printTime(G) :-
	(currentProlog(poplog) ; currentProlog(macprolog)),
	!,
	call(G),
	!.
printTime(G) :-
	!,
	getRuntime(T0),
	printTime(G,T0).

printTime(G,T0) :-
	call(G),
	getRuntime(T1),
	T is T1 - T0,
	format('Total runtime ~3d sec.~n', [T]).
printTime(_,T0) :-
	getRuntime(T1),
	T is T1 - T0,
	format('Total runtime ~3d sec.~n', [T]),
	!,
	fail.

/**********************************************************************
 *
 * simple_term(X) 
 * it contrast to the usage in the Quintus Prolog user manual we
 * call a term `simple` if it is either an atom or a variable.
 * This predicate succeeds iff X is a simple term in this sense.
 *
 */

simple_term(X) :-
	var(X),
	!.
simple_term(X) :-
	atomic(X),
	!.

/**********************************************************************
 *
 * LIBRARY HANDLING
 *
 */

loadLibraries(sicstus) :-
	assertzRE((gensym(Prefix, V) :-
	var(V),
	atomic(Prefix),
	(   retract(gensym_counter(Prefix, M))
	;   M = 0
	),
	N is M+1,
	assertaRE(gensym_counter(Prefix, N)),
	atom_codes(Prefix,P1),
	atom_codes(N,N1),
	append(P1,N1,V1),
	atom_codes(V,V1),
	!)),
	assertzRE((getTwoRandomNumbers(RT,CT) :-
	statistics(runtime,[RT,CT]))),
	assertzRE((getRuntime(RT) :-
	statistics(runtime,[RT|_]))),
	assertzRE((append([],L2,L2))),
	assertzRE((append([A1|L1],L2,[A1|L3]) :-
	append(L1,L2,L3))),
	assertzRE((not(Goal) :- call(\+ Goal))),
	assertzRE((once(Goal) :- Goal, !)),
	assertzRE((onceOrMore(Goal) :- isMooOption(allProofs,yes), Goal)),
	assertzRE((onceOrMore(Goal) :- not(isMooOption(allProofs,yes)), Goal, !)),
	assertzRE((motel_ask(A1) :- deduce(A1))),
	assertzRE((motel_ask(A1,A2) :- deduce(A1,A2))),
	assertzRE((motel_ask(A1,A2,A3) :- deduce(A1,A2,A3))),
	assertzRE((motel_ask(A1,A2,A3,A4) :- deduce(A1,A2,A3,A4))),
	assertzRE((map(A1,A2,A3) :- hop_map(A1,A2,A3))),
	assertzRE((map(A1,A2,A3,A4) :- hop_map(A1,A2,A3,A4))),
	!.
loadLibraries(eclipse) :-
	assertzRE((gensym(Prefix, V) :-
	var(V),
	atomic(Prefix),
	(   retract(gensym_counter(Prefix, M))
	;   M = 0
	),
	N is M+1,
	assertaRE(gensym_counter(Prefix, N)),
	atom_codes(Prefix,P1),
	atom_codes(N,N1),
	append(P1,N1,V1),
	atom_codes(V,V1),
	!)),
	assertzRE((getTwoRandomNumbers(RT,CT) :-
	statistics(runtime,[RT,CT]))),
	assertzRE((getRuntime(RT) :-
	statistics(times,[RT|_]))),
	assertzRE((append([],L2,L2))),
	assertzRE((append([A1|L1],L2,[A1|L3]) :-
	append(L1,L2,L3))),
	assertzRE((motel_ask(A1) :- deduce(A1))),
	assertzRE((motel_ask(A1,A2) :- deduce(A1,A2))),
	assertzRE((motel_ask(A1,A2,A3) :- deduce(A1,A2,A3))),
	assertzRE((motel_ask(A1,A2,A3,A4) :- deduce(A1,A2,A3,A4))),
	assertzRE((map(A1,A2,A3) :- hop_map(A1,A2,A3))),
	assertzRE((map(A1,A2,A3,A4) :- hop_map(A1,A2,A3,A4))),
	assertzRE((onceOrMore(Goal) :- isMooOption(allProofs,yes), Goal)),
	assertzRE((onceOrMore(Goal) :- not(isMooOption(allProofs,yes)), Goal, !)),
	!.
loadLibraries(swiprolog) :-
	assertzRE((motel_ask(A1) :- deduce(A1))),
	assertzRE((motel_ask(A1,A2) :- deduce(A1,A2))),
	assertzRE((motel_ask(A1,A2,A3) :- deduce(A1,A2,A3))),
	assertzRE((motel_ask(A1,A2,A3,A4) :- deduce(A1,A2,A3,A4))),
	assertzRE((map(A1,A2,A3) :- hop_map(A1,A2,A3))),
	assertzRE((map(A1,A2,A3,A4) :- hop_map(A1,A2,A3,A4))),
	assertzRE((portray(not(F)) :- display(not(F)))),
	assertzRE((getTwoRandomNumbers(RT,CT) :-
	statistics(cputime,RT1), RT is (ceil(RT1 * 100000)) mod 100000, statistics(atoms,CT))),
	assertzRE((getRuntime(RT) :-
	statistics(cputime,RT1), RT is ceil(RT1 * 1000))),
	index(kb_in(1,0,0,0,1,1,0,0,0,0)),
	index(eq(1,0,0,1,1,0,0,0,0)),
	index(constraint(1,0,0,1,0,0,0,0)),
	assertzRE((retractallSpecial(Head) :- retract(Head), fail)),
	assertzRE((retractallSpecial(Head) :- retract((Head :- _Body)), fail)),
	assertzRE((retractallSpecial(_))),
	assertzRE((onceOrMore(Goal) :- isMooOption(allProofs,yes), Goal)),
	assertzRE((onceOrMore(Goal) :- not(isMooOption(allProofs,yes)), Goal, !)).


loadLibraries(poplog) :-
	op(600,xfy,':'),
	assertzRE((gensym(Prefix, V) :-
	var(V),
	atomic(Prefix),
	(   retract(gensym_counter(Prefix, M))
	;   M = 0
	),
	N is M+1,
	assertaRE(gensym_counter(Prefix, N)),
	atom_codes(Prefix,P1),
	atom_codes(N,N1),
	append(P1,N1,V1),
	atom_codes(V,V1),
	!)),
	assertzRE((append([],L2,L2))),
	assertzRE((append([A1|L1],L2,[A1|L3]) :-
	append(L1,L2,L3))),
	assertzRE((motel_ask(A1) :- deduce(A1))),
	assertzRE((motel_ask(A1,A2) :- deduce(A1,A2))),
	assertzRE((motel_ask(A1,A2,A3) :- deduce(A1,A2,A3))),
	assertzRE((motel_ask(A1,A2,A3,A4) :- deduce(A1,A2,A3,A4))),
	assertzRE((map(A1,A2,A3) :- hop_map(A1,A2,A3))),
	assertzRE((map(A1,A2,A3,A4) :- hop_map(A1,A2,A3,A4))),
	assertzRE((once(Goal) :- Goal, !)),
	assertzRE((onceOrMore(Goal) :- isMooOption(allProofs,yes), Goal)),
	assertzRE((onceOrMore(Goal) :- not(isMooOption(allProofs,yes)), Goal, !)),
	assertzRE((saveMOTEL(F) :- save_program(F))),
	!.
loadLibraries(quintus) :-
	op(300,fx,'~'),
	assertzRE((gensym(Prefix, V) :-
	var(V),
	atomic(Prefix),
	(   retract(gensym_counter(Prefix, M))
	;   M = 0
	),
	N is M+1,
	assertaRE(gensym_counter(Prefix, N)),
	atom_codes(Prefix,P1),
	atom_codes(N,N1),
	append(P1,N1,V1),
	atom_codes(V,V1),
	!)),
	assertzRE((getTwoRandomNumbers(RT,CT) :-
	statistics(runtime,[RT,CT]))),
	assertzRE((getRuntime(RT) :-
	statistics(runtime,[RT|_]))),
	assertzRE((not(Goal) :- call(\+ Goal))),
	assertzRE((once(Goal) :- Goal, !)),
	assertzRE((onceOrMore(Goal) :- isMooOption(allProofs,yes), Goal)),
	assertzRE((onceOrMore(Goal) :- not(isMooOption(allProofs,yes)), Goal, !)),
	assertzRE((motel_ask(A1) :- deduce(A1))),
	assertzRE((motel_ask(A1,A2,A3,A4) :- deduce(A1,A2,A3,A4))),
	assertzRE((motel_ask(A1,A2) :- deduce(A1,A2))),
	assertzRE((motel_ask(A1,A2,A3) :- deduce(A1,A2,A3))),
	assertzRE((map(A1,A2,A3) :- hop_map(A1,A2,A3))),
	assertzRE((map(A1,A2,A3,A4) :- hop_map(A1,A2,A3,A4))),
	assertzRE((saveMOTEL(F) :- save_program(F))),
	!.
loadLibraries(macprolog) :-
	op(600,xfy,':'),
	!.

loadLibraries(xsbprolog) :-
	op(300,fx,'~'),
%	consult(setof),
%       compile(setof),
%        import setof/3, bagof/3,  findall/3, sort/2, keysort/2,'^'/2 from setof,
	!.

testForMacprolog(others) :-
	current_op(_X,_Y,':'),
	!,
	fail.
testForMacprolog(macprolog) :-
	unknown(_X,fail),
	!.

getLibraries :-
	testForMacprolog(_),
	!,
	assertaRE(currentProlog(macprolog)),
	version('MOTEL-0.8.5 June 1994'),
	loadLibraries(macprolog).
getLibraries :-
	current_op(1190,fx,delay),
	!,
	sicstus,
	assertaRE(currentProlog(eclipse)),
	set_flag(variable_names,off),
	loadLibraries(eclipse).

getLibraries :-
	current_op(_X,_Y,?),
	style_check(-singleton),
	!,
	assertaRE(currentProlog(swiprolog)),
	style_check(-discontiguous),
	loadLibraries(swiprolog).

getLibraries :-
	setof((X,Y),prolog_flag(X,Y),L),
	motel_member((single_var,_Z),L),
	!,
	assertaRE(currentProlog(quintus)),
	version('MOTEL-0.8.5 June 1994'),
	prolog_flag(single_var,_,off),
	loadLibraries(quintus).
getLibraries :-
	current_op(_X,hy,_Y),
	loadLibraries(xsbprolog),
	!.
getLibraries :-
	prolog_flag(_X,_Y),
	!,
	assertaRE(currentProlog(sicstus)),
	version('MOTEL-0.8.5 June 1994'),
	prolog_flag(single_var_warnings,_,off),
	(prolog_flag(compiling,_,fastcode) ; true),
	prolog_flag(unknown,_,fail),
%	assertaRE(foreign_file('int.o',[int_init])),
%	assertaRE(foreign(int_init,int_init)),
%	load_foreign_files(['int.o'],[]),
%	int_init,
	loadLibraries(sicstus).
getLibraries :-
	tell('/tmp/v1'), version, told,
	!,
	assertaRE(currentProlog(poplog)),
	version('MOTEL-0.8.5 June 1994'),
	loadLibraries(poplog).

/**********************************************************************
 *
 * OPTIONS
 *
 */

/***********************************************************************
 *
 * setMooOption(+Option,+Set)
 * set isMooOption Option to valueOfCounter Set.
 *
 */

setMooOption(Option,Set) :-
	retractallSpecial(isMooOption(Option,_)),
	assertaRE(isMooOption(Option,Set)),
	!.

/**********************************************************************
 *
 * ifMooOption(+Option,+Set,+Goal)
 * executes Goal if the current valueOfCounter of Option is Set otherwise
 * the predicate suceeds.
 *
 */

ifMooOption(Option,Set,Goal) :-
	isMooOption(Option,Set),
	call(Goal),
	!.
ifMooOption(_,_,_) :-
	!.

retractallSpecial(Env,Pred/Arity) :-
	constructHead(Env,Pred/Arity,Head),
	retractallSpecial(Head), 
	!.


:- getLibraries.




/**********************************************************************
 *
 * @(#) sets.pl 1.1@(#)
 *
 */

%   member(?Element, ?Set)
%   is true when Set is a list, and Element occurs in it.  It may be used
%   to test for an element or to enumerate all the elements by backtracking.
%   Indeed, it may be used to generate the Set!
/*

member(X, [X|_]    ).
member(X, [_,X|_]  ).
member(X, [_,_,X|_]).
member(X, [_,_,_|L]) :-
        member(X, L).
*/

%   reverseList(+List1,-List2
%   reverses the list List1 to get List2

reverseList([],[]) :- !.
reverseList([H|T],L2) :-
	reverseList(T,L1),
	append(L1,[H],L2),
	!.

%   memberchkSpecial(+Element, +Set)
%   means the same thing, but may only be used to test whether a known
%   Element occurs in a known Set.  In return for this limited use, it
%   is more efficient than member/2 when it is applicable.

memberchkSpecial(X, L) :- 
	nonvar(X), 
	nonvar(L),
	memberchk(X,L).


%   nonmember(+Element, +Set)
%   means that Element does not occur in Set.  It does not make sense
%   to instantiate Element in any way, as there are infinitely many
%   terms which do not occur in any given set.  Nor can we generate
%   Set; there are infinitely many sets not containing a given Element.
%   Read it as "the given Element does not occur in the given list Set".
%   This code was suggested by Bruce Hakami; seven versions of this
%   operation were benchmarked and this found to be the fastest.
%   The old code was for DEC-10 Prolog, which did not compile (\+)/1.

nonmember(Element, Set) :-
	nonvar(Element),
	nonvar(Set),
	not(member(Element, Set)).

%   intersectionOfLists(+Set1, +Set2, ?Intersection)
%   is true when all three arguments are lists representing sets,
%   and Intersection contains every element of Set1 which is also
%   an element of Set2, the order of elements in Intersection
%   being the same as in Set1.  That is, Intersection represents
%   the intersectionOfLists of the sets represented by Set1 and Set2.
%   If Set2 is a partial list, Intersection will be empty, which
%   is not, of course, correct.  If Set1 is a partial list, this
%   predicate will run away on backtracking.  Set1 and Set2 should
%   both be proper lists, but this is not checked.  Duplicates in
%   Set1 may survive in Intersection.  It is worthy of note that
%   if Set1 is an ordset, Intersection is an ordset, despite Set2.

intersectionOfLists([], _, []).
intersectionOfLists([Element|Elements], Set, Intersection) :-
	memberchkSpecial(Element, Set),
	!,
	Intersection = [Element|Rest],
	intersectionOfLists(Elements, Set, Rest).
intersectionOfLists([_|Elements], Set, Intersection) :-
	intersectionOfLists(Elements, Set, Intersection).



%   intersectionOfLists(+ListOfSets, ?Intersection)
%   is true when Intersection is the intersectionOfLists of all the sets in
%   ListOfSets.  The order of elements in Intersection is taken from
%   the first set in ListOfSets.  This has been turned inside out to
%   minimise the storage turnover.

intersectionOfLists([Set|Sets], Intersection) :-
	intersection1(Set, Sets, Intersection).

intersection1([], _, []).
intersection1([Element|Elements], Sets, Intersection) :-
	memberchk_all(Sets, Element),
	!,
	Intersection = [Element|Rest],
	intersection1(Elements, Sets, Rest).
intersection1([_|Elements], Sets, Intersection) :-
	intersection1(Elements, Sets, Intersection).

memberchk_all([], _).
memberchk_all([Set|Sets], Element) :-
	memberchkSpecial(Element, Set),
	memberchk_all(Sets, Element).

%   prologListSubtract(+Set1, +Set2, ?Difference)
%   is like intersect, but this time it is the elements of Set1 which
%   *are* in Set2 that are deleted.  Note that duplicated Elements of
%   Set1 which are not in Set2 are retained in Difference.


prologListSubtract([], _, []).
prologListSubtract([Element|Elements], Set, Difference) :-
	memberchkSpecial(Element, Set),
	!,
	prologListSubtract(Elements, Set, Difference).
prologListSubtract([Element|Elements], Set, [Element|Difference]) :-
	prologListSubtract(Elements, Set, Difference).

%   unionSpecial(+Set1, +Set2, ?Union)
%   is true when prologListSubtract(Set1,Set2,Diff) and append(Diff,Set2,Union),
%   that is, when Union is the elements of Set1 that do not occur in
%   Set2, followed by all the elements of Set2.

unionSpecial([], Union, Union).
unionSpecial([Element|Elements], Set, Union) :-
	memberchkSpecial(Element, Set),
	!,
	unionSpecial(Elements, Set, Union).
unionSpecial([Element|Elements], Set, [Element|Union]) :-
	unionSpecial(Elements, Set, Union).

%   unionSpecial(+ListOfSets, ?Union)
%   is true when Union is the unionSpecial of all sets in ListOfSets.


unionSpecial([],[]).
unionSpecial([Set1],Set1).
unionSpecial([Set1,Set2|Sets],Union) :-
	unionSpecial(Set1,Set2,Set),
	unionSpecial([Set|Sets],Union).


%   special_list_to_set(+List, ?Set)
%   is true when List and Set are lists, and Set has the same elements
%   as List in the same order, except that it contains no duplicates.
%   The two are thus equal considered as sets.  If you really want to
%   convert a list to a set, list_to_ord_set is faster, but this way
%   preserves as much of the original ordering as possible.
%   If List contains several copies of an element X, only the LAST
%   copy of X is retained.  If you want to convert a List to a Set,
%   retaining the FIRST copy of repeated elements, call
%	symdiff([], List, Set)


special_list_to_set([], []).
special_list_to_set([Head|Tail], Set) :-
	memberchkSpecial(Head, Tail),
	!,
	special_list_to_set(Tail, Set).
special_list_to_set([Head|Tail], [Head|Set]) :-
	special_list_to_set(Tail, Set).


%   deleteInList(+List, +Kill, ?Residue)
%   is true when List is a list, in which Kill may or may not occur, and
%   Residue is a copy of List with all elements equal to Kill deleted.
%   To extract a single copy of Kill, use select(Kill, List, Residue).
%   If List is not proper, deleteInList/3 will FAIL.  Kill and the elements of
%   List should be sufficiently instantiated for \= to be sound.

deleteInList(-, _, _) :- !, fail.		% reject partial lists
deleteInList([], _, []).
deleteInList([Kill|Tail], Kill, Residue) :- !,
	deleteInList(Tail, Kill, Residue).
deleteInList([Head|Tail], Kill, [Head|Residue]) :-
    %	Head \= Kill,
	deleteInList(Tail, Kill, Residue).


subsetSpecial([],_S2) :- !.
subsetSpecial([E1|S1],S2) :-
	\+ ( \+ (member(E1,S2))),
	subsetSpecial(S1,S2),
	!.

equalset(S1,S2) :-
	subsetSpecial(S1,S2),
	subsetSpecial(S2,S1),
	!.

%----------------------------------------------------------------------	
%   Module : lists
%   Authors: Bob Welham, Lawrence Byrd, and Richard A. O'Keefe
%   Updated: 10/25/90
%   Defines: list processing utilities
%   SeeAlso: library(logicalFlatten)

%   Adapted from shared code written by the same authors; all changes
%   Copyright (C) 1987, Quintus Computer Systems, Inc.  All rights reserved.

%   perm(+List, ?Perm)
%   is true when List and Perm are permutations of each other.  The main
%   use of perm/2 is to generate permutations.  You should not use this
%   predicate in new programs; use permutation/2 instead.  List must be
%   a proper list.  Perm may be partly instantiated.

perm([], []).
perm([X|Xs], Ys1) :-
	perm(Xs, Ys),
	insert(Ys, X, Ys1).


insert(L, X, [X|L]).
insert([H|T], X, [H|L]) :-
	insert(T, X, L).

%   permutation(?List, ?Perm)
%   is true when List and Perm are permuations of each other.
%   Unlike perm/2, it will work even when List is not a proper list.
%   It even acts in a marginally sensible way when Perm isn't proper
%   either, but it will still backtrack forever.
%   Be careful: this is quite efficient, but the number of permutations of an
%   N-element list is N!, and even for a 7-element list that is 5040.

permutation(List, Perm) :-
	permutation(List, Perm, Perm).

permutation([], [], []).
permutation([X|Xs], Ys1, [_|Zs]) :-
	permutation(Xs, Ys, Zs),
	insert(Ys, X, Ys1).



% Copyright (C) 1993 Patrick Brandmeier
%                    Ullrich Hustadt
%                    Renate  Schmidt
%                    Jan     Timm

% This file is part of the MOTEL distribution.

% MOTEL is free software; you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation; either version 1, or (at your isMooOption)
% any later version.

% MOTEL is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
/**********************************************************************
 *
 * @(#) abduction.pl 1.2@(#)
 *
 */

getAbductionHyps(L,[]) :-
	var(L),
	!.
getAbductionHyps([],[]) :-
	!.
getAbductionHyps([in(Env,RN,modal(MS),C,X,A1,A2,A3,A4)|L1],
	[in(Env,RN,modal(MS),C,X,A1,A2,A3,A4)|L2]) :-
	!,
	getAbductionHyps(L1,L2).

doMinimalityCheck(GL1,[in(Env,RN,modal(MS),C,X,_A1,_A2,_A3,_A4)|GL2]) :-
	append(GL1,GL2,GL),
	HYPS = [or(GL),rl([]),fl(H3)],
	constructMLCall(Env,rn(_AX3,_RN3,_S3,_O3),bodyMC(MS),headMC(MS),
	                C,X,HYPS,[],CALLS,_PT35,Goal),
	not(Goal),
	doMinimalityCheck([in(Env,RN,modal(MS),C,X,_A1,_A2,_A3,_A4)|GL1],
	                   GL2),
	!.
doMinimalityCheck(_GL1,[]) :-
	!.
	

doConsistencyCheck(GL1,[in(Env,RN,modal(MS),C,X,_A1,_A2,_A3,_A4)|GL2]) :-
	append(GL1,GL2,GL),
	HYPS = [or(GL),rl([]),fl(H3)],
	normalizeNot(not(C),C1),
	constructMLCall(Env,rn(_AX3,_RN3,_S3,_O3),bodyMC(MS),headMC(MS),
	                C1,X,HYPS,[],CALLS,_PT35,Goal),
	not(Goal),
	doConsistencyCheck([in(Env,RN,modal(MS),C,X,_A1,_A2,_A3,_A4)|GL1],
	                   GL2),
	!.
doConsistencyCheck(_GL1,[]) :-
	!.
	

	
/**********************************************************************
 *
 * @(#) callStack.pl 1.5@(#)
 *
 */

/**********************************************************************
 *
 * THE CALL STACK 
 * is a list of elements of the following form:
 * - true 
 * - in(rn(AX,RN,_,_),modal(MS),C,X,hyp(HYPS))
 * - eq(rn(AX,RN,_,_),modal(MS),X,Y,hyp(HYPS))
 * - constraint(rn(AX,RN,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(HYPS))
 *
 */

/***********************************************************************
 * 
 * checkCallStack(+CallStack,Call)
 * succeeds if the top call on CallStack is not already contained
 * elsewhere in CallStack and Call is not already contained in CallStack.
 * This predicate is used to prevent nontermination.
 *
 */

checkCallStack([],_) :- !.
checkCallStack(IL,A1) :-
%	print('trying '), print(A1), nl,
	noAxiom(A1,IL),
%	IL = [I1|IL1],
	noDouble(IL),
%	printAxiom(A1), nl,
%	print('------------------------------------------------------------'),
%	nl,
	not(clashCS([A1|IL])),
	!.

testEqualAbductiveHypotheses(D1,D2) :-
	currentEnvironment(Env),
	abductiveDerivation(Env,D1,HL1),
	abductiveDerivation(Env,D2,HL2),
	!,
	equalset(HL1,HL2),
	!.
testEqualAbductiveHypotheses(_D1,_D2) :-
	!.

testEqualHypotheses(H1,H2) :-
%	equalset(H1,H2),
	!.


functionalSubterm(Term,Term) :-
	!.
functionalSubterm(app(F:R,Term),Term) :-
	not(atomic(Term)),
	!.
functionalSubterm(app(F:R,Term1),Term2) :-
	not(atomic(Term2)),
	functionalSubterm(Term1,Term2),
	!.

% To prove in(C,X) it is not allowed to use another in-clause generated 
% from the same axiom
sameAxiom(AX,_RN1,MS1,in(C1,X1),HYPS1,D1,
          in(rn(AX,_RN2,_,_),modal(MS2),C2,X2,hyp(HYPS2),ab(D2))) :- 
	not(not(functionalSubterm(X1,X2))),
	not(not(C1 = C2)),
	testEqualAbductiveHypotheses(D1,D2),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,in(_C,X1),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),X2,_,hyp(HYPS2))) :- 
	nonvar(X1),
	nonvar(X2),
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,in(_C,X1),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),_,X2,hyp(HYPS2))) :- 
	not(not(functionalSubterm(X1,X2))),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
% To prove in(C,X) it is not allowed to use a constraint-clause generated 
% from the same axiom
sameAxiom(AX,_RN1,MS1,in(_C,X1),HYPS1,_D1,
          constraint(rn(AX,_RN2,_,_),MS2,(card,app(_,X2),_Rel,_N),hyp(HYPS2))) :- 
	not(not(functionalSubterm(X1,X2))),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,in(_C,X1),HYPS1,_D1,
          solveConstraint(rn(AX,_RN2,_,_),MS2,(card,app(_,X2),_Rel,_N),hyp(HYPS2))) :- 
	not(not(functionalSubterm(X1,X2))),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,eq(X1,_Y),HYPS1,_D1,
          in(rn(AX,_RN2,_,_),modal(MS2),_C,X2,hyp(HYPS2),ab(_D2))) :- 
	nonvar(X1),
	nonvar(X2),
	not(not(functionalSubterm(X1,X2))),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,eq(_X,Y1),HYPS1,_D1,
          in(rn(AX,_RN2,_,_),modal(MS2),_C,Y2,hyp(HYPS2),ab(_D2))) :- 
	not(not(functionalSubterm(Y1,Y2))),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,eq(X1,Y1),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),X2,Y2,hyp(HYPS2))) :- 
	not(not(functionalSubterm(X1,X2))),
	not(not(functionalSubterm(Y1,Y2))),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,eq(X1,app(_Y1)),HYPS1,_D1,
          constraint(rn(AX,_RN2,_,_),MS2,(card,app(_,X2),_Rel,_N),hyp(HYPS2))) :-   
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), 
	!.
sameAxiom(AX,_RN1,MS1,eq(_X,app(_F1:R1,Y1)),HYPS1,_D1,
          constraint(rn(AX,_RN2,_,_),MS2,(card,app(_F2:R2,Y2),_Rel,_N),hyp(HYPS2))) :-
	not(not(R1 = R2)),
	not(not(Y1 = Y2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,eq(X1,app(_Y1)),HYPS1,_D1,
          solveConstraint(rn(AX,_RN2,_,_),MS2,(card,app(_,X2),_Rel,_N),hyp(HYPS2))) :-   
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), 
	!.
sameAxiom(AX,_RN1,MS1,eq(_X,app(_F1:R1,Y1)),HYPS1,_D1,
          solveConstraint(rn(AX,_RN2,_,_),MS2,(card,app(_F2:R2,Y2),_Rel,_N),hyp(HYPS2))) :-
	not(not(R1 = R2)),
	not(not(Y1 = Y2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,eq(_X,Y1),HYPS1,_D1,
          solveConstraint(rn(AX,_RN2,_,_),MS2,(card,app(_,Y2),_Rel,_N),hyp(HYPS2))) :-
	not(not(Y1 = Y2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,c(X1,_,_),HYPS1,_D1,
          in(rn(AX,_RN2,_,_),modal(MS2),_,X2,hyp(HYPS2),ab(_D2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,c(X1,_,_),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),X2,_,hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,c(X1,_,_),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),X2,_,hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,c(X1,_,_),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),_,app(_,X2),hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,c(X1,R1,Rel1),HYPS1,_D1,
          constraint(rn(AX,_RN2,_,_),MS2,(card,app(_F:R2,X2),Rel2,_N),hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	not(not(R1 = R2)),
	not(not(Rel1 = Rel2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,c(X1,R1,Rel1),HYPS1,_D1,
          solveConstraint(rn(AX,_RN2,_,_),MS2,(card,app(_F:R2,X2),Rel2,_N),hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	not(not(R1 = R2)),
	not(not(Rel1 = Rel2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,sc(X1,_,_),HYPS1,_D1,
          in(rn(AX,_RN2,_,_),modal(MS2),_,X2,hyp(HYPS2),ab(_D2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,sc(X1,_,_),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),X2,_,hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,sc(X1,_,_),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),X2,_,hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,sc(X1,_,_),HYPS1,_D1,
          eq(rn(AX,_RN2,_,_),modal(MS2),_,app(_,X2),hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,sc(X1,R1,Rel1),HYPS1,_D1,
          constraint(rn(AX,_RN2,_,_),MS2,(card,app(_F:R2,X2),Rel2,_N),hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	not(not(R1 = R2)),
	not(not(Rel1 = Rel2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(AX,_RN1,MS1,sc(X1,R1,Rel1),HYPS1,_D1,
          solveConstraint(rn(AX,_RN2,_,_),MS2,(card,app(_F:R2,X2),Rel2,_N),hyp(HYPS2))) :- 
	not(not(X1 = X2)),
	not(not(R1 = R2)),
	not(not(Rel1 = Rel2)),
	testEqualHypotheses(HYPS1,HYPS2),
	equalWorlds(MS1,MS2), !.
sameAxiom(_AX,_,_,_,_,_,_) :- !, fail.

equalWorlds(W1,W2) :-
	var(W1),
	var(W2),
	!.
equalWorlds(W1,W2) :-
	var(W1),
	nonvar(W2),
	!,
	fail.
equalWorlds(W1,W2) :-
	var(W2),
	nonvar(W1),
	!,
	fail.
equalWorlds([],[]) :-
	!.
equalWorlds(app(_F:m(_MOp,_A),_W1),[]) :-
	!,
	fail.
equalWorlds([],app(_F:m(_MOp,_A),_W2)) :-
	!,
	fail.
equalWorlds(app(F1:m(MOp,A1),W1),app(F2:m(MOp,A2),W2)) :-
	A1 == A2,
%	var(F1),
%	var(F2),
%       not(not(F1 = F2)),
	!,
	equalWorlds(W1,W2).
equalWorlds(app(F1:m(MOp,A1),_W1),app(F2:m(MOp,A2),_W2)) :-
	A1 == A2,
	nonvar(F1),
	nonvar(F2),
	not(not(F1 = F2)),
	!.
equalWorlds(_W1,_W2) :-
	!,
	fail.
	

noAxiom(true,_) :- !.
noAxiom(_,[]) :- !.
noAxiom(in(rn(AX,RN,_,_),modal(MS),C,X,hyp(HYPS),ab(D)),[C1|CL]) :-
	not(sameAxiom(AX,RN,MS,in(C,X),HYPS,D,C1)),
	noAxiom(in(rn(AX,RN,_,_),modal(MS),C,X,hyp(HYPS),ab(D)),CL).
noAxiom(eq(rn(AX,RN,_,_),modal(MS),X,Y,hyp(HYPS)),[C1|CL]) :-
	not(sameAxiom(AX,RN,MS,eq(X,Y),HYPS,_D,C1)),
	noAxiom(eq(rn(AX,RN,_,_),modal(MS),X,Y,hyp(HYPS)),CL).
noAxiom(constraint(rn(AX,RN,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(HYPS)),[C1|CL]) :-
	not(sameAxiom(AX,RN,MS,c(X,R,Rel),HYPS,_D,C1)),
	noAxiom(constraint(rn(AX,RN,_,_),MS,(card,app(_,X),Rel,N),hyp(HYPS)),CL).
noAxiom(solveConstraint(rn(AX,RN,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(HYPS)),[C1|CL]) :-
	not(sameAxiom(AX,RN,MS,sc(X,R,Rel),HYPS,_D,C1)),
	noAxiom(solveConstraint(rn(AX,RN,_,_),MS,(card,app(_,X),Rel,N),hyp(HYPS)),CL).

noDouble([in(rn(AX,RN,_,_),modal(MS),not(C),X,hyp(_HYPS1),ab(D))|IL]) :-
	!,
	not((member(in(rn(AX1,RN1,_,_),modal(MS),not(C),X1,hyp(_HYPS2),ab(D)),IL), functionalSubterm(X,X1))),
	not((member(in(rn(AX2,RN2,_,_),modal(MS),C,X,hyps(_HYPS3),ab(noAb)),IL),functionalSubterm(X,X1))),
	!,
	noDouble(IL).
noDouble([in(rn(AX,RN,_,_),modal(MS),C,X,hyp(_HYPS1),ab(D))|IL]) :-
	!,
	not((member(in(rn(AX1,RN1,_,_),modal(MS),C,X1,hyp(_HYPS2),ab(D)),IL), functionalSubterm(X,X1))),
	not((member(in(rn(AX2,RN2,_,_),modal(MS),not(C),X1,hyps(_HYPS3),ab(noAb)),IL),functionalSubterm(X,X1))),
	!,
	noDouble(IL).
noDouble([eq(rn(AX,RN,_,_),modal(MS),X,Y,hyp(_HYPS1))|IL]) :-
	!,
	not(member(eq(rn(AX1,RN1,_,_),modal(MS),X,Y,hyp(_HYPS2)),IL)),
	!,
	noDouble(IL).
noDouble([constraint(rn(AX,RN,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(_HYPS1))|IL]) :-
	!,
	not(member(constraint(rn(AX1,RN1,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(_HYPS2)),IL)),
	!,
	noDouble(IL).
noDouble([solveConstraint(rn(AX,RN,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(_HYPS1))|IL]) :-
	!,
	not(member(solveConstraint(rn(AX1,RN1,_,_),MS,(card,app(_F:R,X),Rel,N),hyp(_HYPS2)),IL)),
	!,
	noDouble(IL).
noDouble([solveConstraint(Env1,RL1,noEquivalence,hyp(_HYPS1))|IL]) :-
	!,
	not(member(solveConstraint(Env1,RL1,noEquivalence,hyp(_HYPS2)),IL)),
	!,
	noDouble(IL).
noDouble([I1|IL]) :-
	not(member(I1,IL)),
	!,
	noDouble(I1,IL).
noDouble([]) :-
	!.

printAxiom(solveConstraint(MS,(card,app((_FF:R),X),Rel,N),hyp(HYPS))) :-
	print('axiom???'),
	print('   '),
	print(solveConstraint(MS,(app(R,X),Rel,N),hyp(HYPS))),
	!.
printAxiom(eq(rn(AX,RN,_,_),modal(MS),Y,app((_FF:R),X),hyp(HYPS))) :-
	print(rn(AX,RN)),
	print('   '),
	print(eq(MS,Y,app(R,X),hyp(HYPS))),
	!.
printAxiom(in(rn(AX,RN,_,_),modal(_MS),CN,CON,hyp(HYP))) :-
	print(rn(AX,RN)),
	print('   '),
	print(in(CN,CON,hyp(HYP))),
	!.
printAxiom(constraint(rn(AX,RN,_,_),MS,(card,app((_FF:R),X),Rel,N),hyp(HYPS))) :-
	print(rn(AX,RN)),
	print('   '),
	print(constraint(MS,(app(R,X),Rel,N),hyp(HYPS))),
	!.
printAxiom(true) :-
	!.

/**********************************************************************
 *
 * clashCS(+CL)
 * succeeds if CL is a clash, i.e. it obeys one of the following 
 * conditions:
 * - it contains in(bot,X) for some X.
 * - it contains both in(A,X) and in(not(A),X) for some A and some X.
 *
 */

last([],[],_) :-
	!,
	fail.
last([L1],[],L1) :-
	!.
last([L1|LL1],[L1|LL2],Last) :-
	last(LL1,LL2,Last),
	!.

generateClashGoal(CS1,Goal) :-
	last(CS1,CS2,in(rn(AX,RN,S,O),modal(W1),C,X,hyp(HYPS))),
	getCurrentEnvironment(EnvName),
	environment(EnvName,Env,_),
	constructMLHead(Env,rn(_AX1,_RN1,user,_O1),W1,C1,X,CS1,noAb,[],_,Goal),
	!.

		
clashCS(CL) :-
	retract(clashTest(possible)),
	assertzRE(clashTest(impossible)),
	generateClashGoal(CL,Goal),
	!,
	doClashTest(Goal).
clashCS(_CL) :-
	!,
	fail.
	
doClashTest(InHead1) :-
	call(InHead1),
	InHead1 = in(Env,_,modal(W1),C1,X,hyp(HYP),ab(_),call(_CALL),_),
	atomic(X),
	normalizeNot(not(C1),C2),
	constructMLHead(Env,rn(_AX2,_RN2,_S2,_O2),W1,C2,X,HYP,noAb,[],_,InHead2),
	call(InHead2),
	print('Clash test succeeded for'), nl,
	print(HYP), nl,
	print('and'), nl,
	print(InHead1), nl,
	nl,
	retract(clashTest(impossible)),
	assertzRE(clashTest(possible)),
	!.
doClashTest(Goal) :-
	% the clash goal has failed, so there is no clash
	print('Clash test succeeded for'), nl,
	print(HYP), nl,
	nl,
	retract(clashTest(impossible)),
	assertzRE(clashTest(possible)),
	!,
	fail.




% clashCS(CL) :-
% 	clashTest(possible),
% 	member(in(rn(_,_,_,_),modal(_MS),bot,_X,hyp(_HYPS1)),CL),
% 	!.
% clashCS(CL) :-
% 	clashTest(possible),
% 	member(in(rn(_,_,_,_),modal(MS),not(A),X,hyp(_HYPS1)),CL),
% 	member(in(rn(_,_,_,_),modal(MS),A,X,hyp(_HYPS2)),CL),
% 	!.
% clashCS(CL) :-
% 	clashTest(possible),
% 	member(constraint(rn(_,_,_,_),MS,
% 			  (card,app(_F1:R,X),'>=',N1),hyp(_HYPS1)),CL),
% 	member(constraint(rn(_,_,_,_),MS,
% 			  (card,app(_F2:R,X),'=<',N2),hyp(_HYPS2)),CL),
% 	number(N1),
% 	number(N2),
% 	N1 > N2,
% 	!.
% clashCS(CL) :-
% 	member(constraint(rn(_,_,_,_),MS,
% 			  (card,app(_F1:R,X),'=<',N1),hyp(_HYPS1)),CL),
% 	number(N1),
% 	countAllRoleFillersInCS(MS,R,X,CL,N2),
% 	N2 > N1,
% 	!.
% 		
% 		 
% countAllRoleFillersInCS(MS,R,X,CL,N) :-
% 	getAllRoleFillersInCS(MS,R,X,CL,[],RF),
% 	length(RF,N).
% 
% getAllRoleFillersInCS(_MS,_R,_X,[],RF,RF) :-
% 	!.
% getAllRoleFillersInCS(MS,R,X,
%    [eq(rn(_,_,_,_),modal(MS),Y,app(_F:R,X),hyp(_HYPS))|CL],RF1,RF2) :-
% 	nonvar(Y),
% 	nonvar(X),
% 	atomic(Y),
% 	not(member((X,Y),RF1)),
% 	!,
% 	getAllRoleFillersInCS(MS,R,CL,[(X,Y)|RF1],RF2).
% getAllRoleFillersInCS(MS,R,X,[_|CL],RF1,RF2) :-
% 	getAllRoleFillersInCS(MS,R,X,CL,RF1,RF2),
% 	!.

/**********************************************************************
 *
 * @(#) clash.pl 1.2@(#)
 *
 */

clashInHyp(CL) :-
	member(in(_,modal(_MS),bot,_X,hyp(_HYPS1),ab(_)),CL),
	!.
clashInHyp(CL) :-
	member(in(_N2,modal(MS2),A,X,hyp(_HYPS2),ab(_D2)),CL),
	atomic(A),
	member(in(_N1,modal(MS1),not(A),X,hyp(_HYPS1),ab(_D1)),CL),
	not(not(MS1 = MS2)),
	!.
% clashInHyp(CL) :-
% 	member(constraint(rn(_,_,_,_),MS,
% 			  (card,app(_F1:R,X),'>=',N1),hyp(_HYPS1)),CL),
% 	member(constraint(rn(_,_,_,_),MS,
% 			  (card,app(_F2:R,X),'=<',N2),hyp(_HYPS2)),CL),
% 	number(N1),
% 	number(N2),
% 	N1 > N2,
% 	!.
% clashInHyp(CL) :-
% 	member(constraint(rn(_,_,_,_),MS,
% 			  (card,app(_F1:R,X),'=<',N1),hyp(_HYPS1)),CL),
% 	number(N1),
% 	countAllRoleFillersInCS(MS,R,X,CL,N2),
% 	N2 > N1,
% 	!.
% 		
% 		 
% countAllRoleFillersInCS(MS,R,X,CL,N) :-
% 	getAllRoleFillersInCS(MS,R,X,CL,[],RF),
% 	length(RF,N).
% 
% getAllRoleFillersInCS(_MS,_R,_X,[],RF,RF) :-
% 	!.
% getAllRoleFillersInCS(MS,R,X,
%    [eq(rn(_,_,_,_),modal(MS),Y,app(_F:R,X),hyp(_HYPS))|CL],RF1,RF2) :-
% 	nonvar(Y),
% 	nonvar(X),
% 	atomic(Y),
% 	not(member((X,Y),RF1)),
% 	!,
% 	getAllRoleFillersInCS(MS,R,CL,[(X,Y)|RF1],RF2).
% getAllRoleFillersInCS(MS,R,X,[_|CL],RF1,RF2) :-
% 	getAllRoleFillersInCS(MS,R,X,CL,RF1,RF2),
% 	!.
% 
/**********************************************************************
 *
 * @(#) classifier.pl 1.12@(#)
 *
 */

/***********************************************************************
 *
 * subsumes(+Name1,+Name2)
 * Parameter: Name1     concept or role atom_codes
 *            Name2     concept or role atom_codes
 * true iff Name1 subsumes Name2 in modal context []
 * (so Name1 and Name2 must both be concept names or role names).
 *
 */

subsumes(N1,N2) :-
	getCurrentEnvironment(EnvName),
	subsumes(EnvName,[],N1,N2).

/***********************************************************************
 *
 * subsumes(+MS,+Name1,+Name2)
 * Parameter: MS        modal context
 *            Name1     concept or role atom_codes
 *            Name2     concept or role atom_codes
 * true iff Name1 subsumes Name2 (so Name1 and Name2 must both be
 * concept names or role names).
 *
 */

subsumes(MS,N1,N2) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	currentEnvironment(Env),
	clause(conceptName(Env,_MS1,_W1,N1),_),
	clause(conceptName(Env,_MS2,_W2,N2),_),
	!,
	subsumes(concepts,Env,MS,N1,N2).
subsumes(MS,N1,N2) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	currentEnvironment(Env),
	clause(roleName(Env,_MS1,_W1,N1),_),
	clause(roleName(Env,_MS2,_W2,N2),_),
	subsumes(roles,Env,MS,N1,N2).

subsumes(EnvName,MS,N1,N2) :-
	environment(EnvName,Env,_),
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	clause(conceptName(Env,_MS1,_W1,N1),_),
	clause(conceptName(Env,_MS2,_W2,N2),_),
	!,
	subsumes(concepts,Env,MS,N1,N2).
subsumes(EnvName,MS,N1,N2) :-
	environment(EnvName,Env,_),
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	currentEnvironment(Env),
	clause(roleName(Env,_MS1,_W1,N1),_),
	clause(roleName(Env,_MS2,_W2,N2),_),
	subsumes(roles,Env,MS,N1,N2).

subsumes(concepts,Env,MS,C,D) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	constructMLHead(Env,_RN1,W1,D,aaa,_HYPS,noAb,_CALLS,abox,InHeadD),
	assertaRE((InHeadD :- call(G1))),
 	getQuery(Env,W1,C,aaa,Exp,InHeadC),
%	convertToGoal(Env,_RN2,MS,C,aaa,[or([]),rl([]),fl(_DML1)],noAb,[],
%		      _PT2,InHeadC),
	call((call(G1), InHeadC)),
	retract((InHeadD :- _Body)).
subsumes(concepts,Env,MS,_C,D) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,_G1],_),
	constructMLHead(Env,_RN1,W1,D,aaa,_HYPS,noAb,_CALLS,abox,InHeadD),
	retract((InHeadD :- _Body)),
	!,
	fail.
subsumes(roles,Env,MS,R,S) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(skolem,SF),
	constructEqHead(Env,_RN1,W1,bbb,SF,S,aaa,_HYPS,noAb,_CALLS,abox,InHeadS),
	assertaRE((InHeadS :- call(G1))),
	constructEqHead(Env,_RN2,W1,bbb,_FF,R,aaa,[or([]),rl([]),fl(_DML1)],
			noAb,[],_PT2,InHeadR),
	call((G1, InHeadR)),
	retract((InHeadS :- _Body)).
subsumes(roles,Env,MS,_R,S) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,_G1],_),
	constructEqHead(Env,_RN2,W1,bbb,_FF,S,aaa,_HYPS,noAb,_CALLS,_,InHeadS),
	retract((InHeadS :- _Body)),
	!,
	fail.

/***********************************************************************
 *
 * classified(+MS,+Name)
 * succeeds iff Name is already in the appropriate subsumption hierarchy 
 * in modal context MS.
 *
 */

classified(Env,MS,Concept) :-
	clause(conceptName(Env,_MS1,_W1,Concept),_),
	!,
	conceptHierarchy(Env,MS,Tree),
	search(Concept,Tree).
classified(Env,MS,Role) :-
	clause(roleName(Env,_MS1,_W1,Role),_),
	roleHierarchy(Env,MS,Tree),
	search(Role,Tree).


search(Concept,node(CL,_NL)) :-
	member(Concept,CL),
	!.
search(Concept,node(_CL,NL)) :-
	searchSubtrees(Concept,NL),
	!.

searchSubtrees(_Concept,[]) :-
	!,
	fail.
searchSubtrees(Concept,[N1|_]) :-
	search(Concept,N1),
	!.
searchSubtrees(Concept,[_|NL]) :-
	searchSubtrees(Concept,NL).


search(Concept,node(CL,NL),[node(CL,NL)]) :-
	member(Concept,CL),
	!.
search(Concept,node(_CL,NL),T1) :-
	searchSubtrees(Concept,NL,T1),
	!.

searchSubtrees(_Concept,[],[]) :-
	!.
searchSubtrees(Concept,[N1|NL],T2) :-
	search(Concept,N1,T1),
	searchSubtrees(Concept,NL,TL),
	append(T1,TL,T2),
	!.

/***********************************************************************
 *
 * classify
 * compute the subsumption hierarchy 
 * side effects: 
 * asserts a clause
 *               conceptHierarchy(MS,Tree)
 * where Tree is a tree representation of the subsumption hierarchy.
 * This is now done using the new classification algorithm written
 * by Patrick Brandmeier.
 *
 */

classify :-
	newClassify.
classify(Arg1) :-
	newClassify(Arg1).
classify(EnvName,MS) :-
	newClassify(EnvName,MS).

/***********************************************************************
 *
 * classify(+NewConcept)
 * adds concept NewConcept to the subsumption hierarchy in the modal
 * context [].
 * side effects: 
 * asserts a clause
 *               conceptHierarchy([],Tree)
 * or            roleHierachy([],Tree)
 * where Tree is a tree representation of the subsumption hierarchy.
 *
 */

classify(EnvName,NewConcept) :-
	environment(EnvName,Env,_),
	atomic(NewConcept),
	clause(conceptName(Env,_MS1,_W2,NewConcept),_), % _MS1 might be [] ?
	classify(concepts,[],NewConcept).
classify(EnvName,NewRole) :-
	environment(EnvName,Env,_),
	atomic(NewRole),
	clause(roleName(Env,_MS1,_W1,NewRole),_), % _MS1 might be [] ?
	classify(roles,[],NewRole).


/***********************************************************************
 *
 * oldClassify
 * compute the subsumption hierarchy in the modal context MS
 * side effects: 
 * asserts a clause
 *               conceptHierarchy(MS,Tree)
 * where Tree is a tree representation of the subsumption hierarchy.
 * This is the original classification algorithm written by 
 * Ullrich Hustadt.
 *
 */

oldClassify :-
	getCurrentEnvironment(EnvName),
	oldClassify(EnvName,[]).

oldClassify(EnvName) :-
	environment(EnvName,_Env,_),
	!,
	oldClassify(EnvName,[]).
oldClassify(MS) :-
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	oldClassify(EnvName,MS).

oldClassify(EnvName,MS) :-
	environment(EnvName,Env,_),
	clause(conceptName(Env,MS,_,Concept),_),
	once(classify(concepts,Env,MS,Concept)),
	fail.
oldClassify(EnvName,MS) :-
	environment(EnvName,Env,_),
	clause(roleName(Env,MS,_,Role),_),
	once(classify(roles,Env,MS,Role)),
	fail.
oldClassify(_,_) :-
	!.
	

/***********************************************************************
 *
 * classify(+MS,+NewConcept)
 * adds concept NewConcept to the subsumption hierarchy in the modal
 * context MS.
 * side effects: 
 * asserts a clause
 *               conceptHierarchy(MS,Tree)
 * or            roleHierarchy(MS,Tree)
 * where Tree is a tree representation of the subsumption hierarchy.
 *
 */
 
classify(EnvName,MS,NewConcept) :-
	environment(EnvName,Env,_),
	clause(conceptName(Env,_MS1,_W1,NewConcept),_), % _MS1 might be MS ?
	!,
	classify(concepts,Env,MS,NewConcept).
classify(EnvName,MS,NewRole) :-
	environment(EnvName,Env,_),
	clause(roleName(Env,_MS1,_W1,NewRole),_), % _MS1 might be MS ?
	!,
	classify(roles,Env,MS,NewRole).

classify(concepts,Env,MS,NewConcept) :-
	classified(Env,MS,NewConcept),
	!.
classify(roles,Env,MS,NewRole) :-
	classified(Env,MS,NewRole),
	!.
classify(concepts,Env,MS,NewConcept) :-
	retract(conceptHierarchy(Env,MS,OldTree)),
	classify(concepts,Env,MS,NewConcept,OldTree,NewTree),
	assertzRE(conceptHierarchy(Env,MS,NewTree)).
classify(roles,Env,MS,NewRole) :-
	retract(roleHierarchy(Env,MS,OldTree)),
	classify(roles,Env,MS,NewRole,OldTree,NewTree),
	assertzRE(roleHierarchy(Env,MS,NewTree)).

classify(Type,Env,MS,NewConcept,OldTree,NewTree) :-
	testForSubsumption(Type,Env,MS,NewConcept,OldTree,NewTree,_Judgement),
	!.


/***********************************************************************
 *
 * testForSubsumption(+Type,+MS,+NewConcept,+OldTree
 *                    -NewTree,-Judgement)
 * builds a tree representation NewTree of the subsumption hierarchy 
 * Judgement has the following meaning:
 * below  : NewConcept is below  the top concept of OldTree
 *          in this case NewTree is instantiated with the tree which
 *          has NewConcept inserted in OldTree
 * beside : NewConcept is beside the top concept of OldTree
 *          in this case NewTree is instantiated with the tree which
 *          has NewConcept as top concept and all concepts of OldTree
 *          which are subsumed by NewConcept below it
 * above  : NewConcept is above  the top concept of OldTree
 *          in this case NewTree is not instantiated
 * in     : NewConcept is equivalent to the top concept of OldTree
 *          in this case NewTree is instantiated with the tree which
 *          has NewConcept inserted in OldTree
 *
 */

testForSubsumption(Type,Env,MS,NewConcept,node([ClassifiedConcept|CL],AL),NewTree,Judgement) :-
	once(subsume2(Type,Env,MS,NewConcept,ClassifiedConcept)), 
	testForEquivalence(Type,Env,MS,NewConcept,node([ClassifiedConcept|CL],AL),NewTree,Judgement),
	!.
testForSubsumption(Type,Env,MS,NewConcept,node([ClassifiedConcept|CL],AL),NewTree,below) :-
	% to get here the subsumption test in the first clause
        % must have failed
	once(subsume2(Type,Env,MS,ClassifiedConcept,NewConcept)),
	% so only x \in NewConcept        => x \in ClassifiedConcept
	% but not x \in ClassifiedConcept => x \in NewConcept
	tfsList1(Type,Env,MS,NewConcept,[ClassifiedConcept|CL],[],AL,
                below([]),beside([]),above([]),NewTree),
	!.
testForSubsumption(Type,Env,MS,NewConcept,node([ClassifiedConcept|CL],AL),NewTree,beside) :-
	% neither x \in NewConcept        => x \in ClassifiedConcept
	% nor     x \in ClassifiedConcept => x \in NewConcept
	tfsList2(Type,Env,MS,NewConcept,[ClassifiedConcept|CL],[],AL,
                below([]),beside([]),above([]),NewTree),
	!.

tfsList1(_Type,_,_MS,NewConcept,N,_NL1,[],
        below(NL3),beside(NL4),above(NL5),Tree) :-
	buildTree1(NewConcept,N,below(NL3),beside(NL4),above(NL5),Tree),
	!.
tfsList1(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
        below(NL3),beside(NL4),above(NL5),NewTree) :-
	testForSubsumption(Type,Env,MS,NewConcept,Node1,Tree,Judgement),
	continue1(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
	         below(NL3),beside(NL4),above(NL5),Tree,Judgement,NewTree).

buildTree1(NewConcept,N,below([]),beside(NL2),above(NL3),
	node(N,[node([NewConcept],NL3)|NL2])) :- 
	!.
buildTree1(_NewConcept,N,below(NL1),beside(NL2),above(_),
	node(N,NL)) :-
	unionSpecial(NL1,NL2,NL),
	!.
buildTree1(_NewConcept,_N,_,_,_,_) :-
	!,
	fail.

	
continue1(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
         below(NL3),beside(NL4),above(NL5),Tree,below,NewTree) :-
	% NL4 can be non-empty
	% NL5 should be the empty list !
	tfsList1(Type,Env,MS,NewConcept,N,[Node1|NL1],NL2,
                below([Tree|NL3]),beside(NL4),above(NL5),NewTree),
	!.
continue1(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
         below(NL3),beside(NL4),above(NL5),
         node([NewConcept],[]),beside,NewTree) :-
	tfsList1(Type,Env,MS,NewConcept,N,[Node1|NL1],NL2,
                below(NL3),beside([Node1|NL4]),above(NL5),NewTree),
	!.
continue1(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
         below(NL3),beside(NL4),above(NL5),
         node([NewConcept],[N1|NL]),beside,NewTree) :-
	unionSpecial(NL5,[N1|NL],NL6),
	tfsList1(Type,Env,MS,NewConcept,N,[Node1|NL1],NL2,
                below(NL3),beside([Node1|NL4]),above(NL6),NewTree),
	!.
continue1(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
         below(NL3),beside(NL4),above(NL5),_Tree,above,NewTree) :-
	tfsList1(Type,Env,MS,NewConcept,N,[Node1|NL1],NL2,
	        below(NL3),beside(NL4),above([Node1|NL5]),NewTree),
	!.
continue1(_Type,_,_MS,_NewConcept,N,NL1,[_Node1|NL2],
         below(_NL3),beside(_NL4),above(_NL5),
         Tree,in,node(N,NL)) :-
        % NL3, NL4 and NL5 can be non-empty
	reverseList(NL1,NL6),
	unionSpecial(NL6,[Tree|NL2],NL),
	!.

tfsList2(_Type,_,_MS,NewConcept,N,_NL1,[],
        below(NL3),beside(NL4),above(NL5),Tree) :-
	buildTree2(NewConcept,N,below(NL3),beside(NL4),above(NL5),Tree),
	!.
tfsList2(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
        below(NL3),beside(NL4),above(NL5),NewTree) :-
	testForSubsumption(Type,Env,MS,NewConcept,Node1,Tree,Judgement),
	continue2(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
	         below(NL3),beside(NL4),above(NL5),Tree,Judgement,NewTree).

buildTree2(NewConcept,_N,below([]),beside(_NL2),above([]),
	node([NewConcept],[])) :-
	!.
buildTree2(NewConcept,_N,below([]),beside(_NL2),above(NL3),
	node([NewConcept],NL3)) :- 
	!.
buildTree2(_NewConcept,_N,_,_,_,_) :-
	!,
	fail.

	
continue2(_Type,_,_MS,_NewConcept,_N,_NL1,[_Node1|_NL2],
         below(_NL3),beside(_NL4),above(_NL5),_Tree,below,_NewTree) :-
	!,
	fail.
continue2(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
         below(NL3),beside(NL4),above(NL5),_Tree,beside,NewTree) :-
	tfsList2(Type,Env,MS,NewConcept,N,[Node1|NL1],NL2,
                below(NL3),beside([Node1|NL4]),above(NL5),NewTree),
	!.
continue2(Type,Env,MS,NewConcept,N,NL1,[Node1|NL2],
         below(NL3),beside(NL4),above(NL5),_Tree,above,NewTree) :-
	tfsList2(Type,Env,MS,NewConcept,N,[Node1|NL1],NL2,
	        below(NL3),beside(NL4),above([Node1|NL5]),NewTree),
	!.
continue2(_Type,_,_MS,_NewConcept,_N,_NL1,[_Node1|_NL2],
         below(_NL3),beside(_NL4),above(_NL5),
         _Tree,in,node(_N,_NL)) :-
	!,
	fail.

testForEquivalence(Type,Env,MS,NewConcept,node([ClassifiedConcept|CL],AL),
	           node([NewConcept,ClassifiedConcept|CL],AL),in) :-
	once(subsume2(Type,Env,MS,ClassifiedConcept,NewConcept)),
	% so NewConcept = ClassifiedConcept
	!.
testForEquivalence(_Type,_,_MS,_NewConcept,node([_ClassifiedConcept|_CL],_AL),
	           _,above) :-
	% so only x \in ClassifiedConcept => x \in NewConcept
        % but not x \in NewConcept        => x \in ClassifiedConcept
	!.

subsume2(Type,Env,MS,X,Y) :- var(X),!,fail.
subsume2(Type,Env,MS,X,Y) :- var(Y),!,fail.
subsume2(Type,Env,MS,X,top) :- !,fail.
subsume2(Type,Env,MS,bot,X) :- !,fail.
subsume2(Type,Env,MS,X,bot) :- !.
subsume2(Type,Env,MS,top,X) :- !.
subsume2(Type,Env,MS,X,Y) :- 
	sub3(X,Y),
	!.
subsume2(Type,Env,MS,X,Y) :- 
	nsub3(X,Y),
	!,fail. 
subsume2(Type,Env,MS,X,Y) :- 
	X \== Y,
	subsumes(Type,Env,MS,X,Y), 
  	cont4(X,Y),
	!.
subsume2(Type,Env,MS,X,Y) :- 
	X \== Y,
	cont5a(X,Y),
	!,
	fail.
cont4(top,Y).
cont4(X,Y) :- 
	assert1(sub3(X,Y)),
	succ3(Z,X),
	cont4(Z,Y),!.
cont4(X,Y). 
cont5a(bot,X) :- !.
cont5a(X,bot) :- !,fail.
cont5a(X,Y) :-
	assert1(nsub3(X,Y)),
	succ3(Y,Z),
	cont5a(X,Z),!.

assert2(G) :- not(G),assertzRE(G),!.
assert2(G) :-!.

retract2(G) :- retract(G),!.
retract2(G) :- !.

succ2(X,Y) :- succ3(X,Y),!.
succ2(X,bot) :- !.


/***********************************************************************
 *
 * showHierarchy(+Type)
 * Parameter: Type     'concepts' or 'roles'
 * display subsumption hierarchy in the modal context [].
 *
 */

showHierarchy(Type) :-
	getCurrentEnvironment(EnvName),
	showHierarchy(EnvName,[],Type).

/***********************************************************************
 *
 * showHierarchy(+EnvName,+MS,+Type)
 * Parameter: EnvName   environment atom_codes
 *            MS        modal context
 *            Type      'concepts' or 'roles'
 * display subsumption hierarchy in the modal context MS.
 *
 */

showHierarchy(EnvName,MS,concepts) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Tree),
	showDag([],Tree).
showHierarchy(EnvName,MS,roles) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Tree),
	showDag([],Tree).

showHierarchy(EnvName,Type) :-
	environment(EnvName,_,_),
	!,
	showHierarchy(EnvName,[],Type).
showHierarchy(MS,Type) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	showHierarchy(EnvName,MS,Type).

/***********************************************************************
 *
 * getHierarchy(+Type,-H)
 * Parameter: Type     'concepts' or 'roles'
 * instantiates H with the internal representation of the subsumption 
 * hierarchy of Type in the current environment and modal context [].
 *
 */

getHierarchy(Type,H) :-
	getCurrentEnvironment(EnvName),
	getHierarchy(EnvName,[],Type,H).

/***********************************************************************
 *
 * getHierarchy(+EnvName,+MS,+Type,-H)
 * Parameter: EnvName   environment atom_codes
 *            MS        modal context
 *            Type      'concepts' or 'roles'
 * instantiates H with the internal representation of the subsumption 
 * hierarchy of Type in environment EnvName and modal context MS.
 *
 */

getHierarchy(EnvName,MS,concepts,Tree) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Tree).
getHierarchy(EnvName,MS,roles,Tree) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Tree).

getHierarchy(EnvName,Type,Tree) :-
	environment(EnvName,_,_),
	!,
	getHierarchy(EnvName,[],Type,Tree).
getHierarchy(MS,Type,Tree) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	getHierarchy(EnvName,MS,Type,Tree).

/***********************************************************************
 *
 * showDag(+Depth,+Tree)
 * display subtree of the tree representation of the subsumption 
 * hierarchy which is located at depth D, where D is the lenght of
 * the list Depth of minus signs, in the hierarchy.
 *
 */

showDag(Depth,node(CL,AL)) :-
	writes(Depth),
	writes(" "),
	printClass(CL),
	printArgs([45|Depth],AL).

printClass([C1]) :-
	print(C1),
	nl,
	!.
printClass([C1,C2|CL]) :-
	print(C1),
	writes(" ("),
	printRest([C2|CL]),
	writes(")"),
	nl.
printRest([]) :- !.
printRest([C1]) :-
	print(C1).
printRest([C1,C2|CL]) :-
	print(C1),
	print(", "),
	printRest([C2|CL]).

printArgs(_Depth,[]) :- !.
printArgs(Depth,[N1|NL]) :-
	showDag(Depth,N1),
	printArgs(Depth,NL).






/**********************************************************************
 *
 * @(#) classifier2.pl 1.42@(#)
 *
 */

init_new_daten :- 
	currentEnvironment(Env),
	init_new_daten(Env).

init_new_daten(Env) :-
        init_succ(_),
	init_sub(_),
	init_nsub(_),
	assertzRE(conceptName1(Env,_,top)),
	assertzRE(roleName1(Env,_,top)),
       	assertzRE(succ(concepts,Env,_,top,bot)),
	assertzRE(sub(concepts,Env,_,top,_)),
	assertzRE(nsub(concepts,Env,_,X,X)),	
	assertzRE(succ(roles,Env,_,top,bot)),
	assertzRE(sub(roles,Env,_,top,_)),
	assertzRE(nsub(roles,Env,_,X,X)),
%	assertzRE(sub(roles,Env,_,X,X)),
	assertzRE(sub(roles,Env,_,_,bot)),
	assertzRE(sub(concepts,Env,_,_,bot)).


init_succ(MS) :- 
 	currentEnvironment(Env),
        init_succ(Env,MS),
	!.
init_succ(_MS).
init_succ(Env,MS) :- 
	retractallSpecial(succ(_,Env,MS,_,_)),
	!.

init_sub(MS) :-
	currentEnvironment(Env),
	init_sub(Env,MS).
init_sub(_MS).
init_sub(Env,MS) :- 
	retractallSpecial(sub(_,Env,MS,_,_)),
	!.

init_nsub(MS) :-
 	currentEnvironment(Env),
	init_nsub(Env,MS).
init_nsub(_MS).
init_nsub(Env,MS) :-
	retractallSpecial(nsub(_,Env,MS,_,_)),
	!.

/********************************************************************/
% Test-functions 

neu1 :- newClassify,
	show_dag([]),printStat. 
show :- getCurrentEnvironment(EnvName),
	environment(EnvName,Env,_),
	showDefconcept(Env),
	showDefprimconcept(Env),
	showDefrole(Env),
        showDefprimrole(Env).

neu1(MS) :- newClassify(MS).

newClassify :-
	getCurrentEnvironment(EnvName),
	newClassify(EnvName,[]).

newClassify(EnvName) :-
	environment(EnvName,_Env,_),
	!,
	newClassify(EnvName,[]).
newClassify(MS) :-
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	newClassify(EnvName,MS).

newClassify(EnvName,MS) :-
	environment(EnvName,Env,_),
	init_new_daten(Env),
	initStat,
	testb(Env,MS),
	buildOrdering(Env,MS,CTree,RTree),
	retractallSpecial(conceptHierarchy(Env,MS,_)),
	retractallSpecial(roleHierarchy(Env,MS,_)),
	assertzRE(conceptHierarchy(Env,MS,CTree)),
	assertzRE(roleHierarchy(Env,MS,RTree)),
	ifMooOption(testOutput,yes,printStat),
	!.	
testb(Env,MS) :-
        not(find_concept(concepts,Env,MS)),
        not(find_role(roles,Env,MS)).
	
find_concept(concepts,Env,MS) :-
	getConceptName(Env,MS,Concept),
	not(atom_codes(Concept,[99,111,110,99,101,112,116|_])),
	ifMooOption(testOutput,yes,(print(Concept), nl)),
	addCounter(conceptsClassified,1),
	find_concept1(concepts,Env,MS,Concept).

find_concept1(concepts,Env,MS,Concept) :-
	conceptEqualSets(Env,user,MS,Concept,CT,_),
%	once(find_concept2(concepts,Env,MS,Concept,CT)),
	find_concept2(concepts,Env,MS,Concept,CT),
 	!,
 	fail.
find_concept1(concepts,Env,MS,Concept) :-
	conceptSubsets(Env,user,MS,Concept,CT,_),
%	once(find_pconcept2(concepts,Env,MS,Concept,CT)),
	find_pconcept2(concepts,Env,MS,Concept,CT),
 	!,
	fail.
find_concept1(concepts,Env,MS,Concept) :-
	make_succ2(concepts,Env,MS,Concept),
	!,
	fail.


find_role(roles,Env,MS) :-
	getRoleName(Env,MS,Role),
	not(atom_codes(Role,[114,111,108,101|_])),
	addCounter(rolesClassified,1),
	find_role1(roles,Env,MS,Role).

find_role1(roles,Env,MS,Role) :-
	roleEqualSets(Env,user,MS,Role,CT,_),
	once(find_role2(roles,Env,MS,Role,CT)),
 	fail.
find_role1(roles,Env,MS,Role) :-
	roleSubsets(Env,user,MS,Role,CT,_),
	once(find_prole2(roles,Env,MS,Role,CT)),
	fail.
find_role1(roles,Env,MS,Role) :-
	make_succ2(roles,Env,MS,Role),
	!,
	fail.

/***** Entwicklungsecke....
test fuer den trans.abschluss von roleEqualSets,roleSubsets,concept...

find_role1(roles,Env,MS,Role) :-
	roleEqualSets(Env,user,MS,Role,CT,_),
	find_role11(roles,Env,MS,Role,CT),
	!,
	fail.
find_role11(roles,Env,MS,Role,CT) :-
	find_role2(roles,Env,MS,Role,CT),
	!,
	roleEqualSets(Env,user,MS,CT,CT1,_),
	find_role11(roles,Env,MS,Role,CT1),
	!.
find_role11(roles,Env,MS,Role,CT) :-
	!.

find_role1(roles,Env,MS,Role) :-
	roleSubsets(Env,user,MS,Role,CT,_),
	find_prole11(roles,Env,MS,Role,CT),
 	!,
	fail.
find_prole11(roles,Env,MS,Role,CT) :-
	find_prole2(roles,Env,MS,Role,CT),
	!,
	roleSubsets(Env,user,MS,CT,CT1,_),
	find_prole11(roles,Env,MS,Role,CT1),
	!.
find_prole11(roles,Env,MS,Role,CT) :-
	!.
*/

/*******************************************/
find_concept2(concepts,Env,MS,Concept,and([X|[R]])) :-
	conceptEqualSets(Env,user,MS,Concept1,R,_),
	assert_succ(concepts,Env,MS,X,Concept),
	assert_succ(concepts,Env,MS,Concept1,Concept),		
	!. 
find_concept2(concepts,Env,MS,Concept,and(L)) :-
	find_concept21(concepts,Env,MS,Concept,L),
	!.

find_concept2(concepts,Env,MS,Concept,and([Concept1|[some(Role,Concept1)]])) :-
	getRoleName(Env,MS,Role),
	assert_succ(concepts,Env,MS,Concept1,Concept),	
	!.

find_concept2(concepts,Env,MS,Concept,some(_Role,Concept1)) :-
	find_concept25(Env,MS,Concept,Concept1),
	!. 

find_concept2(concepts,Env,MS,Concept,or([and(L)])) :-
	find_concept26(concepts,Env,MS,Concept,L),
	!.
	
find_concept2(concepts,Env,MS,Concept,or([and(L1)|R])) :-
	find_concept3(Env,MS,Concept,R,L1,Z),
	find_concept31(Env,MS,Concept,Z),	
	!.
find_concept2(concepts,Env,MS,Concept,or(L)) :-
	find_concept26(concepts,Env,MS,Concept,L),
	!.
find_concept2(concepts,Env,MS,Concept,CT) :-
	getConceptName(Env,MS,CT),
	find_concept20(concepts,Env,MS,Concept,CT),
	!.

find_concept20(concepts,Env,MS,Concept,CT) :-
	(succ(concepts,Env,MS,Topconcept,Concept),
	subsume1(concepts,Env,MS,Topconcept,CT)),
	assert1(nsub(concepts,Env,MS,Concept,CT)),
	assert1(nsub(concepts,Env,MS,CT,Concept)),
	assert_succ(concepts,Env,MS,Topconcept,CT),
	!.	
find_concept20(concepts,Env,MS,Concept,CT) :-
	(succ(concepts,Env,MS,Topconcept,CT),
	subsume1(concepts,Env,MS,Topconcept,Concept)),
	assert1(nsub(concepts,Env,MS,Concept,CT)),
	assert1(nsub(concepts,Env,MS,CT,Concept)),
	assert_succ(concepts,Env,MS,Topconcept,Concept),
	!.
find_concept20(concepts,Env,MS,Concept,CT) :-
	assert1(nsub(concepts,Env,MS,Concept,CT)),
	assert1(nsub(concepts,Env,MS,CT,Concept)),
	assert1(succ(concepts,Env,MS,top,Concept)),
	assert1(succ(concepts,Env,MS,top,CT)),
	!.

find_concept21(concepts,_Env,_MS,_Concept,[]) :-
	!.
find_concept21(concepts,Env,MS,Concept,[X|R]) :-
	getConceptName(Env,MS,X),
	assert_succ(concepts,Env,MS,X,Concept),
	find_concept21(concepts,Env,MS,Concept,R),
	!.
find_concept21(concepts,Env,MS,Concept,[not(R1)|R]) :-    
	getConceptName(Env,MS,R1),
	setofOrNil(K,find_concept22(concepts,Env,MS,Concept,R1,K),L),
	find_concept23(concepts,Env,MS,Concept,L),
	find_concept21(concepts,Env,MS,Concept,R),
	!.
find_concept21(concepts,Env,MS,Concept,[_X|R]) :-
	find_concept21(concepts,Env,MS,Concept,R),
	!,
	fail.

find_concept22(concepts,Env,MS,Concept,R1,K) :-
	succ(concepts,Env,MS,K,R1),
	not(succ(concepts,Env,MS,K,Concept)).

find_concept23(concepts,_Env,_MS,_Concept,[]) :-
	!.	
find_concept23(concepts,Env,MS,Concept,[L1|R1]) :-
	find_concept24(concepts,Env,MS,Concept,L1),
	find_concept23(concepts,Env,MS,Concept,R1),
	!.
find_concept24(concepts,Env,MS,Concept,L1) :-
	succ(concepts,Env,MS,Top,L1),
	succ(concepts,Env,MS,Top,K),
	subsume1(concepts,Env,MS,K,Concept),
	setofOrNil(Nf,succ(concepts,Env,MS,K,Nf),Lnf),
	make_succ1(concepts,Env,MS,K,Lnf,Concept),
	!. 
		
find_concept25(Env,MS,Concept,Concept1) :-
	succ(concepts,Env,MS,K,Concept1),
	setofOrNil(Nf,succ(concepts,Env,MS,Concept1,Nf),Lnf),
	make_succ1(concepts,Env,MS,K,Lnf,Concept),
	fail.
find_concept25(_Env,_MS,_Concept,_Concept1) :-
	!,
	fail.

find_concept26(concepts,Env,MS,Concept,[C1|R]) :-
	getConceptName(Env,MS,C1),
%	subsume1(concepts,Env,MS,Concept,C1),
	assert_succ(concepts,Env,MS,Concept,C1),
	find_concept26(concepts,Env,MS,Concept,R).

find_concept3(_Env,_MS,_Concept,[],Z,Z) :- 
	!.
find_concept3(Env,MS,Concept,[and(L1)|R],Z,K) :-
	intersectionOfLists(Z,L1,Z1),
	find_concept3(Env,MS,Concept,R,Z1,K),
	!.

find_concept31(_Env,_MS,_Concept,[]) :-
	!.
find_concept31(Env,MS,Concept,[L1|R1]) :-
	assert_succ(concepts,Env,MS,L1,Concept),
	find_concept31(Env,MS,Concept,R1),
	!.

% ********************** Primconcepte **************************
% es fehlt noch defprimconcept(_,_,some(_,_..))
%                   "         (_,not(),...)
%                   "         (_,...(),...)
					
find_pconcept2(concepts,Env,MS,PrimConcept,not(X)) :-
	getConceptName(Env,MS,X),
	cont1a(concepts,Env,MS,[],X,PrimConcept),
%	succ(concepts,Env,MS,Topconcept,X),
	find_pconcept23(Env,MS,X,PrimConcept,Top),
	assert_succ(concepts,Env,MS,Top,PrimConcept),
	assert_succ(concepts,Env,MS,Top,X),
	!.
find_pconcept2(concepts,Env,MS,Primconcept,and(L)) :-
	find_pconcept24(Env,MS,Primconcept,L),
	!.
find_pconcept2(concepts,Env,MS,PrimConcept,some(X,Y)) :-
	find_pconcept21(Env,MS,PrimConcept,X,Y),
	!.
find_pconcept2(concepts,Env,MS,PrimConcept,and([X|[not(Y)]])) :-
	getConceptName(Env,MS,X),
	getConceptName(Env,MS,Y),
	find_pconcept23(Env,MS,X,Y,Top),
	assert_succ(concepts,Env,MS,Top,PrimConcept),	
%	assert1(sub(concepts,Env,MS,PrimConcept)),
	!.
find_pconcept2(concepts,Env,MS,Primconcept,or([and(L)])) :-
	find_pconcept26(concepts,Env,MS,Primconcept,L),
	!.
find_pconcept2(concepts,Env,MS,Primconcept,or([and(L1)|R])) :-
	find_pconcept3(Env,MS,Primconcept,R,L1,Z),
	find_pconcept31(Env,MS,Primconcept,Z),	
	!.
find_pconcept2(concepts,Env,MS,Primconcept,or(L)) :-
	find_pconcept26(concepts,Env,MS,Primconcept,L),
	!.
find_pconcept2(concepts,Env,MS,PrimConcept,CT) :-
	getConceptName(Env,MS,CT),
	assert1(sub(concepts,Env,MS,CT,PrimConcept)),
	direct_succ(concepts,Env,MS,[],CT,PrimConcept,Z,L1),
        contb(concepts,Env,MS,Z,L1,PrimConcept),
	!.


find_pconcept26(concepts,Env,MS,Primconcept,[C1|R]) :-
	getConceptName(Env,MS,C1),
	subsume1(concepts,Env,MS,C1,Primconcept),
	find_pconcept27(concepts,Env,MS,Primconcept,C1),
  	find_pconcept26(concepts,Env,MS,Primconcept,R).

find_pconcept27(concepts,Env,MS,Primconcept,C1):-
	assert1(sub(concepts,Env,MS,C1,Primconcept)),
	direct_succ(concepts,Env,MS,[],C1,PrimConcept,Z,L1),
        contb(concepts,Env,MS,Z,L1,PrimConcept),
	!.

find_pconcept3(_Env,_MS,_Primconcept,[],Z,Z) :- 
	!.
find_pconcept3(Env,MS,Primconcept,[and(L1)|R],Z,K) :-
	intersectionOfLists(Z,L1,Z1),
	find_pconcept3(Env,MS,Primconcept,R,Z1,K),
	!.

find_pconcept31(_Env,_MS,_Primconcept,[]) :-
	!.
find_pconcept31(Env,MS,Primconcept,[L1|R1]) :-
	find_pconcept27(concepts,Env,MS,Primconcept,L1),
	find_pconcept31(Env,MS,Primconcept,R1),
	!.


find_pconcept21(Env,MS,PrimConcept,X,or([Y1|[Y2]])) :-
	conceptEqualSets(Env,user,MS,Concept,some(X,Y1),_),
	conceptEqualSets(Env,user,MS,Concept1,some(X,Y2),_),
	find_pconcept23(Env,MS,Concept1,Concept,Top),
	assert_succ(concepts,Env,MS,Top,PrimConcept),
	!.

find_pconcept23(Env,MS,X,Y,X) :-
	sub(concepts,Env,MS,X,Y),
	!.
find_pconcept23(Env,MS,X,Y,Y) :-
	sub(concepts,Env,MS,Y,X),
	!.
find_pconcept23(Env,MS,X,Y,Top) :-
	sub(concepts,Env,MS,Top,X),
	sub(concepts,Env,MS,Top,Y).

find_pconcept24(Env,MS,Primconcept,[X|R]) :-
	getConceptName(Env,MS,X),
	assert1(sub(concepts,Env,MS,X,PrimConcept)),
	direct_succ(concepts,Env,MS,[],X,PrimConcept,Z,L1),
        contb(concepts,Env,MS,Z,L1,PrimConcept),
	find_pconcept24(Env,MS,Primconcept,R),
	!.


/*************************************************************************
*                    rollen
*/

find_role2(roles,Env,MS,Role,CT) :-
	getRoleName(Env,MS,CT),
	succ(roles,Env,MS,Toprole,Role),
	assert1(nsub(roles,Env,MS,Role,Ct)),
	assert1(nsub(roles,Env,MS,Ct,Role)),
	assert_succ(roles,Env,MS,Toprole,CT),
	!.	
find_role2(roles,Env,MS,Role,CT) :-
	getRoleName(Env,MS,CT),
	succ(roles,Env,MS,Toprole,CT),
	assert1(nsub(roles,Env,MS,Role,Ct)),
	assert1(nsub(roles,Env,MS,Ct,Role)),
	assert_succ(roles,Env,MS,Toprole,Role),
	!.
find_role2(roles,Env,MS,Role,CT) :-	
	getRoleName(Env,MS,CT),
	assert1(nsub(roles,Env,MS,Role,Ct)),
	assert1(nsub(roles,Env,MS,Ct,Role)),
	assert_succ(roles,Env,MS,top,Role),
	assert_succ(roles,Env,MS,top,CT),
	!.	
find_role2(roles,Env,MS,Role,and([X|[R]])) :-	
	roleEqualSets(Env,user,MS,Role1,R,_),
	assert_succ(roles,Env,MS,X,Role),
	assert_succ(roles,Env,MS,Role1,Role),	
	!. 
find_role2(roles,Env,MS,Role,and([X|[R]])) :-	
	getRoleName(Env,MS,X),
	getRoleName(Env,MS,R),
	assert_succ(roles,Env,MS,X,Role),
	assert_succ(roles,Env,MS,R,Role),
	!.
find_role2(roles,Env,MS,Role,and([Role1|[some(_,Role1)]])) :-	
	assert_succ(roles,Env,MS,Role1,Role),	
	!.
find_role2(roles,Env,MS,Role,or([X|[R]])) :-	
	find_role3(Env,MS,Role,X,R).
find_role2(roles,Env,MS,Role,and(L)) :-
	find_role21(roles,Env,MS,Role,L),
	!.
find_role2(roles,Env,MS,Role,restr(Role1,_Concept)) :-
	assert_succ(roles,Env,MS,Role1,Role),
	!.


find_role2(roles,Env,MS,Role,CT) :-
	CT = or([and(L)]),
	find_role26(roles,Env,MS,Role,L),
	!.
	
find_role2(roles,Env,MS,Role,or([and(L1)|R])) :-
	find_role30(Env,MS,Role,R,L1,Z),
	find_role31(Env,MS,Role,Z),	
	!.
find_role2(roles,Env,MS,Role,or(L)) :-
	find_role26(roles,Env,MS,Role,L),
	!.

find_role26(roles,Env,MS,Role,[C1|R]) :-
	getRoleName(Env,MS,C1),
	subsume1(roles,Env,MS,C1,Role),
	assert_succ(roles,Env,MS,C1,Role),
	find_role26(roles,Env,MS,Role,R).

find_role30(_Env,_MS,_Role,[],Z,Z) :- 
	!.
find_role30(Env,MS,Role,[and(L1)|R],Z,K) :-
	intersectionOfLists(Z,L1,Z1),
	find_role30(Env,MS,Role,R,Z1,K),
	!.

find_role31(_Env,_MS,_Role,[]) :-
	!.
find_role31(Env,MS,Role,[L1|R1]) :-
	assert_succ(roles,Env,MS,L1,Role),
	find_role31(Env,MS,Role,R1),
	!.


find_role3(Env,MS,Role,X,R) :-
	X = and([X1|[R1]]),
	subsume1(roles,Env,MS,Role,R1),
	find_role2(roles,Env,MS,Role,X).
find_role3(Env,MS,Role,X,R) :-
	R = and([X1|[R1]]),
	subsume1(roles,Env,MS,Role,R1),
	find_role2(roles,Env,MS,Role,X).

find_role21(roles,_Env,_MS,_Role,[]) :-
	!.
find_role21(roles,Env,MS,Role,[X|R]) :-
	getRoleName(Env,MS,X),
	assert_succ(roles,Env,MS,X,Role),
	find_role21(roles,Env,MS,Role,R),
	!.
find_role21(roles,Env,MS,Role,[not(R1)|_R]) :-
	getRoleName(Env,MS,R1),
	setofOrNil(K,find_role22(roles,Env,MS,Role,R1,K),L),
	find_role23(roles,Env,MS,Role,L),
	!.
find_role22(roles,Env,MS,Role,R1,K) :-
	succ(roles,Env,MS,K,R1),
	not(succ(roles,Env,MS,K,Role)).

find_role23(roles,_Env,_MS,_Role,[]) :-
	!.	
find_role23(roles,Env,MS,Role,[L1|R1]) :-
	find_role24(roles,Env,MS,Role,L1),
	find_role23(roles,Env,MS,Role,R1),
	!.
find_role24(roles,Env,MS,Role,L1) :-
	succ(roles,Env,MS,Top,L1),
	succ(roles,Env,MS,Top,K),
	subsume1(roles,Env,MS,K,Role),
	setofOrNil(Nf,succ(roles,Env,MS,K,Nf),Lnf),
	make_succ1(roles,Env,MS,K,Lnf,Role),
	!.

/******** PrimRollen ************************************************/

find_prole2(roles,Env,MS,PrimRole,and(L)) :-
	find_prole24(Env,MS,PrimRole,L),
	!.

find_prole2(roles,Env,MS,PrimRole,not(X)) :-
	getRoleName(Env,MS,X),
	cont1a(roles,Env,MS,X,PrimRole),
	find_prole23(Env,MS,X,PrimRole,Top),
	assert_succ(roles,Env,MS,Top,PrimRole),
	assert_succ(roles,Env,MS,Top,X),
	!.

find_prole2(roles,Env,MS,PrimRole,CT) :-
	convertMS(Env,[[],true],MS,[],[W1,G1],_),
	call(G1),
	getRoleName(Env,MS,CT),
	assert1(sub(roles,Env,MS,CT,PrimRole)),
	direct_succ(roles,Env,MS,[],CT,PrimRole,Z,L1),
              contb(roles,Env,MS,Z,L1,PrimRole),
	!.

find_prole2(roles,Env,MS,PrimRole,some(X,Y)) :-
	find_prole21(Env,MS,PrimRole,X,Y),
	!.

find_prole2(roles,Env,MS,PrimRole,and([X|[not(Y)]])) :-
	getRoleName(Env,MS,X),
	getRoleName(Env,MS,Y),
	find_prole23(Env,MS,X,Y,Top),
	assert_succ(roles,Env,MS,Top,PrimRole),	
	!.
	
find_prole2(roles,Env,MS,Primrole,or([and(L1)|R])) :-
	find_prole3(Env,MS,Primrole,R,L1,Z),
	find_prole31(Env,MS,Primrole,Z),	
	!.

find_prole2(roles,Env,MS,Primrole,or(L)) :-
	find_prole26(roles,Env,MS,Primrole,L),
	!.


find_prole21(Env,MS,PrimRole,X,or([Y1|[Y2]])) :-
	roleEqualSets(Env,user,MS,Role,some(X,Y1),_),
	roleEqualSets(Env,user,MS,Role1,some(X,Y2),_),
	find_prole23(Env,MS,Role,Role1,Top),
	assert_succ(roles,Env,MS,Top,PrimRole),
	!.

find_prole23(Env,MS,X,Y,X) :-
	sub(roles,Env,MS,X,Y),
	!.
find_prole23(Env,MS,X,Y,Y) :-
	sub(roles,Env,MS,Y,X),
	!.
find_prole23(Env,MS,X,Y,Top) :-
	sub(roles,Env,MS,Top,X),sub(roles,Env,MS,Top,Y).

find_prole24(_Env,_MS,_PrimRole,[]).
find_prole24(Env,MS,PrimRole,[X|R]) :-
	getRoleName(Env,MS,X),
	assert1(sub(roles,Env,MS,X,PrimRole)),
	direct_succ(roles,Env,MS,[],X,PrimRole,Z,L1),
              contb(roles,Env,MS,Z,L1,PrimRole),
	find_prole24(Env,MS,PrimRole,R),
	!.

find_prole26(roles,Env,MS,Primrole,[C1|R]) :-
	convertMS(Env,[[],true],MS,[],[W1,G1],_),
	call(G1),
	getRoleName(Env,MS,C1),
	subsume1(roles,Env,MS,C1,Primrole),
	find_prole27(roles,Env,MS,Primrole,C1),
  	find_prole26(roles,Env,MS,Primrole,R).

find_prole27(roles,Env,MS,Primrole,C1):-
	assert1(sub(roles,Env,MS,C1,Primrole)),
	direct_succ(roles,Env,MS,[],C1,Primrole,Z,L1),
              contb(roles,Env,MS,Z,L1,Primrole),
	!.

find_prole3(_Env,_MS,_Primrole,[],Z,Z) :- 
	!.
find_prole3(Env,MS,Primrole,[and(L1)|R],Z,K) :-
	intersectionOfLists(Z,L1,Z1),
	find_prole3(Env,MS,Primrole,R,Z1,K),
	!.

find_prole31(_Env,_MS,_Primrole,[]) :-
	!.
find_prole31(Env,MS,Primrole,[L1|R1]) :-
	find_prole27(roles,Env,MS,Primrole,L1),
	find_prole31(Env,MS,Primrole,R1),
	!.

/****************************************************************/

make_succ(MS) :-           
	currentEnvironment(Env),            
              not(make_succ(concepts,Env,MS)),
	not(make_succ(roles,Env,MS)),!.
make_succ(concepts,Env,MS) :-        
	getConceptName(Env,MS,NewConcept),
	ifMooOption(testOutput,yes,(print(NewConcept),nl)),
	make_succ2(concepts,Env,MS,NewConcept),
	fail.
make_succ(roles,Env,MS) :-
	getRoleName(Env,MS,NewRole),
	ifMooOption(testOutput,yes,(print(NewRole),nl)),
	make_succ2(roles,Env,MS,NewRole),
       	fail.
make_succ2(Type,Env,MS,NewConcept) :- 
	NewConcept \== top,!,
	NewConcept \== bot,!,
%	put_succ(Type,Env,MS,NewConcept),
	direct_succ(Type,Env,MS,[],top,NewConcept,X,L),
	contb(Type,Env,MS,X,L,NewConcept),
	!.

contb(_Type,_Env,_MS,[],_L,_NewConcept) :- 
        !.

contb(Type,Env,MS,[X|R],L,NewConcept) :-
        setofOrNil(Y,contc(Type,Env,MS,X,Y,L),L1),
	special_list_to_set(L1,L2),
        make_succ1(Type,Env,MS,X,L2,NewConcept),
        !,
        contb(Type,Env,MS,R,L,NewConcept).
contb(Type,Env,MS,X,L,NewConcept) :-
	special_list_to_set(L,L1),	
        make_succ1(Type,Env,MS,X,L1,NewConcept),
        !.

contc(Type,Env,MS,X,Y,L) :-
        sub(Type,Env,MS,X,Y),
	member(Y,L).

put_succ(Type,Env,MS,New) :-
	put_below(Type,Env,MS,[],top,New,IL),
	assert_succs(IL,New,Type,Env,MS),
	retract_succs(Type,Env,MS,New).

assert_succs([],New,_Type,_Env,_MS).
assert_succs([below(Old)|IL],New,Type,Env,MS) :-
%	not((succ1(Type,Env,MS,Old,X),member(below(X),IL))),  % ?????
	succ1(Type,Env,MS,Old,X),
	not(member(below(X),IL)),  % ?????
	!,
	assert1(succ(Type,Env,MS,Old,New)),
	assert_succs(IL,New,New,Type,Env,MS).
assert_succs([below(_)|IL],New,New,Type,Env,MS) :-
	assert_succs(IL,New,New,Type,Env,MS).
assert_succs([atop(Old)|IL],New,New,Type,Env,MS) :-
	assert1(succ(Type,Env,MS,New,Old)),
	assert_succs(IL,New,New,Type,Env,MS).
assert_succs([aside(_)|IL],New,New,Type,Env,MS) :-
	assert_succs(IL,New,New,Type,Env,MS).

retract_succs(Type,Env,MS,New) :-
	succ1(Type,Env,MS,C1,New),
	succ1(Type,Env,MS,New,C2),
	succ1(Type,Env,MS,C1,C2),
	retract1(succ(Type,Env,MS,C1,C2)),
	fail.
retract_succs(_Type,_Env,_MS,_New) :-
	!.

put_below(Type,Env,MS,Done,Old,New,[below(Old)|IL]) :-
	subsume1(Type,Env,MS,Old,New),
	!,
	put_where(Type,Env,MS,[Old|Done],Old,New,IL).
put_below(Type,Env,MS,Done,Old,New,[atop(Old)]) :-
	subsume1(Type,Env,MS,New,Old),
	!.
put_below(Type,Env,MS,Done,Old,New,[aside(Old)]) :-
	setofOrNil(Y,(succ1(Type,Env,MS,Old,Y), not(member(Y,[Old|Done]))),L),
	put_aside_list(Type,Env,MS,[Old|Done],L,New,IL).

put_where(Type,Env,MS,Done,Old,New,[]) :-
	subsume1(Type,Env,MS,New,Old),
	!,
	succ(concepts,Env,MS,Topconcept,Old),
	assert1(nsub(concepts,Env,MS,Old,New)),
	assert1(nsub(concepts,Env,MS,New,Old)),
	assert_succ(concepts,Env,MS,Topconcept,New).
put_where(Type,Env,MS,Done,Old,New,IL) :-
	setofOrNil(Y,(succ1(Type,Env,MS,Old,Y), not(member(Y,[Old|Done]))),L),
	put_below_list(Type,Env,MS,Done,L,New,IL).

put_aside_list(Type,Env,MS,Done,[Old|L],New,[atop(Old)|IL]) :-
	subsume1(Type,Env,MS,New,Old),
	put_aside_list(Type,Env,MS,[Old|Done],L,New,IL).
put_aside_list(Type,Env,MS,Done,[Old|L],New,IL) :-
	setofOrNil(Y,(succ1(Type,Env,MS,Old,Y), not(member(Y,[Old|Done]))),L1),
	put_aside_list(Type,Env,MS,[Old|Done],L1,New,IL1),
	put_aside_list(Type,Env,MS,[Old|Done],L,New,IL2),
	unionSpecial(IL1,IL2,IL).
put_aside_list(Type,Env,MS,Done,[],New,[]).

put_below_list(Type,Env,MS,Done,[Old|L],New,IL) :-
	put_below(Type,Env,MS,Done,Old,New,IL1),
	put_below_list(Type,Env,MS,[Old|Done],L,New,IL2),
	unionSpecial(IL1,IL2,IL).
put_below_list(Type,Env,MS,Done,[],New,[]).


direct_succ(_Type,_Env,_MS,_Done,bot,_X,_,[]) :- 
	fail.
direct_succ(Type,Env,MS,Done,X,NewConcept,Z,L1) :-
	subsume1(Type,Env,MS,X,NewConcept),
	setofOrNil(Y,(succ1(Type,Env,MS,X,Y), not(member(Y,[X|Done]))),L),
	!,
	check(Type,Env,MS,[X|Done],L,_,X,NewConcept,Z,L1),
	!.
direct_succ(Type,Env,MS,Done,X,NewConcept,Z,L1) :- 
	setofOrNil(Y,(succ1(Type,Env,MS,X,Y), not(member(Y,[X|Done]))),L),
	check(Type,Env,MS,[X|Done],L,_,top,NewConcept,Z,L1),
	!.

check(Type,Env,MS,Done,[Y|L],L2,X,NewConcept,Z,L1) :-
        subsume1(Type,Env,MS,Y,NewConcept),
	!,
        direct_succ(Type,Env,MS,Done,Y,NewConcept,Z1,L10),
	!,        	 				 	 	
	conta(Type,Env,MS,[Y|Done],L,L2,X,NewConcept,Z1,L10,Z,L1),
        !.
check(Type,Env,MS,Done,[Y|L],L2,X,NewConcept,Z,L1) :-
	!,
	check(Type,Env,MS,[Y|Done],L,[Y|L2],X,NewConcept,Z,L1).
check(Type,Env,MS,Done,[],L2,X,NewConcept,X,L1) :-
	check1(Type,Env,MS,Done,L2,NewConcept,L1),
	!.

conta(_Type,_Env,_MS,_Done,[],_L2,_X,_NewConcept,Z1,L10,Z1,L10) :-
        !.
conta(Type,Env,MS,Done,L,L2,X,NewConcept,Z1,L10,Z,L1) :-
        check(Type,Env,MS,Done,L,L2,X,NewConcept,Z2,L11),
 	union1(Z1,Z2,Za),
	delete1(Za,top,Z),
	union1(L10,L11,L1),
        !.

check1(_,_,_,_,[],_,[]) :- !.
check1(Type,Env,MS,Done,[Y|L],NewConcept,[Y|L1]) :-
	subsume1(Type,Env,MS,NewConcept,Y),
	!,
	check1(Type,Env,MS,[Y|Done],L,NewConcept,L1).
check1(Type,Env,MS,Done,[Y|L],NewConcept,L1) :-
	not(member(Y,Done)),
	setofOrNil(Z,succ1(Type,Env,MS,Y,Z),L2),
	check1(Type,Env,MS,[Y|Done],L2,NewConcept,L3),
	check1(Type,Env,MS,[Y|Done],L,NewConcept,L4),
	unionSpecial(L3,L4,L5),
	deleteInList(L5,top,L1),
	!.
check1(Type,Env,MS,Done,[Y|L],NewConcept,L1) :-
	check1(Type,Env,MS,[Y|Done],L,NewConcept,L1),
	!.

%% make_succ1(Type,Env,MS,X,[Y|L],NewConcept) :- 
%% 	not(succ(Type,Env,MS,NewConcept,Y)),
%%         retract1(succ(Type,Env,MS,X,Y)),
%% %	assert1(succ(Type,Env,MS,NewConcept,Y)),
%%         assert_succ(Type,Env,MS,NewConcept,Y),
%% 	!,
%% 	make_succ1(Type,Env,MS,X,L,NewConcept). 
%% make_succ1(Type,Env,MS,X,[Y|L],NewConcept) :- 
%% % 	assert1(succ(Type,Env,MS,x,NewConcept)),
%%         assert_succ(Type,Env,MS,X,NewConcept),
%% 	!,
%% 	make_succ1(Type,Env,MS,X,L,NewConcept).
%% make_succ1(Type,Env,MS,X,[],NewConcept) :- 
%% %	assert1(succ(Type,Env,MS,X,NewConcept)),
%%         assert_succ(Type,Env,MS,X,NewConcept),
%% 	!.

make_succ1(Type,Env,MS,X,[Y|L],NewConcept) :- 
	succ(Type,Env,MS,X,Y),
	!,
	retract1(succ(Type,Env,MS,X,Y)),
	assert1(succ(Type,Env,MS,NewConcept,Y)),
	make_succ1(Type,Env,MS,X,L,NewConcept).
make_succ1(Type,Env,MS,X,[Y|L],NewConcept) :- 
	!,
	assert1(succ(Type,Env,MS,NewConcept,Y)),
	make_succ1(Type,Env,MS,X,L,NewConcept).
make_succ1(Type,Env,MS,X,[],NewConcept) :- 
	assert_succ(Type,Env,MS,X,NewConcept),
 	!.


/****************  practical funktions ******************************/	

subsume1(_Type,_Env,_MS,X,_Y) :- var(X),!,fail.
subsume1(_Type,_Env,_MS,_X,Y) :- var(Y),!,fail.
subsume1(_Type,_Env,_MS,_X,top) :- !,fail.
subsume1(_Type,_Env,_MS,bot,_X) :- !,fail.
subsume1(_Type,_Env,_MS,_X,[]) :- !.
subsume1(_Type,_Env,_MS,_X,bot) :- !.
subsume1(_Type,_Env,_MS,top,_X) :- !.
subsume1(Type,Env,MS,X,Y) :- 
	sub(Type,Env,MS,X,Y),
	!.
subsume1(Type,Env,MS,X,Y) :- 
	nsub(Type,Env,MS,X,Y),
	!,
	fail. 
subsume1(Type,Env,MS,X,Y) :- 
	X \== Y,
	addCounter(Type,1),
	ifMooOption(testOutput,yes,(getRuntime(T1),format('~3d: ~a >= ~a',[T1,X,Y]))),
	subsumes(Type,Env,MS,X,Y), 
	ifMooOption(testOutput,yes,(getRuntime(T1),format(' succeeded (~3d)~n',[T1]))),
	cont(Type,Env,MS,[],X,Y),
	!.
subsume1(Type,Env,MS,X,Y) :- 
	X \== Y,
	ifMooOption(testOutput,yes,(getRuntime(T1),format(' failed (~3d)~n',[T1]))),
	cont1a(Type,Env,MS,[],X,Y),
	!,
	fail.

cont(_Type,_Env,_MS,_,top,_Y).
cont(Type,Env,MS,Done,X,Y) :- 
	assert1(sub(Type,Env,MS,X,Y)),
	succ1(Type,Env,MS,Z,X),
	not(member(Z,Done)),
	cont(Type,Env,MS,[Z|Done],Z,Y),!.
cont(_Type,_Env,_MS,_,_X,_Y). 
cont1a(_Type,_Env,_MS,_,bot,_X) :- 
	!.
cont1a(_Type,_Env,_MS,_,_X,bot) :- 
	!,fail.
cont1a(_Type,_Env,_MS,Done,X,_Y) :-
       member(X,Done), 
       !.
cont1a(Type,Env,MS,Done,X,Y) :-
	assert1(nsub(Type,Env,MS,X,Y)),
	succ1(Type,Env,MS,X,Z),
	cont1a(Type,Env,MS,[X|Done],Z,Y),
	!.

delete1([X|R],top,Z) :-
	deleteInList([X|R],top,Z),
	!.
delete1(_X,top,_Z) :-
	!.

union1([],[],[]).
union1([X|R],[Y|R1],Z):-
	unionSpecial([X|R],[Y|R1],Z),
	!.
union1([X|R],Y,Z) :-
	unionSpecial([X|R],[Y],Z),
	!.
union1([X],Y,Z) :-
	unionSpecial([X],[Y],Z),
	!.
union1(X,[Y],Z) :-
	unionSpecial([X],[Y],Z),
	!.
union1(X,[Y|R],Z) :-
	unionSpecial([X],[Y|R],Z),
	!.
union1(X,Y,Z) :-
	unionSpecial([X],[Y],Z),
	!.
assert1(G) :- 
	not(G),
	assertzRE(G),
	!.
assert1(_G) :-
	!.

assert_succ(_Type,_Env,_MS,X,X) :-
	!.
/*
assert_succ(Type,Env,MS,X,RorC) :-
	assert1(succ(Type,Env,MS,X,RorC)),
	cont(Type,Env,MS,[],X,RorC),
	!.
*/
assert_succ(Type,Env,MS,X,RorC) :-
	cont(Type,Env,MS,[],X,RorC),
	not((sub(Type,Env,MS,X,Y),not(var(Y)),sub(Type,Env,MS,Y,RorC),Y \== RorC)),
	assert1(succ(Type,Env,MS,X,RorC)),
	!.
assert_succ(_Type,_Env,_MS,_X,_RorC).


retract1(G) :- 
	retract(G),
	!.
retract1(_G) :- 
	!.

succ1(Type,Env,MS,X,Y) :- 
	succ(Type,Env,MS,X,Y).
%	!.
succ1(_Type,_Env,_MS,_X,bot).
% 	:-  !.

/*****************************************************************************/
/***************** print and statistic - functions ***************************/
newShowHierarchy :-
	show_dag.

show_dag :-
	currentEnvironment(Env),
	show_dag(Env,[]).
show_dag(MS) :-
	currentEnvironment(Env),
	show_dag(Env,MS).
show_dag(Env,MS) :-
	!,
	print('Concepts'),nl,
        not(show_dag(concepts,Env,MS,top,[])),nl,nl,
	print('Roles'),nl,
	not(show_dag(roles,Env,MS,top,[])).
show_dag(_Type,_Env,_MS,bot,_) :- !,fail.
show_dag(Type,Env,MS,Node,L) :-
	writes(L),
	print(Node),nl,
	succ(Type,Env,MS,Node,N),
  	show_dag(Type,Env,MS,N,[45|L]),
	fail.

initStat :-
	!,
	setCounter(subsumptionTests,0),
	setCounter(concepts,0),
	setCounter(roles,0),
	setCounter(conceptsClassified,0),
	setCounter(rolesClassified,0),
	getRuntime(T0),
	setCounter(runtime,T0),
	!.
getStat(CN,CST,RN,RST,T) :-
	!,
	getRuntime(T1),
	getCounter(subsumptionTests,ST),
	getCounter(concepts,CST),
	getCounter(conceptsClassified,CN),
	getCounter(roles,RST),
	getCounter(rolesClassified,RN),
	getCounter(runtime,T0),
	T is T1 - T0,
	!.
printStat :-
	!,
	getStat(CN,CST,RN,RST,T),
	format('Concepts classified:         ~d~n',CN),
	format('Subsumption tests performed: ~d~n',CST),
	format('Roles    classified:         ~d~n',RN),
	format('Subsumption tests performed: ~d~n',RST),
	format('Total runtime:               ~3d sec.~2n',T),
	!.

buildOrdering(Env,MS,CTree,RTree) :- 
	buildOrdering(concepts,Env,MS,top,[],CTree),
	buildOrdering(roles,Env,MS,top,[],RTree),
	!.


buildOrdering(Type,Env,MS,bot,_Done,node([bot|EquivClass],[])) :-
	!,
	setofOrNil(Z2,(succ(Type,Env,MS,bot,Z2),succ(Type,Env,MS,Z2,bot)),EquivClass),
	!.
buildOrdering(Type,Env,MS,Concept1,Done,node([Concept1|EquivClass],SubtreeList)) :-
	setofOrNil(Z1,succ(Type,Env,MS,Concept1,Z1),S1),
	setofOrNil(Z2,(succ(Type,Env,MS,Concept1,Z2),succ(Type,Env,MS,Z2,Concept1)),EquivClass),
	successorSet(S1,EquivClass,Succ),
	append(Done,[Concept1|EquivClass],Done1),
	buildOrderingList(Type,Env,MS,Succ,Done1,SubtreeList).

buildOrderingList(_Type,_Env,_MS,[],_Done,[]) :-
	!.
buildOrderingList(Type,Env,MS,[C1|CL],Done,SubtreeList) :-
	member(C1,Done),
	!,
	buildOrderingList(Type,Env,MS,CL,Done,SubtreeList).
buildOrderingList(Type,Env,MS,[C1|CL],Done,[Subtree|SubtreeList]) :-
	buildOrdering(Type,Env,MS,C1,Done,Subtree),
	buildOrderingList(Type,Env,MS,CL,Done,SubtreeList),
	!.

successorSet(S1,EquivClass,S2) :-
	successor_set(S1,EquivClass,S3),
	((S3 \== [], S2 = S3) ; (S2 = [bot])),
	!.

successor_set([],_,[]) :-
	!.
successor_set([C1|CL],EquivClass,S2) :-
	member(C1,EquivClass),
	!,
	successor_set(CL,EquivClass,S2).
successor_set([bot|CL],EquivClass,S2) :-
	!,
	successor_set(CL,EquivClass,S2).
successor_set([C1|CL],EquivClass,[C1|S2]) :-
	successor_set(CL,EquivClass,S2).
/**********************************************************************
 *
 * @(#) compileEnv.pl 1.9@(#)
 *
 */

/**********************************************************************
 *
 * compileEnvironment(FileName)
 * 
 */

compileEnvironment(FileName) :-
	see(FileName),
	read(environment(EnvName,_Env,_Comment)),
	seen,
	compileEnvironment(FileName,EnvName),
	!.
compileEnvironment(FileName) :-
	% Some file handling error has occured
	seen,
	!, 
	fail.

compileEnvironment(FileName,EnvName) :-
	see(FileName),
	read(environment(_EnvName,Env,Comment)),
	(removeEnvironment(EnvName) ; true),
	termExpansion(on,Env,CPList),
	tell('/tmp/compile.tmp'),
	write((:- dynamic(constraint/8))), write('.'), nl,
	write((:- dynamic(numb/1))), write('.'), nl,
%	write((:- dynamic(in/9))), write('.'), nl,
%	write((:- dynamic(kb_in/10))), write('.'), nl,
	write((:- dynamic(falsum/2))), write('.'), nl,
%	write((:- dynamic(conceptName/4))), write('.'), nl,
%	write((:- dynamic(roleName/4))), write('.'), nl,
%	write((:- dynamic(conceptEqualSets/6))), write('.'), nl,
	write((:- dynamic(conceptSubsets/6))), write('.'), nl,
%	write((:- dynamic(eq/9))), write('.'), nl,
	write((:- dynamic(inconsistencyCheck/3))), write('.'), nl,
	write((:- dynamic(roleEqualSets/6))), write('.'), nl,
	write((:- dynamic(roleSubsets/6))), write('.'), nl,
	write((:- dynamic(conceptElement/7))), write('.'), nl,
	write((:- dynamic(roleElement/8))), write('.'), nl,
	write((:- dynamic(closed/5))), write('.'), nl,
	write((:- dynamic(sub/4))), write('.'), nl,
	write((:- dynamic(succ/4))), write('.'), nl,
	write((:- dynamic(nsub/4))), write('.'), nl,
	write((:- dynamic(sub3/2))), write('.'), nl,
	write((:- dynamic(succ3/2))), write('.'), nl,
	write((:- dynamic(nsub3/2))), write('.'), nl,
	write((:- dynamic(abductiveDerivation/3))), write('.'), nl,
	write((:- dynamic(consistencyDerivation/3))), write('.'), nl,
	write((:- dynamic(hypothesis/1))), write('.'), nl,
	write((:- dynamic(roleDomain/4))), write('.'), nl,
	write((:- dynamic(roleRange/4))), write('.'), nl,
	write((:- dynamic(roleDefault/4))), write('.'), nl,
	write((:- dynamic(roleNr/4))), write('.'), nl,
	write((:- dynamic(roleDefNr/4))), write('.'), nl,
	write((:- dynamic(roleAttributes/5))), write('.'), nl,
%	write((:- dynamic(given_inflLink/4))), write('.'), nl,
%	write((:- dynamic(given_change/4))), write('.'), nl,
	write((:- dynamic(valueOfCounter/2))), write('.'), nl,
	write((:- dynamic(isMooOption/2))), write('.'), nl,
%	write((:- dynamic(environment/3))), write('.'), nl,
%	write((:- dynamic(conceptHierarchy/3))), write('.'), nl,
%	write((:- dynamic(roleHierarchy/3))), write('.'), nl,
	write((:- dynamic(modalAxiom/6))), write('.'), nl,
%	write((:- dynamic(rel/5))), write('.'), nl,
	write((:- dynamic(compiledPredicate/2))), write('.'), nl,
	writeq((:- assertaRE(environment(EnvName,Env,Comment)))), write('.'), nl,
	writeq((:- retractallSpecial(currentEnvironment(_)))), write('.'), nl,
	writeq((:- assertaRE(currentEnvironment(Env)))), write('.'), nl,
	writeCompiledPredicateFactsToFile(Env,CPList),
	expand_term((in(Env,Name,modal(MS),CN,CON,hyp(HYP),
                        ab(D),call(CALL),PT) :-
	                   kb_in(Env,pr(5),Name,modal(MS),CN,CON,hyp(HYP),
                                 ab(D),call(CALL),PT)),
		    InClause1),
	writeq(InClause1), write('.'), nl,
	expand_term((in(Env,Name,modal(MS),CN,CON,
                        hyp([or(H1),rl(H2),fl(H3)]),ab(noAb),call(CALL),PT) :-
		           clashInHyp(H2), !, fail),
		    InClause2),
	writeq(InClause2), write('.'), nl,
	expand_term(in(Env,X2,X3,X4,X5,X6,X7,X8,X9), Head3),
	writeq((Head3 :- kb_in(Env,pr(3),X2,X3,X4,X5,X6,X7,X8,X9))),
	write('.'), nl,
	expand_term((in(Env,Name,modal(MS),CN,CON,hyp(HYP),
                        ab(D),call(CALL),PT) :-
		          (CN \== top, CN \== bot, CN \== not(top), 
                           CN \== not(bot),
	                   kb_in(Env,pr(3),Name,modal(MS),CN,CON,hyp(HYP),
                                 ab(D),call(CALL),PT))),
		    InClause4),
	writeq(InClause4), write('.'), nl,
	expand_term((in(Env,Name,modal(MS),CN,CON,hyp(HYP),
                        ab(D),call(CALL),PT) :-
		          (CN \== top,CN \== bot, CN \== not(top), 
                           CN \== not(bot),
			   kb_in(Env,pr(1),Name,modal(MS),CN,CON,hyp(HYP),
				 ab(D),call(CALL),PT))),
		    InClause5),
	writeq(InClause5), write('.'), nl,
	repeat,
	read(Clause),
	treatClause(Clause),
	seen,
	told,
	assertConnectionClauses(Env),
	termExpansion(off,Env),
	compile('/tmp/compile.tmp'),
	!.
compileEnvironment(FileName,EnvName) :-
	% Some file handling error has occured
	seen,
	told,
	!,
	fail.

treatClause('end_of_file') :-
	!.
treatClause((:-dynamic Pred/Arity)) :-
%	write((:-dynamic Pred/Arity)), write('.'), nl,
	!,
	fail.
treatClause((in(_X1,_X2,_X3,_X4,_X5,_X6,_X7,_X8,_X9) :- _Body)) :-
	!,
	fail.
treatClause(X) :-
	expand_term(X,Y),
	writeq(Y), write('.'), nl,
	!,
	fail.

writeCompiledPredicateFactsToFile(Env,[]) :-
	!.
writeCompiledPredicateFactsToFile(Env,[Pred/Arity|List]) :-
	writeq((compiledPredicate(Env,Pred/Arity))),
	write('.'), nl,
	writeCompiledPredicateFactsToFile(Env,List).

assertConnectionClauses(Env) :-
	expand_term(constraint(Env,X2,X3,X4,X5,X6,X7,X8),CompConAtom),
	assertzRE((constraint(Env,X2,X3,X4,X5,X6,X7,X8) :-
		 CompConAtom)),
	expand_term(eq(Env,X2,X3,X4,X5,X6,X7,X8,X9),CompEqAtom),
	assertzRE((eq(Env,X2,X3,X4,X5,X6,X7,X8,X9) :-
		 CompEqAtom)),
	expand_term(in(Env,X2,X3,X4,X5,X6,X7,X8,X9),CompInAtom),
	assertzRE((in(Env,X2,X3,X4,X5,X6,X7,X8,X9) :-
		 CompInAtom)),
%	assertzRE((kb_in(Env,X2,X3,X4,X5,X6,X7,X8,X9,X10) :-
%		 comp_kb_in(Env,X2,X3,X4,X5,X6,X7,X8,X9,X10))),
	expand_term(rel(Env,X2,X3,X4,X5),CompRelAtom),
	assertzRE((rel(Env,X2,X3,X4,X5) :-
		 CompRelAtom)),
	!.

termExpansion(on,env(Id),
              [CompCon/8,CompEq/9,CompIn/9,CompKb_in/10,CompRel/6]) :-
	% Generate the names for the compiled in, kb_in, constraint, and rel
	% predicates in environment Id.
	atom_codes(Id,IdChars),
	atom_codes(in,InChars),
	append(InChars,[95,99,95|IdChars],CompInChars),
	atom_codes(CompIn,CompInChars),
	atom_codes(constraint,ConChars),
	append(ConChars,[95,99,95|IdChars],CompConChars),
	atom_codes(CompCon,CompConChars),
	atom_codes(eq,EqChars),
	append(EqChars,[95,99,95|IdChars],CompEqChars),
	atom_codes(CompEq,CompEqChars),
	atom_codes('kb_in',Kb_inChars),
	append(Kb_inChars,[95,99,95|IdChars],CompKb_inChars),
	atom_codes(CompKb_in,CompKb_inChars),
	atom_codes('rel',RelChars),
	append(RelChars,[95,99,95|IdChars],CompRelChars),
	atom_codes(CompRel,CompRelChars),
	% Abolish any previously asserted clauses for the 
	% compiled predicades
	abolish(CompCon/8),
	abolish(CompEq/9),
	abolish(CompIn/9),
	abolish(CompKb_in/10),
	abolish(CompRel/6),
	% Generate the atoms for these predicates 
	CompConAtom =.. [CompCon|[X4,X1,X2,X3,X5,X6,X7,X8]],
	CompEqAtom =.. [CompEq|[X4-X5,X1,X2,X3,X6,X7,X8,X9]],
	CompInAtom =.. [CompIn|[X4-X5,X1,X2,X3,X6,X7,X8,X9]],
	CompKb_inAtom =.. [CompKb_in|[X5-X6,X1,X2,X3,X4,X7,X8,X9,X10]],
	CompRelAtom =.. [CompRel|[X1,X2,X3,X4,X5,X6]],
	% Assert the term_expansion rules needed to translate the
	% interpreted clauses into compiled clauses.
	abolish(term_expansion/2),
	assertzRE((term_expansion((Head :- Body),(Head1 :- Body1)) :-
	term_expansion(Head,Head1),
	term_expansion(Body,Body1))),
	assertzRE((term_expansion((L, Body), (L1,Body1)) :-
	term_expansion(L,L1),
	term_expansion(Body,Body1))),
	assertzRE((term_expansion((L; Body), (L1,Body1)) :-
	term_expansion(L,L1),
	term_expansion(Body,Body1))),
	assertzRE((term_expansion(\+Atom,\+Atom1) :-
	term_expansion(Atom,Atom1))),
	assertzRE((term_expansion(constraint(X1,X2,X3,X4,X5,X6,X7,X8),
				CompConAtom))),
	assertzRE((term_expansion(eq(X1,X2,X3,X4,X5,X6,X7,X8,X9),
				CompEqAtom))),
	assertzRE((term_expansion(in(X1,X2,X3,X4,X5,X6,X7,X8,X9),
				CompInAtom))),
	assertzRE((term_expansion(kb_in(X1,X2,X3,X4,X5,X6,X7,X8,X9,X10),
				CompKb_inAtom))),
	assertzRE((term_expansion(rel(X1,X2,X3,X4,X5),
				CompRelAtom))),
	assertzRE((term_expansion(once(Body1),once(Body2)) :-
		term_expansion(Body1,Body2))),
	assertzRE((term_expansion(call(Body1),call(Body2)) :-
		 term_expansion(Body1,Body2))),
	assertzRE(term_expansion(X,X)),
	!.
termExpansion(off,_) :-
	abolish(term_expansion/2),
	!.

/**********************************************************************
 *
 * @(#) convertToLogicalCNF.pl 1.4@(#)
 *
 */

/***********************************************************************
 *
 * negate(+C1,-C2)
 * C2 is just the term not(C1).
 *
 */

negate(not(C1),C1) :- !.
negate(C1,not(C1)) :- !.

/***********************************************************************
 *
 * invert(+R1,-R2)
 * R2 is just the term inverse(R1).
 *
 */

invert(inverse(R),R) :- !.
invert(R,inverse(R)) :- !.

/***********************************************************************
 *
 * normalizeNot(+C1,-C2)
 * applies the laws
 *      not(and([A,B]))   -> and([not(A),not(B)])
 *      not(or([A,B]))    -> or([not(A),not(B)])
 *      not(not(A))       -> A
 *      not(all(R,C))     -> some(R,not(C))
 *      not(some(R,C))    -> all(R,not(C))
 *      not(atleast(N,R)) -> atmost(N-1,R)
 *      not(atmost(N,R))  -> atleast(N+1,R)
 *      not(b(O,P,C))     -> d(O,P,not(C))
 *      not(d(O,P,C))     -> b(O,P,not(C))
 * to C1 as long as possible to get C2.
 *
 */

normalizeNot(not(and([C1,C2|L1])),or(L3)) :-
	!,
	hop_map(negate,[C1,C2|L1],L2),
	hop_map(normalizeNot,L2,L3).
normalizeNot(not(and([C1])),C3) :-
	negate(C1,C2),
        normalizeNot(C2,C3).
normalizeNot(not(and([])),'bot') :-
	!.
normalizeNot(not(set(L)),not(set(L))) :-
	!.
normalizeNot(not(or([C1,C2|L1])),and(L3)) :-
	!,
	hop_map(negate,[C1,C2|L1],L2),
	hop_map(normalizeNot,L2,L3).
normalizeNot(not(or([C1])),C3) :-
	negate(C1,C2),
        normalizeNot(C2,C3).
normalizeNot(not(or([])),'top') :-
	!.
normalizeNot(not(all(R,C1)),some(R,C2)) :-
	normalizeNot(not(C1),C2).
normalizeNot(not(some(R,C1)),all(R,C2)) :-
	normalizeNot(not(C1),C2).
normalizeNot(not(atleast(N,R)),atmost(M,R)) :-
	M is N-1.
normalizeNot(not(atmost(N,R)),atleast(M,R)) :-
	M is N+1.
normalizeNot(not(b(O,P,C1)),d(O,P,C2)) :-
	normalizeNot(not(C1),C2).
normalizeNot(not(d(O,P,C1)),b(O,P,C2)) :-
	normalizeNot(not(C1),C2).
normalizeNot(not(bc(O,P,C1)),dc(O,P,C2)) :-
	normalizeNot(not(C1),C2).
normalizeNot(not(dc(O,P,C1)),bc(O,P,C2)) :-
	normalizeNot(not(C1),C2).
normalizeNot(not(b(O,P)),d(O,P)) :-
	!.
normalizeNot(not(d(O,P)),b(O,P)) :-
	!.
normalizeNot(not(bc(O,P)),dc(O,P)) :-
	!.
normalizeNot(not(dc(O,P)),bc(O,P)) :-
	!.
normalizeNot(not(not(C1)),C3) :-
	!,
	normalizeNot(C1,C3).
normalizeNot(not(set([])),top) :- !.
normalizeNot(not(top),bot) :- !.
normalizeNot(not(bot),top) :- !.
normalizeNot(C1,C1).

/***********************************************************************
 *
 * normalizeInverse(+R1,-R2)
 * applies the laws
 *      inverse(and([R,S])) -> and([inverse(R),inverse(S)])
 *      inverse(inverse(R)) -> R
 * to R1 as long as possible to get R2.
 *
 */

normalizeInverse(inverse(and(RL1)),and(RL3)) :-
	hop_map(invert,RL1,RL2),
	hop_map(normalizeInverse,RL2,RL3),
	!.
normalizeInverse(inverse(inverse(R1)),R3) :-
	normalizeInverse(R1,R3).
normalizeInverse(R1,R1).

/***********************************************************************
 *
 * logicalFlatten(+C1,-C2)
 * deletes unnecessary occurrences of `and' and `or' in C1 to get C2.
 *
 */

logicalFlatten(and(L1),and(L2)) :-
	!,
	hop_map(logicalFlatten,L1,L3),
	flattenAnd([],L3,L2).
logicalFlatten(or(L1),or(L2)) :-
	!,
	hop_map(logicalFlatten,L1,L3),
	flattenOr([],L3,L2).
logicalFlatten(set(L1),set(L1)) :-
	!.
logicalFlatten(all(R1,C1),all(R2,C2)) :-
	logicalFlatten(R1,R2),
	logicalFlatten(C1,C2).
logicalFlatten(some(R1,C1),some(R2,C2)) :-
	logicalFlatten(R1,R2),
	logicalFlatten(C1,C2).
logicalFlatten(atleast(N,R1),atleast(N,R2)) :-
	logicalFlatten(R1,R2).
logicalFlatten(atmost(N,R1),atmost(N,R2)) :-
	logicalFlatten(R1,R2).
logicalFlatten(b(O,P,C1),b(O,P,C2)) :-
	logicalFlatten(C1,C2).
logicalFlatten(d(O,P,C1),d(O,P,C2)) :-
	logicalFlatten(C1,C2).
logicalFlatten(bc(O,P,C1),bc(O,P1,C2)) :-
	logicalFlatten(P,P1),
	logicalFlatten(C1,C2).
logicalFlatten(dc(O,P,C1),dc(O,P1,C2)) :-
	logicalFlatten(P,P1),
	logicalFlatten(C1,C2).
logicalFlatten(not(C1),not(C2)) :-
	!,
	logicalFlatten(C1,C2).
logicalFlatten(inverse(R1),inverse(R2)) :-
	logicalFlatten(R1,R2).
logicalFlatten(C1,C1).


/***********************************************************************
 *
 * flattenAnd(+L1,+L2,-L3)
 * eliminates occurrences of `and' in L2 to get L2'. L3 is the result
 * of appending L2' to L1.
 *
 */

flattenAnd(L1,[and(L2)|L3],L4) :-
	!,
%	flattenAnd([],L2,L5),
	L5 = L2,
	append(L1,L5,L6),
	flattenAnd(L6,L3,L4).
flattenAnd(L1,[C1|L3],L4) :-
	append(L1,[C1],L6),
	flattenAnd(L6,L3,L4).
flattenAnd(L1,[],L1).

/***********************************************************************
 *
 * flattenOr(+L1,+L2,-L3)
 * eliminates occurrences of `or' in L2 to get L2'. L3 is the result
 * of appending L2' to L1.
 *
 */
 
flattenOr(L1,[or(L2)|L3],L4) :-
	!,
%	flattenOr([],L2,L5),
	L5 = L2,
	append(L1,L5,L6),
	flattenOr(L6,L3,L4).
flattenOr(L1,[C1|L3],L4) :-
	append(L1,[C1],L6),
	flattenOr(L6,L3,L4).
flattenOr(L1,[],L1).

/***********************************************************************
 *
 * distributeAnd(and(+L1),or(+L2),or(-L3))
 * here or(L3) has the form
 *     or([C_1,...,C_n])
 * where C_i is the result of applying de Morgan's laws to
 * and(L1|[A_i]) 
 * where A_i is the ith element of L2.
 *
 */

distributeAnd(and(L1),or([C2|L2]),or([C3|L4])) :-
	% L3 := L1 and C2
	append(L1,[C2],L3),
	% C3 := deMorganAnd(L3)
	deMorgan(and(L3),C3),
	% build other disjuncts
	distributeAnd(and(L1),or(L2),or(L4)).
distributeAnd(and(_L1),or([]),or([])).

/***********************************************************************
 *
 * distributeOr(or(+L1),and(+L2),and(-L3))
 * here and(L3) has the form
 *     and([C_1,...,C_n])
 * where C_i is the result of applying de Morgan's laws to
 * or(L1|[A_i]) 
 * where A_i is the ith element of L2.
 *
 */
	
distributeOr(or(L1),and([C2|L2]),and([C3|L4])) :-
	% L3 := L1 or C2
	append(L1,[C2],L3),
	% C3 := deMorgan(L3)
	deMorgan(or(L3),C3),
	% build other conjuncts
	distributeOr(or(L1),and(L2),and(L4)).
distributeOr(or(_L1),and([]),and([])).
	
/***********************************************************************
 *
 * deMorganAnd(+L1,+L2,-C1)
 * applies de Morgan's law
 *      and([A,or([B,C])]) -> or([and([A,B]),and([A,C])])
 * to and(L1|L2) as long as possible to get C1.
 *
 */

deMorganAnd(L1,[or(L2)|L3],L4) :-
	append(L1,L3,L5),
	distributeAnd(and(L5),or(L2),L4).
deMorganAnd(L1,[C1|L3],L4) :-
	append(L1,[C1],L5),
	deMorganAnd(L5,L3,L4).
deMorganAnd(L1,[],and(L1)).

/***********************************************************************
 *
 * deMorganOr(+L1,+L2,-C1)
 * applies de Morgan's law
 *      or([A,or([B,C])]) -> and([or([A,B]),or([A,C])])
 * to or(L1|L2) as long as possible to get C1.
 *
 */

deMorganOr(L1,[and(L2)|L3],L4) :-
	append(L1,L3,L5),
	distributeOr(or(L5),and(L2),L4).
deMorganOr(L1,[C1|L3],L4) :-
	append(L1,[C1],L5),
	deMorganOr(L5,L3,L4).
deMorganOr(L1,[],or(L1)).

/***********************************************************************
 *
 * deMorgan(+C1,-C2)
 * applies de Morgan's laws to C1
 *      and([A,or([B,C])]) -> or([and([A,B]),and([A,C])])
 *      or([A,and([B,C])]) -> and([or([A,B]),or([A,C])])
 * as long as possible to get C2.
 *
 */

deMorgan(and(L1),C1) :-
	deMorganAnd([],L1,C1).
deMorgan(or(L1),C1) :-
	deMorganOr([],L1,C1).
deMorgan(C1,C1) :-
	!.

/***********************************************************************
 *
 * convertToLogicalCNF(+C1,-C2)
 * C2 is the conjunctive normalform of C1.
 *
 */

convertToLogicalCNF(C1,C6) :-
	normalizeNot(C1,C2),
	logicalFlatten(C2,C3),
	normalizeInverse(C3,C4),
	deMorgan(C4,C5),
	logicalFlatten(C5,C6).

/**********************************************************************
 *
 * @(#) conceptFunctions.pl 1.5@(#)
 *
 */

/***********************************************************************
 *
 * memberConcept(+Concept,+Dag)
 * Arguments: Concept     concept atom_codes
 *            Dag         subsumption hierarchy
 * checks wether or not Concept occurs in the subsumption hierarchy.
 *
 */

memberConcept(Concept,Dag) :-
	memberElement(Concept,Dag).

memberConceptSubtrees(Concept,List) :-
	memberElementSubtrees(Concept,List).

/***********************************************************************
 *
 * memberDirectSubConcepts(+Concept,+Dag)
 * Arguments: Concept     concept atom_codes
 *            Dag         subsumption hierarchy
 * checks wether or not Concept occurs in the direct subconcepts of
 * the top concept of Dag.
 *
 */

memberDirectSubConcepts(Concept,node(_CL,NL)) :-
	!,
	memberDirectSubElements(Concept,NL).

memberDirectSubConcepts(Concept,List) :-
	memberDirectSubElements(Concept,List).

/***********************************************************************
 *
 * getDirectSuperConcepts(+EnvName,+MS,+Concept,-CL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Concept     concept atom_codes
 *            CL          list of concept names
 * CL is the list of all concept names which are direct super concepts
 * of Concept.
 *
 */

getDirectSuperConcepts(EnvName,MS,Concept,CL) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	getDirectSuperElements(Concept,CL,Dag).


/***********************************************************************
 *
 * getAllSuperConcepts(+EnvName,+MS,+Concept,-CL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Concept     concept atom_codes
 *            CL          list of concept names
 * CL is the list of all concept names which are super concepts of
 * Concept.
 *
 */

getAllSuperConcepts(EnvName,MS,Concept,CL) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	getAllSuperElements(Concept,CL,Dag).

/***********************************************************************
 *
 * getDirectSubConcepts(+EnvName,+MS,+Concept,-CL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Concept     concept atom_codes
 *            CL          list of concept names
 * CL is the list of all concept names which are direct super concepts
 * of Concept.
 *
 */

getDirectSubConcepts(EnvName,MS,Concept,CL) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	getDirectSubElements(Concept,CL,Dag).

/***********************************************************************
 *
 * getAllSubConcepts(+EnvName,+MS,+Concept,-CL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Concept     concept atom_codes
 *            CL          list of concept names
 * CL is the list of all concept names which are super concepts of 
 * Concept.
 *
 */

getAllSubConcepts(EnvName,MS,Concept,CL) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	getAllSubElements(Concept,CL,Dag).

/***********************************************************************
 *
 * getConcepts(+MS,-CL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            CL          list of concept names
 * CL is the list of all concept names in the subsumption hierarchy.
 *
 */

getConcepts(EnvName,MS,['top'|CL]) :-
	getAllSubConcepts(EnvName,MS,'top',CL).

/***********************************************************************
 *
 * testDirectSuperConcept(+EnvName,+MS,+Concept1,+Concept2,-Concept)
 * Arguments: EnvName        environment identifier
 *            MS             modal context
 *            Concept1       concept atom_codes
 *            Concept2       concept atom_codes
 *            Concept        concept atom_codes
 * Concept is Concept1 iff Concept1 is a direct superconcept of Concept2
 * or
 * Concept is Concept2 iff Concept2 is a direct superconcept of Concept1
 * otherwise
 * the predicate fails.
 *
 */

testDirectSuperConcept(EnvName,MS,Concept1,Concept2,Concept) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	testDirectSuperElement(Concept1,Concept2,Concept,Dag).

/***********************************************************************
 *
 * testDirectSubConcept(+EnvName,+MS,+Concept1,+Concept2,-Concept)
 * Arguments: EnvName        environment identifier
 *            MS             modal context
 *            Concept1       concept atom_codes
 *            Concept2       concept atom_codes
 *            Concept        concept atom_codes
 * Concept is Concept1 iff Concept1 is a direct subconcept of Concept2
 * or
 * Concept is Concept2 iff Concept2 is a direct subconcept of Concept1
 * otherwise
 * the predicate fails.
 *
 */

testDirectSubConcept(EnvName,MS,Concept1,Concept2,Concept) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	testDirectSubElement(Concept1,Concept2,Concept,Dag).

/***********************************************************************
 *
 * testSuperConcept(+EnvName,+MS,+Concept1,+Concept2,-Concept)
 * Arguments: EnvName        environment identifier
 *            MS             modal context
 *            Concept1       concept atom_codes
 *            Concept2       concept atom_codes
 *            Concept        concept atom_codes
 * Concept is Concept1 iff Concept1 is a direct superconcept of Concept2
 * or
 * Concept is Concept2 iff Concept2 is a direct superconcept of Concept1
 * otherwise
 * the predicate fails.
 *
 */

testSuperConcept(EnvName,MS,Concept1,Concept2,Concept) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	testSuperElement(Concept1,Concept2,Concept,Dag).

/***********************************************************************
 *
 * testSubConcept(+EnvName,+MS,+Concept1,+Concept2,-Concept)
 * Arguments: EnvName        environment identifier
 *            MS             modal context
 *            Concept1       concept atom_codes
 *            Concept2       concept atom_codes
 *            Concept        concept atom_codes
 * Concept is Concept1 iff Concept1 is a direct superconcept of Concept2
 * or
 * Concept is Concept2 iff Concept2 is a direct superconcept of Concept1
 * otherwise
 * the predicate fails.
 *
 */

testSubConcept(EnvName,MS,Concept1,Concept2,Concept) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Dag),
	testSubElement(Concept1,Concept2,Concept,Dag).

/***********************************************************************
 *
 * getCommonSuperConcepts(+EnvName,+MS,+CL1,-CL2)
 * Arguments: EnvName  environment identifier
 *            MS       modal context
 *            CL1      list of concept names
 *            CL2      list of concept names
 * CL2 is the list of all concept names subsuming all concepts in CL1.
 *
 */

getCommonSuperConcepts(EnvName,MS,CL1,CL2) :-
	hop_map(getAllSuperConcepts,[EnvName,MS],CL1,CLL1),
	intersectionOfLists(CLL1,CL2).

/***********************************************************************
 *
 * getCommonSubConcepts(+EnvName,+MS,+CL1,-CL2)
 * Arguments: EnvName  environment identifier
 *            MS       modal context
 *            CL1      list of concept names
 *            CL2      list of concept names
 * CL2 is the list of all concept names which are subsumed by all
 * concepts in CL1.
 *
 */

getCommonSubConcepts(EnvName,MS,CL1,CL2) :-
	hop_map(getAllSubConcepts,[EnvName,MS],CL1,CLL1),
	intersectionOfLists(CLL1,CL2).

/***********************************************************************
 *
 * getAllObjects(+EnvName,+MS,+O)
 *
 */

getAllObjects(EnvName,MS,O13) :-
	!,
	environment(EnvName,Env,_),
	setofOrNil(X1,[C1,AX1]^(conceptElement(Env,MS,_,user,X1,C1,AX1)),O1),
	setofOrNil(X2,[R2,Y2,AX2]^roleElement(Env,MS,_,user,X2,Y2,R2,AX2),O2),
	setofOrNil(Y3,[R3,X3,AX3]^roleElement(Env,MS,_,user,X3,Y3,R3,AX3),O3),
	unionSpecial( O1,O2,O12),
	unionSpecial(O12,O3,O13),
	!.
/**********************************************************************
 *
 * @(#) constraints.pl 1.9@(#)
 *
 */

/**********************************************************************
 *
 * solveConstraint(MS,(card,app((FF:R),X),Rel,N),hyp(HYPS),call(CALLS))
 * if Rel is '>=', 
 *    the predicate succeeds if the cardinality of 
 *    app((FF:R),X) in modal context MS is greater than N.
 *    If N is a variable, it will be instantiated with the greatest
 *    number M such that the cardinality of  app((FF:R),X) in modal 
 *    context MS is provably greater than M.
 * if Rel is '=<', 
 *    the predicate succeeds if the cardinality of 
 *    app((FF:R),X) in modal context MS is smaller than N.
 *    If N is a variable, it will be instantiated with the greatest
 *    number M such that the cardinality of  app((FF:R),X) in modal 
 *    context MS is provably smaller than M.
 *
 */

solveConstraint(Env,MS,(card,app((FF:R),X),Rel,N),(PL,EL),hyp(HYPS),ab(D),call(CALLS),PTO) :-
%	checkCallStack(CALLS,true),
%	SolveHead = solveConstraint(AN,MS,(card,app((FF:R),X),Rel,N),hyp(HYPS)),
	length(CALLS,XXX),
	CALLS1 = CALLS,
	ifMooOption(traceOutput,yes,(format('trying ~d  solve(~w(~w)) ~w ~w~n',[XXX,R,X,Rel,N]))),
	collectAllFillers(Env,MS,R,X,HYPS,D,CALLS1,S),
	computeNumber(S,Rel,(M,EL,PL,PTAbox)),
	continueSolve(Env,MS,(card,app((FF:R),X),Rel,N),hyp(HYPS),ab(D),call(CALLS1),(M,PTAbox),PT),
	PTO = proved(MS,card(R,X,Rel,N),basedOn(PT)).
	

computeNumber([],'=<',(noMaxRestriction,[],[],basedOn(noAboxEntries))) :- !.
computeNumber([],'>=',(noMinRestriction,[],[],basedOn(noAboxEntries))) :- !.
computeNumber(S,_Rel,(M,EL,PL,and(PL))) :-
	reduceToSolutionSet(S,EL,PL),
	length(EL,M).

reduceToSolutionSet([],[],[]) :- !.
reduceToSolutionSet([(E1,PT1,_)|L],L2,L3) :-
	member((E1,_PT2,_R2),L),
	!,
	reduceToSolutionSet(L,L2,L3).
reduceToSolutionSet([(E1,PT1,_)|L],[E1|L2],[PT1|L3]) :-
	reduceToSolutionSet(L,L2,L3).


continueSolve(_,_,(card,_,'=<',N),hyp(_),ab(_),call(_),(M,_PTAbox),_) :-
	number(M),
	nonvar(N),
	M > N,
	!,
	fail.
continueSolve(Env,MS,(card,app((FF:R),X),Rel,M1),hyp(HYPS),ab(D),call(CALLS),(M1,PTAbox),PT3) :-
	number(M1),
	closed(Env,MS,X,newSkolem,R),
	!.
continueSolve(Env,MS,(card,app((FF:R),X),Rel,N),hyp(HYPS),ab(D),call(CALLS),(M1,PTAbox),PT3) :-
	member(solveConstraint(Env,RL2,noEquivalence,_),CALLS),
%	member(R,RL2),
	collectAllConstraints(Env,MS,[R],X,Rel,HYPS,D,CALLS,S),
	findNumberRestriction(Rel,(M1,PTAbox),S,(M3,PT3)),
	!,
	comparisonForRestriction(Rel,M3,N).
continueSolve(Env,MS,(card,app((FF:R),X),Rel,N),hyp(HYPS),ab(D),call(CALLS),(M1,PTAbox),PT3) :-
	not(member(solveConstraint(Env,RL2,noEquivalence,_),CALLS)),
	bagofOrNil(R1,AX2^RN2^S2^O2^F^PT2^(eq(Env,rn(AX2,RN2,S2,O2),modal(MS1),app((F:R),X),app((F:R1),X),hyp(HYPS),ab(D),call(CALLS),PT2), nonvar(F)),RL),
	CALLS1 = [solveConstraint(Env,RL,noEquivalence,_)|CALLS],
	collectAllConstraints(Env,MS,RL,X,Rel,HYPS,D,CALLS1,S),
	findNumberRestriction(Rel,(M1,PTAbox),S,(M3,PT3)),
	!,
	comparisonForRestriction(Rel,M3,N).

collectAllFillers(Env,MS,R,X,HYPS,D,CALLS,S) :-
	EqLiteral = eqGenerator(Env,AX,RN,S,O,MS,Y,app((FF:R),X),HYPS,D,CALLS,PT),
	bagof((Y,PT,[Env,MS,R,X,HYPS,D,CALLS]),AX^RN^S^O^FF^EqLiteral,S),
	!.
collectAllFillers(_,_,_,_,_,_,_,[]) :-
	!.


collectAllConstraints(Env,MS,RL,X,Rel,HYPS,D,CALLS,S) :-
	C1 = constraint(Env,rn(AX1,RN1,S1,O1),MS,(card,app((FF:R1),X),Rel,M2),
			hyp(HYPS),ab(D),call(CALLS),PT),
	bagof((M2,PT,[Env,MS,FF,R1,X,Rel,HYPS,D,CALLS]),AX1^RN1^S1^O1^PT1^FF^AX2^RN2^S2^O2^F^PT2^(member(R1,RL),C1),S),
	!.
collectAllConstraints(_,_MS,_RL,_X,_Rel,_HYPS,_D,_CALLS,[]) :-
	!.


/**********************************************************************
 * 
 * comparisonForRestriction(+Rel,+M,?N)
 * if N is a variable then N is instantiated with M and the predicate
 * succeeds.
 * if N is a number, the predicates succeeds if then goal Rel(M,N)
 * succeeds.
 *
 */

comparisonForRestriction(_Rel,M3,N) :-
	var(N),
	!,
	N = M3.
comparisonForRestriction(Rel,M3,N) :-
	number(M3), number(N),
	Goal =.. [Rel,M3,N],
	call(Goal).
comparisonForRestriction(>=,noMaxRestriction,N) :-
	!.
comparisonForRestriction(>=,noMinRestriction,N) :-
	!,
	fail.
comparisonForRestriction(=<,noMaxRestriction,N) :-
	!,
	fail.
comparisonForRestriction(=<,noMinRestriction,N) :-
	!.
comparisonForRestriction(>=,M,noMaxRestriction) :-
	!,
	fail.
comparisonForRestriction(>=,M,noMinRestriction) :-
	!.
comparisonForRestriction(=<,M,noMaxRestriction) :-
	!.
comparisonForRestriction(=<,M,noMinRestriction) :-
	!,
	fail.

	
/**********************************************************************
 *
 * findNumberRestristriction(+Rel,+L,-N)
 * if Rel is '=<' then N will be instantiated with the smallest number
 * in the list of numbers L.
 * if Rel is '>=' then N will be instantiated with the greatest number
 * in the list of numbers L.
 *
 */

%findNumberRestriction('=<',(noRestriction,PT1),[],(1000000,PT1)) :- !.
%findNumberRestriction('>=',(noRestriction,PT1),[],(0,PT1)) :- !.
%findNumberRestriction('>=',(N,PT1),[],(N,PT1)) :- !.
%findNumberRestriction('=<',(N,PT1),[],(1000000,noConstraintsFound)) :- !.
findNumberRestriction('>=',(N,PT1),[],(N,PT1)) :- !.
findNumberRestriction('=<',(N,PT1),[],(noMaxRestriction,noConstraintsFound)) :- !.
findNumberRestriction(_,(noMinRestriction,_),[(N1,PT2,_)],(N1,PT2)) :- !.
findNumberRestriction(_,(noMaxRestriction,_),[(N1,PT2,_)],(N1,PT2)) :- !.
findNumberRestriction('=<',(M,_PT1),[(N1,PT2,_)],(N1,PT2)) :-
	comparisonForRestriction(=<,N1,M),
	!.
findNumberRestriction('=<',(M,PT1),[(_N1,_,_)],(M,PT1)) :-
	!.
findNumberRestriction('>=',(M,PT1),[(N1,_,_)],(M,PT1)) :-
	comparisonForRestriction(>=,M,N1),
	!.
findNumberRestriction('>=',(_M,_),[(N1,PT2,_)],(N1,PT2)) :-
	!.
findNumberRestriction('>=',(K,PT1),[(N1,_,_)|NL],(N2,PT3)) :-
	findNumberRestriction('>=',(K,PT1,_),NL,(N2,PT3)),
	comparisonForRestriction(>=,N2,N1),
	!.
findNumberRestriction('=<',(K,PT1),[(N1,_,_)|NL],(N2,PT3)) :-
	findNumberRestriction('=<',(K,PT1,_),NL,(N2,PT3)),
	comparisonForRestriction(=<,N2,N1),
	!.
findNumberRestriction(_,_,[(N1,PT1,_)|_NL],(N1,PT1)) :-
	!.


subtractRestrictions(N1,N2,M) :-
	number(N1),
	number(N2),
	!,
	M is N1 - N2.
subtractRestrictions(N1,noMaxRestriction,noMaxRestriction) :-
	!.
subtractRestrictions(noMinRestriction,N2,noMinRestriction) :-
	!.
subtractRestrictions(N1,N2,N1).

addRestrictions(N1,N2,M) :-
	number(N1),
	number(N2),
	!,
	M is N1 + N2.
addRestrictions(noMinRestriction,N2,N2) :-
	number(N2),
	!.
addRestrictions(N1,noMinRestriction,N1) :-
	number(N1),
	!.
addRestrictions(noMaxRestriction,N2,noMaxRestriction) :-
	!.
addRestrictions(N1,noMaxRestriction,noMaxRestriction) :-
	!.
addRestrictions(noMinRestriction,N2,noMinRestriction) :-
	!.







/**********************************************************************
 *
 * @(#) construct.pl 1.13@(#)
 *
 */

inProofTerm(MS,rn(AX,Rule,_,_),D,X,HYPS,PT1,PT) :-
	nonvar(AX),
	conceptSubsets(_Env,_user,MS1,C1,C2,AX),
	PT = proved(in(MS1,D,X),usingAxiom(defprimconcept(C1,C2)),basedOn(PT1)),
	!.
inProofTerm(MS,rn(AX,Rule,_,_),D,X,HYPS,PT1,PT) :-
	nonvar(AX),
	conceptEqualSets(_Env,_user,MS1,C1,C2,AX),
	PT = proved(in(MS1,D,X),usingAxiom(defconcept(C1,C2)),basedOn(PT1)),
	!.
inProofTerm(MS,rn(AX,Rule,_,_),D,X,HYPS,PT1,PT) :-
	nonvar(AX),
	conceptElement(_Env,MS1,_,user,C1,C2,AX),
	PT = proved(in(MS1,D,X),usingAxiom(assert_ind(C1,C2)),basedOn(PT1)),
	!.
inProofTerm(MS,rn(AX,Rule,_,_),D,X,HYPS,PT1,PT) :-
	!.

inProofTerm(MS,Name,D,X,HYPS,PT1,PT) :-
	PT = proved(in(MS,Name,D,X),basedOn(PT1)),
	!.
inProofTerm(MS,D,X,HYPS,PT1,PT) :-
	PT = proved(in(MS,D,X),basedOn(PT1)),
	!.

eqProofTerm(MS,Y,_FF,R,X,HYPS,PT1,PT) :-
	nonvar(R),
	atomic(R),
	!,
	Rel =.. [R,MS,X,Y],
	PT = proved(Rel,basedOn(PT1)),
	!.
eqProofTerm(MS,Y,_FF,R,X,HYPS,PT1,PT) :-
	Rel = rel(R,MS,X,Y),
	PT = proved(Rel,basedOn(PT1)),
	!.
conProofTerm(MS,R,X,Rel,N,HYPS,PT1,PT) :-
	PT = proved(card(R,MS,X,Rel,N),basedOn(PT1)),
	!.
/***********************************************************************
 *
 * makeTerm(+TermPieces,-Term)
 *
 */

makeTerm(Term,Term) :-
	var(Term),
	!.
makeTerm(Term,Term) :-
	atomic(Term),
	!.
makeTerm([Functor|ArgList],Term) :-
	hop_map(makeTerm,ArgListTerms,ArgList),
	Term =.. [Functor|ArgListTerms].
makeTerm(Term,Term).

%element(X) :-
%	atomic(X),
%	!.
%element(X) :-
%	var(X),
%	!.
element(_) :- !.

relation(R,RN,X1,Y1) :-
%	nonvar(R),
%	R =.. [RN,X1,Y1].
	T =.. [RN,X1,Y1],
	R = T.

eqGenerator(Env,AX,RN,S,O,MS,X,Y,HYPS,D,CALLS,PT) :-
	eq(Env,rn(AX,RN,S,O),modal(MS),X,Y,hyp(HYPS),ab(D),call(CALLS),PT),
	nonvar(X),
	nonvar(Y),
	atomic(X).

gensymbol(object,L,NewSymbol) :-
	gensym(object,NewFunction),
	NewSymbol =.. [NewFunction|L],
	!.
gensymbol(Symbol,L,NewSymbol) :-
	gensym(Symbol,NewSymbol),
	!.


/**********************************************************************
 *
 * ruleName(+AxiomName,+RuleName,+Orientation)
 *
 */

ruleName(AxiomName,RuleName,Origin,Orientation,
	 rn(AxiomName,RuleName,Origin,Orientation)) :- 
	!.

reverseOrientation(lInR,rInL) :- !.
reverseOrientation(rInL,lInR) :- !.


typeOfDefinition(_,_,C,system) :-
	var(C),
	!.
typeOfDefinition(Env,MS,C,user) :-
	getConceptName(Env,MS,C),
	!.
typeOfDefinition(_,_,C,system) :-
	atomic(C),
	atom_codes(C,[99,111,110,99,101,112,116|_]),
	!.
typeOfDefinition(Env,MS,R,user) :-
	getRoleName(Env,MS,R),
	!.
typeOfDefinition(_,_,R,system) :-
	atomic(R),
	atom_codes(R,[114,111,108,101|_]),
	!.
typeOfDefinition(Env,MS,not(C),Type) :-
	!,
	typeOfDefinition(Env,MS,C,Type).
typeOfDefinition(_,_,normalWorld(C),system) :-
	!.
typeOfDefinition(_,_,not(normalWorld(C)),system) :-
	!.
typeOfDefinition(_,_,_,user) :-
	!.

% someInterpretation([]).
% someInterpretation([I1|IL]) :-
% 	call(I1),
% 	someInterpretation(IL).
% 
% allInterpretation([]) :-
% 	fail.
% allInterpretation([I1|IL]) :-
% 	(call(I1) ; allInterpretation(IL)).
% 
% roleConjunction(X,IL) :-
% 	var(X),
% 	someInterpretation(IL).
% roleConjunction(X,IL) :-
% 	nonvar(X),
% 	atom_codes(X,[115,107,111,108,101,109|_]),
% 	allInterpretation(IL).
% roleConjunction(X,IL) :-
% 	nonvar(X),
% 	not(atom_codes(X,[115,107,111,108,101,109|_])),
% 	someInterpretation(IL).


/***********************************************************************
 *
 * convertMS(Env,+MS1,+ModalOperator,WVL1,-MS2,WVL2)
 * Arguments: MS1                modal context
 *            ModalOperator      modal operator
 *            WVL1               list of free world variables already
 *                               generated during the conversion
 *            MS2                modal context
 *            WVL2               list of all free world variables 
 *                               generated during the conversion
 * MS2 is the translation of ModalOperator appended to MS1.
 *
 */

genagent(X,_,X) :-
	var(X),
	!.
genagent(all,free,_A) :-
	!.
genagent(all,skolemize,A) :-
	gensym(agent,A),
	!.
genagent(A,_,A) :-
	!.

convertMS(positive,Env,Start,MS,WVL1,End,WVL2) :-
	!,
	convertMS(Env,Start,MS,WVL1,End,WVL2).
convertMS(negative,Env,Start,MS1,WVL1,End,WVL2) :-
	!,
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	convertMS(Env,Start,MS3,WVL1,End,WVL2).
	

convertMS(_Env,_,MS,WVL,[_W1,true],WVL) :-
	var(MS),
	!.
convertMS(_Env,[MS1,Lits1],[],WVL,[MS1,Lits1],WVL) :-
	!.
convertMS(Env,[MS1,Lits1],[d(MOp,A)|L],WVL,[MS3,Lits3],WVL3) :-
	gensym(wp,WP),
	WPTerm = [WP,WVL],
	genagent(A,skolemize,Agent),
	MS2 = app(WPTerm:m(MOp,Agent),MS1),
	convertMS(Env,[MS2,Lits1],L,WVL,[MS3,Lits3],WVL3),
	!.
convertMS(Env,[MS1,Lits1],[b(MOp,A)|L],WVL,[MS3,Lits3],WVL3) :-
	genagent(A,free,Agent),
	Lit = rel(Env,_,m(MOp,Agent),MS1,MS2),
	convertMS(Env,[MS2,(Lit,Lits1)],L,[MS2|WVL],[MS3,Lits3],WVL3),
	!.
convertMS(Env,[MS1,Lits1],[dc(MOp,C)|L],WVL,[MS3,Lits3],WVL3) :-
	gensym(wp,WP),
	WPTerm = [WP,WVL],
	genagent(all,skolemize,Agent),
	MS2 = app(WPTerm:m(MOp,Agent),MS1),
	getQuery(Env,MS1,C,Agent,_Exp,Body),
	convertMS(Env,[MS2,(once(Body),Lits1)],L,WVL,[MS3,Lits3],WVL3),
	!.
convertMS(Env,[MS1,Lits1],[bc(MOp,C)|L],WVL,[MS3,Lits3],WVL3) :-
	genagent(all,free,Agent),
	Lit = rel(Env,_,m(MOp,Agent),MS1,MS2),
	getQuery(Env,MS1,C,Agent,_Exp,Body),
	convertMS(Env,[MS2,((once(Body),Lit),Lits1)],L,[MS2|WVL],[MS3,Lits3],WVL3),
	!.



/***********************************************************************
 *
 * THE STRUCTURE OF THE IN-CLAUSES
 * 
 * 1) THE HEAD
 *    in(Env,RN,modal(W),A1,X,hyp(C1),ab(D),call(H1),Exp)
 *    Env is a internal environment atom_codes
 *    RN  is a rule atom_codes
 *    W   is a world
 *    A1  is a concept atom_codes or the negation of a concept atom_codes
 *    X   is a free variable
 *    C1  is a list of clauses --- the hypotheses that can be used
 *    D   is a atom_codes identifying a specific abductive derivation
 *    H1  is a list of calls   --- the calls to in that have already
 *                                 been used
 *    Exp is a explanation term
 * 2) THE BODY
 *
 */

/***********************************************************************
 *
 * constructMLHead(+ModalSequence,
 *                 +ConceptName,+Constraint,
 *                 +Hypotheses,+CallStack,-Inhead)
 * 
 */

constructInHead(Env,Name,MS,CN,CON,HYP,D,CALL,PT1,InHead) :-
	inProofTerm(MS,Name,CN,CON,HYP,PT1,PT),
	InHead = in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT),
	!.

constructKBHead(Env,Priority,Name,MS,CN,CON,HYP,D,CALL,PT1,InHead) :-
	inProofTerm(MS,Name,CN,CON,HYP,PT1,PT),
	InHead = kb_in(Env,Priority,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT),
	!.

constructMLHead(Env,Name,MS,CN,CON,HYP,D,CALL,PT1,InHead) :-
	inProofTerm(MS,Name,CN,CON,HYP,PT1,PT),
	InHead = kb_in(Env,pr(3),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT),
	!.

getEnvironment(kb_in(Env,pr(_),_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),_),Env).
getEnvironment(in(Env,_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),_),Env).
getModalSequence(kb_in(_,pr(_),_,modal(MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),_),MS).
getModalSequence(in(_,_,modal(MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),_),MS).
getConceptName(kb_in(_,pr(_),_,modal(_MS),CN,_CON,hyp(_HYP),ab(_),call(_CALL),_),CN).
getConceptName(in(_,_,modal(_MS),CN,_CON,hyp(_HYP),ab(_),call(_CALL),_),CN).
getConstraint(kb_in(_,pr(_),_,modal(_MS),_CN,CON,hyp(_HYP),ab(_),call(_CALL),_),CON).
getConstraint(in(_,_,modal(_MS),_CN,CON,hyp(_HYP),ab(_),call(_CALL),_),CON).
getHypotheses(kb_in(_,pr(_),_,modal(_MS),_CN,_CON,hyp(HYP),ab(_),call(_CALL),_),HYP).
getHypotheses(in(_,_,modal(_MS),_CN,_CON,hyp(HYP),ab(_),call(_CALL),_),HYP).
getCallStack(kb_in(_,pr(_),_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(CALL),_),CALL).
getCallStack(in(_,_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(CALL),_),CALL).
getExplanation(kb_in(_,pr(_),_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),E),E).
getExplanation(in(_,_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),E),E).
getInExplanation(kb_in(_,pr(_),_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),
	         proved(I,_)),I).
getInExplanation(in(_,_,modal(_MS),_CN,_CON,hyp(_HYP),ab(_),call(_CALL),
	         proved(I,_)),I).

/**********************************************************************
 *
 * constructEqHead(Env,+MS,+Y,+F,+R,+X,+HYPS,+CALLS,-L)
 *
 */

constructEqHead(Env,Name,MS,Y,F,R,X,HYPS,D,CALLS,PT1,L) :-
	eqProofTerm(MS,Y,F,R,X,HYPS,PT1,PT),
	L = eq(Env,Name,modal(MS),Y,app((F:R),X),hyp(HYPS),ab(D),call(CALLS),PT),
	!.

/**********************************************************************
 *
 * constructEqMark(+MS,+Y,+F,+R,+X,+HYPS,+CALLS,+AN,-L)
 *
 */

constructEqMark(Name,MS,Y,F,R,X,HYPS,_D,_CALLS,L) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	L = eq(Name,modal(MS),Y,app((F:R),X),hyp(H1)),
	!.

/**********************************************************************
 *
 * constructEqCall(Env,+MS,+Y,+F,+R,+X,+HYPS,+CALLS,+AN,-L)
 *
 */

constructEqCall(Env,rn(AX,RN,_Source,Orientation),bodyMC(MS1),headMC(MS2),
	        Y,F,R,X,HYPS,D,CALLS,PT,L) :-
	constructEqMark(rn(AX,RN,_S1,Orientation),MS2,Y,F,R,X,HYPS,D,CALLS,C1),
	L = eq(Env,rn(_AX2,_RN2,_S2,_O2),modal(MS1),Y,app((F:R),X),
               hyp(HYPS),ab(D),call([C1|CALLS]),PT),
	!.

/***********************************************************************
 *
 * constructMLMark(+ModalSequence,+ConceptName,+Constraint,
 *                      +AxiomName,-LoopCheck)
 *
 */

constructMLMark(Name,MS,CN,CON,HYPS,D,LoopCheck) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	LoopCheck = in(Name,modal(MS),CN,CON,hyp(H1),ab(D)),
	!.

constructMLMark(kb_in(_,Pr,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(_),_),LoopCheck) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	LoopCheck = in(Name,modal(MS),CN,CON,hyp(H1),ab(D)),
	!.
constructMLMark(in(_,Pr,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(_),_),LoopCheck) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	LoopCheck = in(Name,modal(MS),CN,CON,hyp(H1),ab(D)),
	!.
constructMLMark(in(_,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(_),_),LoopCheck) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	LoopCheck = in(Name,modal(MS),CN,CON,hyp(H1),ab(D)),
	!.

/***********************************************************************
 *
 * constructMLCall(+Env,rn(+AX1,+RN1,+S1,+O1),bodyMC(MS1),headMC(MS2), 
 *                 +ConceptName,+Variable,
 *                 +Hypotheses,+DerivationName,+CallStack,+Proofterm,
 *                 -InTerm)
 *
 * The information in rn(AX1,RN1,S1,O1)  is used in the following way:
 * AX1, RN1, and O1 is used in the construction of the MLMark
 * which is added to the call stack. If AX1 is `no' then the MLMark is
 * not added to the call stack at all.
 * S1 is used in the construction of InHead. If S1 is a variable, any 
 * rule can be used to prove the call. If S1 is `user' then only user
 * provided rules may be used. If S1 is `system' then only system provided
 * rules may be used.
 *
 */

constructMLCall(Env,rn(AX1,RN1,S1,O1),bodyMC(MS1),headMC(MS2),
                CN,CON,HYPS,D,CALLS,PT1,InHead) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	constructMLMark(rn(AX1,RN1,_S2,_O2),MS2,CN,CON,HYPS,D,Mark),
	convert_loop(AX1,CALLS,Mark,CALLS1),
	getNegatedConcept(CN,C2),
	InHeadH = in(_NameH,modal(MS1),C2,CON,hyp(_H),ab(_D)),
	getSource(S1,Source),
	InHead = in(Env,rn(_AX3,_RN3,Source,_O3),modal(MS1),CN,CON,
                    hyp([or(H1),rl([InHeadH|H2]),fl(H3)]),
                    ab(D),call(CALLS1),PT1),
	!.


getSource(V1,_V2) :-
	var(V1),
	!.
getSource(any,_V2) :-
	!.
getSource(V1,V1) :-
	!.

getNegatedConcept(CN,not(CN)) :-
	var(CN),
	!.
getNegatedConcept(CN,C2) :-
	normalizeNot(not(CN),C2),
	!.

/***********************************************************************
 *
 * constructConHead(Env,+Name,+MS,+F,+R,+X,+Rel,+N,
 *                  +HYPS,+CALLS,-Literal)
 *
 */

constructConHead(Env,Name,MS,F,R,X,Rel,N,HYPS,D,CALLS,PT1,L) :-
	conProofTerm(MS,R,X,Rel,N,HYPS,PT1,PT),
	L = constraint(Env,Name,MS,(card,app((F:R),X),Rel,N),
                       hyp(HYPS),ab(D),call(CALLS),PT),
	!.

/***********************************************************************
 *
 * constructConMark(+MS,+F,+R,+X,+Rel,+N,+HYPS,+CALLS,+AN,-Literal)
 *
 */

constructConMark(Name,MS,F,R,X,Rel,N,HYPS,_D,_CALLS,L) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	L = constraint(Name,MS,(card,app((F:R),X),Rel,N),hyp(H1)),
	!.

constructConMark(constraint(_,Name,MS,(card,A,Rel,N),hyp(HYPS),ab(_D),call(_CALLS),_PT),L) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	L = constraint(Name,MS,(card,A,Rel,N),hyp(H1)),
	!.

/***********************************************************************
 *
 * constructSolveConMark(+MS,+F,+R,+X,+Rel,+N,+HYPS,+CALLS,+AN,-Literal)
 *
 */

constructSolveConMark(Name,MS,F,R,X,Rel,N,HYPS,_D,_CALLS,L) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	L = solveConstraint(Name,MS,(card,app((F:R),X),Rel,N),hyp(H1)),
	!.

constructSolveConMark(constraint(_,Name,MS,(card,A,Rel,N),hyp(HYPS),ab(_D),call(_CALLS),_PT),L) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	L = solveConstraint(Name,MS,(card,A,Rel,N),hyp(H1)),
	!.

/***********************************************************************
 *
 * constructConCall(Env,+MS,+F,+R,+X,+Rel,+N,+HYPS,+CALLS,+AN,-Literal)
 *
 */

constructConCall(Env,bodyMC(MS1),headMC(MS2),F,R,X,Rel,N,HYPS,D,CALLS,AN,PT1,L) :-
	constructConMark(MS2,F,R,X,Rel,N,HYPS,D,CALLS,AN,Mark),
        L = constraint(Env,_Name,MS1,(card,app((F:R),X),Rel,N),
                       hyp(HYPS),ab(D),call([Mark|CALLS]),PT1),
	!.


addDefaultML(I1,L1) :-
	var(L1),
	!,
	L1 = [I1|_L2],
	!.
addDefaultML(I1,[_|L1]) :-
	addDefaultML(I1,L1),
	!.

memberDML(I1,L) :-
	nonvar(L),
	L = [I1|L2],
	!.
memberDML(I1,L) :-
	nonvar(L),
	L = [_|L2],
	memberDML(I1,L2).


/**********************************************************************
 *
 * getAxiom(+Env,+MS,AX)
 * succeeds if AX is an axiom in environment Env and modal context
 * MS.
 *
 */
	
getAxiom(Env,MS,Ax) :-
	axiom(Env,MS,Ax).

/**********************************************************************
 *
 * getConceptName(+Env,+MS,CN)
 * succeeds if CN is a concept atom_codes in environment Env and modal context
 * MS.
 *
 */

getConceptName(Env,MS1,CN) :-
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	clause(conceptName(Env,_,W1,CN),_),
	once((call(G1),conceptName(Env,_,W1,CN))).

/**********************************************************************
 *
 * getRoleName(+Env,+MS,CN)
 * succeeds if CN is a role atom_codes in environment Env and modal context
 * MS.
 *
 */

getRoleName(Env,MS1,CN) :-
	convertMS(negative,Env,[[],true],MS3,[],[W1,G1],_),
	clause(roleName(Env,_,W1,CN),_),
	once((call(G1),roleName(Env,_,W1,CN))).


/**********************************************************************
 *
 * @(#) dag.pl 1.3@(#)
 *
 */

/***********************************************************************
 *
 * memberElement(+Element,+Dag)
 * Parameter: Element     element atom_codes
 *            Dag         subsumption hierarchy
 * checks wether or not Element occurs in the subsumption hierarchy.
 *
 */

memberElement(Element,node(CL,_NL)) :-
	member(Element,CL),
	!.
memberElement(Element,node(_CL,NL)) :-
	memberElementSubtrees(Element,NL),
	!.

memberElementSubtrees(_Element,[]) :-
	!,
	fail.
memberElementSubtrees(Element,[N1|_NL]) :-
	memberElement(Element,N1),
	!.
memberElementSubtrees(Element,[_N1|NL]) :-
	memberElementSubtrees(Element,NL).

/***********************************************************************
 *
 * memberDirectSubElements(+Element,+Dag)
 * Parameter: Element     element atom_codes
 *            Dag         subsumption hierarchy
 * checks wether or not Element occurs in the direct subelements of
 * the top element of Dag.
 *
 */

memberDirectSubElements(Element,node(_CL,NL)) :-
	!,
	memberDirectSubElements(Element,NL).

memberDirectSubElements(_Element,[]) :-
	!,
	fail.
memberDirectSubElements(Element,[node(CL,_NL1)|_NL]) :-
	member(Element,CL),
	!.
memberDirectSubElements(Element,[_N1|NL]) :-
	memberDirectSubElements(Element,NL).

/***********************************************************************
 *
 * getDirectSuperElements(+Element,-CL,+Dag)
 * Parameter: Dag         subsumption hierarchy
 *            Element     element atom_codes
 *            CL          list of element names
 * CL is the list of all element names which are direct super elements
 * of Element.
 *
 */

getDirectSuperElements(Element,CL,node(CL,NL)) :-
	memberDirectSubElements(Element,node(CL,NL)),
	!.
getDirectSuperElements(Element,CL,node(_,NL)) :-
	getDirectSuperElements(Element,CL,NL).

getDirectSuperElements(_Element,[],[]) :-
	!.
getDirectSuperElements(Element,CL,[N1|NL]) :-
	getDirectSuperElements(Element,CL1,N1),
	getDirectSuperElements(Element,CL2,NL),
	unionSpecial(CL1,CL2,CL).

/***********************************************************************
 *
 * getAllSuperElements(+Element,-CL,+Dag)
 * Parameter: Element     element atom_codes
 *            CL          list of element names
 *            Dag         subsumption hierarchy
 * CL is the list of all element names which are super elements of
 * Element.
 *
 */

getAllSuperElements(Element,CL,Dag) :-
	getAllSuperElements(Element,CL,[],Dag).

getAllSuperElements(Element,CL1,CL1,node(CL,_NL)) :-
	member(Element,CL),
	!.
getAllSuperElements(Element,CL3,CL1,node(CL,NL)) :-
	unionSpecial(CL,CL1,CL2),
	getAllSuperElements(Element,CL3,CL2,NL).

getAllSuperElements(_Element,[],_CL1,[]) :-
	!.
getAllSuperElements(Element,CL2,CL1,[N1|NL]) :-
	getAllSuperElements(Element,CL3,CL1,N1),
	getAllSuperElements(Element,CL4,CL1,NL),
	unionSpecial(CL3,CL4,CL2).


/***********************************************************************
 *
 * getDirectSubElements(+Element,-CL,+Dag)
 * Parameter: Element     element atom_codes
 *            CL          list of element names
 *            Dag         subsumption hierarchy
 * CL is the list of all element names which are direct sub elements
 * of Element.
 *
 */

getDirectSubElements(Element,CL1,node(CL,NL)) :-
	member(Element,CL),
	!,
	getSubElements(CL1,NL).
getDirectSubElements(Element,CL1,node(_CL,NL)) :-
	getDirectSubElements(Element,CL1,NL).

getDirectSubElements(_Element,[],[]) :-
	!.
getDirectSubElements(Element,CL,[N1|NL]) :-
	getDirectSubElements(Element,CL1,N1),
	getDirectSubElements(Element,CL2,NL),
	unionSpecial(CL1,CL2,CL).

getSubElements([],[]) :-
	!.
getSubElements(CL,[node(CL1,_)|NL]) :-
	getSubElements(CL2,NL),
	unionSpecial(CL1,CL2,CL).


/***********************************************************************
 *
 * getAllSubElements(+Dag,+Element,-CL,+Dag)
 * Parameter: Element     element atom_codes
 *            CL          list of element names
 *            Dag         subsumption hierarchy
 * CL is the list of all element names which are sub elements of 
 * Element
 *
 */

getAllSubElements(Element,CL1,node(CL,NL)) :-
	member(Element,CL),
	!,
	getElements(CL1,NL).
getAllSubElements(Element,CL1,node(_CL,NL)) :-
	getAllSubElements(Element,CL1,NL),
	!.

getAllSubElements(_Element,[],[]) :-
	!.
getAllSubElements(Element,CL,[N1|NL1]) :-
	getAllSubElements(Element,CL2,N1),
	getAllSubElements(Element,CL3,NL1),
	unionSpecial(CL2,CL3,CL).

/***********************************************************************
 *
 * getElements(-CL,+Dag)
 * Parameter: CL     list of element names
 *            Dag    subsumption hierarchy
 * CL is the list of all element names in the subsumption hierarchy.
 *
 */

getElements(CL,node(CL1,NL)) :-
	getElements(CL2,NL),
	unionSpecial(CL1,CL2,CL).
getElements([],[]) :-
	!.
getElements(CL,[N1|NL]) :-
	getElements(CL1,N1),
	getElements(CL2,NL),
	unionSpecial(CL1,CL2,CL).


/***********************************************************************
 *
 * testDirectSuperElement(+Element1,+Element2,-Element,+Dag)
 * Parameter: Element1       element atom_codes
 *            Element2       element atom_codes
 *            Element        element atom_codes
 *            Dag            subsumption hierarchy
 * Element is Element1 iff Element1 is a direct superelement of Element2
 * or
 * Element is Element2 iff Element2 is a direct superelement of Element1
 * otherwise
 * the predicate fails
 *
 */

testDirectSuperElement(Element1,Element2,Element1,node(CL,NL)) :-
	member(Element1,CL),
	!,
	memberDirectSubElements(Element2,node(CL,NL)).
testDirectSuperElement(Element1,Element2,Element2,node(CL,NL)) :-
	member(Element2,CL),
	!,
	memberDirectSubElements(Element1,node(CL,NL)).

/***********************************************************************
 *
 * testDirectSubElement(+Element1,+Element2,-Element,+Dag)
 * Parameter: Element1       element atom_codes
 *            Element2       element atom_codes
 *            Element        element atom_codes
 *            Dag            subsumption hierarchy
 * Element is Element1 iff Element1 is a direct subelement of Element2
 * or
 * Element is Element2 iff Element2 is a direct subelement of Element1
 * otherwise
 * the predicate fails
 *
 */

testDirectSubElement(Element1,Element2,Element2,node(CL,NL)) :-
	member(Element1,CL),
	!,
	memberDirectSubElements(Element2,node(CL,NL)).
testDirectSubElement(Element1,Element2,Element1,node(CL,NL)) :-
	member(Element2,CL),
	!,
	memberDirectSubElements(Element1,node(CL,NL)).


/***********************************************************************
 *
 * testSuperElement(+Element1,+Element2,-Element,+Dag)
 * Parameter: Element1       element atom_codes
 *            Element2       element atom_codes
 *            Element        element atom_codes
 *            Dag            subsumption hierarchy
 * Element is Element1 iff Element1 is a direct superelement of Element2
 * or
 * Element is Element2 iff Element2 is a direct superelement of Element1
 * otherwise
 * the predicate fails
 *
 */

testSuperElement(Element1,Element2,Element1,node(CL,NL)) :-
	member(Element1,CL),
	!,
	memberElementSubtrees(Element2,NL).
testSuperElement(Element1,Element2,Element2,node(CL,NL)) :-
	member(Element2,CL),
	!,
	memberElementSubtrees(Element1,NL).


/***********************************************************************
 *
 * testSubElement(+Element1,+Element2,-Element,+Dag)
 * Parameter: Element1       element atom_codes
 *            Element2       element atom_codes
 *            Element        element atom_codes
 *            Dag            subsumption hierarchy
 * Element is Element1 iff Element1 is a direct superelement of Element2
 * or
 * Element is Element2 iff Element2 is a direct superelement of Element1
 * otherwise
 * the predicate fails
 *
 */

testSubElement(Element1,Element2,Element1,node(CL,NL)) :-
	member(Element2,CL),
	!,
	memberElementSubtrees(Element1,NL).
testSubElement(Element1,Element2,Element2,node(CL,NL)) :-
	member(Element1,CL),
	!,
	memberElementSubtrees(Element2,NL).


/***********************************************************************
 *
 * getCommonSuperElements(+CL1,-CL2,+Dag)
 * Parameter: CL1      list of element names
 *            CL2      list of element names
 *            Dag      subsumption hierarchy
 * CL2 is the list of all element names subsuming all elements in CL1.
 *
 */

getCommonSuperElements(CL1,CL2,Dag) :-
	hop_map(getAllSuperElements,[Dag],CL1,CLL1),
	intersectionOfLists(CLL1,CL2).

/***********************************************************************
 *
 * getCommonSubElements(+CL1,-CL2,Dag)
 * Parameter: CL1      list of element names
 *            CL2      list of element names
 *            Dag      subsumption hierarchy
 * CL2 is the list of all element names which are subsumed by all
 * elements in CL1.
 *
 */

getCommonSubElements(CL1,CL2,Dag) :-
	hop_map(getAllSubElements,[Dag],CL1,CLL1),
	intersectionOfLists(CLL1,CL2).








/**********************************************************************
 *
 * @(#) env.pl 1.24@(#)
 *
 */


/**********************************************************************
 *
 * getCurrentEnvironment(EnvName)
 * gets the atom_codes of the current environment
 *
 */

getCurrentEnvironment(EnvName) :-
	currentEnvironment(Env),
	environment(EnvName,Env,_),
	!.

/**********************************************************************
 *
 * makeEnvironment(+Name,+Comment)
 * creates new environement with atom_codes Name. Comment can be any string
 * Name will become the current environment.
 *
 */

makeEnvironment(Name,Comment) :-
	getTwoRandomNumbers(RT,CT),
	FirstChar is 97 + (CT mod 26),
	Runtime   is (RT mod 10000),
	atom_codes(Runtime,RTChars),
	atom_codes(EnvIdentifier,[FirstChar|RTChars]),
	assertaRE(environment(Name,env(EnvIdentifier),Comment)),
	retractallSpecial(currentEnvironment(_)),
	assertaRE(currentEnvironment(env(EnvIdentifier))),
	!.

/**********************************************************************
 *
 * showEnvironment(+Name)
 * 
 */

showEnvironment :- 
	getCurrentEnvironment(Name),
	showEnvironment(Name),
	!.

showEnvironment(EnvName) :-
	environment(EnvName,Name,Comment),
	write('Knowledge base '), 
	write(EnvName), 
	nl,
	write('('),
	write(Comment),
	write(')'),
	nl,
	showModalAxioms(Name),
	showDefprimconcept(Name),
	showDefconcept(Name),
	showDefprimrole(Name),
	showDefrole(Name),
	showDefclosed(Name),
	showAssertConcept(Name),
	showAssertRole(Name),
	showFDW(Name),
	!.

showModalAxioms(Name) :-
	modalAxioms(Name,MS,user,K,C,MOp,A),
	once((nonvar(A) ; (A = C))),
	write('        '), 
	write('     modalAxioms('), write(MS), write(','), write(K), write(','),
	write(MOp), write(','), write(A), write(')'), nl,
	fail.
showModalAxioms(_) :-
	!.
showAssertConcept(Name) :-
	clause(conceptElement(Name,MS,_,user,A,C,Ax),_),
	write(Ax), write(':     assert_ind('), write(MS), write(','),
	write(A), write(','), write(C), write(')'), nl,
	fail.
showAssertConcept(_) :-
	!.
showAssertRole(Name) :-
	clause(roleElement(Name,MS,_,user,A,B,R,Ax),_),
	write(Ax), write(':     assert_ind('), write(MS), write(','),
	write(A), write(','), write(B), write(','), write(R), write(')'), nl,
	fail.
showAssertRole(_) :-
	!.
showDefconcept(Name) :-
	conceptEqualSets(Name,user,MS,CN,CT,Ax),
	write(Ax), write(':     defconcept('), write(MS), write(','),
	write(CN), write(','), write(CT), write(')'), nl,
	fail.
showDefconcept(_Name) :-
	!.
showDefprimconcept(Name) :-
	conceptSubsets(Name,user,MS,CN,CT,Ax),
	write(Ax), write(': defprimconcept('), write(MS), write(','),
	write(CN), write(','), write(CT), write(')'), nl,
	fail.
showDefprimconcept(_Name) :-
	!.
showDefrole(Name) :-
	roleEqualSets(Name,user,MS,CN,CT,Ax),
	write(Ax), write(':        defrole('), write(MS), write(','),
	write(CN), write(','), write(CT), write(')'), nl,
	fail.
showDefrole(_Name) :-
	!.
showDefprimrole(Name) :-
	roleSubsets(Name,user,MS,CN,CT,Ax),
	write(Ax), write(':    defprimrole('), write(MS), write(','),
	write(CN), write(','), write(CT), write(')'), nl,
	fail.
showDefprimrole(_Name) :-
	!.
showDefclosed(Name) :-
	closed(Name,MS,X,Y,R),
	write('axiom   '), write(':     defclosed('), write(MS), write(','),
	write(X), write(','), write(Y), write(','), write(R), write(')'),
	nl,
	fail.
showDefclosed(_Name) :-
	!.


/**********************************************************************
 *
 * removeEnvironment(+Name)
 *
 */

removeEnvironment :-
	getCurrentEnvironment(EnvName),
	!,
	removeEnvironment(EnvName).


removeEnvironment(Name) :-
	clearEnvironment(Name),
	retractallSpecial(environment(Name,_,_)),
	retract(currentEnvironment(Name)),
	assertaRE(currentEnvironment(env(e0))),
	!.
removeEnvironment(_Name) :-
	% if we get here, Name was not the current environemt
	!.

/***********************************************************************
 *
 * clearEnvironment(Name)
 *
 */

clearEnvironment :- 
	getCurrentEnvironment(EnvName),
	clearEnvironment(EnvName),
	!.

clearEnvironment(EnvName) :-
	environment(EnvName,Env,_),
	retractCompiledPredicates(Env),
	retractallSpecial(Env,in/9),
	retractallSpecial(Env,kb_in/10),
	retractallSpecial(Env,eq/9),
	retractallSpecial(Env,constraint/8),
	retractallSpecial(Env,rel/5),
	retractallSpecial(Env,closed/5),
	retractallSpecial(Env,compiledPredicate/2),
	retractallSpecial(Env,conceptElement/7),
	retractallSpecial(Env,conceptEqualSets/6),
	retractallSpecial(Env,conceptHierarchy/3),
	retractallSpecial(Env,conceptName/4),
	retractallSpecial(Env,conceptSubsets/6),
	retractallSpecial(Env,environment/3),
	retractallSpecial(Env,given_change/4),
	retractallSpecial(Env,given_inflLink/4),
	retractallSpecial(Env,modalAxioms/7),
	retractallSpecial(Env,roleAttributes/5),
	retractallSpecial(Env,roleDefault/4),
	retractallSpecial(Env,roleDefNr/4),
	retractallSpecial(Env,roleDomain/4),
	retractallSpecial(Env,roleElement/8),
	retractallSpecial(Env,roleEqualSets/6),
	retractallSpecial(Env,roleHierarchy/3),
	retractallSpecial(Env,roleName/4),
	retractallSpecial(Env,roleNr/5),
	retractallSpecial(Env,roleRange/4),
	retractallSpecial(Env,roleSubsets/6),
	retractallSpecial(sub(_,Env,_,_,_)),
	retractallSpecial(succ(_,Env,_,_,_)),
	retractallSpecial(Env,abductiveDerivation/3),
	retractallSpecial(Env,consistencyDerivation/3),
	retractallSpecial(Env,hypothesis/1),
	retractallSpecial(Env,inconsistencyCheck/3),
	retractallSpecial(Env,isMooOption/2),
	retractallSpecial(nsub(_,Env,_,_,_)),
	retractallSpecial(Env,nsub3/2),
	retractallSpecial(Env,sub3/2),
	retractallSpecial(Env,succ3/2),
	!.

/**********************************************************************
 *
 * retractCompiledPredicates(+Env)
 * if the environment Env contains compiled predicates, then for each
 * compiled predicate Pred there is a fact 
 *                    compilePredicate(Env,Pred/Arity).
 * So when the environment is to be removed, we just abolish the 
 * compiled predicates.
 *
 */

retractCompiledPredicates(Env) :-
	compiledPredicate(Env,Pred/Arity),
	abolish(Pred/Arity),
	fail.
retractCompiledPredicates(_) :-
	!.


/**********************************************************************
 *
 * initEnvironment(Name)
 *
 */

initEnvironment :- 
	getCurrentEnvironment(EnvName),
	initEnvironment(EnvName),
	!.

initEnvironment(EnvName) :-
	clearEnvironment(EnvName),
	setMooOption(queryCaching,on),
	environment(EnvName,Env,_),
	assertzRE(theory(Env,
	[
        forall(P,forall(X,forall(Y,forall(Z,implies(and([equal(X,Z), in([],P,pair(Z,Y))]),in([],P,pair(X,Y))))))),
        forall(P,forall(X,forall(Y,forall(Z,implies(and([equal(Y,Z), in([],P,pair(X,Z))]),in([],P,pair(X,Y))))))),
        forall(A,forall(X,forall(Y,implies(and([equal(X,Y), in([],A,X)]),in([],A,Y))))),
	forall(X,forall(Y,implies(equal(X,Y),equal(Y,X)))),
	forall(X,equal(X,X)),
	forall(X,forall(MS,in(MS,top,X)))])),
	assertInRules(Env),
	% Assert equality axioms
	assertEqRule(Env,1),
	% Assert 'top' role
%	assertEqRule(Env,2),
	assertEqRule(Env,3),
	% Proof by hypothesis for roles (Test 14.07.92)
	assertEqRule(Env,4),
	% Assert 'top' concept
	assertInRule(Env,1),
	% Assert 'bot' concept
	assertInRule(Env,2),
	% Proof by hypothesis for concepts
	assertInRule(Env,3),
	% Assert X in some(r,c) => X in atleast(1,r)
%	gensym(axiom,AN11),
%	assertInRule(Env,3,AN11),
	% Assert X in atleast(1,r) => X in some(r,'top')
%	assertInRule(Env,4,AN11),
	% Assert X in atmost(0,r) => X in all(r,c)
%	gensym(axiom,AN10),
%	assertInRule(Env,1,AN10),
	% Assert X in all(r,'bot') => X in atmost(0,r)
%	assertInRule(Env,2,AN10),
	% Assert not('top') law
	% necessary for inconsistent knowledge bases?
	% bad influence on runtime!
%	assertInRule(Env,4),
	% Assert double negation laws
	gensym(axiom,AN6),
%	assertInRule(Env,5,AN6),
%	assertInRule(Env,6,AN6),
	% Concrete domains
	gensym(axiom,AN7),
%	assertInRule(Env,7,AN7),
%	assertInRule(Env,8,AN7),
%	assertInRule(Env,9,AN7),
	%%  Abductive Reasoning
	% Proof by abductive hypothesis
	assertAbductionRule(Env,1),
	% Proof by abduction
	assertAbductionRule(Env,2),
	% Meta Reasoning
%	metaReasoning,
	% Assert concept hierarchy
	assertzRE(conceptHierarchy(Env,[],node(['top'],[]))),
	assertzRE(conceptName(Env,[],[],'top')),
	assertzRE(conceptName(Env,[],[],'bot')),
	% Assert role hierarchy
	assertzRE(roleHierarchy(Env,[],node(['top'],[]))),
	assertzRE(roleName(Env,[],[],'top')),
	initFuncdep,
	!.

/**********************************************************************
 *
 * assertInRules(+Env)
 * asserts the clauses for the in predicate which is used to 
 * construct goals in the user interface. In general the in clauses
 * just call corresponding kb_in clauses. The kb_in clauses result
 * from the translation of terminological and assertional axioms.
 *
 * !! Remember: Changes to this clauses have to be reflected in the
 *              definition of the compileEnv predicate.
 *
 */

assertInRules(Env) :-
	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
		 ifMooOption(traceOutput,yes,(length(CALL,Depth), format('trying ~d  in(~w,~w)~n',[Depth,CN,CON]))),
	kb_in(Env,pr(5),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT),
		 ifMooOption(traceOutput,yes,(length(CALL,Depth), format('succeeded ~d  in(~w,~w)~n',[Depth,CN,CON]))))),
% There are no kb_in clauses with priority 4 at the moment (07.10.92)
%	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
%	kb_in(Env,pr(4),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT))),
	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp([or(H1),rl(H2),fl(H3)]),ab(noAb),call(CALL),PT) :-
		 clashInHyp(H2), !, fail)),
	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
		 (CN \== top, CN \== bot, CN \== not(top), CN \== not(bot),
	kb_in(Env,pr(3),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT)))),
% There are no kb_in clauses with priority 2 at the moment (07.10.92)
%	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
%	kb_in(Env,pr(2),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT))),
	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
		 (CN \== top,CN \== bot, CN \== not(top), CN \== not(bot),
	kb_in(Env,pr(1),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT)))),
% Experimental code (07.10.92 uh)
% It might be useful to have global information about the failure of
% derivations. With the code below such a failure is used to assertzRE to
% hypothesis that the negation of the goal is true.
%	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
%		 (nonvar(CON), nonvar(CN), 
%		  \+ hypothesis(in(Env,modal(MS),CN,CON,ab(D),PT)),
%		  getNegatedConcept(CN,C1),
%		  assertzRE(hypothesis(in(Env,modal(MS),C1,CON,ab(D),assume))),
%		  fail))),
% There are no kb_in clauses with priority 0 at the moment (07.10.92)
%	assertzRE((in(Env,Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT) :-
%	kb_in(Env,pr(0),Name,modal(MS),CN,CON,hyp(HYP),ab(D),call(CALL),PT))),
	!.

assertEqRule(Env,1) :-
	gensym(axiom,AN1),
	gensym(rule,RN1),
	constructEqHead(Env,rn(AN1,RN1,user,lInR),W1,app((F:R),X),F,R,X,HYPS,AB,CALLS,equality,EqHead1),
	constructMLCall(Env,rn(AX,_RN4,_S4,_O4),bodyMC(W1),headMC(W1),normalWorld(R),X,HYPS,AB,CALLS,PT3,InHead2),
	assertzRE(EqHead1),
%       old code (uh 06.05.94)
%	assertzRE((EqHead1 :- checkCallStack(CALLS,true),  simple_term(X))),
%-----------------------------------------------------------------
%       The following would be correct
%	assertzRE((EqHead1 :- checkCallStack(CALLS,true),  InHead2)),
%       old code (uh 20.08.92)
%	assertzRE((eq(Env,rn(AN1,RN1,user,lInR),modal(MS),X,X,hyp(HYPS),
%                   ab(_AB),call(CALLS),proved(eq(MS,X,X,hyp(HYPS),
%                   basedOn(true)))) :- 
%                (checkCallStack(CALLS,true)))),
	!.
assertEqRule(Env,2) :-
	Role1 =.. ['top',_X,_Y],
	gensym(axiom,AN3),
	gensym(rule,RN3),
	constructMLHead(Env,rn(AN3,RN3,user,lInR),_MS,_,Role1,
			_HYPS,_D,_CALLS,tbox,InHeadR),
	assertzRE((InHeadR)),
	!.
assertEqRule(Env,3) :-
	gensym(axiom,AN20),
	gensym(rule,RN20),
	constructEqHead(Env,rn(AN20,RN20,user,lInR),_W1,_Y,_F,top,_X,_HYPS,_D,_CALLS,tbox,EqHead20),
	assertzRE(EqHead20),
	!.
assertEqRule(Env,4) :-
	gensym(axiom,AN21),
	gensym(rule,RN21),
	HYPS = [or(H1),rl(H2),fl(H3)],
	constructEqHead(Env,rn(AN21,RN21,user,lInR),W1,Y,F,R,X,HYPS,D,_CALLS,tbox,EqHead20),
	constructEqMark(rn(_AN21,_RN21,_,_),W1,Y,F,R,X,_HYPS2,D,_CALLS2,EqMark20),
	assertzRE((EqHead20 :- append(H1,H2,H), member(EqMark20,H))),
	!.


assertInRule(Env,1) :-
	% For all X: X in top
	% Priority 5 (high priority)
	gensym(axiom,AN2),
	gensym(rule,RN2),
	constructKBHead(Env,pr(5),rn(AN2,RN2,user,lInR),_W1,'top',X,
			_HYPS,_D,_CALLS,tbox,InHead),
	assertzRE((InHead :- ground_copy(X,X))),
	!.
assertInRule(Env,2) :-
	% For all X: X in not(bot) 
	% What is actually needed is the equivalence of top and not(bot).
	% So we need
	% For all X: X in top if X in not(bot)
	% is subsumed by assertInRule(Env,1).
	% For all X: X in not(top) if X in bot
	% This rule will not be asserted.
	% For all X: X in bot if X in not(top)
	% is subsumed by assertInRule(Env,4).
	% For all X: X in not(bot) if X in top.
	% is subsumed by assertInRule(Env,2), i.e. the rule we will
	% assertzRE now.
	% Priority 5 (high priority)
	gensym(axiom,AN4),
	gensym(rule,RN4),
	constructKBHead(Env,pr(5),rn(AN4,RN4,user,lInR),_W1,not(bot),X,
	                _HYPS,_D,_CALLS,tbox,InHead1),
	assertzRE(InHead1),
	!.
assertInRule(Env,3) :-
	% For all X: X in C if (X in C) is a hypothesis
	% Priority 5 (high priority)
	gensym(axiom,AN4),
	gensym(rule,RN4),
	HYPS = [or(H1),rl(H2),fl(H3)],
	constructInHead(Env,rn(_AN5,_RN5,_S5,_O5),MS,C,X,_HYPS,_D1,_CALLS1,_,InHead1),
	constructKBHead(Env,pr(5),rn(AN4,RN4,system,lInR),MS,C,X,
	                HYPS,_D,_CALLS2,usingHyp(InHead1),InHead2),
	assertzRE((InHead2 :- append(H1,H2,H), member(InHead1,H))),
	constructMLMark(InHead1,Mark1),
	assertzRE((InHead2 :- (append(H1,H2,H), member(Mark1,H)) ; memberDML(Mark1,H3))),
	!.
assertInRule(Env,4) :-
	% For all X: X in not(top) => X in C 
	% Priority 1 (low priority)
	% necessary for inconsistent knowledge bases ?
	gensym(axiom,AN7),
	gensym(rule,RN7),
	constructKBHead(Env,pr(1),rn(AN7,RN7,system,lInR),MS,_C,X,
	                HYPS,D,CALLS,PT3,InHead3),
	constructMLCall(Env,rn(AN7,_RN7,_S7,_O7),bodyMC(MS),headMC(MS),
                        not('top'),X,HYPS,D,CALLS,PT3,L3),
 	constructMLMark(InHead3,Mark3),
	assertzRE((InHead3 :- checkCallStack(CALLS,Mark3), L3)),
	!.

assertInRule(Env,1,AN10) :- 
	% Assert x in atmost(0,r) => x in all(r,c)
	% Priority 1 (low priority)
	gensym(rule,Rule),
	ruleName(AN10,Rule,system,lInR,RN),
	convertInConsequence(Env,pr(1),RN,_MS,W,all(R,C),X,
	                     HYPS,AB,CALLS,PT,(EqLiteral,InHead)),
	constructMLMark(InHead,Mark),
	convertInAntecedent(Env,rn(AN10,system,lInR),bodyMC(W),headMC(W),
			    atmost(0,R),X,HYPS,AB,CALLS,PT,Body),
	assertaRE((InHead :- (nonvar(C), (checkCallStack(CALLS,Mark), once((EqLiteral, Body)))))),
	!.
assertInRule(Env,2,AxiomName) :-
	% Assert x in all(r,'bot') => x in atmost(0,r)
	% Priority 1 (low priority)
	convertInAntecedent(Env,rn(AxiomName,_O,_Orientation),
                            bodyMC(W1),headMC(W1),all(R,'bot'),X,
			    HYPS,AB,CALLS,PT1,Body),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,system,lInR,RN1),
	convertInConsequence(Env,pr(1),RN1,_MS,W1,
			     atmost(0,R),X,HYPS,AB,CALLS,PT1,InHead1),
	constructConMark(InHead1,Mark1),
	assertaRE((InHead1 :- (nonvar(R),(checkCallStack(CALLS,Mark1), once(Body))))),
	!.
assertInRule(Env,3,AxiomName) :-
	% Assert x in some(R,top) => x in atleast(1,R)
	% Priority 1 (low priority)
	convertInAntecedent(Env,rn(AxiomName,system,lInR),
			    bodyMC(W1),headMC(W1),
			    some(R,'top'),X,HYPS,AB,CALLS,PT1,Body),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,system,lInR,RN1),
	convertInConsequence(Env,pr(1),RN1,_MS,W1,
			     atleast(1,R),X,HYPS,AB,CALLS,PT1,InHead1),
	constructConMark(InHead1,Mark1),
	assertaRE((InHead1 :- (nonvar(R), checkCallStack(CALLS,Mark1), once(Body)))),
	!.
assertInRule(Env,4,AxiomName) :-
	% Assert x in atleast(1,R) => x in some(R,top)
	% Priority 1 (low priority)
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,system,lInR,RN1),
	convertInConsequence(Env,pr(1),RN1,_MS,W1,some(R,'top'),X,
	                     HYPS,AB,CALLS,PT1,(EqLiteral, InHead1)),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,system,lInR),
	                    bodyMC(W1),headMC(W1),
			    atleast(1,R),X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), once((EqLiteral, Body))))),
	!.
assertInRule(Env,5,AN6) :-
	% For all X: X in C => X in not(not(C))
	% Priority 1 (low priority)
	gensym(rule,RN6),
	constructKBHead(Env,pr(1),rn(AN6,RN6,system,lInR),MS,not(not(C)),X,
	                HYPS,D,CALLS,PT4,Consequence3),
	constructMLCall(Env,rn(AN6,_RN9,_S9,_O9),bodyMC(MS),headMC(MS),C,X,
	                HYPS,D,CALLS,PT4,Antecedent4),
	constructMLMark(Consequence3,AxiomHead3),
	assertzRE((Consequence3 :- checkCallStack(CALLS,AxiomHead3), Antecedent4)),
	!.
assertInRule(Env,6,AN6) :-
	% For all X: X in not(not(C)) => X in C 
	% Priority 1 (low priority)
	gensym(rule,RN8),
	constructKBHead(Env,pr(1),rn(AN6,RN8,system,lInR),MS,C,X,
	                HYPS,D,CALLS,PT3,Consequence4),
	constructMLCall(Env,rn(AN6,_RN7,_S7,_O7),bodyMC(MS),headMC(MS),
			not(not(C)),X,HYPS,D,CALLS,PT3,Antecedent3),
	constructMLMark(Consequence4,AxiomHead4),
	assertzRE((Consequence4 :- checkCallStack(CALLS,AxiomHead4), Antecedent3)),
	!.
assertInRule(Env,7,AN7) :-
	% For all X: X in set(S2) and subsetSpecial(S2,S1) => X in S1
	% Priority 1 (low priority)
	gensym(rule,RN8),
	constructKBHead(Env,pr(1),rn(AN7,RN8,system,lInR),MS,set(S1),X,
	                HYPS,D,CALLS,PT2,Consequence1),
	constructMLCall(Env,rn(AN7,_RN2,_S2,_O2),bodyMC(MS),headMC(MS),
			set(S2),X,HYPS,D,CALLS,PT2,Antecedent2),
	L1 = subsetSpecial(S2,S1),
	constructMLMark(Consequence1,AxiomHead1),
	assertzRE((Consequence1 :- checkCallStack(CALLS,AxiomHead1), (Antecedent2, L1))),
	!.
assertInRule(Env,8,AN7) :-
	% For all X: X in set(S2) and X in set(S3) and 
	%            intersectionOfLists(S2,S3,S1) => X in S1
	% Priority 1 (low priority)
	gensym(rule,RN8),
	constructKBHead(Env,pr(1),rn(AN7,RN8,system,lInR),MS,set(S1),X,
	                HYPS,D,CALLS,and([PT2,PT3]),Consequence1),
	constructMLCall(Env,rn(AN7,_RN2,_S2,_O2),bodyMC(MS),headMC(MS),
			set(S2),X,HYPS,D,CALLS,PT2,Antecedent2),
	constructMLCall(Env,rn(AN7,_RN3,_S3,_O3),bodyMC(MS),headMC(MS),
			set(S3),X,HYPS,D,CALLS,PT3,Antecedent3),
	L1 = intersectionOfLists([S2,S3],S1),
	constructMLMark(Consequence1,AxiomHead1),
	assertzRE((Consequence1 :- checkCallStack(CALLS,AxiomHead1), (Antecedent3, (Antecedent2, L1)))),
	!.
assertInRule(Env,9,AN7) :-
	% For all X: X in set(S2) and X in set(S3) and 
	%            intersectionOfLists(S2,S3,S1) => X in S1
	% Priority 1 (low priority)
	gensym(rule,RN8),
	constructKBHead(Env,pr(1),rn(AN7,RN8,system,lInR),MS,not(set(S1)),X,
	                HYPS,D,CALLS,and([PT2,PT3]),Consequence1),
	constructMLCall(Env,rn(AN7,_RN2,_S2,_O2),bodyMC(MS),headMC(MS),
			set(S2),X,HYPS,D,CALLS,PT2,Antecedent2),
	constructMLCall(Env,rn(AN7,_RN3,_S3,_O3),bodyMC(MS),headMC(MS),
			set(S3),X,HYPS,D,CALLS,PT3,Antecedent3),
	L1 = prologListSubtract(S2,S3,S1),
	constructMLMark(Consequence1,AxiomHead1),
	assertzRE((Consequence1 :- checkCallStack(CALLS,AxiomHead1), (Antecedent3, (Antecedent2, L1)))),
	!.


assertAbductionRule(Env,1) :-
	% Proof by abductive hypothesis
	gensym(axiom,AN1),
	gensym(rule,RN1),
	constructInHead(Env,rn(_AN2,_RN2,_S2,_O2),MS,C,X,
	                _HYPS1,_D,_CALLS1,_,InHead1),
	constructMLHead(Env,rn(AN1,RN1,system,lInR),MS,C,X,_HYPS2,D1,_CALLS2,usingAbHyp(in(MS,C,X)),InHead2),
	assertzRE((InHead2 :- memberDML(InHead1,D1))),
	!.
assertAbductionRule(Env,2) :-
	% Proof by abduction
	gensym(axiom,AN1),
	gensym(rule,RN1),
	constructInHead(Env,rn(_AN2,_RN2,_S2,_O2),MS,C,X,_HYPS,_D0,_CALLS3,_,InHead2),
	constructMLHead(Env,rn(AN1,RN1,system,lInR),MS,C1,X,
	                HYPS,D1,CALLS,usingAbHyp(in(MS,C,X)),InHead1),
	L1 = normalizeNot(C1,C),
	L2 = not(memberDML(InHead2,D1)),
	L3 = addDefaultML(InHead2,D1),
	assertzRE((InHead1 :- L1, L2, L3)),
	!.


	

/**********************************************************************
 *
 * switchToEnvironment(Name)
 *
 */

switchToEnvironment(Name) :-
	environment(Name,Env,_),
	retractallSpecial(currentEnvironment(_)),
	assertaRE(currentEnvironment(Env)),
	!.

/**********************************************************************
 *
 * saveEnvironment(FileName)
 * 
 */

saveEnvironment(FileName) :-
	getCurrentEnvironment(EnvName),
	saveEnvironment(EnvName,FileName).

saveEnvironment(EnvName,FileName) :-
	tell(FileName),
	writeEnvironment(EnvName),
	told,
	% to be implemented
	!.

writeEnvironment(EnvName) :-
	environment(EnvName,Env,C),
	writeq(environment(EnvName,Env,C)), write('.'), nl,
%	write(':- dynamic(constraint/8).'), nl,
%	write(':- dynamic(in/9).'), nl,
%	write(':- dynamic(kb_in/10).'), nl,
%	write(':- dynamic(rel/5).'), nl,
%	write(':- dynamic(eq/9).'), nl,
%	write(':- dynamic(conceptHierarchy/3).'), nl,
%	write(':- dynamic(roleHierarchy/3).'), nl,
%	write(':- dynamic(conceptEqualSets/6).'), nl,
%	write(':- dynamic(conceptSubsets/6).'), nl,
%	write(':- dynamic(roleEqualSets/6).'), nl,
%	write(':- dynamic(roleSubsets/6).'), nl,
%	write(':- dynamic(conceptName/4).'), nl,
%	write(':- dynamic(roleName/4).'), nl,
%	write(':- dynamic(falsum/2).'), nl,
%	write(':- dynamic(inconsistencyCheck/3).'), nl,
%	write(':- dynamic(conceptElement/6).'), nl,
%	write(':- dynamic(roleElement/7).'), nl,
%	write(':- dynamic(modalAxioms/6).'), nl,
	writeall(in(Env,_A0,_B0,_C0,_D0,_E0,_F0,_G0,_H0)),
	writeall(kb_in(Env,_A1,_B1,_C1,_D1,_E1,_F1,_G1,_H1,_I1)),
	writeall(eq(Env,_A11,_B11,_C11,_D11,_E11,_F11,_G11,_H11)),
	writeall(constraint(Env,_A12,_B12,_C12,_D12,_E12,_F12,_G12)),
	writeall(rel(Env,_A17,_B17,_C17,_D17)),
	writeall(closed(Env,_A18,_B18,_C18,_D18)),
	writeall(compiledPredicate(Env,_A19)),
	writeall(conceptElement(Env,_A14,_B14,_C14,_D14,_E14,_F14)),
	writeall(conceptEqualSets(Env,_A4,_B4,_C4,_D4,_E4)),
	writeall(conceptHierarchy(Env,_A2,_B2)),
	writeall(conceptName(Env,_A8,_B8,_C8)),
	writeall(conceptSubsets(Env,_A5,_B5,_C5,_D5,_E5)),
	writeall(Env,given_change/4),
	writeall(Env,given_inflLink/4),
	writeall(modalAxioms(Env,_A16,_B16,_C16,_D16,_E16,_F16)),
	writeall(Env,roleAttributes/5),
	writeall(Env,roleDefault/4),
	writeall(Env,roleDefNr/4),
	writeall(Env,roleDomain/4),
	writeall(Env,roleElement/8),
	writeall(Env,roleEqualSets/6),
	writeall(Env,roleHierarchy/3),
	writeall(Env,roleName/4),
	writeall(Env,roleNr/5),
	writeall(Env,roleRange/4),
	writeall(Env,roleSubsets/6),
	writeall(succ(_A17,Env,_B17,_C17)),
	writeall(sub(_A18,Env,_B18,_C18)),
	!.

writeall(Head) :-
	clause(Head,Body),
	writeq((Head :- Body)), write('.'), nl, 
	fail.
writeall(_) :- !.

writeall(Env,Pred/Arity) :-
	constructHead(Env,Pred/Arity,Head),
	clause(Head,Body),
	writeq((Head :- Body)), write('.'), nl, 
	fail.
writeall(_,_) :- !.


constructHead(Env,Pred/Arity,Head) :-
	constructArguments(Env,Arity,[],Arguments),
	Head =.. [Pred|Arguments],
	!.
constructArguments(Env,1,Args,[Env|Args]) :-
	!.
constructArguments(Env,N,Args,Arguments) :-
	M is (N - 1),
	constructArguments(Env,M,[X|Args],Arguments),
	!.

/**********************************************************************
 *
 * loadEnvironment(FileName)
 * 
 */

loadEnvironment(FileName) :-	see(FileName),
	read(environment(EnvName,Env,C)),
	(removeEnvironment(EnvName) ; true),
	assertaRE(environment(EnvName,Env,C)),
	repeat,
	read(Clause),
	assertClause(Clause),
	seen,
	!.
loadEnvironment(FileName) :-
	seen,
	!,
	fail.
loadEnvironment(FileName,EnvName) :-
	see(FileName),
	read(environment(_EnvName2,Env,C)),
	(removeEnvironment(EnvName) ; true),
	assertzRE(environment(EnvName,Env,C)),
	repeat,
	read(Clause),
	assertClause(Clause),
	seen,
	!.
loadEnvironment(_FileName,_EnvName) :-
	seen,
	!, 
	fail.

assertClause('end_of_file') :-
	!.
assertClause(Clause) :-
	assertzRE(Clause),
	fail.

/**********************************************************************
 *
 * copyEnvironment(Name1,Name2)
 * copies environment Name1 to environment Name2.
 *
 */

copyEnvironment(Name2) :-
	getCurrentEnvironment(Name1),
	copyEnvironment(Name1,Name2).

copyEnvironment(Name1,Name2) :-
	environment(Name1,Env1,Comment),
	makeEnvironment(Name2,Comment),
	% !! This environment mustn't be initializes because
	% the clauses asserted usually during initialization
	% will also be copied from environment Name1.
	environment(Name2,Env2,_),
	term_expansion(copy,on,Env1,Env2),
	!,
	copyAll(Env1,Env2,in/9),
	copyAll(Env1,Env2,kb_in/10),
	copyAll(Env1,Env2,eq/9),
	copyAll(Env1,Env2,constraint/8),
	copyAll(Env1,Env2,rel/5),
	copyAll(Env1,Env2,closed/5),
	copyAll(Env1,Env2,compiledPredicate/2),
	copyAll(Env1,Env2,conceptElement/7),
	copyAll(Env1,Env2,conceptEqualSets/6),
	copyAll(Env1,Env2,conceptHierarchy/3),
	copyAll(Env1,Env2,conceptName/4),
	copyAll(Env1,Env2,conceptSubsets/6),
	copyAll(Env1,Env2,environment/3),
	copyAll(Env1,Env2,given_change/4),
	copyAll(Env1,Env2,given_inflLink/4),
	copyAll(Env1,Env2,modalAxioms/7),
	copyAll(Env1,Env2,roleAttributes/5),
	copyAll(Env1,Env2,roleDefault/4),
	copyAll(Env1,Env2,roleDefNr/4),
	copyAll(Env1,Env2,roleDomain/4),
	copyAll(Env1,Env2,roleElement/8),
	copyAll(Env1,Env2,roleEqualSets/6),
	copyAll(Env1,Env2,roleHierarchy/3),
	copyAll(Env1,Env2,roleName/4),
	copyAll(Env1,Env2,roleNr/5),
	copyAll(Env1,Env2,roleRange/4),
	copyAll(Env1,Env2,roleSubsets/6),
%	copyAll(Env1,Env2,sub/4),
%	copyAll(Env1,Env2,succ/4),
%	copyAll(Env1,Env2,isMooOption/2),
%	copyAll(Env1,Env2,nsub/4),
	term_expansion(copy,off,Env1,Env2),
	!.

term_expansion(copy,on,Env1,Env2) :-
	abolish(term_expansion/2),
	assertzRE((term_expansion((Head :- Body),(Head1 :- Body1)) :-
	term_expansion(Head,Head1),
	term_expansion(Body,Body1))),
	assertzRE((term_expansion((L, Body), (L1,Body1)) :-
	term_expansion(L,L1),
	term_expansion(Body,Body1))),
	assertzRE((term_expansion((L; Body), (L1,Body1)) :-
	term_expansion(L,L1),
	term_expansion(Body,Body1))),
	assertzRE((term_expansion(\+Atom,\+Atom1) :-
	term_expansion(Atom,Atom1))),
	assertzRE((term_expansion(once(Body1),once(Body2)) :-
		term_expansion(Body1,Body2))),
	assertzRE((term_expansion(call(Body1),call(Body2)) :-
		 term_expansion(Body1,Body2))),
	assertTermExpansionClause(in/9,Env1,Env2),
	assertTermExpansionClause(kb_in/10,Env1,Env2),
	assertTermExpansionClause(eq/9,Env1,Env2),
	assertTermExpansionClause(constraint/8,Env1,Env2),
	assertTermExpansionClause(rel/5,Env1,Env2),
	assertTermExpansionClause(closed/5,Env1,Env2),
	assertTermExpansionClause(compiledPredicate/2,Env1,Env2),
	assertTermExpansionClause(conceptElement/7,Env1,Env2),
	assertTermExpansionClause(conceptEqualSets/6,Env1,Env2),
	assertTermExpansionClause(conceptHierarchy/3,Env1,Env2),
	assertTermExpansionClause(conceptName/4,Env1,Env2),
	assertTermExpansionClause(conceptSubsets/6,Env1,Env2),
	assertTermExpansionClause(environment/3,Env1,Env2),
	assertTermExpansionClause(given_change/4,Env1,Env2),
	assertTermExpansionClause(given_inflLink/4,Env1,Env2),
	assertTermExpansionClause(modalAxioms/7,Env1,Env2),
	assertTermExpansionClause(roleAttributes/5,Env1,Env2),
	assertTermExpansionClause(roleDefault/4,Env1,Env2),
	assertTermExpansionClause(roleDefNr/4,Env1,Env2),
	assertTermExpansionClause(roleDomain/4,Env1,Env2),
	assertTermExpansionClause(roleElement/8,Env1,Env2),
	assertTermExpansionClause(roleEqualSets/6,Env1,Env2),
	assertTermExpansionClause(roleHierarchy/3,Env1,Env2),
	assertTermExpansionClause(roleName/4,Env1,Env2),
	assertTermExpansionClause(roleNr/5,Env1,Env2),
	assertTermExpansionClause(roleRange/4,Env1,Env2),
	assertTermExpansionClause(roleSubsets/6,Env1,Env2),
	assertTermExpansionClause(sub/4,Env1,Env2),
	assertTermExpansionClause(succ/4,Env1,Env2),
	assertzRE((term_expansion(succ(X1,Env1,X3,X4),
				succ(X1,Env2,X3,X4)))),
	assertzRE((term_expansion(sub(X1,Env1,X3,X4),
				sub(X1,Env2,X3,X4)))),
	assertzRE(term_expansion(X,X)),
	!.
term_expansion(copy,off,_Env1,_Env2) :-
	abolish(term_expansion/2),
	!.


assertTermExpansionClause(Pred/Arity,Env1,Env2) :-
	constructArguments(Env,Arity,[],[Env1|Arguments]),
	Head1 =.. [Pred|[Env1|Arguments]],
	Head2 =.. [Pred|[Env2|Arguments]],
	assertzRE((term_expansion(Head1,Head2))),
	!.

expandTerm(A,B) :-
	expand_term(A,B),
	!.

copyall(Env1,_Env2,Pred,Args) :-
	Head1 =.. [Pred,Env1|Args],
	clause(Head1,Body1),
	expandTerm((Head1,Body1),(Head2,Body2)),
	assertzRE((Head2 :- Body2)),
	fail.
copyall(_,_,_,_) :- !.

copyAll(Env1,_Env2,Pred/Arity) :-
	constructHead(Env1,Pred/Arity,Head1),
	clause(Head1,Body1),
	expandTerm((Head1,Body1),(Head2,Body2)),
	assertzRE((Head2 :- Body2)),
	fail.
copyAll(_,_,_) :- !.

/**********************************************************************
 *
 * renameEnvironment(Name1,Name2)
 * renames environment Name1 to environment Name2.
 *
 */

renameEnvironment(Name1,Name2) :-
	retract(environment(Name1,Env,C)),
	assertaRE(environment(Name2,Env,C)),
	% to be implemented
	!.
/**********************************************************************
 *
 * @(#) examples.pl 1.5@(#)
 *
 */

example(1) :-
	makeEnvironment('ex1','von HJO'),
	initEnvironment,
	defconcept(fatherAcademic,and([male,some(child,academic)])),
	defconcept(grandfatherAcademic,and([male,some(child,fatherAcademic)])),
	assert_ind(tom,tim,child),
	assert_ind(tim,mike,child),
	assert_ind(mike,male),
	assert_ind(mike,academic),
	assert_ind(tim,male),
	assert_ind(tom,male).
%%% Example  2:
%%% KRIS-Example
% setof(C,motel_ask(elementOf(mary,C)),L)
% gives L = ['top',grandparent,parent,parent_with_sons_only,
%            parent_with_two_children,person] 
% in Total runtime 12.167 sec. (05.06.92)
example(2) :-
	makeEnvironment('ex2','krisExample'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defconcept(males,some(sex,male)),
	defconcept(females,some(sex,female)),
	defprimconcept(person,some(sex,or([male,female]))),
	defconcept(parent,and([person,some(child,person)])),
	defconcept(mother,and([parent,some(sex,female)])),
	defconcept(father,and([parent,not(mother)])),
	defconcept(grandparent,and([parent,some(child,parent)])),
	defconcept(parent_with_sons_only,and([parent,all(child,some(sex,male))])),
	defconcept(parent_with_two_children,and([parent,atleast(2,child)])),
	assert_ind(tom,father),
	assert_ind(tom,peter,child),
	assert_ind(tom,harry,child),
	assert_ind(mary,parent_with_sons_only),
	assert_ind(mary,tom,child),
	assert_ind(mary,chris,child).
%%% Example  3:
% inconsistent([])
% succeeds in Total runtime 0.000 sec. (05.06.92)
example(3) :-
	makeEnvironment('ex3','Inconsistence'),
	initEnvironment,
	defprimconcept(parent_with_one_child,atmost(1,child)),
	assert_ind(mary,parent_with_one_child),
	assert_ind(mary,tom,child),
	assert_ind(mary,chris,child).
%%% Example  4:
% Modal Operators
example(4) :-
	makeEnvironment('ex4','Inconsistence'),
	initEnvironment,
	defconcept([b(believe,a1)],c1,b(want,a2,car)),
	defconcept([b(believe,a1)],c2,b(want,a3,car)),
	defprimconcept([b(believe,a1)],c1,c2),
	assert_ind([b(believe,a1)],audi,c1).
%%% Example  5:
% subsumes([],c1,c2).
% fails    in Total runtime 0.050 sec. (05.06.92)
% subsumes([],c2,c1).
% succeeds in Total runtime 0.050 sec. (05.06.92)
example(5) :-
	makeEnvironment('ex5','Subsumption'),
	initEnvironment,
	defconcept(c1,and([all(r,a),all(and([r,q]),b)])),
	defconcept(c2,all(and([r,q]),and([a,b]))).
%%% Example  6:
% subsumes([],c1,c2).
% fails    in Total runtime 0.033 sec. (05.06.92)
% subsumes([],c2,c1).
% succeeds in Total runtime 0.033 sec. (05.06.92)
example(6) :-
	makeEnvironment('ex6','Subsumption'),
	initEnvironment,
	defrole(r1,and([r,q])),
	defconcept(d0,and([a,b])),
	defconcept(d1,all(r,a)),
	defconcept(d2,all(r1,b)),
	defconcept(c1,and([d1,d2])),
	defconcept(c2,all(r1,d0)).
%%% Example  7:
example(7) :-
	makeEnvironment('ex7','Subsumption'),
	initEnvironment,
	defconcept(c1,atleast(3,r)),
	defconcept(c2,and([all(and([r,p]),a),all(and([r,q]),not(a)),atleast(2,and([r,p])),atleast(2,and([r,q]))])).
%%% Example  8;
% motel_ask(elementOf(tom,heterosexual))
% succeeds in Total runtime 0.033 sec. (05.06.92)
example(8) :-
	makeEnvironment('ex8','Disjunction of complementary concepts'),
	initEnvironment,
	defprimconcept(male),
	defconcept(female,not(male)),
	defconcept(heterosexual,or([male,female])).
%%% Example  9:
% Variation of the KRIS-Example
% motel_ask(elementOf(chris,male))
% succeeds in Total runtime 0.000 sec. (05.06.92)
example(9) :-
	makeEnvironment('ex9','Variation of the KRIS example'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defprimconcept(person,or([male,female])),
	defconcept(parent,and([person,some(child,person)])),
	defconcept(mother,and([parent,female])),
	defconcept(father,and([parent,not(mother)])),
	defconcept(grandparent,and([parent,some(child,parent)])),
	defconcept(parent_with_sons_only,and([parent,all(child,male)])),
	defconcept(parent_with_two_children,and([parent,atleast(2,child)])),
	assert_ind(tom,father),
	assert_ind(tom,peter,child),
	assert_ind(tom,harry,child),
	assert_ind(mary,parent_with_sons_only),
	assert_ind(mary,tom,child),
	assert_ind(mary,chris,child).
%%% Example 10:
% motel_ask(elementOf(tom,c2)) 
% succeeds in Total runtime 0.017 sec. (05.06.92)
example(10) :-
	makeEnvironment('ex10','Inverse Role'),
	initEnvironment,
	defrole(r2,inverse(r1)),
	defconcept(c1,all(r1,c2)),
	defconcept(c3,some(r2,c1)),
	assert_ind(tom,c3).
%%% Example 11:
% inconsistent([])
% succeeds in Total runtime 0.034 sec. (05.06.92)
example(11) :-
	makeEnvironment('ex11','Inconsistence'),
	initEnvironment,
	defconcept(c1,and([atleast(2,child),atmost(1,child)])),
	assert_ind(tom,c1).
%%% Example 12:
% subsumes([],c1,c2)
% succeeds in Total runtime 0.050 sec. (05.06.92)
% subsumes([],c2,c1)
% fails    in Total runtime 0.200 sec. (05.06.92)
example(12) :-
	makeEnvironment('ex12','Subsumption'),
	initEnvironment,
	defconcept(c1,and([person,atleast(2,child)])),
	defconcept(c2,and([person,atleast(3,restr(child,lawyer))])).
%%% Example 13:
% subsumes([],c1,c2)
% succeeds in Total runtime 0.117 sec. (05.06.92)
example(13) :-
	makeEnvironment('ex13','Subsumption'),
	initEnvironment,
	defconcept(c1,and([person,atmost(4,restr(child,doctor))])),
	defconcept(c2,and([person,female,atmost(3,child)])).
%%% Example 14:
% subsumes([],c1,c2)
% succeeds ???
% subsumes([],c2,c1)
% succeeds in Total runtime 0.250 sec. (06.06.92)
example(14) :-
	makeEnvironment('ex14','Subsumption'),
	initEnvironment,
	defconcept(c1,atmost(0,restr(r,and([atleast(3,s1),atleast(4,s2)])))),
	defconcept(c2,all(restr(r,atleast(2,s1)),atmost(2,s2))).
%%% Example 15:
% subsumes([],c2,c1)
% succeeds in Total runtime 0.067 sec. (05.06.92)
example(15) :-
	makeEnvironment('ex15','Subsumption'),
	initEnvironment,
	defconcept(c1,and([person,all(friend,doctor),all(restr(friend,doctor),atleast(1,speciality))])),
	defconcept(c2,and([person,all(friend,atleast(1,speciality))])).
%%% Example 16:
% subsumes([],c2,c1)
% succeeds in Total runtime 0.450 sec. (06.06.92)
example(16) :-
	makeEnvironment('ex16','Subsumption'),
	initEnvironment,
	defconcept(c1,and([atleast(1,restr(child,lawyer)),atleast(1,restr(child,doctor))])),
	defconcept(c2,or([atleast(2,child),atleast(1,restr(child,and([lawyer,doctor])))])).
%%% Example 17:
% subsumes([],c2,c1)
% succeeds in Total runtime 0.034 sec. (05.06.92)
example(17) :-
	makeEnvironment('ex17','Subsumption'),
	initEnvironment,
	defconcept(c1,some(and([child,friend]),doctor)),
	defconcept(c2,and([some(child,doctor),some(friend,doctor)])).
%%% Example 18:
% motel_ask(elementOf(mary,c4))
% succeeds in Total runtime 0.117 sec. (05.06.92)
example(18) :-
	makeEnvironment('ex18','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defconcept(c3,and([atmost(4,child),atleast(2,restr(child,female))])),
	defconcept(c4,atmost(2,restr(child,female))),
	assert_ind(tom,male),
	assert_ind(peter,male),
	assert_ind(mary,peter,child),
	assert_ind(mary,tom,child),
	assert_ind(mary,c3).
%%% Example 19
% motel_ask(elementOf(amy,female))
% succeeds in Total runtime 0.067 sec. (06.06.92)
example(19) :-
	makeEnvironment('ex19','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defconcept(c5,and([atmost(2,restr(child,male))])),
	assert_ind(tom,male),
	assert_ind(peter,male),
	assert_ind(mary,tom,child),
	assert_ind(mary,peter,child),
	assert_ind(mary,amy,child),
	assert_ind(mary,c5).
%%% Example 20
% inconsistent([])
% succeeds in Total runtime 5.167 sec. (05.06.92)
example(20) :-
	makeEnvironment('ex20','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defconcept(c5,and([atmost(2,restr(child,male)),atmost(1,restr(child,female))])),
	assert_ind(tom,male),
	assert_ind(peter,male),
	assert_ind(mary,tom,child),
	assert_ind(mary,peter,child),
	assert_ind(mary,amy,child),
	assert_ind(mary,jane,child),
	assert_ind(mary,c5).
%%% Example 21
% motel_ask(elementOf(betty,female))
example(21) :-
	makeEnvironment('ex21','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defconcept(c1,and([atmost(1,restr(teacher,male)),atmost(1,restr(teacher,female))])),
	defconcept(c2,and([atmost(2,restr(teacher,male)),atmost(1,restr(teacher,female))])),
	assert_ind(tom,c1),
	assert_ind(sue,c1),
	assert_ind(david,c2),
	assert_ind(tom,betty,teacher),
	assert_ind(tom,peter,teacher),
	assert_ind(sue,betty,teacher),
	assert_ind(sue,chris,teacher),
	assert_ind(david,betty,teacher),
	assert_ind(david,chris,teacher),
	assert_ind(david,peter,teacher).
%%% Example 22
% motel_ask(elementOf(amy,female))
% should succeeds
% but fails in the current implementation
example(22) :-
	makeEnvironment('ex22','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defrole(maleTeacher,restr(teacher,male)),
	defrole(femaleTeacher,restr(teacher,female)),
	defconcept(c1,and([atmost(1,maleTeacher),atmost(1,femaleTeacher)])),
	defconcept(c2,atmost(1,maleTeacher)),
	assert_ind(tom,c2),
	assert_ind(sue,c1),
	assert_ind(tom,betty,teacher),
	assert_ind(tom,chris,teacher),
	assert_ind(tom,robin,teacher),
	assert_ind(sue,betty,teacher),
	assert_ind(sue,chris,teacher).
%%% Example 23
% is a variant of example 23 with user provided names for the 
% restricted roles.
% motel_ask(elementOf(amy,female))
% should succeeds
% but fails in the current implementation
example(23) :-
	makeEnvironment('ex23','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defprimrole(maleTeacher,teacher),
	defprimrole(femaleTeacher,teacher),
	defconcept(c1,and([atmost(1,maleTeacher),atmost(1,femaleTeacher)])),
	defconcept(c2,atmost(1,maleTeacher)),
	assert_ind(tom,c2),
	assert_ind(sue,c1),
	assert_ind(tom,betty,teacher),
	assert_ind(tom,chris,teacher),
	assert_ind(tom,robin,teacher),
	assert_ind(sue,betty,teacher),
	assert_ind(sue,chris,teacher).
%%% Example 24
% motel_ask(elementOf(audi,c3))
% succeeds in Total runtime 1.634 sec. (24.06.92)
example(24) :-
	makeEnvironment('ex24','Modal operators'),
	initEnvironment,	
	modalAxioms(kd45,believe,a1),
	defconcept(c1,b(believe,a1,auto)),
	defconcept(c3,b(believe,a1,c1)),
	defconcept([b(believe,a1)],c1,b(believe,a1,auto)),
	defconcept([b(believe,a1)],c3,b(believe,a1,c1)),
	assert_ind(audi,c1).
%%% Example 25
% not(motel_ask(elementOf(audi,c3)))
% succeeds in Total runtime 0.033 sec. (24.06.92)
example(25) :-
	makeEnvironment('ex25','Modal operators'),
	initEnvironment,	
	modalAxioms(kd45,believe,a1),
	defconcept([b(believe,a1)],c1,b(believe,a1,auto)),
	defconcept([b(believe,a1)],c3,b(believe,a1,c1)),
	assert_ind(audi,c1).
%%% Example 26
% subsumes([],c2,c1)
% succeeds in Total runtime 0.034 sec. (24.06.92)
% not(subsumes([],c1,c2))
% succeeds in Total runtime 1.333 sec. (24.06.92)
example(26) :-
	makeEnvironment('ex27','Subsumption'),
	initEnvironment,
	defconcept(c1,atmost(0,r)),
	defconcept(c2,all(r,c5)).
%%% Example 27
% subsumes([],c2,c1) 
% succeeds in Total runtime 0.067 sec. (24.06.92)
% not(subsumes([],c1,c2))
% succeeds
example(27) :-
	makeEnvironment('ex28','Subsumption'),
	initEnvironment,
	defconcept(c1,not(some(r,'top'))),
	defconcept(c2,all(r,c5)).
%%% Example 28
% motel_ask(ex28,[b(believe,john)],elementOf(audi,auto),P)
% succeeds
example(28) :-
	makeEnvironment('ex28','Modal operators'),
	initEnvironment,	
	modalAxioms(kd45,believe,a1),
	modalAxioms(kd45,believe,all),
	defprimconcept(auto),
	assert_ind([b(believe,all)],audi,auto).
%%% Example 29
% is a variant of example 23 with a more restricted definition of c1
% motel_ask(elementOf(amy,female))
% should succeeds
% but fails in the current implementation
example(29) :-
	makeEnvironment('ex29','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defconcept(male,not(female)),
	defprimrole(teacher),
	defrole(maleTeacher,restr(teacher,male)),
	defrole(femaleTeacher,restr(teacher,female)),
	defconcept(c1,and([atmost(1,maleTeacher),atmost(2,femaleTeacher)])),
	assert_ind(tom,c1),
	assert_ind(sue,c1),
	assert_ind(tom,betty,teacher),
	assert_ind(tom,chris,teacher),
	assert_ind(tom,robin,teacher),
	assert_ind(sue,betty,teacher),
	assert_ind(sue,chris,teacher).
example(30) :-
	makeEnvironment('ex30','Number restrictions'),
	initEnvironment,
	defprimconcept(female),
	defrole(maleTeacher,restr(teacher,not(female))),
	defrole(femaleTeacher,restr(teacher,female)),
	defconcept(c1,and([atmost(1,maleTeacher),atmost(1,femaleTeacher)])),
	defconcept(c2,atmost(1,maleTeacher)),
	assert_ind(tom,c2),
	assert_ind(sue,c1),
	assert_ind(tom,betty,teacher),
	assert_ind(tom,chris,teacher),
	assert_ind(tom,robin,teacher),
	assert_ind(sue,betty,teacher),
	assert_ind(sue,chris,teacher).
%%% Example 31
% First test example for defclosed
% motel_ask(elementOf(tom,onlyMaleChildren))
% succeeds
example(31) :-
	makeEnvironment('ex31','defclosed'),
	initEnvironment,
	defconcept(onlyMaleChildren,all(child,male)),
	assert_ind(tom,peter,child),
	assert_ind(tom,chris,child),
	assert_ind(tom,tim,child),
	assert_ind(peter,male),
	assert_ind(chris,male),
	assert_ind(tim,male),
	defclosed(tom,_Y,child).
%%% Example 32
% First test example for abduction
% abduce(elementOf(robin,male),H,E)
% abduce(elementOf(robin,female),H,E)
example(32) :-
	makeEnvironment('ex32','abduction'),
	initEnvironment,
	defconcept(male,not(female)).
%%% Example 33
% Second test example for abduction
% abduce(elementOf(nixon,dove),H,E)
% abduce(elementOf(nixon,hawk),H,E)
% gives unexpected results!!!
example(33) :-
	makeEnvironment('ex33','abduction'),
	initEnvironment,
	defconcept(c1,and([quaker,normalQuaker])),
	defconcept(c2,and([republican,normalRepublican])),
	defprimconcept(c1,dove),
	defprimconcept(c2,hawk),
	assert_ind(nixon,quaker),
	assert_ind(nixon,republican).
%%% Example 34
% The following gives an inconsistent specification of
% the penguin - bird problem. So
% inconsistent(ex34)
% succeeds
example(34) :-
	makeEnvironment('ex34',abduction),
	initEnvironment,
	defprimconcept(penguin,and([bird,not(fly)])),
	defprimconcept(bird,fly),
	assert_ind(tweety,penguin),
	assert_ind(john,bird).
%%% Example 35
% This is a consistent specification of the penguin - bird problem.
% abduce(ex35,[],elementOf(john,fly),H,E).
% succeeds with
% H = [in(env(e1),rn(_7982,_7983,_7984,_7985),modal([]),normalBird,john,
%         hyp(_7989),ab(_7991),call(_7993),
%         proved(in([],normalBird,john),hyp(_7989),basedOn(_8005)))],
% E = proved(in([],fly,john),hyp([]),
%            basedOn(and([proved(in([],bird,john),hyp([]),basedOn(abox)),
%                         proved(in([],normalBird,john),hyp([]),
%     basedOn(usingAbHyp(in(env(e1),rn(_7525,_7526,_7527,_7528),modal([]),
%                           normalBird,john,hyp(_7532),ab(_7534),call(_7536),
%                           proved(in([],normalBird,john),hyp(_7532),
%                           basedOn(_7548))))))])))
% and
% abduce(ex35,[],elementOf(tweety,fly),H,E).
% fails
example(35) :-
	makeEnvironment('ex35',abduction),
	initEnvironment,
	defprimconcept(penguin,and([bird,not(normalBird)])),
	defprimconcept(and([bird,normalBird]),fly),
	assert_ind(tweety,penguin),
	assert_ind(john,bird).
%%% Example 36
% Variant of example 33 giving the expected results:
% abduce(ex36,[],elementOf(nixon,dove),H,E).
% succeeds with
% H = [in(env(e4),rn(_8077,_8078,_8079,_8080),modal([]),
%         normalQuaker,nixon,hyp(_8084),ab(_8086),call(_8088),
%         proved(in([],normalQuaker,nixon),hyp(_8084),basedOn(_8100)))],
% E = proved(in([],dove,nixon),hyp([]),
%        basedOn(and([proved(in([],quaker,nixon),hyp([]),basedOn(abox)),
%                     proved(in([],normalQuaker,nixon),hyp([]),
%           basedOn(usingAbHyp(in(env(e4),rn(_7620,_7621,_7622,_7623),
%                   modal([]),normalQuaker,nixon,hyp(_7627),ab(_7629),
%                   call(_7631),proved(in([],normalQuaker,nixon),
%                   hyp(_7627),basedOn(_7643))))))]))) 
% and
% abduce(ex36,[],elementOf(nixon,hawk),H,E).
% succeeds with
% H = [in(env(e4),rn(_8077,_8078,_8079,_8080),modal([]),
%         normalRepublican,nixon, hyp(_8084),ab(_8086),call(_8088),
%         proved(in([],normalRepublican,nixon),hyp(_8084),basedOn(_8100)))],
% E = proved(in([],dove,nixon),hyp([]),
%        basedOn(and([proved(in([],republican,nixon),hyp([]),basedOn(abox)),
%                     proved(in([],normalRepublican,nixon),hyp([]),
%           basedOn(usingAbHyp(in(env(e4),rn(_7620,_7621,_7622,_7623),
%                   modal([]),normalRepublican,nixon,hyp(_7627),ab(_7629),
%                   call(_7631),proved(in([],normalRepublican,nixon),
%                   hyp(_7627),basedOn(_7643))))))]))) 
example(36) :-
	makeEnvironment('ex36','abduction'),
	initEnvironment,
	defprimconcept(and([quaker,normalQuaker]),dove),
	defprimconcept(and([republican,normalRepublican]),hawk),
	assert_ind(nixon,quaker),
	assert_ind(nixon,republican).
%%% Example 37
example(37) :-
	makeEnvironment('ex37','abduction'),
	initEnvironment,
	defprimconcept(rained_last_night,grass_is_wet),
	defprimconcept(sprinkler_was_on,grass_is_wet),
	defprimconcept(grass_is_wet,shoes_are_wet).
%%% Example 38
% motel_ask(elementOf(ideaste,c2))
% should succeed
example(38) :-
	makeEnvironment('ex38','disjunctive_information'),
	initEnvironment,
	assert_ind(ideaste,oedipus,hasChild),
	assert_ind(oedipus,polyneikes,hasChild),
	assert_ind(ideaste,polyneikes,hasChild),
	assert_ind(polyneikes,thersandros,hasChild),
	assert_ind(oedipus,fatherMurderer),
	assert_ind(thersandros,not(fatherMurderer)),
	defconcept(c1,and([fatherMurderer,some(hasChild,not(fatherMurderer))])),
	defconcept(c2,some(hasChild,c1)).
%%% Example 39
% motel_ask(elementOf(lucky,female))
% succeeds
example(39) :-
	makeEnvironment('ex39','negation_as_failure'),
	initEnvironment,
	defrole(parentOf,inverse(childOf)),
	defconcept(male,not(female)),
	defprimconcept(and([some(parentOf,top),naf(not(female))]),female),
	assert_ind(mary,lucky,childOf).
%%% Example 40
% motel_ask(elementOf(peter,richPerson))
% succeeds.
% After
% assert_ind(peter,poorPerson)
% the query
% motel_ask(elementOf(peter,richPerson))
% fails
example(40) :-
	makeEnvironment('ex40','negation_as_failure'),
	initEnvironment,
	defprimconcept(and([doctor,naf(not(richPerson))]),richPerson),
	defconcept(poorPerson,not(richPerson)),
	assert_ind(peter,doctor).
%%% Example 41
% motel_ask(elementOf(tom,richPerson))
% succeeds.
% After 
% assert_ind(tom,poorPerson)
% the query
% motel_ask(elementOf(tom,richPerson))
% fails
example(41) :-
	makeEnvironment('ex41','negation_as_failure'),
	initEnvironment,
	defrole(doctorParentOf,restr(inverse(childOf),doctor)),
	defrole(childOfDoctor,inverse(r1)),
	defprimconcept(and([some(doctorParentOf,top),naf(not(richPerson))]),richPerson),
	defconcept(poorPerson,not(richPerson)),
	assert_ind(chris,doctor),
	assert_ind(chris,tom,childOf).
%%% Example 42
% motel_ask(elementOf(audi,fourWheels))
% succeeds.
% After
% assert_ind(audi,fiveWheels)
% the query
% motel_ask(elementOf(audi,fourWheels))
% fails
example(42) :-
	makeEnvironment('ex42','negation_as_failure'),
	initEnvironment,
	defconcept(fourWheels,and([atleast(4,wheels),atmost(4,wheels)])),
	defconcept(fiveWheels,and([atleast(5,wheels),atmost(5,wheels)])),
	defprimconcept(and([car,naf(not(fourWheels))]),fourWheels),
	assert_ind(audi,car).
%%% Example 43
example(43) :-
	makeEnvironment('ex43','concrete_domains'),
	initEnvironment,
	defconcept(colors,set([b,y,r])),
	defconcept(blueOrYellow,set([b,y])),
	defconcept(red,set([r])),
	defconcept(blue,set([b])),
	defconcept(yellow,set([y])),
	defconcept(redOrYellow,set([r,y])),
	defconcept(blueOrRed,set([b,r])),
	defconcept(yellowOrBlue,set([y,b])).
%%% Example 44
% subsumes(c2,c1)
% should succeed
example(44) :-
	makeEnvironment('ex44','concrete_domains'),
	initEnvironment,
	defconcept(c1,set([a,b])),
	defconcept(c2,set([a,b,c])).
%%% Example 45
example(45) :-
	makeEnvironment('ex45','concrete_domains'),
	initEnvironment,
	defconcept(c1,set([a,b,c])),
	defconcept(c2,set([a,b])),
	defconcept(nc2,not(c2)).
%%% Example 46
% An insufficient specification of 
% The bmw is either yellow, blue, or red but not yellow. 
% motel_ask(elementOf(bmw,c3))
% fails
example(46) :-
	makeEnvironment('ex46','concrete_domains'),
	initEnvironment,
	defconcept(c1,some(hasCol,set([yellow,blue,red]))),
	defconcept(c2,some(hasCol,not(set([yellow])))),
	defconcept(c3,some(hasCol,set([blue,red]))),
	assert_ind(bmw,c1),
	assert_ind(bmw,c2).
%%% Example 47
% A correct specification of
% The bmw is either yellow, blue, or red but not yellow. 
% motel_ask(elementOf(bmw,c3))
% succeeds
example(47) :-
	makeEnvironment('ex47','concrete_domains'),
	initEnvironment,
	defconcept(c1,and([some(hasCol,set([yellow,blue,red])),all(hasCol,set([yellow,blue,red]))])),
	defconcept(c2,some(hasCol,not(set([yellow])))),
	defconcept(c3,some(hasCol,set([blue,red]))),
	assert_ind(bmw,c1),
	assert_ind(bmw,c2).
example(48) :-
	makeEnvironment('ex48','concrete_concepts'),
	initEnvironment,
	defconcept(oneSpouse,and([atleast(1,spouse),atmost(1,spouse)])),
	assert_ind(m1,oneSpouse),
	defprimconcept(some(inverse(spouse),set([m1])),set([g0,g1,g2])),
	assert_ind(g0,oneSpouse),
	defprimconcept(some(inverse(spouse),set([g0])),set([m1,g1,g2])),
	assert_ind(g1,oneSpouse),
	defprimconcept(some(inverse(spouse),set([g1])),set([m1,g0,g2])),
	assert_ind(g2,oneSpouse),
	defprimconcept(some(inverse(spouse),set([g2])),set([m1,g0,g1])),
	defconcept(zeroSH,and([atleast(0,sh),atmost(0,sh)])),
	defconcept(oneSH,and([atleast(1,sh),atmost(1,sh)])),
	defconcept(twoSH,and([atleast(2,sh),atmost(2,sh)])),
	assert_ind(g0,zeroSH),
	assert_ind(g1,oneSH),
	assert_ind(g2,twoSH),
	defprimconcept(and([some(inverse(sh),set([m1])),set([m1])]),bot),
	defprimconcept(and([some(inverse(sh),set([g0])),set([g0])]),bot),
	defprimconcept(and([some(inverse(sh),set([g1])),set([g1])]),bot),
	defprimconcept(and([some(inverse(sh),set([g2])),set([g2])]),bot),
	defprimconcept(and([some(inverse(spouse),set([m1])),some(inverse(sh),set([m1]))]),bot),
	defprimconcept(and([some(inverse(spouse),set([g0])),some(inverse(sh),set([g0]))]),bot),
	defprimconcept(and([some(inverse(spouse),set([g1])),some(inverse(sh),set([g1]))]),bot),
	defprimconcept(and([some(inverse(spouse),set([g2])),some(inverse(sh),set([g2]))]),bot),
%	defconcept(some(sh,set([m1])),some(inverse(sh),set([m1]))),
%	defconcept(some(sh,set([g0])),some(inverse(sh),set([g0]))),
%	defconcept(some(sh,set([g1])),some(inverse(sh),set([g1]))),
%	defconcept(some(sh,set([g2])),some(inverse(sh),set([g2]))).
	defrole(sh,inverse(sh)),
	defrole(spouse,inverse(spouse)).
%%% Example 49
% motel_ask(elementOf(p,c4))
% should fail
example(49) :-
	makeEnvironment('ex49','defaults'),
	initEnvironment,
	defconcept(c4,and([c5,c6])),
	defprimconcept(and([c0,naf(not(c2))]),c5),
	defprimconcept(and([c0,naf(not(c3))]),c6),
	defconcept(c1,or([not(c2),not(c3)])),
	assert_ind(p,c0),
	assert_ind(p,c1).
example(50) :-
	makeEnvironment('ex50','complete_or'),
	initEnvironment,
	defprimconcept(c1,c0),
	defprimconcept(not(c1),c0).
example(51) :-
	makeEnvironment('ex51','functional_dependencies'),
	initEnvironment,
	def(posInfl(f,d)),
	def(posInfl(h,f)),
	def(posInfl(a,b)),
	def(posInfl(b,c)),
	def(posInfl(c,d)),
	def(negInfl(b,e)),
	def(negInfl(e,d)),
	def(posInfl(g,e)),
	def(posInfl(a,g)),
	def(increase(a)).
example(52) :-
	makeEnvironment('ex52','functional_dependencies'),
	initEnvironment,
	def(increase(hasCubicCapacity)),
	def(negInfl(withRebate,hasPrice)),
	def(posInfl(hasPrice,hasOverallCost)),
	def(posInfl(hasCubicCapacity,hasListPrice)),
	def(posInfl(hasListPrice,hasPrice)),
	def(posInfl(hasCubicCapacity,hasFuelConsumption)),
	def(posInfl(hasFuelConsumption,hasOverallCost)),
	def(posInfl(hasCubicCapacity,hasMaxSpeed)),
	def(negInfl(hasCatConverter,hasMaxSpeed)),
	def(posInfl(hasCatConverter,hasFuelConsumption)),
	def(posInfl(hasCubicCapacity,hasWeight)),
	def(negInfl(hasWeight,hasMaxSpeed)).
example(53) :-
	makeEnvironment('ex53','functional_dependencies'),
	initEnvironment,
	def(increase(hasCubicCapacity)),
	def(infl(withRebate,hasPrice,-1.0)),
	def(infl(hasPrice,hasOverallCost,1.0)),
	def(infl(hasCubicCapacity,hasListPrice,1.2)),
	def(infl(hasListPrice,hasPrice,1.0)),
	def(infl(hasCubicCapacity,hasFuelConsumption,0.8)),
	def(infl(hasFuelConsumption,hasOverallCost,1.0)),
	def(infl(hasCubicCapacity,hasHorsePower,1.0)),
	def(infl(hasHorsePower,hasFuelConsumption,1.0)),
	def(infl(hasHorsePower,hasMaxSpeed,1.0)),
	def(infl(hasFuelType,hasMaxSpeed,0.8)),
	def(infl(hasCatConverter,hasHorsePower,-0.5)),
	def(infl(hasCubicCapacity,hasWeight,0.5)),
	def(infl(hasWeight,hasHorsePower,-1.0)).
example(54) :-
	makeEnvironment('ex54','functional_dependencies'),
	initEnvironment,
	def(negInfl(a,b)),
	def(posInfl(b,e)),
	def(posInfl(e,d)),
	def(negInfl(g,e)),
	def(negInfl(a,g)).
%
%	Apart from the notation identical to ex54.
%
example(55) :-
	makeEnvironment('ex55','functional_dependencies'),
	initEnvironment,
	def(infl(a,b,1.0)),
	def(infl(b,e,1.0)),
	def(infl(e,d,1.0)),
	def(infl(g,e,1.0)),
	def(infl(a,g,-1.0)).
example(56) :-
	makeEnvironment('ex56','functional_dependencies'),
	initEnvironment,
	def(infl(a,b,1.0)),
	def(infl(b,e,1.0)),
	def(infl(e,d,1.0)),
	def(infl(g,e,1.0)),
	def(infl(a,g,-1.0)),
	def(infl(f,g,0.5)),
	def(infl(f,h,-0.5)),
	def(infl(h,d,0.3)).
example(57) :-
	makeEnvironment('ex57','functional_dependencies'),
	initEnvironment,
	def(posInfl(a,b)),
	def(posInfl(b,c)),
	def(posInfl(c,d)).
example(58) :- 
	makeEnvironment('ex58','functional_dependencies'),
	initEnvironment,
	def(posInfl(a,b)),
	def(posInfl(b,c)),
	def(posInfl(c,d)),
	def(infl(e,b,-1.0)),
	def(infl(e,c,0.5)).
example(59) :-
	sb_defenv('mybox','sb.lit'),
	sb_initenv,
	sb_primconcept(person),
	sb_primconcept(woman,[supers([person])]),
	sb_primconcept(man,[supers([person])]),
	sb_disjoint(man,woman),
	sb_primelemrole(child,'domain-range'(parent,person,person)),
	sb_defconcept(parent,[supers([person]),
                              nr(child,1,30,2)]),
	sb_defconcept(mother,[supers([parent,woman])]),
	sb_defconcept(father,[supers([parent,man])]),
	sb_defconcept(granni,[supers([grandparent,mother])]),
	sb_defelem(harry,[isa(parent)]),
	sb_defelem(mary,[isa(mother), 
                         irole(child, 
                               iname('marys-child'),
                               [nr(1,30,2), vr(harry)])]).
example(60) :-
	makeEnvironment('ex60','Modal operators'),
	initEnvironment,	
	modalAxioms(kd45,believe,peter),
	defprimconcept([b(believe,peter)],doctor,richPerson),
	assert_ind([b(believe,peter)],tom,doctor).
%%% Example 61
% deduce(elementOf(tweety,fly))
% deduce(elementOf(tweety,nest))
% deduce(elementOf(tweety,not(emu)))
% deduce(elementOf(tweety,not(cuckoo)))
% succeed
example(61) :-
	makeEnvironment('ex61','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(and([bird,naf(not(fly))]), fly),
	defprimconcept(and([bird,naf(not(nest))]), nest),
	defprimconcept(emu,not(fly)),
	defprimconcept(cuckoo,not(nest)),
	assert_ind(tweety,bird).
%%% Example 62
% deduce(elementOf(tweety,bird))
% deduce(elementOf(tweety,fly))
% deduce(elementOf(tweety,nest))
% consistent([])
% succeed
% deduce(elementOf(tweety,not(emu)))
% deduce(elementOf(tweety,emu))
% deduce(elementOf(tweety,not(cuckoo)))
% deduce(elementOf(tweety,cuckoo))
% deduce(elementOf(tweety,not(bird)))
% fail
example(62) :-
	makeEnvironment('ex62','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(and([bird,naf(not(fly))]), fly),
	defprimconcept(and([bird,naf(not(nest))]), nest),
	defprimconcept(emu,not(fly)),
	defprimconcept(cuckoo,not(nest)),
	defconcept(bird,or([emu,cuckoo])),
	assert_ind(tweety,bird).
%%% Example 63
% deduce(elementOf(tweety,bird))
% deduce(elementOf(tweety,fly))
% deduce(elementOf(tweety,nest))
% deduce(elementOf(tweety,sparrow))
% deduce(elementOf(tweety,not(emu)))
% deduce(elementOf(tweety,not(cuckoo)))
% consistent([])
% succeed
example(63) :-
	makeEnvironment('ex63','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(and([bird,naf(not(fly))]), fly),
	defprimconcept(and([bird,naf(not(nest))]), nest),
	defprimconcept(emu,not(fly)),
	defprimconcept(cuckoo,not(nest)),
	defconcept(bird,or([sparrow,emu,cuckoo])),
	assert_ind(tweety,bird).
%%% Example 64
% deduce(elementOf(peter,leftHandUsable))
% deduce(elementOf(peter,rightHandUsable))
% deduce(elementOf(peter,oneHandUsable))
% succeed
% deduce(elementOf(peter,bothHandsUsable))
% deduce(elementOf(peter,not(bothHandsUsable))
% fail
example(64) :-
	makeEnvironment('ex64','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(naf(leftHandBroken),leftHandUsable),
	defprimconcept(naf(rightHandBroken),rightHandUsable),
	defconcept(oneHandBroken,or([leftHandBroken,rightHandBroken])),
	defconcept(oneHandUsable,or([leftHandUsable,rightHandUsable])),
	defconcept(bothHandsUsable,and([leftHandUsable,rightHandUsable])),
	assert_ind(peter,oneHandBroken).
%%% Example 65
% deduce(elementOf(peter,leftHandUsable))
% can prove leftHandUsable by default because
% cannot prove leftHandBroken because
% can prove oneHandBroken but
% cannot prove not(rightHandBroken) because
% cannot prove rightHandUsable because
% can prove rightHandBroken because
% can prove oneHandBroken and
% can prove not(leftHandBroken) because
% can prove leftHandUsable by default because
% cannot prove leftHandBroken because the loop check prevents
%                                     the application of any axiom
% deduce(elementOf(peter,rightHandUsable))
% deduce(elementOf(peter,not(bothHandsUsable))
% succeed
% deduce(elementOf(peter,bothHandsUsable))
% deduce(elementOf(peter,oneHandUsable))
% cannot prove oneHandUsable becauce
% (cannot prove leftHandUsable because
%  can prove leftHandBroken because
%  oneHandBroken is a fact and
%  (can prove not(rightHandBroken) because
%   can prove rightHandUsable by default because
%   cannot prove rightHandBroken because
%   can prove oneHandBroken but 
%   cannot prove not(leftHandBroken) because
%   cannot prove leftHandUsable because the loop check prevents
%                                       the application of any axiom))
% and it is also not possible possible to prove rightHandUsable
% for similar reasons
% deduce(elementOf(peter,not(oneHandUsable)))
% fail
example(65) :-
	makeEnvironment('ex65','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(naf(leftHandBroken),leftHandUsable),
	defprimconcept(naf(rightHandBroken),rightHandUsable),
	defconcept(oneHandBroken,or([leftHandBroken,rightHandBroken])),
	defconcept(oneHandUsable,or([leftHandUsable,rightHandUsable])),
	defconcept(bothHandsUsable,and([leftHandUsable,rightHandUsable])),
	defprimconcept(leftHandBroken,not(leftHandUsable)),
	defprimconcept(rightHandBroken,not(rightHandUsable)),
	assert_ind(peter,oneHandBroken).
%%% Example 66
% deduce(elementOf(peter,leftHandUsable))
% deduce(elementOf(peter,rightHandUsable))
% deduce(elementOf(peter,oneHandUsable))
% deduce(elementOf(peter,not(bothHandsUsable))
% succeed
% deduce(elementOf(peter,bothHandsUsable))
% deduce(elementOf(peter,not(oneHandUsable)))
% fail
example(66) :-
	makeEnvironment('ex66','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(naf(leftHandBroken),leftHandUsable),
	defprimconcept(naf(rightHandBroken),rightHandUsable),
	defconcept(oneHandBroken,or([leftHandBroken,rightHandBroken])),
	defconcept(oneHandUsable,or([naf(not(leftHandUsable)),naf(not(rightHandUsable))])),
	defconcept(bothHandsUsable,and([leftHandUsable,rightHandUsable])),
	defprimconcept(leftHandBroken,not(leftHandUsable)),
	defprimconcept(rightHandBroken,not(rightHandUsable)),
	assert_ind(peter,oneHandBroken).
%%% Example 67
example(67) :-
	makeEnvironment('ex67','Defaults and the lottery paradox'),
        initEnvironment,        
        defprimconcept(naf(leftHandBroken),leftHandUsable),
        defprimconcept(naf(rightHandBroken),rightHandUsable),
        defprimconcept(leftHandBroken,not(leftHandUsable)),
        defprimconcept(rightHandBroken,not(rightHandUsable)),
        defconcept(oneHandUsable,or([leftHandUsable,rightHandUsable])),
        defconcept(oneHandBroken,or([leftHandBroken,rightHandBroken])),
        defconcept(bothHandsBroken,and([leftHandBroken,rightHandBroken])),
        assert_ind(peter,oneHandBroken),
        assert_ind(peter,not(bothHandsBroken)).
example(68) :-
	makeEnvironment('ex68','Defaults and the lottery paradox'),
        initEnvironment,        
        defprimconcept(naf(bot),leftHandUsable),
        defprimconcept(naf(bot),rightHandUsable),
        defprimconcept(leftHandBroken,not(leftHandUsable)),
        defprimconcept(rightHandBroken,not(rightHandUsable)),
        defconcept(oneHandUsable,or([leftHandUsable,rightHandUsable])),
        defconcept(oneHandBroken,or([leftHandBroken,rightHandBroken])),
        defconcept(bothHandsBroken,and([leftHandBroken,rightHandBroken])),
        assert_ind(peter,oneHandBroken),
        assert_ind(peter,not(bothHandsBroken)).
%%% Example 69
% deduce(elementOf(tweety,bird))
% succeeds
% deduce(elementOf(tweety,not(bird)))
% deduce(elementOf(tweety,fly))
% deduce(elementOf(tweety,not(fly)))
% deduce(elementOf(tweety,nest))
% deduce(elementOf(tweety,not(nest)))
% fail
example(69) :-
	makeEnvironment('ex69','Defaults and the lottery paradox'),
	initEnvironment,	
	defprimconcept(and([bird,naf(exception),naf(not(fly))]), fly),
	defprimconcept(and([bird,naf(exception),naf(not(nest))]), nest),
	defprimconcept(emu,exception),
	defprimconcept(cuckoo,exception),
	defconcept(bird,or([emu,cuckoo])),
	assert_ind(tweety,bird).
%%% Example 70
% deduce(elementOf(a,clearTop))
% deduce(elementOf(a,not(clearTop)))
% fail
% deduce(elementOf(b,clearTop))
% deduce(elementOf(b,clearTop))
% succeed
example(70) :-
	makeEnvironment('ex70','Defaults and existential quantification'),
	initEnvironment,
	defconcept(blocked,some(on,top)),
	defprimconcept(and([block,naf(blocked)]),clearTop),
	assert_ind(a,block),
	assert_ind(b,block),
	assert_ind(c,block),
	assert_ind(a,b,on).
example(71) :-
	makeEnvironment('ex71','PRACMA'),
	initEnvironment,
	defprimconcept(sporttyp),
	defprimconcept(envtyp),
	sb_primconcept([b(believe,pk)],carwish,[supers([car])]),
	sb_primelemrole([bc(want,sporttyp)],has_tyre,'domain-range'(carwish,broad_tyre,broad_tyre)),
	sb_primelemrole([bc(believe,sporttyp)],speed,'domain-range'('2cv',low,low)),
	sb_primelemrole([bc(want,envtyp)],has_part,'domain-range'(carwish,cat_conv,cat_conv)),
	sb_primelemrole([bc(believe,envtyp)],speed,'domain-range'('2cv',fast,fast)),
%	modalAxioms(kd45,believe,pk),	
%	modalAxioms(kd45,want,pk),	
	modalAxioms(kd45,believe,concept(sporttyp)),
	modalAxioms(kd45,want,concept(sporttyp)),
	modalAxioms(kd45,believe,concept(envtyp)),
	modalAxioms(kd45,want,concept(envtyp)).
example(72) :-
	makeEnvironment('ex72','DEMO'),
	initEnvironment,
	defprimconcept(sporttyp),
	defprimconcept(umwelttyp),
	modalAxioms([b(believe,pv)],k,want,concept(sporttyp)),
	modalAxioms([b(believe,pv)],k,want,concept(umwelttyp)),
	modalAxioms(kd45,believe,all),
	sb_primconcept([b(believe,all)], vw, [supers([auto])]),
	sb_primconcept([b(believe,all)], opel, [supers([auto])]),
	assert_ind([b(believe,all)],polo,vw),
	assert_ind([b(believe,all)],manta,opel),
	sb_defconcept([b(believe,pv),bc(want,sporttyp)],wunsch_auto,[supers([auto,hatSpoiler])]),
	% Anmerkung:
        % In MOTEL ist es m"oglich, mehrere sich erg"anzende Definitionen 
        % f"ur ein Konzept (hier z.B. vw) zu haben. Damit ein Konzept im
        % Verlauf des Dialogs st"andig zu verfeinern. 
	sb_primconcept([b(believe,pv),bc(believe,sporttyp)],vw,[supers([langsam])]),
	defprimconcept([b(believe,pv),bc(believe,sporttyp)],and([auto,hatKat,naf(not(langsam))]),langsam),
	sb_defconcept([b(believe,pv),bc(want,umwelttyp)],wunsch_auto,[supers([auto,hatKat])]),
	sb_primconcept([b(believe,pv),bc(believe,umwelttyp)],vw,[supers([not(langsam)])]),
	assert_ind([b(believe,pv)],pk,sporttyp),
        % Anmerkung:
	% Bei der folgenden Definition reicht es nicht zu sagen, da\3
        % polo ein Auto ist oder das alle glauben, da\3 polo ein Auto ist,
        % da man durchaus Sachen im want haben kann, die der Realit"at 
        % widersprechen. Deshalb mu\3 pk wollen, da\3 polo ein auto ist.
	assert_ind([b(believe,pv),b(want,pk)],polo,auto).
        % Demo:
        %
        % setof(C,motel_ask([b(believe,pk)],elementOf(polo,C)),L).
        % L = [auto,langsam,top,vw,not(bot)]
        % Zun"achst erbt hier der pk vom b(believe,all), den Glauben, da\3
        % polo ein vw und damit ein auto ist. Vom b(believe,sporttyp) erbt 
        % er, da\3 vw's langsam sind, womit auch der polo langsam ist.
        % 
        % setof(C,motel_ask([b(believe,pk)],elementOf(manta,C)),L)
        % L = [auto,opel,top,not(bot)]
        % Da es sich bei dem manta um einen opel handelt, wird zun"achst
        % nicht angenommen, da\3 der manta langsam ist.
        %
        % assert_ind([b(believe,pv),b(believe,pk)],manta,hatKat)
        % Hiermit haben wir festgelegt, da\3 der pk glaubt, da\3 der manta
        % einen Katalysator hat. Nun erbt der pk vom sporttyp aber auch
        % die Regel, da\3 Autos mit Katalysatoren normalerweise langsam sind.
        % Dies f"uhrt bei der Wiederholung der letzten Anfrage zu folgendem
        % Ergebnis:
        %
        % setof(C,motel_ask([b(believe,pk)],elementOf(manta,C)),L)
        % L = [auto,hatKat,langsam,opel,top,not(bot)]
        %
        % Wir k"onnen neben der Deduktion auf Abduktion verwenden:
        %
        % abduce([b(want,pk)],H,elementOf(polo,wunsch_auto),E).
        % E = proved(in(app(_A:m(want,pk),[]),wunsch_auto,polo),
        %     basedOn(and([proved(in(app(_A:m(want,pk),[]),auto,polo),
        %     basedOn(abox)),
        %     proved(in(app(_A:m(want,pk),[]),hatSpoiler,polo),
        %     basedOn(usingAbHyp(in(app(_A:m(want,pk),[]),hatSpoiler,polo))))]))),
        % H = [in(app(_B:m(want,pk),[]),hatSpoiler,polo)]          
        % D.h. pk will den polo als Wunschauto, wenn der polo einen Spoiler hat.
        %
        % Nun erhalten wir von PRACMA die Anweisungen zu einem 
        % Stereotypwechsel:
        %
        % delete_ind(pk,sporttyp)
        % assert_ind(pk,umwelttyp)
        %
        % Dadurch "andern sich die Anfrageergebnisse wie folgt:
        %
        % setof(C,motel_ask([b(believe,pk)],elementOf(polo,C)),L).
        % L = [auto,top,vw,not(bot),not(langsam)]
        %
        % Der polo geh"ort nun zu den nicht langsamen Autos, da umwelttypen
        % genau dies glauben.
        % 
        % setof(C,motel_ask([b(believe,pk)],elementOf(manta,C)),L).
        % L = [auto,hatKat,opel,top,not(bot)]
        % 
        % Der Manta hat zwar immernoch einen Katalysator, ist aber trotzdem
        % nicht langsam, da umwelttypen nicht glauben, da\3 Katalysatoren ein
        % Auto langsam machen.
        %
        % Wir k"onnen auch in diesem Fall fragen, unter welchen Umst"anden
        % pk den polo f"ur sein Wunschauto halten w"urde:
        %
        % abduce([b(want,pk)],H,elementOf(polo,wunsch_auto),E).
        % E = proved(in(app(_A:m(want,pk),[]),wunsch_auto,polo),
        %     basedOn(and([proved(in(app(_A:m(want,pk),[]),auto,polo),
        %     basedOn(abox)),
        %     proved(in(app(_A:m(want,pk),[]),hatKat,polo),
        %     basedOn(usingAbHyp(in(app(_A:m(want,pk),[]),hatKat,polo))))]))),
        % H = [in(app(_B:m(want,pk),[]),hatKat,polo)]
        %
        % Wie erwartet, soll das Wunschauto von pk nun einen Katalysator haben.
example(73) :-
	assert_ind([b(believe,all)],polo,vw),
	defprimconcept([b(believe,pv),bc(believe,sporttyp)],vw,langsam),
	assert_ind([b(believe,pv)],pk,sporttyp),
	modalAxioms(kd45,believe,pv),
	modalAxioms([b(believe,pv)],kd45,believe,concept(sporttyp)).
example(74) :-
	makeEnvironment('ex74','DEMO'),
	initEnvironment,
	defprimconcept(sporttyp),
	defprimconcept(umwelttyp),
	modalAxioms([b(glaubt,pv)],k,will,concept(sporttyp)),
	modalAxioms([b(glaubt,pv)],k,will,concept(umwelttyp)),
	modalAxioms(kd45,glaubt,all),
	sb_primconcept([b(glaubt,all)], vw, [supers([auto])]),
	sb_primconcept([b(glaubt,all)], opel, [supers([auto])]),
	assert_ind([b(glaubt,all)],polo,vw),
	assert_ind([b(glaubt,all)],manta,opel),
	defprimconcept([b(glaubt,pv),bc(will,sporttyp)],and([auto,or([hatSpoiler,hatSchiebedach])]),wunschAuto),
	defprimconcept([b(glaubt,pv),bc(glaubt,sporttyp)],vw,langsam),
	defprimconcept([b(glaubt,pv),bc(glaubt,sporttyp)],and([auto,hatKat,naf(not(langsam))]),langsam),
	defconcept([b(glaubt,pv),bc(will,umwelttyp)],wunschAuto,and([auto,hatKat])),
	defprimconcept([b(glaubt,pv),bc(glaubt,umwelttyp)],vw,not(langsam)),
	assert_ind([b(glaubt,pv)],pk,sporttyp),
	assert_ind([b(glaubt,pv),b(will,pk)],polo,auto).
example(75) :-
	makeEnvironment('ex75','DEMO'),
	initEnvironment,
	defprimconcept(racer),
	defprimconcept(creeper),
	modalAxioms([b(believe,ps)],k,want,concept(racer)),
	modalAxioms([b(believe,ps)],k,want,concept(creeper)),
	modalAxioms(kd45,believe,all),
	defprimconcept([b(believe,all)], vw, car),
	defprimconcept([b(believe,all)], bmw, car),
	assert_ind([b(believe,all)],beetle,vw),
	assert_ind([b(believe,all)],'bmw735',bmw),
	defprimconcept([b(believe,ps),bc(want,racer)],and([car,or([has_spoiler,has_sliding_roof])]),dream_car),
	defprimconcept([b(believe,ps),bc(believe,racer)],vw,slow),
	defprimconcept([b(believe,ps),bc(believe,racer)],and([car,has_cat_conv,naf(not(slow))]),slow),
	defconcept([b(believe,ps),bc(want,creeper)],dream_car,and([car,has_cat_conv])),
	defprimconcept([b(believe,ps),bc(believe,creeper)],vw,not(slow)),
	assert_ind([b(believe,ps)],pc,racer),
	assert_ind([b(believe,ps),b(want,pc)],beetle,car).
example(76) :-
	makeEnvironment('ex76','SETHEO'),
	initEnvironment,
	defprimconcept(racer),
	defprimconcept(creeper),
	modalAxioms([b(believe,ps)],k,want,concept(racer)),
	modalAxioms([b(believe,ps)],k,want,concept(creeper)),
	modalAxioms(kd45,believe,all),
	defprimconcept([b(believe,all)], vw, car),
	defprimconcept([b(believe,all)], bmw, car),
	assert_ind([b(believe,all)],beetle,vw),
	assert_ind([b(believe,all)],'bmw735',bmw),
	defprimconcept([b(believe,ps),bc(want,racer)],and([car,or([has_spoiler,has_sliding_roof])]),dream_car),
	defprimconcept([b(believe,ps),bc(believe,racer)],vw,slow),
	defconcept([b(believe,ps),bc(want,creeper)],dream_car,and([car,has_cat_conv])),
	defprimconcept([b(believe,ps),bc(believe,creeper)],vw,not(slow)),
	assert_ind([b(believe,ps)],pc,racer),
	assert_ind([b(believe,ps),b(want,pc)],beetle,car).
%%% Example 77
% the results for 
% deduce(elementOf(mary,grandparent),E)
% should be a subsetSpecial of the results for
% abduce(H,elementOf(mary,grandparent),E).
example(77) :-
	makeEnvironment('ex77','smallKRISExample'),
	initEnvironment,
	defconcept(parent,and([person,some(child,person)])),
	defconcept(father,and([parent,not(mother)])),
	defconcept(grandparent,and([parent,some(child,parent)])),
	assert_ind(tom,father),
	assert_ind(mary,parent),
	assert_ind(mary,tom,child).
example(78) :-
	makeEnvironment('beispiel8.0','Original von Baldes'),
	initEnvironment,
	defprimconcept([],ps_ueber100,top),
	defprimconcept([],altesBaujahr,top),
	defprimconcept([],porsche,top),
	defprimconcept([],ford,top),
	defprimconcept([],fiat,top),
	defprimconcept([],porsche,leistungsstarkesAuto),
	defprimconcept([],leistungsstarkesAuto,verbrauchtvielBenzin),
	defprimconcept([],altesModell,verbrauchtvielBenzin),
	defprimconcept([],schlechteReifen,verbrauchtvielBenzin),
	defconcept([],leistungsstarkerMotor,ps_ueber100),
	defconcept([],leistungsstarkesAuto,leistungsstarkerMotor),
	assert_ind([],auto5,porsche),
	assert_ind([],auto3,schlechteReifen),
	assert_ind([],auto3,altesModell),
	assert_ind([],auto3,fiat),
	assert_ind([],auto2,ps_ueber100),
	assert_ind([],auto2,ford),
	assert_ind([],auto1,ps_ueber100),
	assert_ind([],auto1,porsche).
example(79) :-
	makeEnvironment('beispiel8.1','Minimalbeispiel'),
	initEnvironment,
	assert_ind([],auto3,schlechteReifen),
	assert_ind([],auto3,altesModell),
	defprimconcept([],altesModell,verbrauchtvielBenzin),
	defprimconcept([],schlechteReifen,verbrauchtvielBenzin).
example(80) :-
	sb_defenv('mybox','sb.lit'),
	sb_initenv,
	sb_primconcept(person),
	sb_primconcept(woman,[supers([person])]),
	sb_primconcept(man,[supers([person])]),
	sb_disjoint(man,woman),
	sb_primelemrole(child,'domain-range'(parent,person,person)),
	sb_defconcept(parent,[supers([person]),
                              nr(child,1,30,2)]),
	sb_defconcept(mother,[supers([parent,woman])]),
	sb_defconcept(father,[supers([parent,man])]),
	sb_defconcept(granni,[supers([grandparent,mother])]).
example(81) :-
	modalAxioms([b(believe,ps)],kd45,believe,pc),
	modalAxioms(kd45,believe,ps),
	assert_ind([b(believe,ps),b(believe,pc)],audi,car).
example(82) :-
	assert_ind(car1,and([car,
                     atleast(1,restr(hasPart,seat)),
                     all(restr(hasPart,seat),
                         some(hasAttribute,heatable))])).
example(83) :-
	makeEnvironment('ext0','modProv test 1'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defprimconcept(person,some(sex,or([male,female]))).
example(84) :-
	makeEnvironment('ext1','modProv test 2'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defprimconcept(person,some(sex,or([male,female]))),
	defconcept(parent,and([person,some(child,person)])).
example(85) :-
	makeEnvironment('ext1','modProv test 2'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defprimconcept(person,some(sex,or([male,female]))),
	defconcept(parent,and([person,some(child,person)])),
	defconcept(mother,and([parent,some(sex,female)])),
	defconcept(father,and([parent,not(mother)])).
example(86) :-
	makeEnvironment('ext2','modProv test 3'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defprimconcept(person,some(sex,or([male,female]))),
	defconcept(parent,and([person,some(child,person)])),
	defconcept(mother,and([parent,some(sex,female)])),
	defconcept(father,and([parent,not(mother)])),
	defconcept(grandparent,and([parent,some(child,parent)])),
	defconcept(parent_with_sons_only,and([parent,all(child,some(sex,male))])).
example(87) :-
	makeEnvironment('ext3','modProv test 4'),
	initEnvironment,
	defprimconcept(male),
	defprimconcept(female,not(male)),
	defconcept(males,some(sex,male)),
	defconcept(females,some(sex,female)),
	defprimconcept(person,some(sex,or([male,female]))),
	defconcept(parent,and([person,some(child,person)])),
	defconcept(mother,and([parent,some(sex,female)])),
	defconcept(father,and([parent,not(mother)])),
	defconcept(grandparent,and([parent,some(child,parent)])),
	defconcept(parent_with_sons_only,and([parent,all(child,some(sex,male))])),
	assert_ind(tom,father),
	assert_ind(tom,peter,child),
	assert_ind(tom,harry,child),
	assert_ind(mary,parent_with_sons_only),
	assert_ind(mary,tom,child),
	assert_ind(mary,chris,child).
example(88) :-
	makeEnvironment('person','person.tbox from KRIS'),
	initEnvironment,
	defprimconcept(female,not(male)),
	defconcept(man,and([human,male])),
	defconcept(woman,and([human,female])),
	defconcept(mother,and([woman,some(child,human)])),
	defconcept(father,and([man,some(hild,human)])),
	defconcept(parent,or([mother,father])),
	defconcept(grandparent,and([parent,some(child,parent)])),
	defconcept(father_with_sons_only,and([father,all(child,male)])).
example(89) :-
	makeEnvironment('fss','Knowledge base FSS'),
	initEnvironment,
	defprimconcept(sbone),
	defprimconcept(lexicon,sbone),
	defprimconcept(fss,sbone),
	defprimconcept(pointing,fss),
	defprimconcept(vague_p,pointing),
	defprimconcept(standard_p,pointing),
	defprimconcept(encircling_p,pointing),
	defprimconcept(exact_p,pointing),
	defprimconcept(time,fss),
	defprimconcept(moment,time),
	defprimconcept(period,time),
	defprimconcept(interval,time),
	defprimconcept(yearly,interval),
	defprimconcept(jaehrlich,and([yearly, lexicon])),
	defprimconcept(weekly,interval),
	defprimconcept(woechentlich,and([lexicon, weekly])),
	defprimconcept(daily,interval),
	defconcept(taeglich,and([daily,lexicon])),
	defprimconcept(monthly,interval),
	defconcept(monat,and([monthly, lexicon])),
	defprimconcept(speech_act, fss),
	defprimconcept(order,speech_act),
	defprimconcept(assertion,speech_act),
	defprimconcept(question,speech_act),
	defprimconcept(interjection,speech_act),
	defprimconcept(determiner,fss),
	defconcept(d,and([determiner, lexicon])),
	defprimconcept(indefinite,determiner),
	defconcept(ein,and([indefinite,lexicon])),
	defprimconcept(cardinal,indefinite),
	defconcept(number35,and([cardinal, lexicon])),
	defprimconcept(number50,and([cardinal,lexicon])),
	defconcept(fuenfunddreissig,and([cardinal, lexicon])),
	defprimconcept(interrogative,determiner),
	defprimconcept(definite,determiner),
	defprimconcept(demonstrative,definite),
	defconcept(der,and([definite, lexicon])),
	defconcept(die,and([definite, lexicon])),
	defprimconcept(possessive,definite),
	defconcept(dem,and([lexicon, definite])),
	defconcept(mein,and([lexicon, determiner])),
	defprimconcept(property_filler, fss),
	defprimconcept(adjective_property,property_filler),
	defprimconcept(truth_value,adjective_property),
	defprimrole(truth_mod),
	defconcept(abstract_thing,and([thing,some(truth_mod,top),some(truth_mod,top)])),
	defprimconcept(atom_codes,abstract_thing),
	defconcept(thing,and([property_filler,
	some(det,determiner),
	some(deitic_mpd,pointing),
	some(named,atom_codes)])),
	defconcept(predicate,and([fss,
	some(subject,thing),
	some(purpose,predicate),
	some(time,time),
	some(illoc,speech_act),
	some(cause,predicate),
	some(result,thing),
	some(location,thing)])),
	defprimconcept(state,and([predicate,some(time,period)])),
	defconcept(human,and([animate,some(volition,volitional_sq)])),
	defconcept(geographical_object,and([inanimate,some(origin_mod,origin)])),
	defprimconcept(wohn,and([lexicon, state,
	some(agent,human),
	some(location_wohn,location)])),
	defprimconcept(qualitative,adjective_property),
	defprimconcept(quality,qualitative),
	defprimconcept(colour, quality),
	defconcept(concrete_thing,and([thing,some(colour_mod,colour)])),
	defprimconcept(relation,adjective_property),
	defconcept(individual,and([concrete_thing,some(relative_mod,relation)])),
	defconcept(mass_noun,concrete_thing),
	defprimconcept(material,mass_noun),
	defconcept(inanimate,and([individual,some(material_mod,material)])),
	defprimconcept(weight,quality),
	defconcept(motion,and([action,some(destination,geographical_object),
	some(source,geographical_object)])),
	defconcept(motion_by_means,and([motion,some(means,touchable_object)])),
	defconcept(fahr,and([lexicon, motion_by_means])),
	defconcept(geh,and([lexicon, motion])),
	defconcept(treff,and([lexicon, action])),
	defconcept(werf,and([lexicon, action, some(concerned,top)])),
	defconcept(causative,action),
	defconcept(productive,and([causative,some(result,thing)])),
	defconcept(write,and([productive,some(concerned,thing)])),
	defprimconcept(canvas,touchable_object),
	defconcept(enter,and([write,some(location_enter,canvas)])),
	defconcept(arbeit,and([lexicon, action])),
	defprimconcept(repeat,action),
	defprimconcept(wiederhol,and([repeat, lexicon])),
	defconcept(transaction,and([action,some(beneficative,human)])),
	defconcept(schenk,and([lexicon,transaction,some(concerned,thing)])),
	defprimconcept(zahl,and([lexicon, transaction])),
	defconcept(kauf,and([lexicon,transaction,some(concerned,thing)])),
	defprimconcept(reason,action),
	defprimconcept(verursach,and([lexicon, reason])),
	defconcept(unterricht,and([predicate, lexicon])),
	defprimconcept(property,predicate),
	defconcept(value_property,and([property,some(measure,abstract_thing)])),
	defconcept(kost,and([cost, lexicon])),
	defprimconcept(deducte,property),
	defprimconcept(absetzbar,and([deducte, lexicon])),
	defprimconcept(sein,and([lexicon, property])),
	defprimconcept(besitzen,and([lexicon, property])),
	defprimconcept(haben,and([lexicon, property,
	some(has_property_haben,thing)])),
	defprimconcept(origin,adjective_property),
	defprimconcept(state_q,qualitative),
	defprimconcept(volitional_sq,state_q),
	defprimconcept(physical_sq,state_q),
	defprimconcept(klein,and([lexicon, physical_sq])),
	defprimconcept(gross,and([lexicon, physical_sq])),
	defprimconcept(rot,and([colour, lexicon])),
	defprimconcept(worth,quality),
	defprimconcept(voelklingen_name),
	defprimconcept(gi,and([abstract_thing, lexicon])),
	defconcept(indication_of_quantity,
	and([abstract_thing,
	some(quantity,cardinal)])),
	defconcept(dm,and([indication_of_quantity, lexicon])),
	defprimconcept(schreiner,and([profession, lexicon])),
	defprimconcept(informatiker,and([profession, lexicon])),
	defprimconcept(action_content,and([abstract_thing, action])),
	defprimconcept(motion_content,and([action_content, motion])),
	defprimconcept(motion_by_means_content,and([motion_by_means, action_content])),
	defprimconcept(cost,abstract_thing),
	defprimconcept(kosten,and([lexicon, cost])),
	defprimconcept(geld,and([lexicon, cost])),
	defprimconcept(profession,abstract_thing),
	defprimconcept(tax_action,abstract_thing),
	defprimconcept(steuerhandlung,and([lexicon, tax_action])),
	defprimconcept(number,abstract_thing),
	defconcept(fahrt,and([thing, lexicon])),
	defconcept(das,and([thing, lexicon])),
	defconcept(animate,and([individual,some(physis_mod,physical_sq)])),
	defprimconcept(frau,and([human, lexicon])),
	defconcept(mann,and([human, lexicon])),
	defconcept(junge,and([human, lexicon])),
	defprimconcept(sie,and([lexicon, human])),
	defprimconcept(person,and([lexicon, human])),
	defconcept(karl,and([lexicon, human])),
	defconcept(ich,and([lexicon, human])),
	defconcept(peter,and([lexicon, human])),
	defprimconcept(plant,animate),
	defconcept(animal,and([animate,some(volition,volitional_sq)])),
	defprimconcept(town,geographical_object),
	defconcept(voelklingen,and([town, lexicon])),
	defprimconcept(saarbruecken,and([town, lexicon])),
	defprimconcept(dudweiler,and([town, lexicon])),
	defprimconcept(saarlouis,and([lexicon, town])),
	defprimconcept(berlin,and([lexicon, town])),
	defprimconcept(wald,and([geographical_object, lexicon])),
	defprimconcept(hier,and([geographical_object, lexicon])),
	defprimconcept(ort,and([lexicon, geographical_object])),
	defprimconcept(information,inanimate),
	defprimconcept(string,information),
	defprimconcept(system,and([human, inanimate])),
	defconcept(vehicle,and([touchable_object,some(worth_mod,worth)])),
	defprimconcept(fahrrad,and([vehicle, lexicon])),
	defprimconcept(bus,and([vehicle, lexicon])),
	defprimconcept(motorrad,and([vehicle, lexicon])),
	defprimconcept(buch,and([lexicon, touchable_object])),
	defprimconcept(kochbuch,and([lexicon, touchable_object])),
	defprimconcept(result,touchable_object),
	defprimconcept(auktion,and([lexicon, thing])),
	defprimconcept(was,and([lexicon, thing])).
example(90) :-
	example(89),
	assert_ind(birthday,yearly),
	assert_ind(hello,speech_act),
	assert_ind(plane1,thing).
/**********************************************************************
 *
 * @(#) fdwAbduce.pl 1.1@(#)
 *
 */

aux_abduce(Env,World,[],change(Y,_),Ws) :-
	bagof(W,Z^changingInfl(Env,World,Z,Y,W),Ws),
	!.

aux_abduce(_,_,[],_,[]).

aux_abduce(Env,World,[change(X,Wx)|Hs],change(Y,_),[Wy|Ws]) :-
	infl(Env,World,X,Y,Wxy),
	not(given_change(Env,World,X,_)),
	weightOf_change(Wx,Wxy,Wy),
	aux_abduce(Env,World,Hs,change(Y,_),Ws).

aux2_abduce(_,_,_,[]).

aux2_abduce(EnvName,MS,change(X,Wx),[Change|Changes]) :-
	nonvar(Change),
	abduce(EnvName,MS,change(X,Wx),Change,[]),
	abduce(EnvName,MS,change(X,Wx),Changes,[]).

/***********************************************************************
 *
 * default_change(+-Change,+-WeightedChange)
 *
 *	Change is of the form 
 *		increase(+-X), noChange(+-X), decrease(+-X).
 *
 *	WeightedChange is of the form
 *		change(+-X,+-W)
 *	with W being the default weight associated with Change.
 */

default_change(increase(X),change(X,W)) :-
	nonvar(W),
	W > 0.0.

default_change(decrease(X),change(X,W)) :-
	nonvar(W),
	W < 0.0.

default_change(noChange(X),change(X,W)) :-
	nonvar(W),
	W = 0.0.

default_change(increase(X),change(X,1.0)).

default_change(decrease(X),change(X,-1.0)).

default_change(noChange(X),change(X,0.0)).

/***********************************************************************
 *
 * default_changes(+-Changes,+-WeightedChanges)
 *
 *	Changes is a list of
 *		increase(+-X), noChange(+-X), decrease(+-X)
 *	predicates.
 *
 *	WeightedChanges is a list of
 *		change(+-X,+-W)
 *	predicates where W being the default weight associated 
 *	with the appropriate Changes predicates.
 */

default_changes([],[]).

default_changes([Change|Changes],[WeightedChange|WeightedChanges]) :-
	default_change(Change,WeightedChange),
	default_changes(Changes,WeightedChanges).










/**********************************************************************
 *
 * @(#) fdwUserInterface.pl 1.1@(#)
 *
 */


/***********************************************************************
 *
 * initFuncdep
 *
 *	asserts default given_ clauses which prevent errors if the user
 *	has not (implicitly) defined any given_ clauses.
 */

initFuncdep :-
	assertzRE((given_inflLink(_,_,_,_) :- !, fail)),
	assertzRE((given_change(_,_,_,_) :- !, fail)).
	

/***********************************************************************
 *
 * initialize, initialise
 *
 *	Similar to initialize in
 *	~hustadt/pop/motel/motel-0.0.6/userInterface.pl
 */

% For those of us who prefer the alternative spelling
initialise :-
	initialize.

/***********************************************************************
 *
 * listFDW
 *
 *	lists the internal representation of the information defined by 
 *	the user.
 */

listFDW :-
	listing(given_inflLink),
	listing(given_change).

/***********************************************************************
 *
 * showFDW
 *
 *	displays the user defined information in the knowledge base.
 *	(Similar to showEnvironment.)
 */

showFDW :-
        getCurrentEnvironment(EnvName),
	environment(EnvName,Env,Comment),
        print('Functional Dependencies: '),
        print(EnvName),
        print(' ('),
        print(Comment),
        print(')'),
        nl,
	showFDW(Env).

showFDW(Env) :-
	showInfl(Env),
	showChange(Env).

showInfl(Env) :-
	given_inflLink(Env,World,app(_,W,X),Y),
	print(World),
	print('infl('),
	print(X), print(','), print(Y), print(','), print(W), print(').'),
	nl,
	fail.

showInfl(_).

showChange(Env) :-
	given_change(Env,World,X,W),
	print(World),
	print('change('),
	print(X), print(','), print(W), print(').'),
	nl,
	fail.

showChange(_).

showFD :-
        getCurrentEnvironment(EnvName),
	environment(EnvName,Env,Comment),
        print('Functional Dependencies: '),
        print(EnvName),
        print(' ('),
        print(Comment),
        print(')'),
        nl,
	showFD(Env).

showFD(Env) :-
	showPosInfl(Env),
	showNegInfl(Env),
	showNoInfl(Env),
	showIncrease(Env),
	showDecrease(Env),
	showNoChange(Env).

showPosInfl(Env) :-
	given_inflLink(Env,World,app(_,W,X),Y),
	W > 0.0,
	print(World),
	print('posInfl('),
	print(X), print(','), print(Y), print(').'),
	nl,
	fail.

showPosInfl(_).

showNegInfl(Env) :-
	given_inflLink(Env,World,app(_,W,X),Y),
	W < 0.0,
	print(World),
	print('negInfl('),
	print(X), print(','), print(Y), print(').'),
	nl,
	fail.

showNegInfl(_).

showNoInfl(Env) :-
	given_inflLink(Env,World,app(_,0.0,X),Y),
	print(World),
	print('noInfl('),
	print(X), print(','), print(Y), print(').'),
	nl,
	fail.

showNoInfl(_).

showIncrease(Env) :-
	given_change(Env,World,X,W),
	W > 0.0,
	print(World),
	print('increase('),
	print(X), print(').'),
	nl,
	fail.

showIncrease(_).

showDecrease(Env) :-
	given_change(Env,World,X,W),
	W < 0.0,
	print(World),
	print('decrease('),
	print(X), print(').'),
	nl,
	fail.

showDecrease(_).

showNoChange(Env) :-
	given_change(Env,World,X,0.0),
	print(World),
	print('noChange('),
	print(X), print(').'),
	nl,
	fail.

showNoChange(_).

/***********************************************************************
 *
 * def(+EnvName,+MS,:+Fact)
 *
 *	Fact is one of 
 *		infl(+X,+Y,+W),
 *		posInfl(+X,+Y), negInfl(+X,+Y), noInfl(+X,+Y),
 *		change(+X,+W),
 *		increase(+X), decrease(+X).
 *
 *	This predicate is used to update the knowledge base of
 *	information about the functional dependencies. The definition
 *	of multiple influences between attributes and multiple changes 
 *	on an attribute are prevented. 
 *
 *	Note that, X and Y denote roles/attributes (of cars) and W
 *	denotes the weight of X influencing Y or W denotes the weight
 *	of change of an attribute. 
 *
 *	posInfl is assigned the weight 1.0, negInfl the weight -1.0 and 
 *	noInfl the weight 0.0. The weights for increase, decrease and
 *	noChange are 1.0, -1.0 and 0.0, respectively.
 */

def(EnvName,MS,infl(X,Y,W)) :-
	get_Env_World(EnvName,MS,Env,World),
	atomic(X),
	assertNames(Env,World,X,role),
	atomic(Y),
	assertNames(Env,World,Y,role),
	wellDefined_InflWeight(W),
	not(given_inflLink(Env,World,app(_,_,X),Y)),
	gensym(sk,F),
	assertaRE(given_inflLink(Env,World,app(F,W,X),Y)).

def(EnvName,MS,change(X,W)) :-
	get_Env_World(EnvName,MS,Env,World),
	atomic(X),
	assertNames(Env,World,X,role),
	wellDefined_ChangeWeight(W),
	not(given_change(Env,World,X,_)),
	assertaRE(given_change(Env,World,X,W)).

def(EnvName,MS,posInfl(X,Y)) :-
	def(EnvName,MS,infl(X,Y,1.0)).

def(EnvName,MS,negInfl(X,Y)) :-
	def(EnvName,MS,infl(X,Y,-1.0)).

def(EnvName,MS,noInfl(X,Y)) :-
	def(EnvName,MS,infl(X,Y,0.0)).

def(EnvName,MS,increase(X)) :-
	def(EnvName,MS,change(X,1.0)).

def(EnvName,MS,decrease(X)) :-
	def(EnvName,MS,change(X,-1.0)).

def(EnvName,MS,noChange(X)) :-
	def(EnvName,MS,change(X,0.0)).

/***********************************************************************
 *
 * def(:+Fact)
 *
 *	calls def(+EnvName,+MS,:+Fact) with default environment EnvName 
 *	and empty modal sequence.
 */

def(Fact) :-
        getCurrentEnvironment(EnvName),
	def(EnvName,[],Fact).

/***********************************************************************
 *
 * def(+EnvName,:+Fact)
 *
 *	calls def(+EnvName,+MS,:+Fact) with default environment EnvName 
 *	and empty modal sequence.
 */

def(EnvName,Fact) :-
        environment(EnvName,_,_),
	def(EnvName,[],Fact).

/***********************************************************************
 *
 * def(+MS,:+Fact)
 *
 *	calls def(+EnvName,+MS,:+Fact) with default environment EnvName 
 *	and empty modal sequence.
 */

def(MS,Fact) :-
        nonvar(MS),
        (MS = [] ; MS = [_|_]),
        !,
        getCurrentEnvironment(EnvName),
	def(EnvName,[],Fact).

/***********************************************************************
 *
 * undef(+EnvName,+MS,:+-Fact)
 *
 *	retracts all facts matching Fact.
 */

undef(EnvName,MS,infl(X,Y,W)) :-
        environment(EnvName,Env,_),
	retract(given_inflLink(Env,MS,app(_,W,X),Y)),
	fail.
undef(EnvName,MS,change(X,W)) :-
        environment(EnvName,Env,_),
	retract(given_change(EnvName,MS,X,W)),
	fail.
undef(EnvName,MS,posInfl(X,Y)) :-
        environment(EnvName,Env,_),
	retract(given_inflLink(Env,MS,app(_,1.0,X),Y)),
	fail.
undef(EnvName,MS,negInfl(X,Y)) :-
        environment(EnvName,Env,_),
	retract(given_inflLink(Env,MS,app(_,-1.0,X),Y)),
	fail.
undef(EnvName,MS,noInfl(X,Y)) :-
        environment(EnvName,Env,_),
	retract(given_inflLink(Env,MS,app(_,0.0,X),Y)),
	fail.
undef(EnvName,MS,increase(X)) :-
        environment(EnvName,Env,_),
	retract(given_change(Env,MS,X,1.0)),
	fail.
undef(EnvName,MS,decrease(X)) :-
        environment(EnvName,Env,_),
	retract(given_change(Env,MS,X,-1.0)),
	fail.
undef(EnvName,MS,noChange(X)) :-
        environment(EnvName,Env,_),
	retract(given_change(Env,MS,X,0.0)),
	fail.
undef(_,_,_).

/***********************************************************************
 *
 * undef(:+-Fact)
 *
 *	retracts all facts matching Fact in default environment and
 *	default modal context.
 */

undef(Fact) :-
        getCurrentEnvironment(EnvName),
	undef(EnvName,[],Fact).

/***********************************************************************
 *
 * undef(+EnvName,:+-Fact)
 *
 *	retracts all facts matching Fact in default environment and
 *	default modal context.
 */

undef(EnvName,Fact) :-
        environment(EnvName,_,_),
	!,
	undef(EnvName,[],Fact).

/***********************************************************************
 *
 * undef(+MS,:+-Fact)
 *
 *	retracts all facts matching Fact in default environment and
 *	default modal context.
 */

undef(MS,Fact) :-
        (MS = [] ; MS = [_|_]),
        !,
        getCurrentEnvironment(EnvName),
	undef(EnvName,[],Fact).

/***********************************************************************
 *
 * get_Env_World(+EnvName,+MS,-Env,-World),
 *
 */

get_Env_World(EnvName,MS,Env,World) :-
	environment(EnvName,Env,_),
        convertMS(Env,[[],true],MS,[],[World,G1],_),
        call(G1).

/**********************************************************************
 *
 * @(#) folToClause.pl 1.2@(#)
 *
 */
%---------------------------------------------------------------------------!
% Project:      MOTEL 1.0
% Module:       folToClause.pl
% Purpose:      Translation of first-order logic formulae to clauses
% Last Change:  04.02.93
% Language:     Prolog
% Author:       Ullrich Hustadt
% Address:      Max-Planck-Institut for Computer Science
%               Im Stadtwald
%               6600 Saarbr"ucken
%               Germany
% Email:        Ullrich.Hustadt@mpi-sb.mpg.de
% Copyright:    (C) 1993 Ullrich Hustadt
% Copying:      This software is provided under the GNU General Public Licen!
% Warranty:     This is a research prototype. There is absolutely no warrant!
%---------------------------------------------------------------------------!
%
%
% Syntax of first-order logic formulae
% ====================================
% Atom    => in(X,ConceptName)
%            eq(PrologTerm,PrologTerm)
%            rel(RoleName,PrologTerm,PrologTerm)
%
% Formula =>   Atom
%            | and([Formula,Formula])
%            | or([Formula,Formula])
%            | not(Formula)
%            | implies(Formula,Formula)
%            | equivalent(Formula,Formula)
%            | forall(PrologVar,Formula)
%            | exists(PrologVar,Formula)
%> % Syntax of clauses
% =================
% Clause  => cl(Head,Body)
% Head    =>   []
%            | [Atom|Head]
% Body    =>   []
%            | [Atom|Body]
%----------------------------------------------------------------------
% translate(+F,-C)
% Parameter: F   First-order formula
%            C   Clause

translate(X,Clauses) :-
	implout(X,X1),
	negin(X1,X2),
	skolem(X2,X3,[]),
	univout(X3,X4),
	conjn(X4,X5),
	clausify(X5,Clauses,[]).


%----------------------------------------------------------------------
% implout(+F1,-F2)
% Arguments: F1   First-order formula
%            F2   First-order formula
% removes implications and equivalences in F1 resulting in F2
%
% Author: Ullrich Hustadt

implout(equivalent(P,Q),and([or([not(P1),Q1]),or([P1,not(Q1)])])) :-
	isMooOption(translationMode,flatRelational),
	!,
	implout(P,P1),
	implout(Q,Q1).
implout(equivalent(P,Q),or([and([P1,Q1]),and([not(P1),not(Q1)])])) :-
	!,
	implout(P,P1),
	implout(Q,Q1).
implout(implies(P,Q),or([not(P1),Q1])) :-
	!,
	implout(P,P1),
	implout(Q,Q1).
implout(forall(X,P),forall(X,P1)) :-
	!,
	implout(P,P1).
implout(exists(X,P),exists(X,P1)) :-
	!,
	implout(P,P1).
implout(and(L),and(L1)) :-
	!,
	map(implout,L,L1).
implout(or(L),or(L1)) :-
	!,
	map(implout,L,L1).
implout(not(P),not(P1)) :-
	!,
	implout(P,P1).
implout(P,P).

%----------------------------------------------------------------------
% negin(+F1,-F2)
% Parameter: F1   First-order formula
%            F2   First-order formula
% computes the negation normalWorld form of F1 
%
% Author: Ullrich Hustadt

negin(not(P),P1) :-
	!,
	neg(P,P1).
negin(forall(X,P),forall(X,P1)) :-
	!,
	negin(P,P1).
negin(exists(X,P),exists(X,P1)) :-
	!,
	negin(P,P1).
negin(and(L),and(L1)) :-
	!,
	map(negin,L,L1).
negin(or(L),or(L1)) :-
	!,
	map(negin,L,L1).
negin(P,P).

%----------------------------------------------------------------------
% neg(+F1,-F2)
% Parameter: F1   First-order formula
%            F2   First-order formula
% negates formula F1 to get F2
%
% Author: Ullrich Hustadt

neg(not(P),P1) :-
	!,
	negin(P,P1).
neg(forall(X,P),exists(X,P1)) :-
	!,
	neg(P,P1).
neg(exists(X,P),forall(X,P1)) :-
	!,
	neg(P,P1).
neg(and(L),or(L1)) :-
	!,
	map(neg,L,L1).
neg(or(L),and(L1)) :-
	!,
	map(neg,L,L1).
neg(P,not(P)).

%----------------------------------------------------------------------
% skolem(+F1,-F2,*Vars)
% Parameter: F1     First-order formula
%            F2     First-order formula
%            Vars   List of variables
% F2 is the skolemized form of F1.
%
% Author: Ullrich Hustadt

skolem(forall(X,P),forall(X,P1),Vars) :-
	!,
	skolem(P,P1,[X|Vars]).
skolem(exists(X,P),P2,Vars) :-
	!,
	skolem(P,P1,Vars),
	gensym(f,F),
	Sk =.. [F|Vars],
	logicalSubst(P1,P2,X,Sk).
skolem(and(L),and(L1),Vars) :-
	!,
	map(skolem,[Vars],L,L1).
skolem(or(L),or(L1),Vars) :-
	!,
	map(skolem,[Vars],L,L1).
skolem(P,P,_).


%----------------------------------------------------------------------
% logicalSubst(+F1,-F2,+X,+Sk)
% Parameter: F1     First-order formula
%            F2     First-order formula
%            X      Variable that will be substituted
%            Sk     Skolem term 
% substitutes Sk for X in formula F1.
% 
% Author: Ullrich Hustadt

logicalSubst(T1,T2,X,Sk) :-
	(atomic(T1) ; var(T1)),
	T1 == X,
	!,
	T2 = Sk.
logicalSubst(T1,T2,X,_Sk) :-
	(atomic(T1) ; var(T1)),
	not(T1 == X),
	!,
	T2 = T1.
logicalSubst(forall(Y,P),forall(Y,P),X,_Sk) :-
	X == Y,
	!.
logicalSubst(forall(Y,P),forall(Y,P1),X,Sk) :-
	!,
	logicalSubst(P,P1,X,Sk).
logicalSubst(exists(Y,P),exists(Y,P),X,_Sk) :-
	X == Y,
	!.
logicalSubst(exists(Y,P),exists(Y,P1),X,Sk) :-
	!,
	logicalSubst(P,P1,X,Sk).
logicalSubst(and(L),and(L1),X,Sk) :-
	!,
	map(logicalSubst,[X,Sk],L,L1).
logicalSubst(or(L),or(L1),X,Sk) :-
	!,
	map(logicalSubst,[X,Sk],L,L1).
logicalSubst(not(P),not(P1),X,Sk) :-
	!,
	logicalSubst(P,P1,X,Sk).
logicalSubst(T1,T2,X,Sk) :-
	!,
	T1 =.. [F|Args],
	map(logicalSubst,[X,Sk],Args,Args1),
	T2 =.. [F|Args1].

%----------------------------------------------------------------------
% univout(+F1,-F1)
% Parameter: F1   First-order formula
%            F2   First-order formula
% removes quantifiers
%
% Author: Ullrich Hustadt

univout(forall(_X,P),P1) :-
	!,
	univout(P,P1).
univout(and(L),and(L1)) :-
	!,
	map(univout,L,L1).
univout(or(L),or(L1)) :-
	!,
	map(univout,L,L1).
univout(P,P).

%----------------------------------------------------------------------
% conjn(+F1,-F2)
% Parameter: F1   First-order formula
%            F2   First-order formula
% computes the conjunctive normalWorld form of F1
%
% Author: Ullrich Hustadt

conjn(and(L),R) :-
	!,
	map(conjn,L,L1),
	conjn1(and(L1),R).
conjn(or(L),R) :-
	!,
	map(conjn,L,L1),
	conjn1(or(L1),R).
conjn(P,P).

conjn1(or([and([P,Q]),R]),and([P1,Q1])) :-
	!,
	conjn(or([P,R]),P1),
	conjn(or([Q,R]),Q1).
conjn1(or([R,and([P,Q])]),and([P1,Q1])) :-
	!,
	conjn(or([P,R]),P1),
	conjn(or([Q,R]),Q1).
conjn1(P,P).

clausify(and([P,Q]),C1,C2) :-
	!,
	clausify(P,C1,C3),
	clausify(Q,C3,C2).
clausify(P,[cl(A,B)|Cs],Cs) :-
	inclause(P,A,[],B,[]),
	!.
clausify(_,C,C).

inclause(or([P,Q]),A,A1,B,B1) :-
	!,
	inclause(P,A2,A1,B2,B1),
	inclause(Q,A,A2,B,B2).
inclause(not(P),A,A,B1,B) :-
	!,
	not(memq(P,A)),
	putin(P,B,B1).
inclause(P,A1,A,B,B) :-
	not(memq(P,B)),
	putin(P,A,A1).

putin(X,[],[X]) :-
	!.
putin(X,[Y|L],L) :-
	X == Y,
	!.
putin(X,[Y|L],[Y|L1]) :-
	putin(X,L,L1).


	
memq(_X,[]) :-
	!,
	fail.
memq(X,[Y|_L]) :-
	X == Y,
	!.
memq(X,[_|L]) :-
	memq(X,L).
	
	


/**********************************************************************
 *
 * @(#) hop.pl 1.4@(#)
 *
 */

/***********************************************************************
 * 
 * hop_map(+Pred,+InList,-OutList)
 * calls Pred(X,Y) for all X in InList and collects all Y to get
 * OutList.
 *
 */

hop_map(_Pred,[],[]) :- !.
hop_map(Pred,[H1|T1],[H2|T2]) :-
	Clause =.. [Pred,H1,H2],
	call(Clause),
	hop_map(Pred,T1,T2).

/***********************************************************************
 * 
 * hop_map(+Pred,+[A1,...,An],+InList,-OutList)
 * calls Pred(A1,...,An,X,Y) for all X in InList and collects all Y to 
 * get OutList.
 *
 */

hop_map(_Pred,_Args,[],[]) :- !.
hop_map(Pred,Args,[H1|T1],[H2|T2]) :-
	Clause =.. [Pred|[H1,H2|Args]],
	call(Clause),
	hop_map(Pred,Args,T1,T2).

mapGoal(_Goal,_X,[]) :-
	!.
mapGoal(Goal,X,[(Y,_PTY)|L1]) :-
	not(not((X = Y, call(Goal)))),
	mapGoal(Goal,X,L1).
	
/**********************************************************************
 *
 * try(+G)
 * calls G and succeeds even if G fails.
 *
 */

try(G)  :- call(G).
try(_G) :- true.


/**********************************************************************
 *
 * doboth(G1,G2)
 * calls G1 and if G1 succeeds G2 is called.
 *
 */

doboth(G1,G2) :-
	call(G1),
	call(G2).

/**********************************************************************
 *
 * tell(GoalList)
 * calls all the goals given in argument GoalList which is either a
 * list of PROLOG goals or a single PROLOG goal.
 *
 */

callList([]) :-
	!.
callList([G1|GL]) :-
	!,
	call(G1),
	callList(GL).
callList(G1) :-
	call(G1).


/**********************************************************************
 *
 * toList(+ListTerm,-List)
 * converts a LISP-like list ListTerm into a PROLOG-like list List
 *
 */

tolist(nil,[]) :- !.
tolist(cons(A,L1),[A|L2]) :-
	tolist(L1,L2).

/**********************************************************************
 *
 * setofOrNil(A,B,C)
 * succeeds with the same result as setof(A,B,C) if setof(A,B,C) 
 * succeeds. Otherwise C will be instantiated with the empty list.
 *
 */

setofOrNil(A,B,C) :-
	setof(A,B,C),
	!.
setofOrNil(A,B,[]) :-
	!.

/**********************************************************************
 *
 * bagofOrNil(A,B,C)
 * succeeds with the same result as bagof(A,B,C) if bagof(A,B,C) 
 * succeeds. Otherwise C will be instantiated with the empty list.
 *
 */

bagofOrNil(A,B,C) :-
	setof(A,B,C),
	!.
bagofOrNil(A,B,[]) :-
	!.

/**********************************************************************
 *
 * @(#) infl.pl 1.5@(#)
 *
 */

/***********************************************************************
 *
 * getInflDescription(+Env,+World,-DescriptY,+-Y)
 *
 *	Given a role Y this predicate returns its description in terms
 *	of the least attribute on which Y depends as a possible chain 
 *	of influence relationships. DescriptY is an attribute or it 
 *	is of the form app(sk_,W,Z) where W denotes a weight.
 *
 *	This predicate is now superfluous. Its replacement is the one
 *	with three arguments.
 */

getInflDescription(Env,World,app(F,W,DescriptZ),Y) :-
	given_inflLink(Env,World,app(F,W,Z),Y),
	getInflDescription(Env,World,DescriptZ,Z).

getInflDescription(Env,World,X,X) :-
	atom(X),
	!,
	not(given_inflLink(Env,World,_,X)).

getInflDescription(Env,World,X,X) :-
	var(X),
	!.

/***********************************************************************
 *
 * getInflDescription(+Env,+World,-DescriptY,+-X,+-Y)
 *
 *	Given a role Y this predicate returns its description in terms
 *	of the attribute X on which Y depends as a chain of influence 
 *	relationships. DescriptY is an attribute or it is of the form 
 *	app(sk_,W,Z) where W denotes a weight.
 */

getInflDescription(Env,World,app(F,W,DescriptZ),X,Y) :-
	given_inflLink(Env,World,app(F,W,Z),Y),
	getInflDescription(Env,World,DescriptZ,X,Z).

getInflDescription(Env,World,X,X,X) :-
	!.

/***********************************************************************
 *
 * test_inflLink(+-X,+-Y,+-W)
 *
 *	X is either an attribute/role or it is of the form
 *	app(sk_,_,_).
 *
 *	Y is of the form app(+-F,1.0,+Z) or app(+-F,-1.0,+Z).
 *
 *	This predicate tests for influence of weight W between X and Y.
 */

test_inflLink(X,Y,W) :-
	nonvar(X),
	Y = app(F,W,X),
	!,
	nonvar(F).

test_inflLink(X,Y,W) :-
	var(X),
	nonvar(Y),
	Y = app(F,W,X),
	atom(X),
	!.

test_inflLink(X,Y,W) :-
	var(X),
	var(Y),
	!,
	fail.

test_inflLink(X,app(F,W1,Y),W) :-
	test_inflLink(X,Y,W2),
	weightOf_ChainedInfl(W1,W2,W).

/***********************************************************************
 *
 * inflLink(+Env,+World,+-X,+-Y,+-W)
 *
 *	tests if attribute X influences attribute Y with weight W.
 *
 *	Note: the output for uninstantiated X and/or Y depends on the
 *	order of the literals in the body of infl.
 */

inflLink(Env,World,X,Y,W) :-
	wellDefined_attribute(Env,World,X),
	wellDefined_attribute(Env,World,Y),
	(var(W);
	wellDefined_InflWeight(W)),
	getInflDescription(Env,World,Z2,X,Y),
	test_inflLink(X,Z2,W).

inflLink(Env,World,X,Y,W) :-
	var(X),
	wellDefined_attribute(Env,World,Y),
	(var(W);
	wellDefined_InflWeight(W)),
	getInflDescription(Env,World,Z2,X,Y),
	test_inflLink(X,Z2,W).

inflLink(Env,World,X,Y,W) :-
	wellDefined_attribute(Env,World,X),
	var(Y),
	(var(W);
	wellDefined_InflWeight(W)),
	getInflDescription(Env,World,Z2,X,Y),
	test_inflLink(X,Z2,W).

inflLink(Env,World,X,Y,W) :-
	var(X),
	var(Y),
	(var(W);
	wellDefined_InflWeight(W)),
	getInflDescription(Env,World,Z2,X,Y),
	test_inflLink(X,Z2,W).

/***********************************************************************
 *
 * leastInfl(+Env,+World,+-X,+-Y)
 *
 *	succeeds if X is a least attribute influencing Y.
 */

leastInfl(Env,World,X,Y) :-
	getInflDescription(Env,World,_,X,Y),
	not(X = Y),
	not(given_inflLink(Env,World,_,X)).

/***********************************************************************
 *
 * leastInfls(+Env,+World,+-Xs,+Y)
 *
 *	collects the least attributes influencing Y in Xs.
 */

leastInfls(Env,World,Xs,Y) :-
	setof(X,leastInfl(Env,World,X,Y),Xs).

/***********************************************************************
 *
 * greatestInfl(+Env,+World,+-X,+-Y)
 *
 *	succeeds if Y is a greatest attribute influenced by X.
 */

greatestInfl(Env,World,X,Y) :-
	getInflDescription(Env,World,_,X,Y),
	not(X = Y),
	not(given_inflLink(Env,World,app(_,_,Y),_)).

/***********************************************************************
 *
 * greatestInfls(+Env,+World,+X,+-Ys)
 *
 *	collects the greatest attributes influenced by X in Ys.
 */

greatestInfls(Env,World,X,Ys) :-
	setof(Y,greatestInfl(Env,World,X,Y),Ys).

/***********************************************************************
 *
 * infl(+Env,+World,+-X,+-Y,+-W)
 *
 *	computes the cumulative weight W of all the influence links 
 *	between the attributes X and Y.
 */

infl(Env,World,X,Y,W) :-
	bagof(Weight,inflLink(Env,World,X,Y,Weight),Weights),
	weightOf_TotalInfl(Weights,W).

/***********************************************************************
 *
 * maxPosInfl(+Env,+World,+-X,+-Y,+-Wmax)
 *
 *	succeeds if Wmax is the greatest weight with which X influences 
 *	Y positively.
 */

maxPosInfl(Env,World,X,Y,WMax) :-
	var(X),
	bagof(W,Z^posInfl(Env,World,Z,Y,W),Ws),
	motel_max(Ws,WMax,wellDefined_InflWeight),
	posInfl(Env,World,X,Y,WMax).

maxPosInfl(Env,World,X,Y,WMax) :-
	var(Y),
	bagof(W,Z^posInfl(Env,World,X,Z,W),Ws),
	motel_max(Ws,WMax,wellDefined_InflWeight),
	posInfl(Env,World,X,Y,WMax).

maxPosInfl(Env,World,X,Y,WMax) :-
	nonvar(X),
	nonvar(Y),
	posInfl(Env,World,X,Y,WMax).

/***********************************************************************
 *
 * maxNegInfl(+Env,+World,+-X,+-Y,+-WMin)
 *
 *	succeeds if WMin is the greatest weight with which X influences 
 *	Y negatively.
 */

maxNegInfl(Env,World,X,Y,WMin) :-
	var(X),
	bagof(W,Z^negInfl(Env,World,Z,Y,W),Ws),
	motel_min(Ws,WMin,wellDefined_InflWeight),
	negInfl(Env,World,X,Y,WMin).

maxNegInfl(Env,World,X,Y,WMin) :-
	var(Y),
	bagof(W,Z^negInfl(Env,World,X,Z,W),Ws),
	motel_min(Ws,WMin,wellDefined_InflWeight),
	negInfl(Env,World,X,Y,WMin).

maxNegInfl(Env,World,X,Y,WMin) :-
	nonvar(X),
	nonvar(Y),
	negInfl(Env,World,X,Y,WMin).

/***********************************************************************
 *
 * posInfl(+Env,+World,+-X,+-Y)
 *
 *	succeeds if attribute X influences attribute Y positively.
 */

posInfl(Env,World,X,Y) :-
	infl(Env,World,X,Y,W),
	W > 0.0.

/***********************************************************************
 *
 * posInfl(+Env,+World,+-X,+-Y,+-W)
 *
 *	succeeds if attribute X influences attribute Y positively with
 *	weight W.
 */

posInfl(Env,World,X,Y,W) :-
	infl(Env,World,X,Y,W),
	W > 0.0.

/***********************************************************************
 *
 * negInfl(+Env,+World,+-X,+-Y)
 *
 *	succeeds if attribute X influences attribute Y negatively.
 */

negInfl(Env,World,X,Y) :-
	infl(Env,World,X,Y,W),
	W < 0.0.

/***********************************************************************
 *
 * negInfl(+Env,+World,+-X,+-Y,+-W)
 *
 *	succeeds if attribute X influences attribute Y negatively with
 *	weight W.
 */

negInfl(Env,World,X,Y,W) :-
	infl(Env,World,X,Y,W),
	W < 0.0.

/***********************************************************************
 *
 * noInfl(+Env,+World,+-X,+-Y)
 *
 *	succeeds if the cumulative influence between the attributes X and
 *	Y is 0.0.
 */

noInfl(Env,World,X,Y) :-
	infl(Env,World,X,Y,0.0).

/***********************************************************************
 *
 * simultInfl(+Env,+World,+-Xs,+-Y,+-W)
 *
 *	checks if the list Xs is well-defined (that is, is Xs a SET of
 *	independent attributes) and computes the total weight W of the 
 *	attributes in the list Xs simultaneously influencing attribute Y.
 */

simultInfl(Env,World,Xs,Y,W) :-
	nonvar(Xs),
	wellDefined_setOfAttributes(Env,World,Xs),
	aux_simultInfl(Env,World,Xs,Y,Ws),
	weightOf_SimultInfl(Ws,W).

simultInfl(Env,World,Xs,Y,W) :-
	var(Xs),
	!,
	leastInfl(Env,World,Xs,Y),
	aux_simultInfl(Env,World,Xs,Y,Ws),
	wellDefined_setOfAttributes(Env,World,Xs),
	weightOf_SimultInfl(Ws,W).

aux_simultInfl(_,_,[],_,[]).

aux_simultInfl(Env,World,[X|Xs],Y,[W|Ws]) :-
	infl(Env,World,X,Y,W),
	aux_simultInfl(Env,World,Xs,Y,Ws).

aux_simultInfl(Env,World,[X|Xs],Y,Ws) :-
	not(getInflDescription(Env,World,_,X,Y)),
	aux_simultInfl(Env,World,Xs,Y,Ws).

/***********************************************************************
 *
 * simultPosInfl(+Env,+World,+-Xs,+-Y)
 *
 *	succeeds if the simultaneous influence of the attributes in the
 *	list Xs on the attribute Y is positive.
 */

simultPosInfl(Env,World,Xs,Y) :-
	simultInfl(Env,World,Xs,Y,W),
	W > 0.0.

/***********************************************************************
 *
 * simultNegInfl(+Env,+World,+-Xs,+-Y)
 *
 *	succeeds if the simultaneous influence of the attributes in the
 *	list Xs on the attribute Y is positive.
 */

simultNegInfl(Env,World,Xs,Y) :-
	simultInfl(Env,World,Xs,Y,W),
	W < 0.0.

/***********************************************************************
 *
 * simultNoInfl(+Env,+World,+-Xs,+-Y)
 *
 *	succeeds if the simultaneous influence of the attributes in the
 *	list Xs on the attribute Y is positive.
 */

simultNoInfl(Env,World,Xs,Y) :-
	simultInfl(Env,World,Xs,Y,0.0).

/***********************************************************************
 *
 * change(+Env,+World,+-Y,+-Wy)
 *
 *	determines the change in Y.
 */

change(Env,World,Y,Wy) :-
	bagof(W,X^changingInfl(Env,World,X,Y,W),Ws),
	weightOf_SimultChange(Ws,Wy).

change(Env,World,Y,Wy) :-
	given_change(Env,World,Y,Wy).

/***********************************************************************
 *
 * changingInfl(+Env,+World,+-X,+-Y,+-Wy)
 *
 *	succeeds if the influencing attribute X of Y changes. Wy is the
 *	weight of the resulting change in Y.
 */

changingInfl(Env,World,X,Y,Wy) :-
	infl(Env,World,X,Y,Wxy),
	given_change(Env,World,X,Wx),
	weightOf_change(Wx,Wxy,Wy).

/***********************************************************************
 *
 * increase(+Env,+World,+-Y)
 *
 *	succeeds if attribute Y increases.
 */

increase(Env,World,Y) :-
	change(Env,World,Y,W),
	W > 0.0.
%	change(Env,World,Y,1.0).

/***********************************************************************
 *
 * decrease(+Env,+World,+-Y)
 *
 *	succeeds if attribute Y decreases.
 */

decrease(Env,World,Y) :-
	change(Env,World,Y,W),
	W < 0.0.
%	change(Env,World,Y,-1.0).

/***********************************************************************
 *
 * noChange(+Env,+World,+-Y)
 *
 *	succeeds if attribute Y does not change (i.e. there is neither
 *	an increase nor a decrease).
 */

noChange(Env,World,Y) :-
	change(Env,World,Y,0.0).

/***********************************************************************
 *
 * wellDefined_attribute(+EnvName,+World,+X)
 *
 *	Is X an attribute?
 *
 *	Note: At the moment this clause succeeds if X is an atom. We
 *	may want to do more verifying here.
 */

wellDefined_attribute(Env,World,X) :-
	atom(X),
	roleName(Env,_MS,World,X),
	!.

/***********************************************************************
 *
 * wellDefined_setOfAttributes(+Env,+World,+Xs)
 *
 *	Succeeds if Xs is a variable or if Xs is a SET of independent
 *	(with respect to the influence relationship) atoms.
 *
 *	Note: In the current implementation the independence is NOT 
 *	verified.
 */

wellDefined_setOfAttributes(Env,World,Xs) :-
	isSet(Xs),
	noInflLinks(Env,World,Xs).

/***********************************************************************
 *
 * isSet(+L)
 *
 *	Succeeds if L is a SET.
 */

isSet([]) :-
	!.
isSet([E|L]) :-
	not(member(E,L)),
	isSet(L).


/***********************************************************************
 *
 * noInflLinks(+Env,+World,+Xs)
 *
 *	Succeeds if there are no links among any of the attributes in Xs.
 *
 *	NOTE: The complexity is quadratic, namely (n-1)^2, 
 *	where n is the length of Xs.
 */

noInflLinks(Env,World,[X|Xs]) :-
	wellDefined_attribute(Env,World,X),
	aux_noInflLinks(Env,World,X,Xs),
	noInflLinks(Env,World,Xs).

noInflLinks(_,_,[]).

aux_noInflLinks(Env,World,X,[Y|Ys]) :-
	not(getInflDescription(Env,World,_,X,Y)),
	not(getInflDescription(Env,World,_,Y,X)),
	aux_noInflLinks(Env,World,X,Ys).

aux_noInflLinks(_,_,_,[]).

/***********************************************************************
 *
 * wellDefined_SimultChanges(+Changes)
 *
 *	Succeeds if Changes is a list of changes of the form
 *	change(X,W) in which no X occurs more than once.
 */

wellDefined_SimultChanges(Changes) :-
	attributes(Changes,Xs),
	isSet(Xs),
	!.

/***********************************************************************
 *
 * attributes(+Changes,+-Xs)
 *
 *	Generates a list Xs of attributes X from the list Changes.
 *	The elements of Changes are of the form change(X,W).
 */

attributes([],[]).

attributes([change(X,_)|Changes],[X|Xs]) :-
	attributes(Changes,Xs).

/***********************************************************************
 *
 * wellDefined_InflWeight(+W)
 *
 *	Is the given weight W of influence well-defined?
 */

wellDefined_InflWeight(W) :-
	float(W),
	!.
wellDefined_InflWeight(W) :-
	integer(W),
	!.
%	W >= -1.0,
%	W =< 1.0.

/***********************************************************************
 *
 * weightOf_ChainedInfl(+-W1,+-W2,+-W)
 *
 *	defines the weight W of chained influences with weights W1 and
 *	W2.
 *	W is given by f(W1,W2) where in this implementation f is
 *	multiplication.
 */

weightOf_ChainedInfl(W1,W2,W) :-
	product(W1,W2,W,wellDefined_ChangeWeight).

/***********************************************************************
 *
 * weightOf_TotalInfl(+Ws,+-W)
 *
 *	computes the the total weight W from the Ws. 
 *	Here, W is the sum of the Ws.
 *	We could have just as well chosen W to be the arithmetic
 *	mean of the Ws.
 *	Which is better remains open for the moment.
 */

weightOf_TotalInfl(Ws,W) :-
	sum(Ws,W,wellDefined_InflWeight).
%	arithm_Mean(Ws,W,wellDefined_InflWeight).

/***********************************************************************
 *
 * weightOf_SimultInfl(+-Ws,+-W)
 *
 *	computes the weight W of a list of simultaneous influences from
 *	different attributes with weights specified in Ws.
 *	Here, W is the sum of the Ws.
 *	We could have just as well chosen W to be the arithmetic
 *	mean of the Ws.
 *	Which is better remains open for the moment.
 */

weightOf_SimultInfl(Ws,W) :-
	sum(Ws,W,wellDefined_InflWeight).
%	arithm_Mean(Ws,W,wellDefined_InflWeight).

/***********************************************************************
 *
 * wellDefined_ChangeWeight(+W)
 *
 *	Is the given weight W of change well-defined?
 */

wellDefined_ChangeWeight(W) :-
	float(W),
	!.
wellDefined_ChangeWeight(W) :-
	integer(W),
	!.
%	W >= -1.0,
%	W =< 1.0.

/***********************************************************************
 *
 * weightOf_change(+-Wx,+-Wxy,-+Wy)
 *
 *	succeeds if Wy = f(Wx,Wxy) for a given f. 
 *	I chose f to be multiplication.
 */

weightOf_change(Wx,Wxy,Wy) :-
	product(Wx,Wxy,Wy,wellDefined_ChangeWeight).

/***********************************************************************
 *
 * weightOf_SimultChange(+Ws,+-W)
 *
 *	computes the weight W of the change resulting from
 *	simultaneous changes with weights Ws.
 *	W is the sum over the Ws.
 */

weightOf_SimultChange(Ws,W) :-
	sum(Ws,W,wellDefined_ChangeWeight).

/***********************************************************************
 *
 * arithm_Mean([+-Value|+Values],+-Mean,+IsWellDefName)
 *
 *	Given a list of values (Values) and a predicate atom_codes for
 *	checking whether each of the values is well-defined this clause
 *	computes the arithmetical mean (Mean) over Values.
 *	Provided Mean is given the first valueOfCounter may be a variable.
 */

arithm_Mean([],0.0,IsWellDefName) :-
	!.

arithm_Mean([Value|Values],Mean,IsWellDefName) :-
	var(Value),
	!,
	length([Value|Values],N),
	Sum is Mean * N,
	sum([Value|Values],Sum,IsWellDefName).

arithm_Mean(Values,Mean,IsWellDefName) :-
	sum(Values,Sum,IsWellDefName),
	length(Values,N),
	Mean is Sum / N.

/***********************************************************************
 *
 * sum([+-Value|+Values],+-Sum,+IsWellDefName)
 *
 *	Given a list of values (Values) and a predicate atom_codes 
 *	(IsWellDefName) for checking whether each of the values is 
 *	well-defined this clause computes the sum (Sum) of the values.
 *	Provided Sum is given the first valueOfCounter may be a variable.
 */

sum([Value|Values],Sum,IsWellDefName) :-
	var(Value),
	!,
	IsWellDef =.. [IsWellDefName,Sum],
	IsWellDef,
	sum(Values,VSum,IsWellDefName),
	Value is Sum - VSum.

sum([Value|Values],Sum,IsWellDefName) :-
	IsWellDef =.. [IsWellDefName,Value],
	IsWellDef,
	sum(Values,VSum,IsWellDefName),
	Sum is Value + VSum.

sum([],0.0,_).

/***********************************************************************
 *
 * product(+Factor1,+Factor2,+-Product,+IsWellDefName)
 * product(+-Factor1,+Factor2,+Product,+IsWellDefName)
 * product(+Factor1,+-Factor2,+Product,+IsWellDefName)
 *
 *	Given two values (Factor1 and Factor2) and a predicate atom_codes 
 *	(IsWellDefName) for checking whether each of the values is 
 *	well-defined this clause computes the product (Product) of the 
*	values.
 */

product(Factor1,Factor2,Product,IsWellDefName) :-
	IsWellDef1 =.. [IsWellDefName,Factor1],
	IsWellDef1,
	IsWellDef2 =.. [IsWellDefName,Factor2],
	IsWellDef2,
	Product is Factor1 * Factor2,
	!.

product(Factor1,Factor2,Product,IsWellDefName) :-
	IsWellDef1 =.. [IsWellDefName,Factor2],
	IsWellDef1,
	IsWellDef2 =.. [IsWellDefName,Product],
	IsWellDef2,
	Factor1 is Product / Factor2,
	!.

product(Factor1,Factor2,Product,IsWellDefName) :-
	IsWellDef1 =.. [IsWellDefName,Factor1],
	IsWellDef1,
	IsWellDef2 =.. [IsWellDefName,Product],
	IsWellDef2,
	Factor2 is Product / Factor1,
	!.

/***********************************************************************
 *
 * max([+-Value|+Values],+-Max,+IsWellDefName)
 *
 *	Given a list of values (Values) and a predicate atom_codes 
 *	(IsWellDefName) for checking whether each of the values is 
 *	well-defined this clause determines the maximum (Max) of the 
 *	values.
 *
 * max(+Value1,+Value2,+-Max)
 *
 *	returns the bigger valueOfCounter of Value1 and Value2 in Max.
 */

motel_max([Max],Max,_) :-
	!.

motel_max([Value|Values],Max,IsWellDefName) :-
	IsWellDef =.. [IsWellDefName,Value],
	IsWellDef,
	motel_max(Values,VMax,IsWellDefName),
	lub(Value,VMax,Max).

lub(Value1,Value2,Value1) :-
	Value1 > Value2,
	!.

lub(Value1,Value2,Value2).

/***********************************************************************
 *
 * min([+-Value|+Values],+-Min,+IsWellDefName)
 *
 *	Given a list of values (Values) and a predicate atom_codes 
 *	(IsWellDefName) for checking whether each of the values is 
 *	well-defined this clause determines the minimum (Min) of the 
 *	values.
 *
 * min(+Value1,+Value2,+-Min)
 *
 *	returns the smaller valueOfCounter of Value1 and Value2 in Min.
 */

motel_min([Min],Min,_) :-
	!.

motel_min([Value|Values],Min,IsWellDefName) :-
	IsWellDef =.. [IsWellDefName,Value],
	IsWellDef,
	motel_min(Values,VMin,IsWellDefName),
	glb(Value,VMin,Min).

glb(Value1,Value2,Value1) :-
	Value1 < Value2,
	!.

glb(Value1,Value2,Value2).

/**********************************************************************
 *
 * @(#) klone.pl 1.10@(#)
 *
 */

/***********************************************************************
 *
 * defprimconcept(+Environment,+Left)
 * Parameter: ConceptName       concept atom_codes
 * defines the concept ConceptName in modal context [].
 *
 */

defprimconcept(Left) :-
	getCurrentEnvironment(EnvName),
	defprimconcept(EnvName,[],Left).


/***********************************************************************
 *
 * defprimconcept(+Environment,+Left)
 * Parameter: ConceptName       concept atom_codes
 * defines the concept ConceptName in modal context [].
 *
 */

defprimconcept(EnvName,Left) :-
	environment(EnvName,_,_),
	!,
	defprimconcept(EnvName,[],Left).
defprimconcept(MS,Left) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	defprimconcept(EnvName,MS,Left).
defprimconcept(Left,Right) :-
	getCurrentEnvironment(EnvName),
	defprimconcept(EnvName,[],Left,Right).
	

/***********************************************************************
 *
 * defprimconcept(+Environment,+MS,+Left)
 * Parameter: ModalSequence     modal context
 *            ConceptName       concept atom_codes
 * defines the concept ConceptName in modal context ModalSequence.
 *
 */

defprimconcept(EnvName,MS,Left) :-
	environment(EnvName,Env,_),
	(MS = [] ; MS = [_|_]),
	atomic(Left),
	assertzRE(conceptSubsets(Env,user,MS,Left,'top',noAxiom)),
	assertzRE(axiom(Env,MS,defprimconcept(MS,Left,'top'))),
	assertNames(Env,MS,Left,concept),
	!.

defprimconcept(MS,Left,Right) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	defprimconcept(EnvName,MS,Left,Right).

/***********************************************************************
 *
 * defprimconcept(+Environment,+Left,+Right)
 * Parameter: ConceptName       concept atom_codes
 *            ConceptTerm       concept term
 * defines the concept ConceptName to be a subsetSpecial of the concept
 * ConceptTerm in modal context [].
 *
 */

defprimconcept(EnvName,Left,Right) :-
	environment(EnvName,_,_),
	defprimconcept(EnvName,[],Left,Right).

/***********************************************************************
 *
 * defprimconcept(+Environment,+ModalSequence,+Left,+Right)
 * Parameter: ModalSequence     modal context
 *            ConceptName       concept atom_codes
 *            ConceptTerm       concept term
 * defines the concept ConceptName to be a subsetSpecial of the concept
 * ConceptTerm in modal context ModalSequence.
 *
 */

defprimconcept(EnvName,MS,L,R) :-
	environment(EnvName,Env,_),
%	nonvar(MS),
	convertToLogicalCNF(L,Left),
	convertToLogicalCNF(R,Right),
	assertNames(Env,MS,Left,concept),
	assertNames(Env,MS,Right,concept),
	assertzRE(axiom(Env,MS,defprimconcept(MS,L,R))),
	unfold(Env,[(user,concept,Left,Right)],[(_Origin,_,L1,_,R1)|DL]),
	gensym(axiom,AxiomName1),
	assertzRE(conceptSubsets(Env,user,MS,Left,Right,AxiomName1)),
	typeOfDefinition(Env,MS,L1,Origin),
	assertConceptLInR(Env,rn(AxiomName1,Origin,lInR),MS,L1,R1),
	defList(Env,MS,DL,_),
	negate(R1,NotRight1),
	convertToLogicalCNF(NotRight1,NotRight),
	negate(L1,NotLeft1),
	convertToLogicalCNF(NotLeft1,NotLeft),
	notClauseL(Env,MS,NotRight,NotLeft).


notClauseL(Env,MS,Left,Right) :-
	% assertzRE that Left is included in Right
	unfold(Env,[(user,concept,Left,Right)],[(_O,_,Concept1,C3,Concept2)|DL2]),
	defPositiveList(Env,MS,DL2),
	gensym(axiom,AxiomName2),
	typeOfDefinition(Env,MS,Concept1,O),
	assertzRE(conceptSubsets(Env,user,MS,Concept1,C3,AxiomName2)),
	assertConceptLInR(Env,rn(AxiomName2,O,lInR),MS,Concept1,Concept2).
/* 
notClauseL(Env,MS,Left,Right) :-
	% assertzRE that Left is included in Right
	atomic(Left),
	!,
	unfold(Env,[(user,concept,Left,Right)],[(_O,_,Concept1,C3,Concept2)|DL2]),
	defPositiveList(Env,MS,DL2),
	gensym(axiom,AxiomName2),
	typeOfDefinition(Env,MS,Concept1,O),
	assertConceptLInR(Env,rn(AxiomName2,O,lInR),MS,Concept1,Concept2),
	assertzRE(conceptSubsets(Env,user,MS,Concept1,C3,AxiomName2)).
notClauseL(Env,MS,Left,Right) :-
	atomic(Right),
	!,
	gensym(concept,Concept1),
	unfold(Env,[(system,concept,Concept1,Left)],DL2),
	defPositiveList(Env,MS,DL2),
	gensym(axiom,AxiomName2),
	assertConceptLInR(Env,rn(AxiomName2,system,lInR)MS,Concept1,Right),
	assertzRE(conceptSubsets(Env,system,MS,Concept1,Concept2,AxiomName2)).
notClauseL(Env,MS,Left,Right) :-
	!,
	gensym(concept,Concept1),
	gensym(concept,Concept2),
	unfold(Env,[(system,concept,Concept1,Left),(system,concept,Concept2,Right)],DL2),
	defPositiveList(Env,MS,DL2),
	gensym(axiom,AxiomName2),
	assertConceptLInR(Env,rn(AxiomName,system,lInR),MS,Concept1,Concept2),
	assertzRE(conceptSubsets(Env,system,MS,Concept1,Concept2,AxiomName2)).
*/

notClausesLR(Env,MS,Left,Right,DL2) :-
	unfold(Env,[(system,concept,Left,Right)],DL2),
	defPositiveList(Env,MS,DL2).

/***********************************************************************
 *
 * defconcept(+ConceptName,+ConceptTerm)
 * Parameter: ConceptName       concept atom_codes
 *            ConceptTerm       concept term
 * defines the concept ConceptName to be equivalent to the concept
 * ConceptTerm in modal context [].
 *
 */ 

defconcept(ConceptName,ConceptTerm) :-
	getCurrentEnvironment(EnvName),
	defconcept(EnvName,[],ConceptName,ConceptTerm).

defconcept(MS,CN,CT) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	defconcept(EnvName,MS,CN,CT),
	!.
defconcept(EnvName,ConceptName,ConceptTerm) :-
	nonvar(EnvName),
	environment(EnvName,_,_),
	!,
	defconcept(EnvName,[],ConceptName,ConceptTerm).

/***********************************************************************
 *
 * defconcept(+ModalSequence,+ConceptName,+ConceptTerm)
 * Parameter: ModalSequence     modal context
 *            ConceptName       concept atom_codes
 *            ConceptTerm       concept term
 * defines the concept ConceptName to be equivalent to the concept
 * ConceptTerm in modal context ModalSequence.
 *
 */ 

defconcept(EnvName,MS,CT1,CT2) :-
	nonvar(EnvName),
	environment(EnvName,Env,_),
	convertToLogicalCNF(CT1,ConceptTerm1),
	convertToLogicalCNF(CT2,ConceptTerm2),
	assertNames(Env,MS,ConceptTerm1,concept),
	assertNames(Env,MS,ConceptTerm2,concept),
	assertzRE(axiom(Env,MS,defconcept(MS,CT1,CT2))),
	unfold(Env,[(user,concept,ConceptTerm1,ConceptTerm2)],DL),
	defList(Env,MS,DL,_).

defPositiveList(_,_,[]) :- !.
defPositiveList(Env,MS,[(Origin,concept,ConceptName,CTO,ConceptTerm)|DL]) :-
	gensym(axiom,AxiomName),
	assertzRE(conceptEqualSets(Env,Origin,MS,ConceptName,CTO,AxiomName)),
	assertConceptRInL(Env,rn(AxiomName,Origin,rInL),MS,ConceptName,ConceptTerm),
	assertConceptLInR(Env,rn(AxiomName,Origin,lInR),MS,ConceptName,ConceptTerm),
	defPositiveList(Env,MS,DL).
defPositiveList(Env,MS,[(_Origin,role,RN,_RTO,RT)|RDL]) :-
	gensym(axiom,AxiomName),
	assertRoleLInR(Env,MS,RN,RT,AxiomName),
	assertRoleRInL(Env,MS,RN,RT,AxiomName),
	defPositiveList(Env,MS,RDL).

defList(_,_,[],[]) :- !.
defList(Env,MS,[(Origin,concept,ConceptName,CTO,ConceptTerm)|DL],
        NeededDL3) :-
	gensym(axiom,AxiomName),
	assertzRE(conceptEqualSets(Env,Origin,MS,ConceptName,CTO,AxiomName)),
	assertConceptRInL(Env,rn(AxiomName,Origin,rInL),MS,ConceptName,ConceptTerm),
	assertConceptLInR(Env,rn(AxiomName,Origin,lInR),MS,ConceptName,ConceptTerm),
	negate(ConceptTerm,NotRight1),
	convertToLogicalCNF(NotRight1,NotRight),
	negate(ConceptName,NotLeft1),
	convertToLogicalCNF(NotLeft1,NotLeft),
	notClausesLR(Env,MS,NotRight,NotLeft,NeededDL1),
	defList(Env,MS,DL,NeededDL2),
	append(NeededDL1,NeededDL2,NeededDL3).
defList(Env,MS,[(Origin,role,RN,RTO,RT)|RDL],NeededDL) :-
	gensym(axiom,AxiomName),
	assertzRE(roleEqualSets(Env,Origin,MS,RN,RTO,AxiomName)),
	assertRoleLInR(Env,MS,RN,RT,AxiomName),
	assertRoleRInL(Env,MS,RN,RT,AxiomName),
	defList(Env,MS,RDL,NeededDL).

undefList(_,_,[]) :- !.
undefList(EnvName,MS,[(Origin,concept,ConceptName,CTO,ConceptTerm)|DL]) :-
	undefconcept(EnvName,MS,ConceptName,CTO),
	undefList(Env,MS,DL).
undefList(EnvName,MS,[(Origin,role,RN,RTO,RT)|RDL]) :-
	undefrole(EnvName,MS,RN,RTO),
	undefList(Env,MS,RDL).

/***********************************************************************
 *
 * assert_ind(+ModalSequence,+ABoxElement,+ConceptTerm)
 * Parameter: ModalSequence     modal context
 *            ABoxElement       atom_codes of ABox element
 *            ConceptTerm       concept term
 * adds ABoxElement to Concept in modal context ModalSequence.
 *
 */

assert_ind(X,CT) :-
	getCurrentEnvironment(EnvName),
	assert_ind(EnvName,[],X,CT).

assert_ind(EnvName,X,CT) :-
	environment(EnvName,_,_),
	!,
	assert_ind(EnvName,[],X,CT).
assert_ind(MS,X,CT) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	assert_ind(EnvName,MS,X,CT).

assert_ind(X,Y,R) :-
	getCurrentEnvironment(EnvName),
	assert_ind(EnvName,X,Y,R).

assert_ind(EnvName,MS,X,C) :-
	environment(EnvName,Env,_),
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	atomic(X),
	gensym(axiom,AxiomName),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,user,lInR,RN1),
	defineEquivalentConceptname(EnvName,MS,C,assertzRE,C1),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertaRE((conceptElement(Env,MS,W1,user,X,C1,AxiomName) :- call(G1))),
	assertzRE(axiom(Env,MS,assert_ind(MS,X,C1))),
	constructMLHead(Env,RN1,W1,C1,X,_HYPS,_D,_CALLS,abox,InHead),
	assertaRE((InHead :- call(G1))),
	assertNames(Env,MS,C1,concept).

/***********************************************************************
 *
 * assert_ind(+ModalSequence,+ABoxElement1,+ABoxElement2,+Role)
 * Parameter: ModalSequence     modal context
 *            ABoxElement1      atom_codes of ABox element
 *            ABoxElement2      atom_codes of ABox element
 *            Role              role atom_codes
 * adds the pair (ABoxElement1,ABoxElement2) to Role in modal context
 * ModalSequence.
 *
 */

assert_ind(EnvName,X,Y,R) :-
	environment(EnvName,_,_),
	!,
	atomic(X),
	atomic(Y),
	!,
	assert_ind(EnvName,[],X,Y,R).
assert_ind(MS,X,Y,R) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	!,
	atomic(X),
	atomic(Y),
	!,
	assert_ind(EnvName,MS,X,Y,R).

assert_ind(EnvName,MS,X,Y,RT) :-
	environment(EnvName,Env,_),
	atomic(X),
	atomic(Y),
	defineEquivalentRolename(EnvName,MS,RT,assertzRE,R),
	Role1 =.. [R,X,Y],
	assertaRE(Role1),
%	Role2 =.. [R,X,Y],
	gensymbol(skolem,[X,Y],SF),
	gensym(axiom,AX),
	gensym(rule,RN),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	constructEqHead(Env,rn(AX,RN,user,lInR),W1,Y,SF,R,X,_,_D,CALLS,abox,EqLiteral),
	assertaRE((EqLiteral :- (checkCallStack(CALLS,true), call(G1)))),
	assertNames(Env,MS,R,role),
	assertzRE(axiom(Env,MS,assert_ind(MS,X,Y,R))),
	assertaRE((roleElement(Env,MS,W1,user,X,Y,R,AX) :- call(G1))).


/***********************************************************************
 *
 * defprimrole(+RN)
 * Parameter: RN        role atom_codes
 * defines the role RN in modal context [].
 * 
 */

defprimrole(Role) :-
	currentEnvironment(Env),
	!,
	assertNames(Env,[],Role,role),
	assertaRE(roleSubsets(Env,user,[],Role,'top',noAxiom)).

defprimrole(EnvName,Role) :-
	environment(EnvName,Env,_),
	!,
	assertNames(Env,[],Role,role),
	assertaRE(axiom(Env,[],defprimrole([],Role,'top'))),
	assertaRE(roleSubsets(Env,user,[],Role,'top',noAxiom)).

/***********************************************************************
 *
 * defprimrole(+MS,+RN)
 * Parameter: MS        modal context
 *            RN        role atom_codes
 * defines the role RN in modal context MS.
 * 
 */

defprimrole(MS,Role) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	currentEnvironment(Env),
	assertNames(Env,MS,Role,role),
	assertaRE(axiom(Env,MS,defprimrole(MS,Role,'top'))),
	assertaRE(roleSubsets(Env,user,MS,Role,'top',noAxiom)).

defprimrole(R1,R2) :-
	getCurrentEnvironment(EnvName),
	defprimrole(EnvName,[],R1,R2).

/***********************************************************************
 *
 * defprimrole(+RN,+Role)
 * Parameter: RN        role atom_codes
 *            Role      role term
 * defines the role RN to be a subsetSpecial of the role Role in modal
 * context [].
 * 
 */

defprimrole(EnvName,RN,Role) :-
	environment(EnvName,_,_),
	atomic(RN),
	!,
	defprimrole(EnvName,[],RN,Role).
defprimrole(MS,RN,Role) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	atomic(RN),
	!,
	defprimrole(EnvName,MS,RN,Role).

/***********************************************************************
 *
 * defprimrole(+MS,+RN,+Role)
 * Parameter: MS        modal context
 *            RN        role atom_codes
 *            Role      role term
 * defines the role RN to be a subsetSpecial of the role Role in modal
 * context MS.
 *
 */

defprimrole(EnvName,MS,RN,Role) :-
	environment(EnvName,Env,_),
	atomic(RN),
	assertNames(Env,MS,RN,role),
	assertNames(Env,MS,Role,role),
	unfold(Env,[(user,role,RN,Role)],[(user,role,RN,_,RT)|RDL]),
	gensym(axiom,AxiomName),
	assertaRE(axiom(Env,MS,defprimrole(MS,RN,Role))),
	assertaRE(roleSubsets(Env,user,MS,RN,Role,AxiomName)),
	assertRoleLInR(Env,MS,RN,RT,AxiomName),
	defList(Env,MS,RDL,_).

/***********************************************************************
 *
 * defrole(+RN,+Role)
 * Parameter: RN        role atom_codes
 *            Role      role term
 * defines role RN to be equivalent to the role Role in modal context
 * [].
 *
 */

defrole(RN,Role) :-
	getCurrentEnvironment(EnvName),
	defrole(EnvName,[],RN,Role).

defrole(MS,RN,Role) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	defrole(EnvName,[],RN,Role).
defrole(EnvName,RN,Role) :-
	nonvar(EnvName),
	environment(EnvName,_,_),
	defrole(EnvName,[],RN,Role).

/***********************************************************************
 *
 * defrole(+MS,+RN,+Role)
 * Parameter: MS        modal context
 *            RN        role atom_codes
 *            Role      role term
 * defines the role RN to be equivalent to the role Role in modal
 * context MS.
 *
 */

defrole(EnvName,MS,RN,Role) :-
	environment(EnvName,Env,_),
	atomic(RN),
	unfold(Env,[(user,role,RN,Role)],RDL),
	assertNames(Env,MS,RN,role),
	assertNames(Env,MS,Role,role),
	assertaRE(axiom(Env,MS,defrole(MS,RN,Role))),
	defList(Env,MS,RDL,_).

/**********************************************************************
 *
 * defdisjoint(EnvName,MS,ConceptList)
 * Parameter: EnvName         environment atom_codes
 *            MS              modal context
 *            ConceptList     list of concept names
 *
 */

defdisjoint(CL) :-
	getCurrentEnvironment(EnvName),
	defdisjoint(EnvName,[],CL),
	!.

defdisjoint(EnvName,CL) :-
	environment(EnvName,_,_),
	defdisjoint(EnvName,[],CL),
	!.
defdisjoint(MS,CL) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	defdisjoint(EnvName,MS,CL),
	!.

defdisjoint(_EnvName,_MS,[]) :-
	!.
defdisjoint(EnvName,MS,[C1|CL]) :-
	defdisjoint(EnvName,MS,C1,CL),
	defdisjoint(EnvName,MS,CL),
	!.

defdisjoint(_EnvName,_MS,_C1,[]) :-
	!.
defdisjoint(EnvName,MS,C1,[C2|CL]) :-
	defprimconcept(EnvName,MS,C1,not(C2)),
	defdisjoint(EnvName,MS,C1,CL).


/**********************************************************************
 *
 * defclosed(EnvName,MS,X,Y,R)
 *
 */

defclosed(X,Y,R) :-
	getCurrentEnvironment(EnvName),
	defclosed(EnvName,[],X,Y,R),
	!.

defclosed(EnvName,X,Y,R) :-
	environment(EnvName,_,_),
	defclosed(EnvName,[],X,Y,R),
	!.
defclosed(MS,X,Y,R) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	defclosed(EnvName,MS,X,Y,R),
	!.

defclosed(EnvName,MS,X,Y,R) :-
	environment(EnvName,Env,_),
	assertzRE(closed(Env,MS,X,Y,R)),
	!.

/***********************************************************************
 *
 * assertNames(+Type,+MS,+CT)
 * Arguments: Type   'concept' or 'role'
 *            MS     modal context
 *            T      concept or role term
 * asserts for each concept atom_codes CN in T a fact
 *            conceptName(CN)
 * and for each role atom_codes RN in T a fact
 *            roleName(RN)
 * These facts are used to distinguish concept and role names introduced 
 * by the user from those introduced by the system.
 *
 */

assertNames(Env,MS,CT,Type) :-
	namesInTerm(CT,CNL1,Type),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	hop_map(assertName,[Env,MS,W1,G1],CNL1,_).

assertName((concept,CN1),alreadyAsserted,Env,MS,W1,G1) :-
% If the concept atom_codes is already asserted with identical modal sequence, 
% then we do nothing.
	clause(conceptName(Env,MS,_,CN1),_),
	!.
assertName((role,CN1),alreadyAsserted,Env,MS,W1,G1) :-
% If the role atom_codes is already asserted with identical modal sequence, 
% then we do nothing.
	clause(roleName(Env,MS,_,CN1),_),
	!.
assertName((concept,CN1),newAsserted,Env,MS,W1,G1) :-
% Otherwise we assertzRE the concept atom_codes
% Remember: The fact that the concept atom_codes is not already asserted with
% identical modal sequence does not mean that we are not already able to 
% deduce that the concept atom_codes is present in the modal context corresponding
% to the modal sequence.
	assertzRE((conceptName(Env,MS,W1,CN1) :- G1)),
	!.
assertName((role,CN1),newAsserted,Env,MS,W1,G1) :-
% Otherwise we assertzRE the role atom_codes
% Remember: The fact that the role atom_codes is not already asserted with
% identical modal sequence does not mean that we are not already able to 
% deduce that the role atom_codes is present in the modal context corresponding
% to the modal sequence.
	assertzRE((roleName(Env,MS,W1,CN1) :- G1)),
	!.
	
/***********************************************************************
 *
 * namesInTerm(+T1,-TL+Type) 
 * Arguments: T1     concept or role term
 *            TL     list of pairs (Type1,Name)
 *            Type   'concept' or 'role'
 * TL is the list of all concept and role names in T1.
 *
 */

namesInTerm(and(CTL),CNL,Type) :-
	hop_map(namesInTerm,[Type],CTL,CNLL),
	unionSpecial(CNLL,CNL),
	!.
namesInTerm(or(CTL),CNL,Type) :-
	hop_map(namesInTerm,[Type],CTL,CNLL),
	unionSpecial(CNLL,CNL),
	!.
namesInTerm(some(R,C),L,_) :-
	namesInTerm(R,L1,role),
	namesInTerm(C,L2,concept),
	append(L1,L2,L).
namesInTerm(all(R,C),L,_) :-
	namesInTerm(C,L1,concept),
	namesInTerm(R,L2,role),
	append(L1,L2,L).
namesInTerm(restr(R,C),L,_) :-
	namesInTerm(C,L1,concept),
	namesInTerm(R,L2,role),
	append(L1,L2,L).
namesInTerm(atleast(_N,R),L,_) :-
	namesInTerm(R,L,role).
namesInTerm(atmost(_N,R),L,_) :-
	namesInTerm(R,L,role).
namesInTerm(inverse(R),L,Type) :-
	namesInTerm(R,L,Type).
namesInTerm(not(C),L,Type) :-
	namesInTerm(C,L,Type).
namesInTerm(naf(C),L,Type) :-
	setMooOption(queryCaching,off),
	namesInTerm(C,L,Type).
namesInTerm(b(_O,_P,C),L,Type) :-
	namesInTerm(C,L,Type).
namesInTerm(d(_O,_P,C),L,Type) :-
	namesInTerm(C,L,Type).
namesInTerm(bc(_O,D,C),L,Type) :-
	namesInTerm(D,L1,Type),
	namesInTerm(C,L2,Type),
	append(L1,L2,L).
namesInTerm(dc(_O,D,C),L,Type) :-
	namesInTerm(D,L1,Type),
	namesInTerm(C,L2,Type),
	append(L1,L2,L).
namesInTerm(set(_L),[],_Type) :-
	!.
namesInTerm(L,[(Type,L)],Type) :-
	atomic(L),
	!.



/**********************************************************************
 *
 * @(#) kloneToFOL.pl 1.12@(#)
 *
 */
%------------------------------------------------------------------------------
% Project:      MOTEL 1.0
% Module:       malcToFOL.pl
% Purpose:      Translation of modal KL-ONE terms to first-order logic 
%               formulae to clauses
% Last Change:  27.03.93
% Language:     Prolog
% Author:       Ullrich Hustadt
% Address:      Max-Planck-Institut for Computer Science
%               Im Stadtwald
%               6600 Saarbr"ucken
%               Germany
% Email:        Ullrich.Hustadt@mpi-sb.mpg.de
% Copyright:    (C) 1993 Ullrich Hustadt
% Copying:      This software is provided under the GNU General Public License.
% Warranty:     This is a research prototype. There is absolutely no warranty.
%------------------------------------------------------------------------------

axiomToClause(MC,VL,T1,Op,T2,C) :-
	axiomToFOL(MC,VL,T1,Op,T2,F),
	forallQuantify(VL,F,F1),
	translate(F1,C1),
	clausesToSystemSyntax(C1,C).

forallQuantify([],F,F) :-
	!.
forallQuantify([X|VL],F1,forall(X,F2)) :-
	forallQuantify(VL,F1,F2).

%----------------------------------------------------------------------
% axiomToFOL(+MODALCONTEXT,+VARLIST,+TERM1,+OPERATOR,+TERM2,-FORMULA)
% If OPERATOR is 'equivalent', then FORMULA is the translation of the 
% equivalence of TERM1 and TERM2 in MODALCONTEXT.
% If OPERATOR is 'implies', then FORMULA is the translation of the
% implication of TERM2 by TERM1 in MODALCONTEXT.

axiomToFOL(MC,VL,_,in,C,F) :-
	!,
	isMooOption(translationMode,TM),
	malcToFOL(TM,U,VL,C,F1),
	modalContextToFOL(MC,[],U,F1,F).
axiomToFOL(MC,VL,C1,Op,C2,F) :-
	isMooOption(translationMode,TM),
	malcToFOL(TM,U,VL,C1,F1),
	malcToFOL(TM,U,VL,C2,F2),
	F3 =.. [Op,F1,F2],
	modalContextToFOL(MC,[],U,F3,F).

modalContextToFOL([],V,V,F,F) :-
	!.
modalContextToFOL([b(O,A)|MC],U1,V,F3,
	          forall(U2,implies(rel(X1,X2,U1,U2),F4))) :-
	convertMS(e1,[U1,true],[b(O,A)],[],[U2,(rel(e1,X1,X2,U1,U2), true)],_),
	modalContextToFOL(MC,U2,V,F3,F4).
modalContextToFOL([d(O,A)|MC],U1,V,F3,F4) :-
	convertMS(e1,[U1,true],[d(O,A)],[],
                  [app(W1 : m(O,A), U1),true],_),
	modalContextToFOL(MC,app(typed(W1,m(O,A)),U1),V,F3,F4).
modalContextToFOL([bc(O,C)|MC],U1,V,F3,
	          forall(A,forall(U2,implies(and([F1,rel(X1,m(O,A),U1,U2)]),F4)))) :-
	convertMS(e1,[U1,true],[bc(O,C)],[],
	          [U2,((once(_G),rel(e1,X1,m(O,A),U1,U2)),true)],_),
	isMooOption(translationMode,TM),
	malcToFOL(TM,U1,[A],C,F1),
	modalContextToFOL(MC,U2,V,F3,F4).
modalContextToFOL([dc(O,C)|MC],U1,V,F3,
	          forall(V,and([F1,F4]))) :-
	convertMS(e1,[U1,true],[dc(O,C)],[],
	          [app(W1 : m(O,A), U1),_G],_),
	isMooOption(translationMode,TM),
	malcToFOL(TM,U1,[A],C,F1),
	modalContextToFOL(MC,[app(typed(W1,m(O,A)), U1)],V,F3,F4).


    
%----------------------------------------------------------------------
% malcToFOL(functional,+WORLD,+VARLIST,+TERM,-FORMULA)
% translates TERM in WORLD for VARLIST into the first-order logic 
% formula FORMULA.
%
% Author: Ullrich Hustadt

malcToFOL(Trans,U,[X],and([C1]),F1) :-
	malcToFOL(Trans,U,[X],C1,F1).
malcToFOL(Trans,U,[X],and([C1|CL]),
	   and([F1,F2])) :-
	malcToFOL(Trans,U,[X],C1,F1),
	malcToFOL(Trans,U,[X],and(CL),F2).
malcToFOL(Trans,U,[X],or([C1]),F1) :-
	malcToFOL(Trans,U,[X],C1,F1).
malcToFOL(Trans,U,[X],or([C1|CL]),
	   or([F1,F2])) :-
	malcToFOL(Trans,U,[X],C1,F1),
	malcToFOL(Trans,U,[X],or(CL),F2).
malcToFOL(Trans,U,[X],set(L),F) :-
	!,
	setDisjunction(X,L,F).
malcToFOL(Trans,U,[X],not(C),not(F)) :-
	malcToFOL(Trans,U,[X],C,F),
	!.
malcToFOL(Trans,U,[X],naf(C),naf(F)) :-
	malcToFOL(Trans,U,[X],C,F),
	!.
malcToFOL(Trans,U,[X],all(R,C),
	   forall(Y,implies(F1,F2))) :-
	malcToFOL(Trans,U,[X,Y],R,F1),
	malcToFOL(Trans,U,[Y],C,F2).
malcToFOL(relational,U,[X],some(R,C),
	   exists(Y,and([F1,F2]))) :-
	malcToFOL(relational,U,[X,Y],R,F1),
	malcToFOL(relational,U,[Y],C,F2).
malcToFOL(flatRelational,U,[X],some(R,C),
	   exists(Y,and([F1,F2]))) :-
	malcToFOL(flatRelational,U,[X,Y],R,F1),
	malcToFOL(flatRelational,U,[Y],C,F2).
malcToFOL(functional,U,[X],some(R,C),
	   exists(F,F2)) :-
	malcToFOL(functional,U,[app(fun(F,R),X)],C,F2).
malcToFOL(Trans,U,[X],atleast(N,R),F) :-
	nrToFOL(Trans,U,[X],atleast(N,R),F).
malcToFOL(Trans,U,[X],atmost(N,R),F) :-
	nrToFOL(Trans,U,[X],atmost(N,R),F).
malcToFOL(Trans,U,[X],b(O,A,C2),
           forall(V,implies(rel(O,A,U,V),F))) :-
	malcToFOL(Trans,V,[X],C2,F).    
malcToFOL(relational,U,[X],d(O,A,C2),
	   exists(V,and([rel(O,A,U,V),F]))) :-
	malcToFOL(relational,V,[X],C2,F).
malcToFOL(flatRelational,U,[X],d(O,A,C2),
	   exists(V,and([rel(O,A,U,V),F]))) :-
	malcToFOL(relational,V,[X],C2,F).
malcToFOL(functional,U,[X],d(O,A,C2),
	   exists(W1,F)) :-
	convertMS(e1,[U,true],[d(O,A)],[],[app(W1 : m(O,A), U), true],_),
	malcToFOL(functional,app(typed(W1,m(O,A)),U),[X],C2,F).
malcToFOL(Trans,U,[X],bc(O,C1,C2),
	   forall(A,forall(V,implies(and([F1,rel(O,A,U,V)]),F2)))) :-
        malcToFOL(Trans,U,[A],C1,F1),
	malcToFOL(Trans,V,[X],C2,F2).
malcToFOL(relational,U,[X],dc(O,C1,C2),
	   forall(A,exists(V,and([and([F1,rel(O,A,U,V)]),F2])))) :-
	malcToFOL(relational,U,[A],C1,F1),
	malcToFOL(relational,V,[X],C2,F2).
malcToFOL(flatRelational,U,[X],dc(O,C1,C2),
	   forall(A,exists(V,and([and([F1,rel(O,A,U,V)]),F2])))) :-
	malcToFOL(flatRelational,U,[A],C1,F1),
	malcToFOL(flatRelational,V,[X],C2,F2).
malcToFOL(functional,U,[X],dc(O,C1,C2),
	   forall(A,exists(W1,and([F1,F2])))) :-
	convertMS(e1,[U,true],[d(O,A)],[],[app(W1 : m(O,A), U), true],_),
	malcToFOL(functional,U,[A],C1,F1),
	malcToFOL(functional,app(typed(W1,m(O,A)),U),[X],C2,F2).
malcToFOL(Trans,U,[X],A,F) :-
	atomic(A),
	F =.. [in,U,A,X].
malcToFOL(Trans,U,[X,Y],inverse(R),F) :-
	malcToFOL(Trans,U,[Y,X],R,F).
malcToFOL(Trans,U,[X,Y],and([R1]),F) :-
	!,
	malcToFOL(Trans,U,[X,Y],R1,F).
malcToFOL(Trans,U,[X,Y],and([R1|RL]),
	   and([F1,F2])) :-
	malcToFOL(Trans,U,[X,Y],R1,F1),
	malcToFOL(Trans,U,[X,Y],and(RL),F2).
malcToFOL(Trans,U,[X,Y],or([R1]),F) :-
	!,
	malcToFOL(Trans,U,[X,Y],R1,F).
malcToFOL(Trans,U,[X,Y],or([R1|RL]),
	   or([F1,F2])) :-
	malcToFOL(Trans,U,[X,Y],R1,F1),
	malcToFOL(Trans,U,[X,Y],or(RL),F2).
malcToFOL(Trans,U,[X,Y],restrict(R,C),
	   and([F1,F2])) :-
	malcToFOL(Trans,U,[X,Y],R,F1),
	malcToFOL(Trans,U,[Y],C,F2).
malcToFOL(Trans,U,[X,Y],restr(R,C),
	   and([F1,F2])) :-
	malcToFOL(Trans,U,[X,Y],R,F1),
	malcToFOL(Trans,U,[Y],C,F2).
malcToFOL(relational,U,[X,Y],P,F) :-
	atomic(P),
	F =.. [in,U,P,pair(X,Y)].
malcToFOL(flatRelational,U,[X,Y],P,F) :-
	atomic(P),
	F =.. [in,U,P,X,Y].
malcToFOL(functional,U,[X,Y],P,equal(Y,app(fun(F,P),X))) :-
	atomic(P),
	atomic(X),
	gensym(f,F),
	!.
malcToFOL(functional,U,[X,Y],P,equal(Y,app(fun(F,P),X))) :-
	atomic(P),
	var(X),
	!.
	
	

%----------------------------------------------------------------------
% nrToFOL([+VAR],+NUMBERRESTRICTION,-FORMULA)
% translates NUMBERRESTRICTION into FORMULA for variable VAR.
%
% Author: Ullrich Hustadt

nrToFOL(Trans,U,[X],atmost(0,R),forall(Y,not(F1))) :-
	!,
	malcToFOL(Trans,U,[X,Y],R,F1).
nrToFOL(Trans,U,[X],atmost(M,R),F) :-
	% M >= 1
	N is M+1,
	nVars(N,VarList),
	relConjunction(U,X,VarList,R,F1),
	eqDisjunction(VarList,F2),
	quantify(forall,VarList,implies(F1,F2),F).
nrToFOL(Trans,_U,[_X],atleast(0,_R),true) :-
	!.
nrToFOL(Trans,U,[X],atleast(1,R),exists(Y,F1)) :-
	!,
	malcToFOL(Trans,U,[X,Y],R,F1).
nrToFOL(Trans,U,[X],atleast(N,R),F) :-
	nVars(N,VarList),
	relConjunction(U,X,VarList,R,F1),
	neqConjunction(VarList,F2),
	quantify(exists,VarList,and([F1,F2]),F).

%----------------------------------------------------------------------
% quantify(+QUANTIFIER,+VARLIST,+MATRIX,-FORMULA)
% FORMULA is a formula with a quantifier prefix consisting only of
% quantifiers equal to QUANTIFIER and containing all variables in 
% VARLIST and the matrix of FORMULA is MATRIX.
%
% Author: Ullrich Hustadt

quantify(forall,[Y1],F,forall(Y1,F)) :-
	!.
quantify(forall,[Y1|YL],F,forall(Y1,F3)) :-
	quantify(forall,YL,F,F3).
quantify(exists,[Y1],F,exists(Y1,F)) :-
	!.
quantify(exists,[Y1|YL],F,exists(Y1,F3)) :-
	quantify(exists,YL,F,F3).

%----------------------------------------------------------------------
% setDisjunction(+VAR,+CONSTLIST,-FORMULA)
% FORMULA is a disjunction containing equalities for any pair (VAR,CONST) 
% where CONST is an element of CONSTLIST. CONSTLIST must include atleast
% one element.
%
% Author: Ullrich Hustadt

setDisjunction(X,[],false) :-
	!.
setDisjunction(X,[A],eq(X,A)) :-
	!.
setDisjunction(X,[A|L],or([eq(X,A),F])) :-
	setDisjunction(X,L,F).

%----------------------------------------------------------------------
% eqDisjunction(+VARLIST,-FORMULA)
% FORMULA is a disjunction containing equalities for any pair
% of variables that can be build using variables in VARLIST. VARLIST
% must include at least 2 variables.
%
% Author: Ullrich Hustadt

eqDisjunction([Y1,Y2],F1) :-
	!,
	eqDisjunction(Y1,[Y2],F1),
	!.
eqDisjunction([Y1|YL],or([F1,F2])) :-
	eqDisjunction(Y1,YL,F1),
	eqDisjunction(YL,F2).

eqDisjunction(Y1,[Y2],equal(Y1,Y2)) :-
	!.
eqDisjunction(Y1,[Y2|YL],or([equal(Y1,Y2),F2])) :-
	eqDisjunction(Y1,YL,F2).

%----------------------------------------------------------------------
% neqConjunction(+VARLIST,-FORMULA)
% FORMULA is a conjunction containing inequalities for any pair
% of variables that can be build using variables in VARLIST. VARLIST
% must include at least 2 variables.
%
% Author: Ullrich Hustadt

neqConjunction([Y1,Y2],F1) :-
	!,
	neqConjunction(Y1,[Y2],F1),
	!.
neqConjunction([Y1|YL],and([F1,F2])) :-
	neqConjunction(Y1,YL,F1),
	neqConjunction(YL,F2).

neqConjunction(Y1,[Y2],not(equal(Y1,Y2))) :-
	!.
neqConjunction(Y1,[Y2|YL],and([not(equal(Y1,Y2)),F2])) :-
	neqConjunction(Y1,YL,F2).

%----------------------------------------------------------------------
% relConjunction(+VAR,+VARLIST,+ROLETERM,-FORMULA)
% FORMULA is a conjunction containing the translation of ROLETERM for
% any pair that can be build taking VAR and an element of VARLIST.
%
% Author: Ullrich Hustadt

relConjunction(_U,_X,[],_,true) :-
	!.
relConjunction(U,X,[Y1],R,F) :-
	!,
	isMooOption(translationMode,TM),
	malcToFOL(TM,U,[X,Y1],R,F).
relConjunction(U,X,[Y1|YL],R,and([F1,F2])) :-
	isMooOption(translationMode,TM),
	malcToFOL(TM,U,[X,Y1],R,F1),
	relConjunction(U,X,YL,R,F2).

%----------------------------------------------------------------------
% nVars(+N,-VARLIST)
% VARLIST is a list of N fresh Prolog variables.
%
% Author: Ullrich Hustadt

nVars(0,[]) :-
	!.
nVars(N,[_Y1|VL]) :-
	N >= 1,
	!,
	M is N-1,
	nVars(M,VL).
nVars(_,[]).

%----------------------------------------------------------------------


printSystemSyntax(CL) :-
	isMooOption(prover,P),
	printSystemSyntax(P,CL).

printSystemSyntax(S,[(false <- T1)|CL]) :-
	!,
	write('<- '),
	printSystemSyntax(S,T1),
	write('.'),
	nl,
	printSystemSyntax(CL).
printSystemSyntax(S,[(H1 <- true)|CL]) :-
	!,
	printSystemSyntax(S,H1),
	write(' '),
	write('<- '),
	write('.'),
	nl,
	printSystemSyntax(CL).
printSystemSyntax(scan,[C1|CL]) :-
	!,
	printSystemSyntax(scanClause,C1),
	printSystemSyntax(scan,CL).
printSystemSyntax(scanClause,[-(C1),C2|CL]) :-
	!,
	write('-'),
	printSystemSyntax(scanAtom,C1),
	write(' | '),
	printSystemSyntax(scanClause,[C2|CL]).
printSystemSyntax(scanClause,[C1,C2|CL]) :-
	!,
	printSystemSyntax(scanAtom,C1),
	write(' | '),
	printSystemSyntax(scanClause,[C2|CL]).
printSystemSyntax(scanClause,[-(C1)]) :-
	!,
	write('-'),
	printSystemSyntax(scanAtom,C1),
	write('.'),
	nl.
printSystemSyntax(scanClause,[C1]) :-
	!,
	printSystemSyntax(scanAtom,C1),
	write('.'),
	nl.
printSystemSyntax(scanAtom,app(P,L)) :-
	!,
	print(P),
	write('('),
	print(L),
	write(')').
printSystemSyntax(scanAtom,C1) :-
	!,
	print(C1).
printSystemSyntax(otter,[C1|CL]) :-
	!,
	printSystemSyntax(otterClause,C1),
	printSystemSyntax(otter,CL).
printSystemSyntax(otterClause,[-(C1),C2|CL]) :-
	!,
	write('-'),
	print(C1),
	write(' | '),
	printSystemSyntax(otterClause,[C2|CL]).
printSystemSyntax(otterClause,[C1,C2|CL]) :-
	!,
	print(C1),
	write(' | '),
	printSystemSyntax(otterClause,[C2|CL]).
printSystemSyntax(otterClause,[-(C1)]) :-
	!,
	write('-'),
	print(C1),
	write('.'), 
	nl,
	printSystemSyntax(otter,CL).
printSystemSyntax(S,[C1|CL]) :-
	!,
	print(C1),
	write('.'),
	nl,
	printSystemSyntax(S,CL).
printSystemSyntax(otterClause,[]) :-
	write('.'),
	nl,
	!.
printSystemSyntax(_,[]) :-
	!.
printSystemSyntax(_,CL) :-
	print(CL).


%----------------------------------------------------------------------
% clausesToNHProlog(+CLAUSES,-NHCLAUSES)
% translates CLAUSES which are given in abstract syntax to NHCLAUSES
% which are in near-Horn Prolog syntax.
%
% Author: Ullrich Hustadt


literalsToNHProlog([H1,H2|HL],(H1,HL2)) :-
	literalsToNHProlog([H2|HL],HL2).
literalsToNHProlog([H1],H1) :-
	!.
literalsToNHProlog([],true) :-
	!.

implicationToNHProlog(HL1,[],HL1) :-
	!.
implicationToNHProlog(HL1,TL1,(HL1 :- TL1)) :-
	!.

%----------------------------------------------------------------------
% clausesToLOP(+CLAUSES,-NHCLAUSES)
% translates CLAUSES which are given in abstract syntax to NHCLAUSES
% which are in LOP syntax.
%
% Author: Ullrich Hustadt


clausesToSystemSyntax(CL1,CL2) :-
	isMooOption(prover,setheo),
	clausesToSystemSyntax('LOP',CL1,CL2).
clausesToSystemSyntax(CL1,CL2) :-
	isMooOption(prover,otter),
	clausesToSystemSyntax(otter,CL1,CL2).
clausesToSystemSyntax(CL1,CL1) :-
	isMooOption(prover,decider),
	!.

clausesToSystemSyntax('NHProlog',[cl(HL,TL)|CL],[C2|CL2]) :-
	literalsToNHProlog(HL,HL1),
	literalsToNHProlog(TL,TL1),
	implicationToNHProlog(HL1,TL1,C2),
	clausesToSystemSyntax('NHProlog',CL,CL2).
clausesToSystemSyntax('LOP',[cl(HL0,TL0)|CL],[C2|CL2]) :-
	clauseToSequent(cl(HL0,TL0),HL,TL),
	literalsToLOP(succedent,HL,HL1),
	literalsToLOP(antecedent,TL,TL1),
	implicationToLOP(HL1,TL1,C2),
	clausesToSystemSyntax('LOP',CL,CL2).
clausesToSystemSyntax(otter,[cl(HL0,TL0)|CL],[C2|CL2]) :-
	map(negateLiterals,TL0,TL1),
	append(HL0,TL1,L2),
	literalsToOtter(L2,C2),
	clausesToSystemSyntax(otter,CL,CL2).
clausesToSystemSyntax(_,[],[]).


literalsToOtter([~H1,H2|HL],[- H1| HL2]) :-
	literalsToOtter([H2|HL],HL2).
literalsToOtter([H1,H2|HL],[H1| HL2]) :-
	literalsToOtter([H2|HL],HL2).
literalsToOtter([~H1],[- H1]) :-
	!.
literalsToOtter([H1],[H1]) :-
	!.
literalsToOtter([],true) :-
	!.

clauseToSequent(cl([],TL),HL1,[]) :-
	!,
	map(negateLiterals,TL,HL1).
clauseToSequent(cl(HL,TL),HL,TL) :-
	!.

negateLiterals(~L,L) :-
	!.
negateLiterals(L,~L) :-
	!.

literalsToLOP(antecedent,[H1,H2|HL],(H1,HL2)) :-
	literalsToLOP(antecedent,[H2|HL],HL2).
literalsToLOP(succedent,[H1,H2|HL],(H1;HL2)) :-
	literalsToLOP(succedent,[H2|HL],HL2).
literalsToLOP(_,[H1],H1) :-
	!.
literalsToLOP(_,[],true) :-
	!.

implicationToLOP(HL1,true,(HL1 <- true)) :-
	!.
implicationToLOP(HL1,TL1,(HL1 <- TL1)) :-
	!.


%----------------------------------------------------------------------
% envToFOL(+CLAUSES,-NHCLAUSES)
% translates CLAUSES which are given in abstract syntax to NHCLAUSES
% which are in LOP syntax.
%
% Author: Ullrich Hustadt

envToFOL(Name,CL) :-
	isMooOption(translationMode,flatRelational),
	!,
	translateModalAxioms(Name,CL1),
	translateAxioms(Name,CL2),
	append(CL1,CL2,CL),
	!.
envToFOL(Name,CL) :-
	theory(Name,CLI0),
	map(translateFOLtoClause,CLI0,CLI1),
	clausesToSystemSyntax(CLI1,CL0),
	translateModalAxioms(Name,CL1),
	translateAxioms(Name,CL2),
	append(CL0,CL1,CL01),
	append(CL01,CL2,CL),
	!.

translateModalAxiom([],[]) :-
	!.
translateModalAxiom([[MS,KClass,MOp,concept(C)]|L1],CL) :-
	!,
	malcToFOL(functional,U,[A],C,F1),
	translateClass(KClass,MOp,C,[A],F2),
	modalContextToFOL(MS,[],U,forall(A,implies(F1,F2)),F3),
	translate(F3,C1),
	clausesToSystemSyntax(C1,CL1),
	translateModalAxiom(L1,CL2),
	append(CL1,CL2,CL).
translateModalAxiom([[MS,KClass,MOp,all]|L1],CL) :-
	!,
	translateClass(KClass,MOp,all,[A],F2),
	modalContextToFOL(MC,[],U,forall(A,F2),F3),
	translate(F3,C1),
	clausesToSystemSyntax(C1,CL1),
	translateModalAxiom(L1,CL2),
	append(CL1,CL2,CL).
translateModalAxiom([[MS,KClass,MOp,A]|L1],CL) :-
	!,
	translateClass(KClass,MOp,C,[A],F2),
	modalContextToFOL(MC,[],U,forall(A,F2),F3),
	translate(F3,C1),
	clausesToSystemSyntax(C1,CL1),
	translateModalAxiom(L1,CL2),
	append(CL1,CL2,CL).

translateClass(kd45,MOp,C,[A],
	rel(C,m(MOp,A),B,app(typed(F,m(MOp,A)),D))) :-
	!.
translateClass(k,   MOp,C,[A],
        rel(C,m(MOp,A),B,app(typed(F,m(MOp,A)),B))) :-
	!.
translateClass(kd5, MOp,C,[A],
        and([rel(C,m(MOp,A),app(typed(F1,m(MOp,A)),U),app(typed(F2,m(MOp,A)),V)),
             rel(C,m(MOp,A),U,app(typed(F2,m(MOp,A)),U))])) :-
	!.


translateModalAxioms(Name,CL) :-
	setofOrNil([MS,KClass,MOp,Concept],
                   [X1,B1]^clause(modalAxioms(Name,MS,user,KClass,Concept,MOp,X1),B1),
		   L1),
	translateModalAxiom(L1,CL).

translateAxiom([],[]) :-
	!.
translateAxiom([[A1,A2,A3,A4,A5]|L1],CL) :-
	axiomToClause(A1,A2,A3,A4,A5,CL1),
	translateAxiom(L1,CL2),
	append(CL1,CL2,CL).

translateFOLtoClause(F1,CL) :-
	translate(F1,[CL]).

translateAxioms(Name,CL) :-
	setofOrNil([MS,[A],_,in,C],
	           [X1,Ax,B1]^clause(conceptElement(Name,MS,X1,user,A,C,Ax),B1),
		   L1),
	translateAxiom(L1,CL1),
	setofOrNil([MS,[A,B],_,in,R],
	           [X1,Ax,B1]^clause(roleElement(Name,MS,X1,user,A,B,R,Ax),B1),
		   L2),
	translateAxiom(L2,CL2),
	setofOrNil([MS,[X],CT1,equivalent,CT2],
	           [Ax,B1]^clause(conceptEqualSets(Name,user,MS,CT1,CT2,Ax),B1),
		   L3),
	translateAxiom(L3,CL3),
	setofOrNil([MS,[X],CT1,implies,CT2],
	           [Ax,B1]^clause(conceptSubsets(Name,user,MS,CT1,CT2,Ax),B1),
		   L4),
	translateAxiom(L4,CL4),
	setofOrNil([MS,[X,Y],RN,equivalent,RT],
	           [Ax,B1]^clause(roleEqualSets(Name,user,MS,RN,RT,Ax),B1),
		   L5),
	translateAxiom(L5,CL5),
	setofOrNil([MS,[X,Y],RN,implies,RT],
	           [Ax,B1]^clause(roleSubSets(Name,user,MS,RN,RT,Ax),B1),
		   L6),
	translateAxiom(L6,CL6),
%	closed(Name,MS,X,Y,R),
	append(CL1,CL2,CL12),
	append(CL12,CL3,CL13),
	append(CL13,CL4,CL14),
	append(CL14,CL5,CL15),
	append(CL15,CL6,CL),
	!.


/**********************************************************************
 *
 * @(#) modal.pl 1.7@(#)
 *
 */

modalAxioms(KName,MOp,A) :-
	getCurrentEnvironment(EnvName),
	modalAxioms(EnvName,[],KName,MOp,A).

/**********************************************************************
 *
 * genclass(+Agent,-Class) 
 * classifies Agent to distinguish axioms for a modal operator behaving
 * equally for all agents from axioms for a mutual modal operator.
 *
 */

genclass(_,_,A,A,every,true) :-
	var(A),
	!.
genclass(_,_,all,_,all,true) :-
	!.
genclass(Env,[W1,G1],concept(C),Agent,C,(Body,G1)) :-
	!,
	getQuery(Env,W1,C,Agent,_Exp,Body),
	!.
genclass(_,[W1,G1],A,A,some,G1) :-
	!.

/**********************************************************************
 * 
 * assertMA(+Class,+Head,+WorldGoal,+Goal)
 * asserts the appropriate clause for the given Class. If Class is all,
 * i.e. we are dealing with a mutual modal operator, no world checks 
 * have to be done. Otherwise WorldGoal has to be added to the body of
 * the clause.
 *
 */

assertMA(A1,rel(Env,every,m(MOp,A1),X,Y), WG, G) :-
	var(A1),
	assertaRE((rel(Env,every,m(MOp,A1),X,Y) :- (WG, G))),
	!.
assertMA(all,rel(Env,all,m(MOp,A),X,Y), WG, G) :-
	assertaRE((rel(Env,all,m(MOp,A),X,Y) :-  G)),
	!.
assertMA(A,rel(Env,some,m(MOp,A),X,Y), WG, G) :-
	assertaRE((rel(Env,some,m(MOp,A),X,Y) :- (WG, G))),
	!.
assertMA(concept(_),rel(Env,D,m(MOp,A),X,Y), WG, G) :-
	assertaRE((rel(Env,D,m(MOp,A),X,Y) :- (WG, G))),
	!.


/**********************************************************************
 *
 * modalAxioms(+EnvName,+KripkeClass,+MOp,+Agent)
 * asserts the modal axioms for the modal operator MOp and agent Agent
 * in environment EnvName for KripkeClass.
 *
 */
	
modalAxioms(MS,KName,MOp,A1) :-
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	modalAxioms(EnvName,MS,KName,MOp,A1).
modalAxioms(EnvName,KName,MOp,A1) :-
	environment(EnvName,_,_),
	modalAxioms(EnvName,[],KName,MOp,A1).

modalAxioms(EnvName,MS,k,MOp,A1) :-
	environment(EnvName,Env,_),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	genclass(Env,[W1,G1],A1,A,C,Goal),
	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
	assertMA(A1,
                 rel(Env,C,m(MOp,A),U,app(_FF:m(MOp,A),U)), 
		 (not(not(world(Env,m(MOp,A),U,V)))), 
		 (normalWorld(Env,U), Goal)),
	assertaRE(modalAxioms(Env,MS,user,k,A1,MOp,A)),
	!.
modalAxioms(EnvName,MS,kd45,MOp,A1) :-
	environment(EnvName,Env,_),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	genclass(Env,[W1,G1],A1,A,C,Goal),
	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
	assertMA(A1,
	         rel(Env,C,m(MOp,A),U,app(_FF:m(MOp,A),V)), 
		 (not(not(world(Env,m(MOp,A),U,V)))), 
		 (normalWorld(Env,U), Goal)),
	assertaRE(modalAxioms(Env,MS,user,kd45,A1,MOp,A)),
	!.
modalAxioms(EnvName,MS,kd4e,MOp,A) :-
	modalAxioms(EnvName,kd45,MOp,A).
modalAxioms(EnvName,MS,kd5,MOp,A1) :-
	environment(EnvName,Env,_),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	genclass(Env,[W1,G1],A1,A,C,Goal),
	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
	assertMA(A1,
	         rel(Env,C,m(MOp,A),app(_F1:m(MOp,A),U),app(_F2:m(MOp,A),V)), 
		 ((world(Env,m(MOp,A),U,V), not(U == []))), 
		 Goal),
	assertMA(A1,
	         rel(Env,C,m(MOp,A),U,app(_F2:m(MOp,A),U)), 
		 true, 
		 Goal),
	assertaRE(modalAxioms(Env,MS,user,kd5,A1,MOp,A)),
	!.
modalAxioms(EnvName,MS,kd4,MOp,A1) :-
	environment(EnvName,Env,_),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	genclass(Env,[W1,G1],A1,A,C,Goal),
	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
	assertMA(A1,rel(Env,C,m(MOp,A),U,app(_F1:m(MOp,A),U)), Goal),
	assertMA(A1,rel(Env,C,m(MOp,A),U,app(_F1:m(MOp,A),V)), (world(Env,m(MOp,A),U,V), (rel(Env,_,m(MOp,A),U,V), Goal))),
	assertaRE(modalAxioms(Env,MS,user,k4,A1,MOp,A)),
	!.
modalAxioms(EnvName,MS,kt,MOp,A1) :-
	environment(EnvName,Env,_),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	genclass(Env,[W1,G1],A1,A,C,Goal),
	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
	assertMA(A1,rel(Env,C,m(MOp,A),U,app(_F1:m(MOp,A),U)), Goal),
	assertMA(A1,rel(Env,C,m(MOp,A),U,U), Goal),
	assertaRE(modalAxioms(Env,MS,user,kt,A1,MOp,A)),
	!.

%% new code
%% uh 17.04.94
%% modalAxioms(EnvName,MS,k,MOp,A1) :-
%% 	environment(EnvName,Env,_),
%% 	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
%% 	genclass(Env,[W1,G1],A1,A,C,Goal),
%% 	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
%% 	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
%% 	assertMA(A1,
%%                  rel(Env,C,m(MOp,A),U,app(_FF:m(MOp,A),U)), 
%% 		 (not(not(world(Env,m(MOp,A),W1,U)))),
%% 		 (normalWorld(Env,U), Goal)),
%% 	assertaRE(modalAxioms(Env,MS,user,k,A1,MOp,A)),
%% 	!.
%% modalAxioms(EnvName,MS,kd45,MOp,A1) :-
%% 	environment(EnvName,Env,_),
%% 	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
%% 	genclass(Env,[W1,G1],A1,A,C,Goal),
%% 	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
%% 	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
%% 	assertMA(A1,
%% 	         rel(Env,C,m(MOp,A),V,app(_FF:m(MOp,A),W)), 
%% 		 (not(not((world(Env,m(MOp,A),U,V),
%% 		 world(Env,m(MOp,A),U,W),
%% 		 world(Env,m(MOp,_),[],U))))),
%% 		 true),
%% %	assertMA(A1,
%% %                 rel(Env,C,m(MOp,A),U,app(_FF:m(MOp,A),U)), 
%% %		 (not(not(world(Env,m(MOp,A),U,V)))), 
%% %		 (normalWorld(Env,U), Goal)),
%% 	assertaRE(modalAxioms(Env,MS,user,kd45,A1,MOp,A)),
%% 	!.
%% modalAxioms(EnvName,MS,kd4e,MOp,A) :-
%% 	modalAxioms(EnvName,kd45,MOp,A).
%% modalAxioms(EnvName,MS,kd5,MOp,A1) :-
%% 	environment(EnvName,Env,_),
%% 	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
%% 	genclass(Env,[W1,G1],A1,A,C,Goal),
%% 	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
%% 	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
%% 	assertMA(A1,
%% 	         rel(Env,C,m(MOp,A),app(_F1:m(MOp,A),U),app(_F2:m(MOp,A),V)), 
%% 		 ((world(Env,m(MOp,A),W1,U), 
%% 		   (world(Env,m(MOp,A),W1,V), not(U == [])))), 
%% 		 Goal),
%% 	assertMA(A1,
%% 	         rel(Env,C,m(MOp,A),U,app(_F2:m(MOp,A),U)), 
%% 		 (world(Env,m(MOp,A),W1,U)), 
%% 		 Goal),
%% 	assertaRE(modalAxioms(Env,MS,user,kd5,A1,MOp,A)),
%% 	!.
%% modalAxioms(EnvName,MS,kd4,MOp,A1) :-
%% 	environment(EnvName,Env,_),
%% 	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
%% 	genclass(Env,[W1,G1],A1,A,C,Goal),
%% 	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
%% 	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
%% 	assertMA(A1,
%%                  rel(Env,C,m(MOp,A),U,app(_F1:m(MOp,A),U)), 
%% 		 (world(Env,m(MOp,A),W1,U)),
%% 		 Goal),
%% 	assertMA(A1,
%%                  rel(Env,C,m(MOp,A),U,app(_F1:m(MOp,A),V)), 
%% 	         (world(Env,m(MOp,A),W1,U), 
%% 		  (world(Env,m(MOp,A),W1,V), rel(Env,_,m(MOp,A),U,V))),
%% 		 Goal),
%% 	assertaRE(modalAxioms(Env,MS,user,k4,A1,MOp,A)),
%% 	!.
%% modalAxioms(EnvName,MS,kt,MOp,A1) :-
%% 	environment(EnvName,Env,_),
%% 	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
%% 	genclass(Env,[W1,G1],A1,A,C,Goal),
%% 	retractallSpecial(rel(Env,C,m(MOp,A),_,_)),
%% 	retractallSpecial(modalAxioms(Env,MS,user,_,A1,MOp,A)),
%% 	assertMA(A1,
%% 	         rel(Env,C,m(MOp,A),U,app(_F1:m(MOp,A),U)), 
%% 		 (world(Env,m(MOp,A),W1,U)),
%% 		 Goal),
%% 	assertMA(A1,
%% 	         rel(Env,C,m(MOp,A),U,U), 
%% 		 (world(Env,m(MOp,A),W1,U)),
%% 		 Goal),
%% 	assertaRE(modalAxioms(Env,MS,user,kt,A1,MOp,A)),
%% 	!.

/**********************************************************************
 *
 * normalWorld(+EnvName,+World)
 * succeeds if World is normalWorld, i.e. has a successor.
 *
 */

normalWorld(_,_).

/**********************************************************************
 *
 * world(+EnvName,m(+MOp,+Agent),+WorldSequence) 
 * checks wether or not WorldSequence is a sequence of worlds for
 * modal operator MOp and agent Agent.
 *
 */

world(_Env,m(_MOp,_A),U,U).
world(Env,m(MOp,A),U,app(_FF:m(MOp,A),V)) :-
	world(Env,m(MOp,A),U,V).

worldDepth(W,0) :-
	var(W),
	!.
worldDepth([],0).
worldDepth(app(_FF:m(_MOp,_A),V),N) :-
	worldDepth(V,M),
	N is M+1.

/* append([], List, List).
append([Head|Tail], List, [Head|Rest]) :- 
        append(Tail, List, Rest).

member(Element, [Head|Tail]) :-
	member_(Tail, Head, Element).

% auxiliary to avoid choicepoint for last element
member_(_, Element, Element).
member_([Head|Tail], _, Element) :-
	member_(Tail, Head, Element).

not(Goal) :- 
	call(\+ Goal).
*/

setofOrNil(A,B,C) :-
        (setof(A,B,C) -> true ; C = []).


/**********************************************************************
 *
 * OPTIONS
 *
 */

/***********************************************************************
 *
 * setMooOption(+Option,+Set)
 * set isMooOption Option to valueOfCounter Set.
 *
 */

setMooOption(Option,Set) :-
        retractallSpecial(isMooOption(Option,_)),
        assertaRE(isMooOption(Option,Set)).

/**********************************************************************
 *
 * ifMooOption(+Option,+Set,+Goal)
 * executes Goal if the current valueOfCounter of Option is Set otherwise
 * the predicate suceeds.
 *
 */

ifMooOption(Option,Set,Goal) :-
        (isMooOption(Option,Set) ->
	    call(Goal)
	;
	    true
	).

retractallSpecial(Env,Pred/Arity) :-
        constructHead(Env,Pred/Arity,Head),
        retractallSpecial(Head).


modFindClause([],[]).
modFindClause([CL|T],[CL|Erg1]) :-
	% nur holen was man braucht
	modPositiv(CL,[in(_,_,X)]),
	% tests vorziehen
	var(X),
	modNegativ(CL,[in(_,_,Y)]),
	var(Y), 
	X == Y,!, % nicht da der cut?
	modProofTree(CL,_PT1),
	modFindClause(T,Erg1).
modFindClause([CL|T],[CL|Erg1]) :-
	modPositiv(CL,[in(_,_,X1,Y1)]),
	var(X1),
	var(Y1),	
	modNegativ(CL,[in(_,_,X2,Y2)]),
	var(X2),
	var(Y2),
	X1 == X2,
	Y1 == Y2,!, % hier cut?
	modProofTree(CL,_PT1),
	modFindClause(T,Erg1).
modFindClause([_|T],Erg) :-
	modFindClause(T,Erg).


%---------------------------------------------------------------------------
% modInference(+CLAUSELIST1,-BOOL,-CLAUSELIST2,+LEVEL)
% BOOL is `false' if CLAUSELIST1 is consistent. Otherwise, BOOL is `true'
% and CLAUSELIST2 is a list of clauses which have exactly one positive 
% literal and are a consequence of CLAUSELIST1.
% modInference is a end-recursive predicate.  % falsch, wegen den cuts
% LEVEL is the level of recursion % that has been reached.
%
% Author:      Ullrich Hustadt
% Modified:    94/12/14

modInference(CL1,Bool,CL,stat(N3,N4)) :-
	modForwardSubsumption(CL1,[],[],[],CL2),
	ifMooOption(workingOutput,yes,(length(CL2,N2), write('Starting with '), print(N2), write(' clauses: '),nl,printClauseList(CL2),nl)),
	modInference([],CL2,CL3,Bool,1),
	length(CL3,N3),
	modFindClause(CL3,CL4),
	length(CL4,N4),
	(isMooOption(decider,on) ->
	    CL = CL4
	;
	    CL = CL3
	).

modInference(Set1,Set2,[],Bool,_) :-
% 	append(Set1,Set2,Set3), nicht unn"otig Terme nur zum lesen aufbauen
	(member(cl([],[],_Pt),Set1) ->
	    true
	;
	    member(cl([],[],_Pt),Set2)
	),
	!,
	Bool = false.
modInference(Old,New,Result,Bool,Level) :-
	ifMooOption(workingOutput,yes,(write('Starting modInference on level '),print(Level),nl)),
	ifMooOption(compare,yes,(print('Clauses: '),nl,printClauseList(New))),
	modConsequences(product,Old,New,C1),
	modConsequences(combination,New,New,C2),
	append(Old,New,OldClauses),
	append(C1,C2,NewClauses),
%	ifMooOption(workingOutput,yes,(length(NewClauses,N1), write('Consequences: '),print(N1),nl)),
	ifMooOption(traceOutput,yes,(write('Starting subsumption tests.'),nl,write('Old clauses: '),printClauseList(OldClauses),nl,write('New clauses: '),printClauseList(NewClauses),nl)),
	modForwardSubsumption(NewClauses,OldClauses,[],RemainingOldClauses,NonSubsumedClauses),
	modInferenceCont(RemainingOldClauses,NonSubsumedClauses,Result,Bool,Level).

modInferenceCont(RemainingOldClauses,[],RemainingOldClauses,true,_) :-
	ifMooOption(compare,yes,(print('Final Clauses: '),nl,printClauseList(RemainingOldClauses))).
modInferenceCont(RemainingOldClauses,NonSubsumedClauses,Result,Bool,Level) :-
	NonSubsumedClauses \== [],
	ifMooOption(traceOutput,yes,(length(RemainingOldClauses,N2), write('Remaining old clauses: '),print(N2),nl,printClauseList(RemainingOldClauses),nl)),
        ifMooOption(traceOutput,yes,(length(NonSubsumedClauses,N3),write('Remaining new clauses: '),print(N3),nl,printClauseList(NonSubsumedClauses),nl)),
	M is Level+1,
	modInference(RemainingOldClauses,NonSubsumedClauses,Result,Bool,M).

%---------------------------------------------------------------------------
% modDelete(+ENV,+MS,+CONCEPTROLENAME,+CLAUSELLIST,-LIST)
% LIST is the result of removing CONCEPTROLENAME of CLAUSELLIST 
%
% Author:      Patrick Brandmeier

modDelete(CR,CList,EList) :-
	modDelete([],CR,CList,EList).

modDelete(MS,CR,CList,EList) :-
	currentEnvironment(Env),
	modDelete(Env,MS,CR,CList,EList).

modDelete(Env,_MS,CR,CList,EList) :-
	currentEnvironment(Env), % warum 2mal hintereinander?
	(conceptName(Env,_,_,CR);roleName(Env,_,_,CR)),
	ifMooOption(prover,Prover,true),
	setMooOption(prover,nil),
	modDelete1(CList,CR,EList), % 1st 2nd argument swapped
	setMooOption(prover,Prover).

% first argument indexing -> 1st 2nd swapped
modDelete1([],_CR,[]).
modDelete1([Cl|Cr],CR,Out) :-
	modProofTree(Cl,PTree),
	collect(PTree,List),
	not(modMember(CR,List)),
	% hier soll wohl cut hin, oder?
	!,
	Out = [Cl|Er], % postpone output unification after the cut!
	modDelete1(CR,Cr,Er). % jetzt ist es tailrec
modDelete1([_Cl|Cr],CR,Er) :-
	modDelete1(CR,Cr,Er).

%---------------------------------------------------------------------------
% modSubsumes(+ENV,+MS,+CONCEPTROLENAME1,+CONCEPTROLENAME2,+CLAUSELLIST)
% succeed if CONCEPTROLENAME1 subsumes CONCEPTROLENAME2
%
% Author:      Patrick Brandmeier

modSubsumes(CR1,CR2,CList) :-
	modSubsumes([],CR1,CR2,CList).

modSubsumes(MS,_CR1,_CR2,CList) :-
	currentEnvironment(Env),
	modSubsumes(Env,MS,_CR,CList,_EList).

modSubsumes(Env,_MS,CR1,CR2,CList) :-
	currentEnvironment(Env), % wieder; warum 2x currentEnv
	% ist das exclusiv?
	% wenn ja, dann un"otiger choicepoint
	(conceptName(Env,_,_,CR1);roleName(Env,_,_,CR1)),
	(conceptName(Env,_,_,CR2);roleName(Env,_,_,CR2)),
	ifMooOption(prover,Prover,true),
	setMooOption(prover,nil),
	modSubsumes1(CR1,CR2,CList),  % 1st 2nd swapped (tailrec)
	setMooOption(prover,Prover).

modSubsumes1([Cl|_Cr],CR1,CR2) :-
	modPositiv(Cl,P),
	modPositiv(Cl,N),
	collect(P,List1),
	collect(N,List2),
	modMember(CR1,List1),
	modMember(CR2,List2),
	!.
% modSubsumes1(List,CR1,CR2) :-
modSubsumes1([_|List],CR1,CR2) :-
	write('modified modSubsumes1'),nl,
	modSubsumes1(List,CR1,CR2). % das ist eine Endlos-Schleife
% vermutlich [_|List] im Kopf ?

%---------------------------------------------------------------------------
% modElementOf(+ENV,+MS,+CONCEPTROLENAME1,+CONCEPTROLENAME2,+CLAUSELLIST)
%
% Author:      Patrick Brandmeier

modElementOf(EnvName,MS,X,CT,CList) :-
	currentEnvironment(Env),
	environment(EnvName,Env,_),	
	modSuccList(CT,EnvName,MS,CList,SuccList), % 3rd arg becomes 1st
	modMember(X,SuccList).

modSuccList([],_EnvName,_MS,_CList,Out) :- !,Out = [].
modSuccList([CT|CR],EnvName,MS,CList,SuccList) :-	
	modSuccList(EnvName,MS,CT,CList,SuccList1),
	modSuccList(EnvName,MS,CR,CList,SuccList2),
	unionSpecial(SuccList1,SuccList2,SuccList),
	!.
modSuccList(CT,_EnvName,_MS,CList,SuccList) :-	
	findall(NC,(member(El,CList),modPositiv(El,CT),modNegativ(El,NC)),SuccList),
	!.

modAsk(CR,CList) :-
	modAsk([],CR,CList).

modAsk(MS,CR,CList) :-
	currentEnvironment(Env),
	environment(EnvName,Env,_),
	modAsk(EnvName,MS,CR,CList).

modAsk(EnvName,MS,elementOf(X,CT),_CList) :-
	currentEnvironment(Env),
	environment(EnvName,Env,_),	
% das wird irgendwie immer 2x mal gemacht, warum?
% das ??? ist nicht von mir
%       ???	
        defineEquivalentConceptname(EnvName,MS,CT,query,C),
        convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
        getNegatedConcept(C,C1),
        constructMLMark(rn(_AN5,_RN5,_S5,_O5),W1,C1,X,_HYPS,_D1,_InHead1),
        getQuery(Env,W1,C,X,_Exp,Goal),
        performQuery(X,G1,Goal),
        allowedAnswerConcept(Env,C).
%       ????   


%---------------------------------------------------------------------------
% modAnd(+BOOL1,+BOOL2,-BOOL3)
% BOOL3 is the logical conjunction of the boolean values BOOL1 and BOOL2.
%
% Author:      Ullrich Hustadt

modAnd(false,_,false).
modAnd(true,X,X).


%---------------------------------------------------------------------------
% modJoin(+LIST1,+LIST2,-LIST3)
% If LIST1 and LIST2 are not syntactically equal, LIST3 is the result of 
% appending LIST2 to LIST1. Otherwise, LIST3 is LIST1.
%
% Author:      Ullrich Hustadt

modJoin(CL1,CL2,CL1) :-
	CL1 == CL2,
	!.
modJoin(CL1,CL2,CL3) :-
	append(CL1,CL2,CL3).

%---------------------------------------------------------------------------
% modPositiv(+Clause,-Positiv) 
% Returns the positiv of the clause
% modNegativ(+Clause,-Negativ) 
% Returns the negativ of the clause
% modProofTree(+Clause,-ProovTree)
% Returns the proof-tree of the clause
%
% Author:      Ullrich Hustadt

% vermeide unn"otige Variablen, niemals cut (nur eine Klausel)
modPositiv(C,P) :- arg(1,C,P).
modNegativ(C,N) :- arg(2,C,N).
modProofTree(cl(_,_,char(PT,_,_)),PT).
modProofTree(cl(_,_,PT),PT) :-
	atomic(PT).
modNewArgOfClause(cl(_,_,char(_,Arg1,Arg2)),Arg1,Arg2).


printClauseList([]) :- nl.
printClauseList([C|CL]) :-
	write('Clause: '),
	print(C),
	nl,
	printClauseList(CL).

% Klauseln aus RList sollen mit allen Klauseln aus LList resolviert werden
% zwei cuts in einer Klausel => fast immer was nicht ok
% cut am Angang definitiv unn"otig
modConsequences(Type,LList,RList,Consequences) :-
	ifMooOption(traceOutput,yes,(write('Starting modConsequences.'),nl)),
	ifMooOption(traceOutput,yes,(length(LList,N1), length(RList,N2), write('Starting outer loop with '),print(N2),write(' on '), print(N1),write(' clauses.'),nl)),
	modSetfactor(LList,Factors),
	ifMooOption(traceOutput,yes,(length(Factors,N3), write('Number of factors '),print(N3),nl)),
        modRemoveTaut(Factors,NonTautologicalFactors),
	all_maxlits_all_clauses(LList,LListMax),
	all_maxlits_all_clauses(RList,RListMax),
	modSetproduct0(Type,LListMax,RListMax,Resolvents),
	ifMooOption(traceOutput,yes,(length(Resolvents,N4), write('Number of resolvents '), print(N4),nl)),
	modRemoveTaut(Resolvents,NonTautologicalResolvents),
	append(NonTautologicalFactors,NonTautologicalResolvents,Consequences).

%---------------------------------------------------------------------------
% all_maxlits_all_clauses(+CLAUSELIST1,ECLAUSELIST2)
% ECLAUSELIST2 will be a list of clauses where each clause is of the form
% cl(PLits,NLits,PT)-maxlits(MPLits,MNLits)
% such that MPLits is the list of maximal positive literals in the clause,
% and MNLits is the list of maximal negative literals in the clause.
%
% Author:      Peter Barth

all_maxlits_all_clauses([],[]).
all_maxlits_all_clauses([Clause|List],[Clause-MaxLits|ListMax]) :-
	find_maximal_literals(Clause,MaxLits),
	ifMooOption(traceOutput,yes,(write('Maximal literals '), print(MaxLits), write(' in '), print(Clause), nl)),
	all_maxlits_all_clauses(List,ListMax).
	
%---------------------------------------------------------------------------
% modSetfactor(+CLAUSES,-FACTORS)
% FACTORS is the list of all factors of clauses in CLAUSES
% with respect to order-restricted factoring.
%
% Author:      Ullrich Hustadt
% Modified:    95/02/03 Peter Barth
% Description: Ullrich Hustadt

modSetfactor([],[]).
modSetfactor([Clause|ClauseList],FactorList) :-
        setofOrNil(Factor,maximalFactor(Clause,Factor),FactorList1),
	% !, % setof is det!
	modSetfactor(ClauseList,FactorList2), % nicht tailrek (acc passing)
	append(FactorList1,FactorList2,FactorList).

%---------------------------------------------------------------------------
% modSetproduct0(+CLAUSELIST1,+CLAUSELIST2,-RESOLVENTS)
% RESOLVENTS is the list of all resolvents of clauses in CLAUSELIST1
% and CLAUSELIST2 with respect to order-restricted resolution.
%
% Author:      Ullrich Hustadt
% Modified:    95/02/03 Peter Barth
% Description: Ullrich Hustadt

modSetproduct0(_,[], _, []) :-
	ifMooOption(traceOutput,yes,(nl,write('Ended outer loop.'),nl)).
modSetproduct0(product,[Head-MLitsHead|Tail], Set, Result) :-
%	ifMooOption(traceOutput,yes,(length(Set,N),write('Starting inner loop for '),print(Head),write(' with '),print(N),nl)),
        modSetproduct(Set, Head, MLitsHead, Result1),
        modSetproduct0(product,Tail, Set, Result2),
	append(Result1,Result2, Result).
modSetproduct0(combination,[Head-MLitsHead|Tail], [C1|Set], Result) :-
	ifMooOption(workingOutput,yes,(write('Computing all resolvents with '),print(Head),nl)),
        modSetproduct([C1|Set], Head, MLitsHead, Result1),
        modSetproduct0(combination,Tail, Set, Result2),
	append(Result1,Result2, Result).
 
%---------------------------------------------------------------------------
% modSetproduct(+CLAUSELIST1,+CLAUSE,+MAXLITS,-RESOLVENTS)
% RESOLVENTS is the list of all resolvents of clauses in CLAUSELIST1 with 
% CLAUSE (which contains MAXLITS as maximal literals) with respect to 
% order-restricted resolution.
%
% Author:      Ullrich Hustadt
% Modified:    95/02/03 Peter Barth
% Description: Ullrich Hustadt

modSetproduct([], _X, _, []).
%	ifMooOption(traceOutput,yes,(nl,write('Ended inner loop for '),print(X),nl)).
modSetproduct([Head-MLitsHead|Tail], X, MLitsX, Erg) :-
%% Removed uh 03.02.95
%%	not(modClEqual(Head,X)),
	setofOrNil(Res3,maximalResolvent(X,MLitsX,Head,MLitsHead,Res3),Resolvents),
        modSetproduct(Tail, X, MLitsX, TailX),
	append(Resolvents,TailX,Erg).


%---------------------------------------------------------------------------
% find_maximal_literals(+CLAUSE1,maxlits(+MPLITS,+MNLITS))
% MPLITS will be the list of maximal positive literals in CLAUSE1,
% MNLITS will be the list of maximal negative literals in CLAUSE1.
%
% Author:      Peter Barth

find_maximal_literals(Clause,maxlits(MlitsP,MlitsN)) :-
	modPositiv(Clause,P),
	setofOrNil(ML,maximal_literal(P,Clause,ML),MlitsP),
	modNegativ(Clause,N),
	setofOrNil(ML,maximal_literal(N,Clause,ML),MlitsN).

maximal_literal(Ls,C,Lit) :-
	member(Lit,Ls),
	modMaximalLiteral(Lit,C).

modRemoveEqualLit([],[]) :-
	!.
modRemoveEqualLit([cl(PTerm,NTerm,PTree)|Cl],[cl(C1,C2,PTree)|CLR]) :-
	modRemoveEqualLit1(PTerm,C1),
	modRemoveEqualLit1(NTerm,C2),
	!,
	modRemoveEqualLit(Cl,CLR).
modRemoveEqualLit1([H],[H]) :-
	!.
modRemoveEqualLit1([Head|Tail],Erg) :-
	modMember(Head,Tail),
	!,
	modRemoveEqualLit1(Tail,Erg).
modRemoveEqualLit1([Head|Tail],[Head|Erg]) :-
	modRemoveEqualLit1(Tail,Erg).


%---------------------------------------------------------------------------
% modBackwardSubsumption(+CLAUSELIST1,+CLAUSELIST2,-CLAUSELIST3)
% CLAUSELIST3 will be the list of all clauses in CLAUSELIST1 which are not
% subsumed by clauses in CLAUSELIST2.
%
% Author:      Ullrich Hustadt

modBackwardSubsumption([],_NewClauses,[]).
modBackwardSubsumption([OldClause|OldClauses],NewClauses,AllClauses) :-
	modFindSubsumingClause(NewClauses,OldClause),!,
	modBackwardSubsumption(OldClauses,NewClauses,AllClauses).
modBackwardSubsumption([OldClause|OldClauses],NewClauses,[OldClause|AllClauses]) :-
	modBackwardSubsumption(OldClauses,NewClauses,AllClauses).

%---------------------------------------------------------------------------
% modForwardSubsumption(+CLAUSELIST1,+CLAUSELIST2,-CLAUSELIST3)
% CLAUSELIST3 will be the list of all clauses in CLAUSELIST2 which are not
% subsumed by clauses in CLAUSELIST1.
%
% Author:      Ullrich Hustadt

modForwardSubsumption([],OldClauses,ProductiveNewClauses,OldClauses,ProductiveNewClauses) :-
	ifMooOption(traceOutput,yes,nl).
modForwardSubsumption([NewClause|NewClauses],OldClauses0,ProductiveNewClauses,OldClauses1,NewClauses1) :-
	ifMooOption(workingOutput,yes,(write('S'),ttyflush)),	
	(
	    modFindSubsumingClause(ProductiveNewClauses,NewClause)
	;
	    modFindSubsumingClause(OldClauses0,NewClause)
	),
	!,
	modForwardSubsumption(NewClauses,OldClauses0,ProductiveNewClauses,OldClauses1,NewClauses1).
modForwardSubsumption([NewClause|NewClauses],OldClauses0,ProductiveNewClauses0,OldClauses2,NewClauses2) :-
%	ifMooOption(traceOutput,yes,(write('B('),ttyflush)),
	modBackwardSubsumption(OldClauses0,[NewClause],OldClauses1),
	modBackwardSubsumption(ProductiveNewClauses0,[NewClause],ProductiveNewClauses1),
%	ifMooOption(traceOutput,yes,(write(')B'),ttyflush)),
	modForwardSubsumption(NewClauses,OldClauses1,[NewClause|ProductiveNewClauses1],OldClauses2,NewClauses2).


%---------------------------------------------------------------------------
% modExtractCR(+CLAUSE1,-CLAUSE2)
% Clause2 is the list of Concept-Role-Name in CLAUSE1
%
% Author:  Patrick Brandmeier

modExtract(Cl,P1,N1) :-
	modPositiv(Cl,P),
	modNegativ(Cl,N),
	modExtractCR(P,P1),
	modExtractCR(N,N1).

modExtractCR([],[]) :-
	!.
modExtractCR([H|T],[L1|L]) :-
	modExtractCR1(H,L1),
	modExtractCR(T,L),
	!.
modExtractCR1(in(_,L1,_),L1).
modExtractCR1(in(_,L1,_,_),L1).

modExtractSkolem(Pos,Neg,Skol) :-
	modExtractSkolem(Pos,Skol1),
	modExtractSkolem(Neg,Skol2),
	modUnion(Skol1,Skol2,Skol).
modExtractSkolem([],[]).
modExtractSkolem([H|T],L) :-
	modExtractSkolem1(H,L1),	
	modExtractSkolem(T,L2),
	modUnion(L1,L2,L).

modExtractSkolem1(in(_,_,Var),[]) :-
	(var(Var);atom(Var)).
modExtractSkolem1(in(_,_,Var),[S]) :-
	nonvar(Var),
	functor(Var,S,_).
modExtractSkolem1(in(_,_,Var,Var1),S) :-
	((var(Var1);atom(Var1)) ->
	    S = [];
	    (functor(Var1,S1,_),S = [S1])).


modSubsumes(C,D) :-
%	ifMooOption(traceOutput,yes,(write('Test if '), print(C), write(' subsumes '), print(D), nl)),
	modNewArgOfClause(C,[PTC,NTC],Skol1),  % ?
	modNewArgOfClause(D,[PTD,NTD],Skol2),  % ?
	subsetSpecial(PTC,PTD),subsetSpecial(NTC,NTD),  % ?
	subsetSpecial(Skol1,Skol2),  % ?
	modPositiv(D,PD),modNegativ(D,ND),
%	modPositiv(C,PC),modNegativ(C,NC),
%	copy_term(cl(PC,NC),cl(PC0,NC0)),
	modPositiv(C,PC0),modNegativ(C,NC0),
	ground_copy(cl(PD,ND),cl(PD0,ND0)),
	ifMooOption(traceOutput,yes,(write('Ground Term D: '),print(D), nl)),
	!,
	not(not((newStillman(PC0,PD0),newStillman(NC0,ND0)))),
	ifMooOption(traceOutput,yes,(write('Answer is positive.'), nl)).
%       stillman(NC0,ND0,1,1).
%	stillman(PC0,PD0,1,1),

my_stillman(C1,C2,D1,D2) :-
	((newStillman(C1,D1),newStillman(C2,D2)) ->
	    (not(not((newStillman(C1,D1),newStillman(C2,D2)))) ->
		true;
		(write('stillman'),write(C1),write(C2),write(D1),write(D2),nl,fail));
            (not(not((newStillman(C1,D1),newStillman(C2,D2)))) ->
		(write('stillman'),write(C1),write(C2),write(D1),write(D2),nl,fail);
		fail)).
	

stillman(ArgC,ArgD,I,J) :-
	length(ArgD,K),
	not(J > K),
	!,
	stillman1(A,I,J,K,ArgC,ArgD),
	((length(ArgC,I);(I1 is I+1,stillman(ArgC,ArgD,I1,1))) ->
	    true;
	    (A1 is  A + 1,stillman(ArgC,ArgD,I,A1))).
stillman1(A,I,A,K,ArgC,ArgD) :-
	not(A > K),
	!,
	((modNth(I,ArgC,LC),modNth(A,ArgD,LC)) ->
	    NA = A;
	    (A1 is A+1,stillman1(NA,I,A1,K,ArgC,ArgD))).

newStillman([],ArgD) :- !.
newStillman([LitC|R],ArgD) :-
	newStillman1(LitC,ArgD),
	!,
	newStillman(R,ArgD).

newStillman1(LitC,[LitD|R]) :-
	((LitC = LitD) ->
	    !;
	    newStillman1(LitC,R)).

modNth(1,[H|_T],H) :- !.
modNth(Nr,[_|T],E) :-
	Nr1 is Nr - 1,
	modNth(Nr1,T,E).


%---------------------------------------------------------------------------
% modFindSubsumingClause(+CLAUSE1,+CLAUSELIST)
% true iff CLAUSELIST contains a clause subsuming CLAUSE1.
%
% Author:      Ullrich Hustadt

%modFindSubsumingClause(_Clause,[]) :-
%	!,
%	ifMooOption(traceOutput,yes,(write('found nothing.'), nl)),
%	fail.

%modFindSubsumingClause([Clause2|ClauseList],Clause1) :-
%	modProofTree(Clause2,PT2),
%	modProofTree(Clause1,PT1),
%	not(subsetSpecial(PT2,PT1)),
%	!,
%	(modFindSubsumingClause(ClauseList,Clause1)->
%	    true;
%	    modSubsumes(Clause2,Clause1)).

modFindSubsumingClause([Clause2|_ClauseList],Clause1) :-
%	modNewArgOfClause(Clause2,[PosL2,NegL2],Skol2),   % ?
%	modNewArgOfClause(Clause1,[PosL1,NegL1],Skol1),  % ?
%	subsetSpecial(PosL2,PosL1), subsetSpecial(NegL2,NegL1),  % ?
%	subsetSpecial(Skol2,Skol1),  % ?
%	!,  % ?
	modSubsumes(Clause2,Clause1).
	ifMooOption(traceOutput,yes,(write('Subsumption:'),nl,print(Clause2),write(' subsumes '),nl,print(Clause1),nl)).

modFindSubsumingClause([_Clause2|ClauseList],Clause1) :-
	modFindSubsumingClause(ClauseList,Clause1).


%---------------------------------------------------------------------------
% modClSubsumes(+CLAUSE1,+CLAUSE2)
% true iff CLAUSE1 subsumes CLAUSE2.
%
% Author:      Patrick Brandmeier
% Modified:    94/12/13 Ullrich Hustadt
%              95/02/03 Peter Barth					
% Description: Ullrich Hustadt


modOldSubsumes(CL1,CL2) :-
	modSubsumes_maybe(CL1,CL2),
	ground_copy(CL2,cl(P21,N21,PT21)),
	% The clause cl(P21,N21,PT21) is negated by turning it into cl(N21,P21,PT21)
	modLiteralsToClauses(cl(N21,P21,PT21),ClauseList),
%	ifMooOption(traceOutput,yes,(write('Test if '), print(cl(P1,N1)), write(' subsumes '), print(cl(P2,N2)), nl)),
%	write('?'),ttyflush,
	modSubsumptionTest(ClauseList,[CL1],Result),
	Result == true.
%	write('S'),ttyflush.
%	ifMooOption(traceOutput,yes,(write('Answer is positive.'), nl)),

modSubsumes_maybe(CL1,CL2) :-
	modPositiv(CL1,P1),
	modNegativ(CL1,N1),
	modPositiv(CL2,P2),
	modNegativ(CL2,N2),
	all_maybe_unifiable(P1,P2),
	all_maybe_unifiable(N1,N2).

all_maybe_unifiable([],_).
all_maybe_unifiable([Lit|Lits],ULits) :-
	one_maybe_unifiable(ULits,Lit),
	all_maybe_unifiable(Lits,ULits).

one_maybe_unifiable([Lit0|_Lits],Lit1) :-
	maybe_unifiable(Lit0,Lit1),!.
one_maybe_unifiable([_Lit0|Lits],Lit1) :-
	one_maybe_unifiable(Lits,Lit1).

%---------------------------------------------------------------------------
% modSubsumptionTest(+CLAUSELIST1,+CLAUSELIST2,-RESULT)
% tries to derive the empty clause from CLAUSELIST1 and CLAUSELIST2
% (see the description of a subsumption algorithm in [Chang and Lee, 1973]
% RESULT is instantiated by `true' if the empty clause can be derived.
% Otherwise, RESULT is instantiated by `false'.
%
% Author:      Ullrich Hustadt
% Description: Ullrich Hustadt

modSubsumptionTest(_W,U,Result) :-
	member(cl([],[],_),U),
	!,
	% cl(P1,N1,_) subsumes cl(P2,N2,_)
	Result = true.
modSubsumptionTest(_W,[],Result) :-
	!,
	% cl(P1,N1,_) does not subsume cl(P2,N2,_)
	Result = false.
modSubsumptionTest(W,U1,Result) :-
	modAllResolvents(W,U1,U2),
	modSubsumptionTest(W,U2,Result).

%---------------------------------------------------------------------------
% modAllResolvents(+CLAUSELIST1,+CLAUSELIST2,-CLAUSELIST3)
% CLAUSELIST3 is the list all resolvents of all pairs of clauses CLAUSE1 and 
% CLAUSE2 where CLAUSE1 is taken from CLAUSELIST1 and CLAUSE2 is taken from 
% CLAUSELIST2.
%
% Author:      Ullrich Hustadt
% Description: Ullrich Hustadt

modAllResolvents(CL1,CL2,Res) :-
	modAllResolvents(CL1,CL2,[],Res).

modAllResolvents([],_,Res,Res).
modAllResolvents([C|CL1],CL2,Res0,Res2) :-
	modAllResolvents1(CL2,C,Res0,Res1),
	modAllResolvents(CL1,CL2,Res1,Res2).

modAllResolvents1([],_,Res,Res).
modAllResolvents1([C1|CL1],C2,Res0,Res2) :-
	setofOrNil(C3,classicalResolvent(C1,C2,C3),U2),
	append(U2,Res0,Res1),
	modAllResolvents1(CL1,C2,Res1,Res2).
	

classicalResolvent(cl(P1,N1,char(PT1,A1,A2)),cl(P2,N2,char(PT2,B1,B2)),cl(E1,E2,char(PT3,[C1,C2],C3))) :-
	find_maybe_unifiable(P1,N2,L1,L2),
	modReplaceVar(variants(L1,L2,P1,N1,P2,N2),variants(L11,L21,P11,N11,P21,N21)),
	modUnify(L11,L21),
	modSubtract(P11,[L11],C),
	modSubtract(N21,[L21],D), 
	modUnion(C,P21,E1),
	modUnion(D,N11,E2),
	modUnion(PT1,PT2,PT3),
	modExtractSkolem(E1,E2,C3),
	modExtractCR(E1,C1),
	modExtractCR(E2,C2),
	!.
classicalResolvent(cl(P1,N1,char(PT1,A1,A2)),cl(P2,N2,char(PT2,B1,B2)),cl(E1,E2,char(PT3,[C1,C2],C3))) :-
	find_maybe_unifiable(P2,N1,L1,L2),
	modReplaceVar(variants(L1,L2,P1,N1,P2,N2),variants(L11,L21,P11,N11,P21,N21)),
	modUnify(L11,L21),
	modSubtract(P21,[L21],C),
	modSubtract(N11,[L11],D), 
	modUnion(C,P11,E1),
	modUnion(D,N21,E2),
	modUnion(PT1,PT2,PT3),
	modExtractCR(E1,C1),
	modExtractCR(E2,C2),
	modExtractSkolem(E1,E2,C3),
	!.

%---------------------------------------------------------------------------
% modLiteralsToClauses(CLAUSE1,CLAUSELIST)
% negate the clause CLAUSE1 and turns each literal in CLAUSE1 into a 
% clause. The resulting list of clauses is CLAUSELIST.
%
% Author:      Patrick Brandmeier
% Description: Ullrich Hustadt

modLiteralsToClauses(Cl,PCL) :-
	modPositiv(Cl,P),
	modNegativ(Cl,N),
	modPositiveLiteralsToClauses(P,PCL,NCL),
	modNegativeLiteralsToClauses(N,NCL).

% holes (difference lists!)
modPositiveLiteralsToClauses([],Tail,Tail).
modPositiveLiteralsToClauses([H|T],[cl([H],[],_)|T1],Tail) :-
	modPositiveLiteralsToClauses(T,T1,Tail).

modNegativeLiteralsToClauses([],[]).
modNegativeLiteralsToClauses([H|T],[cl([],[H],_)|T1]) :-
	modNegativeLiteralsToClauses(T,T1).


%---------------------------------------------------------------------------
% modClReplaceVarWithAtom(CLAUSE,VARLIST,NUMBER)
% CLAUSE is a clause and VARLIST is a list of VAR1-VAR2 where VAR1 
% and VAR2 are Prolog variables, such that VAR2 occurs in CLAUSE. Every such 
% variable VAR2 is unified with a fresh constant. As a side effect, a ground 
% instance of CLAUSE is computed.
% To generate a fresh constant, the integer NUMBER is used and incremented
% every time it has been used.
%
% Author:      Patrick Brandmeier
% Description: Ullrich Hustadt

modClReplaceVarWithAtom([],_C,_).
modClReplaceVarWithAtom([_-New|T],C,M) :-
	genconstant(M,New,N),
	modClReplaceVarWithAtom(T,C,N).

genconstant(M,V,N) :-
	N is M+1,
	atom_codes(M,N1),
	atom_codes(V,[0's|N1]).

modRemoveTaut([],[]) :-
	!.
modRemoveTaut([CL1|CL],CLN) :-
	modPositiv(CL1,PL),
	modNegativ(CL1,NL),
	modProofTree(CL1,_PT),
%	ifMooOption(traceOutput,yes,(write('Trying to remove '),print(cl(PL,NL,PT)))),
	member(P,PL),
	member(N,NL),
	not(not(modVariant(P,N))),
	!,
%	ifMooOption(traceOutput,yes,(write(' succeeded.'),nl)),
	modRemoveTaut(CL,CLN).
modRemoveTaut([CL1|CL],[CL1|CLN]) :-
	!,
%	ifMooOption(traceOutput,yes,(write(' failed.'),nl)),
	modRemoveTaut(CL,CLN).

%---------------------------------------------------------------------------
% maximalFactor(+CLAUSE1,-CLAUSE2)
% CLAUSE2 is a factor of CLAUSE1
%
% Author:      Patrick Brandmeier
% Modified:    94/12/13 Ullrich Hustadt
% Description: Ullrich Hustadt

maximalFactor(cl(PLL,NLL,PT),cl(C1,C2,PT)) :-
	modFactorLiteralList(cl(PLL,NLL,PT),PLL,C1), 
	modFactorLiteralList(cl(PLL,NLL,PT),NLL,C2), 
	% check whether the C1 is actually a factor of PLL, i.e. C1 has to
        % be shorther than PLL. Do the same for NLL and C2.
	length(PLL,LengthPLL),
	length(NLL,LengthNLL),
	length(C1,LengthC1),
	length(C2,LengthC2),
	hasChanged(LengthPLL,LengthC1,LengthNLL,LengthC2).

hasChanged(L1,NL1,_L2,_NL2) :-
	L1 \== NL1,
	!.
hasChanged(_L1,_NL1,L2,NL2) :-
	L2 \== NL2,
	!.


modFactorLiteralList(cl(PLL,NLL,PT),[H|T],LiteralList) :-
	memberAndPos(L1,[H|T],PosL1),
	modMaximalLiteral(L1,cl(PLL,NLL,PT)),
	memberAndPos(L2,[H|T],PosL2),
	PosL1 \== PosL2,
	modFactorLiterals([H|T],L1,L2,LiteralList),
	!.
modFactorLiteralList(_,LiteralList,LiteralList) :-
	!.
 
modFactorLiterals(LiteralList,Literal1,Literal2,ResultList) :-
	modUnify(Literal1,Literal2),
	modSubtract(LiteralList,[Literal2],DifferenceList),
	modUnion(DifferenceList,[Literal1],ResultList),
	!.

memberAndPos(X,[X|_],0).
memberAndPos(X,[_|L],N) :-
	memberAndPos(X,L,M),
	N is M+1.

%---------------------------------------------------------------------------
% maximalResolvent(+CLAUSE1,+MLits1,+CLAUSE2,+MLits2,-CLAUSE3)
% CLAUSE3 is a resolvent of CLAUSE1 and CLAUSE2 such that the resolvent 
% literals are maximal in the respective clauses.
%
% Author:      Patrick Brandmeier
% Modified:    94/12/13 Ullrich Hustadt
% Description: Ullrich Hustadt

maximalResolvent(CL1,ML1,CL2,ML2,cl(E1,E2,char(PT3,[CLEP,CLEN],Ar2))) :-
	arg(1,ML1,MP1),
	arg(2,ML2,MN2),
%	write('from '),write(MP1),write(' and '),write(MN2),nl,
	find_maybe_unifiable(MP1,MN2,L1,L2),   
	modPositiv(CL1,P1),
	modPositiv(CL2,P2),
	modNegativ(CL1,N1),
	modNegativ(CL2,N2),
	modProofTree(CL1,PT1),
	modProofTree(CL2,PT2),
	modUnion(PT1,PT2,PT3),
	modReplaceVar(variants(L1,L2,P1,N1,P2,N2),variants(L11,L21,P11,N11,P21,N21)),
	L11 = L21,
%	modUnify(L11,L21),
	modSubtract(P11,[L11],C),
	modSubtract(N21,[L21],D), 
	modUnion(C,P21,E1),
	modUnion(D,N11,E2),
	modExtractCR(E1,CLEP),
	modExtractCR(E2,CLEN),
	modExtractSkolem(E1,E2,Ar2),
	ifMooOption(traceOutput,yes,(write('Resolved '), print(CL1), nl, write(' and '),print(CL2),nl,write(' on '), print(L1), write(' and '), print(L2), nl, write('getting '), print(cl(E1,E2,char(PT3,[CLEP,CLEN],Ar2))),nl)).
%	write('selected '),write(L1),write(' with '),write(L2),nl,
%	write('P'),ttyflush.
maximalResolvent(CL1,ML1,CL2,ML2,cl(E1,E2,char(PT3,[CLEP,CLEN],Ar2))) :-
	arg(2,ML1,MN1),
	arg(1,ML2,MP2),
%	write('from '),write(MN1),write(' and '),write(MP2),nl,
	find_maybe_unifiable(MN1,MP2,L1,L2),   
	modPositiv(CL1,P1),
	modPositiv(CL2,P2),
	modNegativ(CL1,N1),
	modNegativ(CL2,N2),
	modProofTree(CL1,PT1),
	modProofTree(CL2,PT2),
	modUnion(PT1,PT2,PT3),
	modReplaceVar(variants(L1,L2,P1,N1,P2,N2),variants(L11,L21,P11,N11,P21,N21)),
	L11 = L21,
%	modUnify(L11,L21),
	modSubtract(P21,[L21],C),
	modSubtract(N11,[L11],D), 
	modUnion(C,P11,E1),
	modUnion(D,N21,E2),
	modExtractCR(E1,CLEP),
	modExtractCR(E2,CLEN),
	modExtractSkolem(E1,E2,Ar2),
	ifMooOption(traceOutput,yes,(write('Resolved '), print(CL1), nl, write(' and '),print(CL2),nl,write(' on '), print(L1), write(' and '), print(L2), nl, write('getting '), print(cl(E1,E2,char(PT3,[CLEP,CLEN],Ar2))),nl)).
%	write('from '),write(MN1),write(' and '),write(MP2),nl,
%	write('selected '),write(L1),write(' with '),write(L2),nl,
%	write('N'),ttyflush.


%---------------------------------------------------------------------------
% modMaximalLiteral(+LITERAL,+CLAUSE)
% true iff LITERAL covers all literals in CLAUSE.
%
% Author:      Patrick Brandmeier
% Modified:    94/12/13 Ullrich Hustadt
% Description: Ullrich Hustadt

modMaximalLiteral(L1,cl(PLL,NLL,_PT)) :-
	modMaximalLiteralList(PLL,L1),
	modMaximalLiteralList(NLL,L1).

modMaximalLiteralList([],_A).
modMaximalLiteralList([H|T],A) :-
	modLiteralCovers(A,H),
	modMaximalLiteralList(T,A).

modLiteralCovers(A,B) :-
	functor(A,_,AA),
	functor(B,_,AB),
	modLiteralCovers(A,B,AA,AB).

modLiteralCovers(_A,_B,_,0) :- !.
modLiteralCovers(A,B,AA,AB) :-
	arg(AB,B,SB),
	modLiteralCoversSB(A,SB,AA),
	AB1 is AB-1,
	modLiteralCovers(A,B,AA,AB1).
	
modLiteralCoversSB(A,SB,AA) :-
	AA >= 1,
	arg(AA,A,SA),
	(do_CoversTermtest(SA,SB) ->
	    true
	;
	    AA1 is AA-1,
	    modLiteralCoversSB(A,SB,AA1)
	).

do_CoversTermtest(T1,T2) :-
	modCovers(T1,T2).
do_CoversTermtest(T1,T2) :-
	modSubterm(T2,T1).


modCovers(X,Y) :-  
	var(X),!,
	X == Y.
modCovers(Clause1,Clause2) :-
%       t = f(t1,...,tn) , s is var and s = ti for some i ,i=1...n.
	var(Clause2),
	!,
	functor(Clause1,_,A),
	var_equal_subterm(A,Clause1,Clause2).
modCovers(Clause1,Clause2) :-
%       t= f(t1,..,tn)  s= g(t1,..tm)  , n>=m>=0
	functor(Clause1,_,A1),
	functor(Clause2,_,A2),
	A1 >= A2,
	var_equal_subterms(A2,Clause1,Clause2),
	!.
modCovers(Clause1,Clause2) :-
%       t=s
	nonvar(Clause2),
	nonvar(Clause1),
	not(not(Clause1 = Clause2)).


var_equal_subterm(A,Term,Var) :-
	A >= 1,
	arg(A,Term,V),
	(Var == V -> 
	    true 
	;
	    A1 is A-1,
	    var_equal_subterm(A1,Term,Var)
	).

var_equal_subterms(0,_Term0,_Term1) :- !.
var_equal_subterms(A,Term0,Term1) :-
	A >= 1,
	arg(A,Term0,V0),
	arg(A,Term1,V1),
	(V0 == V1 -> 
	    true 
	;
	    A1 is A-1,
	    var_equal_subterms(A1,Term0,Term1)
	).
 
modSubterm(A1,A2) :-
        A1 == A2,
        !.
modSubterm(A1,A2) :-
	nonvar(A2),
	functor(A2,_,A),
	modSubterm(A1,A2,A).

modSubterm(A1,A2,A) :-
	A >= 1,
	arg(A,A2,SA2),	
	(modSubterm(A1,SA2) ->
	    true
	;
	    AM1 is A - 1,
	    modSubterm(A1,A2,AM1)
	).


modUnify(X,Y) :-
	unify(X,Y).

unify(X, Y) :-
        var(X),var(Y),!,
        X = Y.        
unify(X, Y) :-
        var(X),!,
        occurs_check(Y, X),  
        X = Y.
unify(X, Y) :-
        var(Y),!,
        occurs_check(X, Y),
        X = Y.
unify(X, Y) :-
        atomic(X),!,
        X = Y.
unify(X, Y) :-
        functor(X, F, N),
        functor(Y, F, N),
        unify(N, X, Y).
        
unify(0, _, _) :- !.
unify(N, X, Y) :-
        arg(N, X, Xn),arg(N, Y, Yn),
        unify(Xn, Yn),
        M is N-1,
        !,
        unify(M, X, Y).

occurs_check(Term, Var) :-
        var(Term),!,
        Term \== Var.
occurs_check(Term, Var) :-
        functor(Term, _, Arity),
        occurs_check(Arity, Term, Var).

occurs_check(0, _, _) :- !.
occurs_check(N, Term, Var) :-
        arg(N, Term, Arg),
        occurs_check(Arg, Var),
        M is N-1,
        !,
        occurs_check(M, Term, Var).

maybe_unifiable(T0,_T1) :-
	var(T0),!.
maybe_unifiable(_T0,T1) :-
	var(T1),!.
maybe_unifiable(T0,T1) :-
	functor(T0,F,A),
	functor(T1,F,A),
	maybe_unifiable(T0,T1,A).

maybe_unifiable(_T0,_T1,0) :- !.
maybe_unifiable(T0,T1,A) :- 
	arg(A,T0,ST0),
	arg(A,T1,ST1),
	maybe_unifiable(ST0,ST1),
	A1 is A-1,
	maybe_unifiable(T0,T1,A1).

% finds two literals that may be unifiable one from each list
find_maybe_unifiable([Lit0|_Lits0],Lits1,Lit0,U1) :-
	find_maybe_unifiable(Lits1,Lit0,U1).
find_maybe_unifiable([_Lit0|Lits0],Lits1,U0,U1) :-
	find_maybe_unifiable(Lits0,Lits1,U0,U1).
	
find_maybe_unifiable([Lit1|_Lits1],Lit0,Lit1) :-
	maybe_unifiable(Lit1,Lit0).
find_maybe_unifiable([_|Lits1],Lit0,U1) :-
	find_maybe_unifiable(Lits1,Lit0,U1).

% finds two maximal literals that may be unifiable one from each list
% first collect maximal literals from the second list (that may have a least one unifiable partner)
find_max_maybe_unifiable(Lits0,CL0,Lits1,CL1,U0,U1) :-
	collect_maximals(Lits1,CL1,Lits0,MLits1),
	find_max_maybe_unifiable(Lits0,CL0,MLits1,U0,U1).

collect_maximals([],_,_,[]).
collect_maximals([Lit1|Lits1],CL1,Lits0,MLits2) :-
	((modMaximalLiteral(Lit1,CL1),maybe_unifiablelist(Lits0,Lit1)) ->
	    MLits2 = [Lit1|MLits1]
	;
	    MLits2 = MLits1
	),
	collect_maximals(Lits1,CL1,MLits1).

maybe_unifiablelist([Lit0|Lits0],Lit1) :-
	(maybe_unifiable(Lit0,Lit1) ->
	    true
	;
	    maybe_unifiablelist(Lits0,Lit1)
	).
	

find_max_maybe_unifiable([Lit0|_Lits0],CL0,Lits1,U0,U1) :-
	modMaximalLiteral(Lit0,CL0),
	find_max_maybe_unifiable(Lits1,Lit0,U0,U1).
find_max_maybe_unifiable([_Lit0|Lits0],CL0,Lits1,U0,U1) :-
	find_max_maybe_unifiable(Lits0,CL0,Lits1,U0,U1).
	
find_max_maybe_unifiable([Lit1|_Lits1],Lit0,Lit0,Lit1) :-
	maybe_unifiable(Lit1,Lit0).
find_max_maybe_unifiable([_|Lits1],Lit0,U0,U1) :-
	find_max_maybe_unifiable(Lits1,Lit0,U0,U1).

 
%---------------------------------------------------------------------------
% modReplaceVar(+TERM1,-TERM2)
% TERM2 is a variant of TERM1, i.e. all (Prolog) variables in T1 are replaced
% by fresh variables.
%
% Author:      Patrick Brandmeier
% Description: Ullrich Hustadt

modReplaceVar(T1,T2) :-
	modcopy_term(T1,T2). 
%	modReplaceVar(T1,T2,[],_).

%---------------------------------------------------------------------------
% modReplaceVar(+TERM1,-TERM2,+VARLIST1,-VARLIST2)
% TERM2 is a variant of TERM1, i.e. all (Prolog) variables in T1 are replaced
% by fresh variables. VARLIST2 contains a list of lists [VAR1,VAR2], where 
% VAR1 is a variable occurring in TERM1 which is replaced by VAR2 in TERM2.
% VARLIST1 contains a similar list containing such replacement lists which
% have been computed for other parts of the term.
%
% Author:      Patrick Brandmeier
% Description: Ullrich Hustadt

modReplaceVar(T1,T2,VarList1,VarList2) :-
	var(T1),
	!,
	modReplaceVarmember(VarList1,T1,T2,VarList2).
modReplaceVar(T1,T2,VarList1,VarList2) :-
	atomic(T1),
	!,
	T1 = T2,
	VarList1 = VarList2.
% Lists special seems to pay off
modReplaceVar([E0|R0],[E1|R1],VarList1,VarList3) :-
	!,
	modReplaceVar(E0,E1,VarList1,VarList2),
	modReplaceVarList(R0,R1,VarList2,VarList3).
modReplaceVar(T1,T2,VarList1,VarList2) :-
	functor(T1,F,A),
	functor(T2,F,A),
	modReplaceVar(T1,T2,VarList1,VarList2,A).

modReplaceVarList([],[],VarList,VarList).
modReplaceVarList([E0|R0],[E1|R1],VarList1,VarList3) :-
	modReplaceVar(E0,E1,VarList1,VarList2),
	modReplaceVarList(R0,R1,VarList2,VarList3).

modReplaceVar(_T1,_T2,VarList,VarList,0) :- !.
modReplaceVar(T1,T2,VarList1,VarList3,A) :-
	arg(A,T1,ST1),
	arg(A,T2,ST2),
	modReplaceVar(ST1,ST2,VarList1,VarList2),
	A1 is A-1,
	modReplaceVar(T1,T2,VarList2,VarList3,A1).


%---------------------------------------------------------------------------
% modReplaceVarmember(+VARLIST1,+VAR1,-VAR2,-VARLIST2)
% VAR1 is a (Prolog) variable. If VAR1 is contained in VARLIST1, i.e.
% there is a list [VAR1,VAR3] in VARLIST1, then VAR3 will be VAR3 and
% VARLIST2 is equal to VARLIST1. Otherwise, VAR2 is a fresh variable and
% VARLIST2 is VARLIST1 extended by [VAR1,VAR2].
%
% Author:      Patrick Brandmeier
% Description: Ullrich Hustadt

% pb
% [A,B] -> A-B (Assoziationsliste)
% 3rd is 1st arg

modReplaceVarmember([],A,B,[A-B]).
modReplaceVarmember([A3-A4|T1],A1,A2,[A3-A4|T2]) :-
	(A1 == A3 ->
	    A2 = A4,
	    T1 = T2
	;
	    modReplaceVarmember(T1,A1,A2,T2)
	).


modNotEqual(Arg1,Arg1) :-
	!,fail.
modNotEqual(_,_).


modUnion(A,[],A) :-
	!.
modUnion([],A,A) :-
	!.
modUnion([],[],[]).
modUnion([X|R],[Y|R1],Z):-
	modUnion1([X|R],[Y|R1],Z),
	!.
modUnion([X|R],Y,Z) :-
	modUnion1([X|R],[Y],Z),
	!.
modUnion([X],Y,Z) :-
	modUnion1([X],[Y],Z),
	!.
modUnion(X,[Y],Z) :-
	modUnion1([X],[Y],Z),
	!.
modUnion(X,[Y|R],Z) :-
	modUnion1([X],[Y|R],Z),
	!.
modUnion(X,Y,Z) :-
	modUnion1([X],[Y],Z),
	!.
modUnion1([], Union, Union).
modUnion1([Element|Elements], Set, Union) :-
	memberVarList(Element, Set),
	!,
	modUnion1(Elements, Set, Union).
modUnion1([Element|Elements], Set, [Element|Union]) :-
	modUnion1(Elements, Set, Union).


modClUnion(false,_,false).
modClUnion(_,false,false).
modClUnion([],Union,Union).
modClUnion([El|Els],Set,Union) :-
	modClmember(El,Set),
	!,
	modClUnion(Els,Set,Union).
modClUnion([El|Els],Set,[El|Union]) :-
	modClUnion(Els,Set,Union).

modCl_list_to_set([], []) :-
	ifMooOption(traceOutput,yes,(print('modCl_list_to_set done.'),nl)).
modCl_list_to_set([Head|Tail], Set) :-
	ifMooOption(traceOutput,yes,(length([Head|Tail],N),print(N),print(' '))),
	modClmember(Head, Tail),
	!,
	modCl_list_to_set(Tail, Set).
modCl_list_to_set([Head|Tail], Set) :-
	var(Head),
	!,	
	modCl_list_to_set(Tail,Set),
	!.
modCl_list_to_set([Head|Tail], [Head|Set]) :-
	modCl_list_to_set(Tail, Set).
	
modClmember(Er,[H|_T]) :-
	modClEqual(Er,H),
	!.
modClmember(Er,[_|T]) :-
	modClmember(Er,T),
	!.

modClEqual(CL1,CL2) :-
	modPositiv(CL1,P1),
	modPositiv(CL2,P2),
	modNegativ(CL1,N1),
	modNegativ(CL2,N2),
	modEqualset(P1,P2),
	modEqualset(N1,N2),
	!.

modEqualset(A, B) :-
        modSubset(A, B),
        modSubset(B, A), !.

modVarEqualSet(L1,L2) :-
	modVarSubset(L1,L2),
	modVarSubset(L2,L1),
	!.
modVarSubset([],_) :- !.
modVarSubset([H1|T],List) :-
	memberVarList(H1,List),
	modVarSubset(T,List),
	!.

modSubset([], _) :- !.
modSubset([B|C], A) :-
	member(L,A),
        not(not(modVariant(B,L))),
	!,
        modSubset(C, A), 
	!.


modVariant(A,B) :-
	var(A),
	var(B),
	!,
	A = B.
modVariant(A,B) :-
	var(A),
	nonvar(B),
	!,
	fail.
modVariant(A,B) :-
	nonvar(A),
	var(B),
	!,
	fail.
modVariant(A,B) :-
	atomic(A),
	atomic(B),
	!,
	A == B.
modVariant(A,B) :-
	A =.. [F|TLA],
	B =.. [F|TLB],
	!,
	modVariantList(TLA,TLB).
modVariantList([],[]) :-
	!.
modVariantList([A|TLA],[B|TLB]) :-
	modVariant(A,B),
	modVariantList(TLA,TLB).


modnonmember([_,_],[]) :-
	!.
modnonmember([X,Y],[[X1,Y1]|_]) :-
	modClEqual(X,X1),
	modClEqual(Y,Y1),
	!,fail.
modnonmember([X,Y],[[X1,Y1]|_]) :-
	modClEqual(X,Y1),
	modClEqual(Y,X1),
	!,fail.
modnonmember([X,Y],[_|T]) :-
	modnonmember([X,Y],T),
	!.

modMember(X,Y) :-
        nonvar(Y),
        X==Y.
modMember(_X,Y) :-
        var(Y),
        !,fail.
modMember(X, [Y|_]    ) :-
        nonvar(Y),
        X=Y.
modMember(X, [_,Y|_]  ) :-
        nonvar(Y),
        X=Y.
modMember(X, [_,_,Y|_]) :-
        nonvar(Y),
        X==Y.
modMember(X, [_,_,_|L]) :-
        modMember(X, L).


%%% no variables ...
%%%

mod_list_to_set([], []).
mod_list_to_set([Head|Tail], Set) :-
	memberVarList(Head, Tail),
	!,
	mod_list_to_set(Tail, Set).
mod_list_to_set([Head|Tail], Set) :-
	var(Head),
	mod_list_to_set(Tail,Set),
	!.
mod_list_to_set([Head|Tail], [Head|Set]) :-
	mod_list_to_set(Tail, Set).

mod_deleteInList(L1,L2,L3) :-
	deleteInList(L1,L2,L3),
	!.
mod_deleteInList(L1,_,L1) :-
	!.

%%% memberVarList(X,Y)
%%% true if X in VariableList Y

memberVarList(X,[Y|_]) :-
	X == Y,!.
memberVarList(X, [_|T]    ) :-
	memberVarList(X,T).


%%% modCollect(X,Y) 
%%% Y exists of all Variables in X

modCollect([],[]) :-
	!.
modCollect([X|R],L) :-
	var(X),
	modCollect(R,L1),
	unionSpecial([X],L1,L),
	!.
modCollect([X|R],L) :-
	(atom(X);number(X)),	
	modCollect(R,L),
	!.
modCollect([[X1|R1]|R],L) :-
	var(X1),
	modCollect(R1,L1),
	modCollect(R,L2),
	unionSpecial(L1,L2,L3),
	unionSpecial(L3,[X1],L),
	!.
modCollect([[X|R1]|R],L) :-
	(atom(X);number(X)),
	modCollect(R1,L1),
	modCollect(R,L3),
	unionSpecial(L1,L3,L),
	!.
modCollect([[X1|R1]|R],L) :-
	X1 =.. X2,
	modCollect(X2,L2),
	modCollect(R1,L1),
	modCollect(R,L3),
	unionSpecial(L1,L2,L4),
	unionSpecial(L4,L3,L),
	!.
modCollect([X|R],L3) :-
	X =.. X1,
	modCollect(X1,L1),
	modCollect(R,L2),
	unionSpecial(L1,L2,L3),
	!.
modCollect(X,[X]) :-
	var(X),
	!.
modCollect(X,[]) :-
	(atom(X);number(X)),
	!.
modCollect(X,L1) :-
	X =.. X1,
	modCollect(X1,L1),!.


% modSubtract1(List,Kill,Res)
% deletes all clauses in List which are in Kill 
%

modSubtract1([], _, []).
modSubtract1([Element|Elements], Set, Difference) :-
%	ifMooOption(traceOutput,yes,(length([Element|Elements],N),write('Trying to prologListSubtract '),print(Element),write(' with '),print(N))),
	modClmember(Element,Set),
        !,
%	ifMooOption(traceOutput,yes,(write(' succeeded.'),nl)),
        modSubtract1(Elements, Set, Difference).
modSubtract1([Element|Elements], Set, [Element|Difference]) :-
%	ifMooOption(traceOutput,yes,(write(' failed.'),nl)),
        modSubtract1(Elements, Set, Difference).

% modSubtract(List,Kill,Res)
% deletes all variables in List which are in Kill 
%

modSubtract([], _, []).
modSubtract([Element|Elements], Set, Difference) :-
        memberVarList(Element, Set),
        !,
        modSubtract(Elements, Set, Difference).
modSubtract([Element|Elements], Set, [Element|Difference]) :-
        modSubtract(Elements, Set, Difference).

not_subtract(L1,L2,L3) :-
	prologListSubtract(L1,L2,L3),
	!,fail.
not_subtract(_,_,_) :-
	!.


% pb
modcopy_term(T0,T1) :-
	copy_term(T0,T1). % Builtin in SICStus


ground_copy(T0,T1) :-
	ground_copy(T0,T1,[],_,0,_).

ground_copy(T0,T1,Subst0,Subst1,N0,N1) :-
	var(T0),!,
	do_subst(Subst0,T0,T1,Subst1,N0,N1).
ground_copy(T0,T0,Subst0,Subst0,N0,N0) :-
	atomic(T0),!.
ground_copy(T0,T1,Subst0,Subst1,N0,N1) :-
	functor(T0,F,A),
	functor(T1,F,A),
	ground_copy(A,T0,T1,Subst0,Subst1,N0,N1).

ground_copy(0,_T0,_T1,Subst,Subst,N,N) :- !.
ground_copy(A,T0,T1,Subst0,Subst2,N0,N2) :- 
	arg(A,T0,ST0),
	arg(A,T1,ST1),
	ground_copy(ST0,ST1,Subst0,Subst1,N0,N1),
	A1 is A -1,
	ground_copy(A1,T0,T1,Subst1,Subst2,N1,N2).

do_subst([],T0,T1,[T0-T1],N0,N1) :-
	genconstant(N0,T1,N1).
do_subst([V-C|Subst0],T0,T1,Subst1,N0,N1) :-
	V == T0,!,
	Subst1 = [V-C|Subst0],
	N0 = N1,
	T1 = C.
do_subst([V-C|Subst0],T0,T1,[V-C|Subst1],N0,N1) :-
	do_subst(Subst0,T0,T1,Subst1,N0,N1).



testtime(N) :-
	timeit(test(N,_,_)).

profileit(N) :-
	compile('~barth/Prolog/SICStus/Tools/profiler'),
	compile('/HG/local/knowRep/motel/src/motel/modProv'),
	test1(N,_,_),
	print_profile.


modTranslateInDecide([],[]) :-
        !.
modTranslateInDecide([cl(ListH,ListR,ProofTree)|T],Erg) :-
        append(ListH,ListR,List),
        collect(List,ErList),
        (modMember(equal,ErList) ->
            modTranslateInDecide(T,Erg);
            (modTranslateInDecide(T,Cl2),
            append([cl(ListH,ListR,ProofTree)],Cl2,Erg))),
        !.


modEnvToFOL(Name,CL) :-
	isMooOption(translationMode,flatRelational),
	!,
	modTranslateModalAxioms(Name,CL1),
	modTranslateAxioms(Name,CL2),
	append(CL10,CL2,CL),
	!.
modTranslateModalAxioms(Name,CL) :-
	setofOrNil([MS,KClass,MOp,Concept],
                   [X1,B1]^clause(modalAxioms(Name,MS,user,KClass,Concept,MOp,X1),B1),
		   L1),
	modTranslateModalAxiom(L1,CL).

modTranslateModalAxiom([],[]) :-
	!.
modTranslateModalAxiom([[MS,KClass,MOp,concept(C)]|L1],CL) :-
	!,
	malcToFOL(functional,U,[A],C,F1),
	translateClass(KClass,MOp,C,[A],F2),
	modalContextToFOL(MS,[],U,forall(A,implies(F1,F2)),F3),
	translate(F3,C1),
	clausesToSystemSyntax(C1,CL1),
	modPurCl2Cl(CL1,C,CL10),
	modTranslateModalAxiom(L1,CL2),
	append(CL10,CL2,CL).
modTranslateModalAxiom([[MS,KClass,MOp,all]|L1],CL) :-
	!,
	translateClass(KClass,MOp,all,[A],F2),
	modalContextToFOL(MC,[],U,forall(A,F2),F3),
	translate(F3,C1),
	clausesToSystemSyntax(C1,CL1),
	modPurCl2Cl(CL1,all,CL10),
	modTranslateModalAxiom(L1,CL2),
	append(CL10,CL2,CL).
modTranslateModalAxiom([[MS,KClass,MOp,A]|L1],CL) :-
	!,
	translateClass(KClass,MOp,C,[A],F2),
	modalContextToFOL(MC,[],U,forall(A,F2),F3),
	translate(F3,C1),
	clausesToSystemSyntax(C1,CL1),
	modPurCl2Cl(CL1,A,CL10),
	modTranslateModalAxiom(L1,CL2),
	append(CL10,CL2,CL).


modTranslateAxioms(Name,CL) :-
	setofOrNil([MS,[A],_,in,C],
	           [X1,Ax,B1]^clause(conceptElement(Name,MS,X1,user,A,C,Ax),B1),
		   L1),
	modTranslateAxiom(L1,CL1),
	setofOrNil([MS,[A,B],_,in,R],
	           [X1,Ax,B1]^clause(roleElement(Name,MS,X1,user,A,B,R,Ax),B1),
		   L2),
	modTranslateAxiom(L2,CL2),
	setofOrNil([MS,[X],CT1,equivalent,CT2],
	           [Ax,B1]^clause(conceptEqualSets(Name,user,MS,CT1,CT2,Ax),B1),
		   L3),
	modTranslateAxiom(L3,CL3),
	setofOrNil([MS,[X],CT1,implies,CT2],
	           [Ax,B1]^clause(conceptSubsets(Name,user,MS,CT1,CT2,Ax),B1),
		   L4),
	modTranslateAxiom(L4,CL4),
	setofOrNil([MS,[X,Y],RN,equivalent,RT],
	           [Ax,B1]^clause(roleEqualSets(Name,user,MS,RN,RT,Ax),B1),
		   L5),
	modTranslateAxiom(L5,CL5),
	setofOrNil([MS,[X,Y],RN,implies,RT],
	           [Ax,B1]^clause(roleSubSets(Name,user,MS,RN,RT,Ax),B1),
		   L6),
	modTranslateAxiom(L6,CL6),
%	closed(Name,MS,X,Y,R),
	append(CL1,CL2,CL12),
	append(CL12,CL3,CL13),
	append(CL13,CL4,CL14),
	append(CL14,CL5,CL15),
	append(CL15,CL6,CL),
	!.


modTranslateAxiom([],[]) :-
	!.
modTranslateAxiom([[A1,A2,A3,A4,A5]|L1],CL) :-
	modAxiomToClause(A1,A2,A3,A4,A5,CL1),
	modTranslateAxiom(L1,CL2),
	append(CL1,CL2,CL).

modAxiomToClause(MC,VL,T1,Op,T2,CL) :-
	modExpand(VL,T1,TN1,TL1),
	modExpand(VL,T2,TN2,TL2),
 	axiomToFOL(MC,VL,TN1,Op,TN2,F),
	modAxiomsToClause(MC,TL1,CL1),
	modAxiomsToClause(MC,TL2,CL2),
	forallQuantify(VL,F,F1),
	translate(F1,C1),
	clausesToSystemSyntax(C1,C),
	modPurCl2Cl(C,T1,Cl),
	modPurCl2Cl(CL1,T1,CL10),
	modPurCl2Cl(CL2,T1,CL20),
	append(CL10,CL20,CL3),
	append(CL3,Cl,CL).

modPurCl2Cl([],VL,[]) :- !.
modPurCl2Cl(cl(Pos,Neg),VL,[cl(Pos,Neg,char(VL1,[CRP,CRN],Skol))]) :-
	((var(VL);VL = [_|_]) ->
	    VL1 = VL;
	    VL1 = [VL]),
	modExtractCR(Pos,CRP),
	modExtractCR(Neg,CRN),
	modExtractSkolem(Pos,Neg,Skol),
	!.
modPurCl2Cl([PCl|TCl],VL,Cl) :-
	modPurCl2Cl(PCl,VL,C1),
	modPurCl2Cl(TCl,VL,C2),
	append(C1,C2,Cl),
	!.
modPurCl2Cl([_PCl|TCl],VL,C) :-
	modPurCl2Cl(TCl,VL,C),
	!.
	
modAxiomsToClause(MC,[],[]) :-
	!.
modAxiomsToClause(MC,[T|TL],CL3) :-
	T = (VL,T1,Op,T2),
	axiomToFOL(MC,VL,T1,Op,T2,F),
	forallQuantify(VL,F,F1),
	translate(F1,C1),
	clausesToSystemSyntax(C1,CL1),
	modAxiomsToClause(MC,TL,CL2),
	append(CL1,CL2,CL3).

modExpand(_,V,V,[]) :-
	var(V),
	!.
modExpand(_,V,V,[]) :-
	atom(V),
	!.
modExpand(VL,and([C1]),and([F1]),TL) :-
	modExpand(VL,C1,F1,TL).
modExpand(VL,and([C1|CL]), and([F1|F2]),TL) :-
	modExpand(VL,C1,F1,TL1),
	modExpand([X],and(CL),and(F2),TL2),
	append(TL1,TL2,TL).
modExpand(VL,or([C1]),or([F1]),TL) :-
	modExpand(VL,C1,F1,TL).
modExpand(VL,or([C1|CL]), or([F1|F2]),TL) :-
	modExpand(VL,C1,F1,TL1),
	modExpand([X],or(CL),or(F2),TL2),
	append(TL1,TL2,TL).
modExpand([X],set(L),F) :-
	!,
	setDisjunction(X,L,F).
modExpand(VL,not(C),not(F),TL) :-
	modExpand(VL,C,F,TL),
	!.
modExpand(VL,naf(C),naf(F),TL) :-
	modExpand(VL,C,F,TL),
	!.
modExpand([X],all(R,C),C1,[([X],C1,equivalent,all(R,D))|TL]) :-
	gensym(concept,C1),
	modExpand([X],C,D,TL).
modExpand([X],some(R,C),C1,[([X],C1,equivalent,some(R,D))|TL]) :-
	gensym(concept,C1),
	modExpand([X],C,D,TL).
modExpand([X],atleast(N,R),atleast(N,R),[]) :-
	!.
modExpand([X],atmost(N,R),atmost(N,R),[]) :-
	!.
modExpand([X],b(O,A,C2),
           forall(V,implies(rel(O,A,U,V),F))) :-
	malcToFOL(Trans,V,[X],C2,F).    
modExpand([X],d(O,A,C2),undefined,[]) :-
	!.
modExpand([X],d(O,A,C2),undefined,[]) :-
	!.
modExpand([X],d(O,A,C2),undefined,[]) :-
	!.
modExpand([X],bc(O,C1,C2),undefined,[]) :-
	!.
modExpand([X],dc(O,C1,C2),undefined,[]) :-
	!.
modExpand([X],dc(O,C1,C2),undefined,[]) :-
	!.
modExpand([X],dc(O,C1,C2),undefined,[]) :- 
	!.
modExpand([X,Y],inverse(R),inverse(S),TL) :-
	modExpand([Y,X],R,S,TL),
	!.
modExpand([X,Y],restrict(R,C),restrict(S,D),TL) :-
	modExpand([X,Y],R,S,TL1),
	modExpand([Y],C,D,TL2),
	append(TL1,TL2,TL),
	!.

      

test1(K,Bool,CL) :-
        example(K),
	!,
        environment(_,Env,_),
        Env \== env(e0),
	setMooOption(prover,decider),
	setMooOption(translationMode,flatRelational),	
	setMooOption(decider,on),
        modEnvToFOL(Env,K2),
        getRuntime(T0),
        length(K2,N0),
	modInference(K2,Bool,CL,stat(N1,N2)),
	length(CL,N3),
	getRuntime(T1),
        T is T1 - T0,
        format("Total runtime:                         ~t~3d~45| sec.~n",T),
        format("Number of clauses    at the beginning: ~t~d~41|~n",N0),
        format("Number of clauses    at the end:       ~t~d~41|~n",N1),
        format("Number of SH clauses at the end:       ~t~d~41|~n",N2),
        !.
 
test(K,Bool,CL) :-
        getRuntime(T0),
	setMooOption(prover,decider),
	setMooOption(translationMode,flatRelational),
	setMooOption(decider,on),
	clauseSet(K,K2),
        length(K2,N0),
	modInference(K2,Bool,CL,stat(N1,N2)),
	length(CL,N3),
	getRuntime(T1),
        T is T1 - T0,
        format("Total runtime:                      ~t~3d~45| sec.~n",T),
        format("Number of clauses at the beginning: ~t~d~41|~n",N0),
        format("Number of persistent clauses:       ~t~d~41|~n",N1),
        format("Number of persistent horn clauses:  ~t~d~41|~n",N2),
        format("Number of clauses at the end     : ~t~d~41|~n",N3),
	!.

% Clause set 83
% generated from example 83
% Total runtime 0.620 sec. on a SPARC 10/512
clauseSet(83,
[cl([],[in([],concept52,_9400),in([],sex,_9400,_9841),in([],concept49,_9841)],c01),
cl([in([],sex,_9400,f16(_9400)),in([],concept52,_9400)],[],c02),
cl([in([],concept49,f16(_9400)),in([],concept52,_9400)],[],c03),
cl([],[in([],concept52,_9400),in([],person,_9400)],c04),
cl([in([],sex,_9433,f17(_9433))],[in([],concept53,_9433)],c05),
cl([in([],male,f17(_9433)),in([],female,f17(_9433))],[in([],concept53,_9433)],c06),
cl([in([],concept53,_9433)],[in([],male,_12722),in([],sex,_9433,_12722)],c07),
cl([in([],concept53,_9433)],[in([],female,_12722),in([],sex,_9433,_12722)],c08),
cl([in([],concept53,_9433)],[in([],person,_9433)],c09),
cl([],[in([],male,_9468),in([],female,_9468)],c10),
cl([],[in([],female,_9496),in([],male,_9496)],c11),
cl([in([],top,_9524)],[in([],male,_9524)],c12)]).
% Clause set 84
% generated from example 84
% 14.03.95: Total runtime 1.067 sec.
%           Total runtime 1.290 sec on a SPARC 10/512
% Number of clauses at the beginning:     9
% Number of persistent clauses:           9
% Number of persistent horn clauses:      3
% Number of clauses at the end     :      3
clauseSet(84,
[cl([in([],child,_9408,f6(_9408))],[in([],concept21,_9408)],c01),
cl([in([],person,f6(_9408))],[in([],concept21,_9408)],c02),
cl([in([],concept21,_9408)],[in([],child,_9408,_9701),in([],person,_9701)],c03),
cl([in([],person,_9371)],[in([],parent,_9371)],c04),
cl([in([],concept21,_9371)],[in([],parent,_9371)],c05),
cl([in([],parent,_9371)],[in([],person,_9371),in([],concept21,_9371)],c0),
cl([],[in([],concept22,_13682),in([],sex,_13682,_14123),in([],concept15,_14123)],c07),
cl([in([],sex,_13682,f7(_13682)),in([],concept22,_13682)],[],c08),
cl([in([],concept15,f7(_13682)),in([],concept22,_13682)],[],c09),
cl([],[in([],concept22,_13682),in([],person,_13682)],c10),
cl([in([],sex,_13715,f8(_13715))],[in([],concept23,_13715)],c11),
cl([in([],male,f8(_13715)),in([],female,f8(_13715))],[in([],concept23,_13715)],c12),
cl([in([],concept23,_13715)],[in([],male,_132779),in([],sex,_13715,_132779)],c13),
cl([in([],concept23,_13715)],[in([],female,_132779),in([],sex,_13715,_132779)],c14),
cl([in([],concept23,_13715)],[in([],person,_13715)],c15),
cl([],[in([],male,_13750),in([],female,_13750)],c16),
cl([],[in([],female,_13778),in([],male,_13778)],c17),
cl([in([],top,_13806)],[in([],male,_13806)],c18)]).
% Clause set 85
% generated from example 85
% 14.03.95: Total runtime 10.450 sec.
%           Total runtime 21.090 sec. on a SPARC 10/512 
% Number of clauses at the beginning:    18
% Number of persistent clauses:          31
% Number of persistent horn clauses:     10
% Number of clauses at the end     :     10
clauseSet(85,
[
cl([in([],parent,_36965)],[in([],father,_36965)],c01),
cl([],[in([],mother,_36965),in([],father,_36965)],c02),
cl([in([],father,_36965),in([],mother,_36965)],[in([],parent,_36965)],c03),
cl([in([],sex,_37012,f1(_37012))],[in([],concept11,_37012)],c04),
cl([in([],female,f1(_37012))],[in([],concept11,_37012)],c05),
cl([in([],concept11,_37012)],[in([],sex,_37012,_37029),in([],female,_37029)],c06),
cl([in([],parent,_36966)],[in([],mother,_36966)],c07),
cl([in([],concept11,_36966)],[in([],mother,_36966)],c08),
cl([in([],mother,_36966)],[in([],parent,_36966),in([],concept11,_36966)],c09),
cl([in([],child,_37114,f2(_37114))],[in([],concept12,_37114)],c10),
cl([in([],person,f2(_37114))],[in([],concept12,_37114)],c11),
cl([in([],concept12,_37114)],[in([],child,_37114,_37131),in([],person,_37131)],c12),
cl([in([],person,_36967)],[in([],parent,_36967)],c13),
cl([in([],concept12,_36967)],[in([],parent,_36967)],c14),
cl([in([],parent,_36967)],[in([],person,_36967),in([],concept12,_36967)],c15),
cl([],[in([],concept13,_37221),in([],sex,_37221,_37238),in([],concept1,_37238)],c16),
cl([in([],sex,_37221,f3(_37221)),in([],concept13,_37221)],[],c17),
cl([in([],concept1,f3(_37221)),in([],concept13,_37221)],[],c18),
cl([],[in([],concept13,_37221),in([],person,_37221)],c19),
cl([in([],sex,_37222,f4(_37222))],[in([],concept14,_37222)],c20),
cl([in([],male,f4(_37222)),in([],female,f4(_37222))],[in([],concept14,_37222)],c21),
cl([in([],concept14,_37222)],[in([],male,_37313),in([],sex,_37222,_37313)],c22),
cl([in([],concept14,_37222)],[in([],female,_37313),in([],sex,_37222,_37313)],c23),
cl([in([],concept14,_37222)],[in([],person,_37222)],c24),
cl([],[in([],male,_37223),in([],female,_37223)],c25),
cl([],[in([],female,_37224),in([],male,_37224)],c26),
cl([in([],top,_37225)],[in([],male,_37225)],c27)]).
% Clause set 86
% generated from example 86
% 14.03.95: Total runtime   302.114 sec.
% 28.02.95: Total runtime  1867.817 sec. on a SPARC 10/512
% 01.01.95: Total runtime 15330.417 sec.
% Number of clauses at the beginning:    42
% Number of persistent clauses:         171
% Number of persistent horn clauses:     28
clauseSet(86,
[cl([in([],concept43,_10062)],[in([],concept42,_9576),in([],child,_9576,_10062)],c01),
cl([in([],child,_9576,f9(_9576)),in([],concept42,_9576)],[],c02),
cl([in([],concept42,_9576)],[in([],concept43,f9(_9576))],c03),
cl([in([],sex,_9576,f10(_9576))],[in([],concept43,_9576)],c04),
cl([in([],male,f10(_9576))],[in([],concept43,_9576)],c05),
cl([in([],concept43,_9576)],[in([],sex,_9576,_12299),in([],male,_12299)],c06),
cl([in([],parent,_9371)],[in([],parent_with_sons_only,_9371)],c07),
cl([in([],concept42,_9371)],[in([],parent_with_sons_only,_9371)],c08),
cl([in([],parent_with_sons_only,_9371)],[in([],parent,_9371),in([],concept42,_9371)],c09),
cl([in([],child,_132002,f11(_132002))],[in([],concept44,_132002)],c10),
cl([in([],parent,f11(_132002))],[in([],concept44,_132002)],c11),
cl([in([],concept44,_132002)],[in([],child,_132002,_132295),in([],parent,_132295)],c12),
cl([in([],parent,_9409)],[in([],grandparent,_9409)],c13),
cl([in([],concept44,_9409)],[in([],grandparent,_9409)],c14),
cl([in([],grandparent,_9409)],[in([],parent,_9409),in([],concept44,_9409)],c15),
cl([in([],parent,_9444)],[in([],father,_9444)],c16),
cl([],[in([],mother,_9444),in([],father,_9444)],c17),
cl([in([],father,_9444),in([],mother,_9444)],[in([],parent,_9444)],c18),
cl([in([],sex,_137853,f12(_137853))],[in([],concept45,_137853)],c19),
cl([in([],female,f12(_137853))],[in([],concept45,_137853)],c20),
cl([in([],concept45,_137853)],[in([],sex,_137853,_138146),in([],female,_138146)],c21),
cl([in([],parent,_9478)],[in([],mother,_9478)],c22),
cl([in([],concept45,_9478)],[in([],mother,_9478)],c23),
cl([in([],mother,_9478)],[in([],parent,_9478),in([],concept45,_9478)],c24),
cl([in([],child,_142032,f13(_142032))],[in([],concept46,_142032)],c25),
cl([in([],person,f13(_142032))],[in([],concept46,_142032)],c26),
cl([in([],concept46,_142032)],[in([],child,_142032,_142325),in([],person,_142325)],c27),
cl([in([],person,_9513)],[in([],parent,_9513)],c28),
cl([in([],concept46,_9513)],[in([],parent,_9513)],c29),
cl([in([],parent,_9513)],[in([],person,_9513),in([],concept46,_9513)],c30),
cl([],[in([],concept47,_146356),in([],sex,_146356,_164367),in([],concept24,_164367)],c31),
cl([in([],sex,_146356,f14(_146356)),in([],concept47,_146356)],[],c32),
cl([in([],concept24,f14(_146356)),in([],concept47,_146356)],[],c3),
cl([],[in([],concept47,_146356),in([],person,_146356)],c34),
cl([in([],sex,_146389,f15(_146389))],[in([],concept48,_146389)],c35),
cl([in([],male,f15(_146389)),in([],female,f15(_146389))],[in([],concept48,_146389)],c36),
cl([in([],concept48,_146389)],[in([],male,_167248),in([],sex,_146389,_167248)],c37),
cl([in([],concept48,_146389)],[in([],female,_167248),in([],sex,_146389,_167248)],c38),
cl([in([],concept48,_146389)],[in([],person,_146389)],c39),
cl([],[in([],male,_146424),in([],female,_146424)],c40),
cl([],[in([],female,_146452),in([],male,_146452)],c41),
cl([in([],top,_146480)],[in([],male,_146480)],c42)]).
% Clause set 87
% generated from example 87
clauseSet(87,
[cl([in([],concept43,_10062)],[in([],concept42,_9576),in([],child,_9576,_10062)],c01),
cl([in([],child,_9576,f9(_9576)),in([],concept42,_9576)],[],c02),
cl([in([],concept42,_9576)],[in([],concept43,f9(_9576))],c03),
cl([in([],sex,_9576,f10(_9576))],[in([],concept43,_9576)],c04),
cl([in([],male,f10(_9576))],[in([],concept43,_9576)],c05),
cl([in([],concept43,_9576)],[in([],sex,_9576,_12299),in([],male,_12299)],c06),
cl([in([],parent,_9371)],[in([],parent_with_sons_only,_9371)],c07),
cl([in([],concept42,_9371)],[in([],parent_with_sons_only,_9371)],c08),
cl([in([],parent_with_sons_only,_9371)],[in([],parent,_9371),in([],concept42,_9371)],c09),
cl([in([],child,_132002,f11(_132002))],[in([],concept44,_132002)],c10),
cl([in([],parent,f11(_132002))],[in([],concept44,_132002)],c11),
cl([in([],concept44,_132002)],[in([],child,_132002,_132295),in([],parent,_132295)],c12),
cl([in([],parent,_9409)],[in([],grandparent,_9409)],c13),
cl([in([],concept44,_9409)],[in([],grandparent,_9409)],c14),
cl([in([],grandparent,_9409)],[in([],parent,_9409),in([],concept44,_9409)],c15),
cl([in([],parent,_9444)],[in([],father,_9444)],c16),
cl([],[in([],mother,_9444),in([],father,_9444)],c17),
cl([in([],father,_9444),in([],mother,_9444)],[in([],parent,_9444)],c18),
cl([in([],sex,_137853,f12(_137853))],[in([],concept45,_137853)],c19),
cl([in([],female,f12(_137853))],[in([],concept45,_137853)],c20),
cl([in([],concept45,_137853)],[in([],sex,_137853,_138146),in([],female,_138146)],c21),
cl([in([],parent,_9478)],[in([],mother,_9478)],c22),
cl([in([],concept45,_9478)],[in([],mother,_9478)],c23),
cl([in([],mother,_9478)],[in([],parent,_9478),in([],concept45,_9478)],c24),
cl([in([],child,_142032,f13(_142032))],[in([],concept46,_142032)],c25),
cl([in([],person,f13(_142032))],[in([],concept46,_142032)],c26),
cl([in([],concept46,_142032)],[in([],child,_142032,_142325),in([],person,_142325)],c27),
cl([in([],person,_9513)],[in([],parent,_9513)],c28),
cl([in([],concept46,_9513)],[in([],parent,_9513)],c29),
cl([in([],parent,_9513)],[in([],person,_9513),in([],concept46,_9513)],c30),
cl([],[in([],concept47,_146356),in([],sex,_146356,_164367),in([],concept24,_164367)],c31),
cl([in([],sex,_146356,f14(_146356)),in([],concept47,_146356)],[],c32),
cl([in([],concept24,f14(_146356)),in([],concept47,_146356)],[],c3),
cl([],[in([],concept47,_146356),in([],person,_146356)],c34),
cl([in([],sex,_146389,f15(_146389))],[in([],concept48,_146389)],c35),
cl([in([],male,f15(_146389)),in([],female,f15(_146389))],[in([],concept48,_146389)],c36),
cl([in([],concept48,_146389)],[in([],male,_167248),in([],sex,_146389,_167248)],c37),
cl([in([],concept48,_146389)],[in([],female,_167248),in([],sex,_146389,_167248)],c38),
cl([in([],concept48,_146389)],[in([],person,_146389)],c39),
cl([],[in([],male,_146424),in([],female,_146424)],c40),
cl([],[in([],female,_146452),in([],male,_146452)],c41),
cl([in([],top,_146480)],[in([],male,_146480)],c42),
cl([in([],father,tom)],[],c43),
cl([in([],child,tom,peter)],[],c44),
cl([in([],child,tom,harry)],[],c45),
cl([in([],child,mary,tom)],[],c46),
cl([in([],child,mary,chris)],[],c47),
cl([in([],parent_with_sons_only,mary)],[],c48)]).
% Clause set 88
% generated from example 88
% 14.03.95: Total runtime  943.049 sec.
% 28.02.95: Total runtime 1966.120 sec. on a SPARC 10/512
clauseSet(88,
[cl([in([],male,_B)],[in([],concept16,_A),in([],child,_A,_B)],c1),cl([in([],child,_A,f1(_A)),in([],concept16,_A)],[],c01),
cl([in([],concept16,_A)],[in([],male,f1(_A))],c02),
cl([in([],father,_C)],[in([],father_with_sons_only,_C)],c03),
cl([in([],concept16,_C)],[in([],father_with_sons_only,_C)],c04),
cl([in([],father_with_sons_only,_C)],[in([],father,_C),in([],concept16,_C)],c05),
cl([in([],child,_D,f2(_D))],[in([],concept17,_D)],c06),
cl([in([],parent,f2(_D))],[in([],concept17,_D)],c07),
cl([in([],concept17,_D)],[in([],child,_D,_E),in([],parent,_E)],c08),
cl([in([],parent,_F)],[in([],grandparent,_F)],c09),
cl([in([],concept17,_F)],[in([],grandparent,_F)],c10),
cl([in([],grandparent,_F)],[in([],parent,_F),in([],concept17,_F)],c11),
cl([in([],mother,_G),in([],father,_G)],[in([],parent,_G)],c12),
cl([in([],parent,_G)],[in([],mother,_G)],c13),
cl([in([],parent,_G)],[in([],father,_G)],c14),
cl([in([],hild,_H,f3(_H))],[in([],concept18,_H)],c15),
cl([in([],human,f3(_H))],[in([],concept18,_H)],c16),
cl([in([],concept18,_H)],[in([],hild,_H,_I),in([],human,_I)],c17),
cl([in([],man,_J)],[in([],father,_J)],c18),
cl([in([],concept18,_J)],[in([],father,_J)],c19),
cl([in([],father,_J)],[in([],man,_J),in([],concept18,_J)],c20),
cl([in([],child,_K,f4(_K))],[in([],concept19,_K)],c21),
cl([in([],human,f4(_K))],[in([],concept19,_K)],c22),
cl([in([],concept19,_K)],[in([],child,_K,_L),in([],human,_L)],c23),
cl([in([],woman,_M)],[in([],mother,_M)],c24),
cl([in([],concept19,_M)],[in([],mother,_M)],c25),
cl([in([],mother,_M)],[in([],woman,_M),in([],concept19,_M)],c26),
cl([in([],human,_N)],[in([],woman,_N)],c27),
cl([in([],female,_N)],[in([],woman,_N)],c28),
cl([in([],woman,_N)],[in([],human,_N),in([],female,_N)],c29),
cl([in([],human,_O)],[in([],man,_O)],c30),
cl([in([],male,_O)],[in([],man,_O)],c31),
cl([in([],man,_O)],[in([],human,_O),in([],male,_O)],c32),
cl([],[in([],male,_P),in([],female,_P)],c33),
cl([],[in([],female,_Q),in([],male,_Q)],c34)]).
% Clause set fssTBox
% generated from the fss knowledge base
clauseSet(fssTBox,
[cl([in([],touchable_object,_A)],[in([],vehicle,_A)],c001),
cl([in([],worth_mod,_A,f8(_A))],[in([],vehicle,_A)],c002),
cl([in([],worth,f8(_A))],[in([],vehicle,_A)],c003),
cl([in([],vehicle,_A)],[in([],touchable_object,_A),in([],worth_mod,_A,_B),in([],worth,_B)],c004),
cl([in([],town,_C)],[in([],voelklingen,_C)],c005),
cl([in([],lexicon,_C)],[in([],voelklingen,_C)],c006),
cl([in([],voelklingen,_C)],[in([],town,_C),in([],lexicon,_C)],c007),
cl([in([],animate,_D)],[in([],animal,_D)],c008),
cl([in([],volition,_D,f9(_D))],[in([],animal,_D)],c009),
cl([in([],volitional_sq,f9(_D))],[in([],animal,_D)],c010),
cl([in([],animal,_D)],[in([],animate,_D),in([],volition,_D,_E),in([],volitional_sq,_E)],c011),
cl([in([],lexicon,_F)],[in([],peter,_F)],c012),
cl([in([],human,_F)],[in([],peter,_F)],c013),
cl([in([],peter,_F)],[in([],lexicon,_F),in([],human,_F)],c014),
cl([in([],lexicon,_G)],[in([],ich,_G)],c015),
cl([in([],human,_G)],[in([],ich,_G)],c016),
cl([in([],ich,_G)],[in([],lexicon,_G),in([],human,_G)],c017),
cl([in([],lexicon,_H)],[in([],karl,_H)],c018),
cl([in([],human,_H)],[in([],karl,_H)],c019),
cl([in([],karl,_H)],[in([],lexicon,_H),in([],human,_H)],c020),
cl([in([],human,_I)],[in([],junge,_I)],c021),
cl([in([],lexicon,_I)],[in([],junge,_I)],c022),
cl([in([],junge,_I)],[in([],human,_I),in([],lexicon,_I)],c023),
cl([in([],human,_J)],[in([],mann,_J)],c024),
cl([in([],lexicon,_J)],[in([],mann,_J)],c025),
cl([in([],mann,_J)],[in([],human,_J),in([],lexicon,_J)],c026),
cl([in([],individual,_K)],[in([],animate,_K)],c027),
cl([in([],physis_mod,_K,f10(_K))],[in([],animate,_K)],c028),
cl([in([],physical_sq,f10(_K))],[in([],animate,_K)],c029),
cl([in([],animate,_K)],[in([],individual,_K),in([],physis_mod,_K,_L),in([],physical_sq,_L)],c030),
cl([in([],thing,_M)],[in([],das,_M)],c031),
cl([in([],lexicon,_M)],[in([],das,_M)],c032),
cl([in([],das,_M)],[in([],thing,_M),in([],lexicon,_M)],c033),
cl([in([],thing,_N)],[in([],fahrt,_N)],c034),
cl([in([],lexicon,_N)],[in([],fahrt,_N)],c035),
cl([in([],fahrt,_N)],[in([],thing,_N),in([],lexicon,_N)],c036),
cl([in([],indication_of_quantity,_O)],[in([],dm,_O)],c037),
cl([in([],lexicon,_O)],[in([],dm,_O)],c038),
cl([in([],dm,_O)],[in([],indication_of_quantity,_O),in([],lexicon,_O)],c039),
cl([in([],abstract_thing,_P)],[in([],indication_of_quantity,_P)],c040),
cl([in([],quantity,_P,f11(_P))],[in([],indication_of_quantity,_P)],c041),
cl([in([],cardinal,f11(_P))],[in([],indication_of_quantity,_P)],c042),
cl([in([],indication_of_quantity,_P)],[in([],abstract_thing,_P),in([],quantity,_P,_Q),in([],cardinal,_Q)],c043),
cl([in([],cost,_R)],[in([],kost,_R)],c044),
cl([in([],lexicon,_R)],[in([],kost,_R)],c045),
cl([in([],kost,_R)],[in([],cost,_R),in([],lexicon,_R)],c046),
cl([in([],property,_S)],[in([],value_property,_S)],c047),
cl([in([],measure,_S,f12(_S))],[in([],value_property,_S)],c048),
cl([in([],abstract_thing,f12(_S))],[in([],value_property,_S)],c049),
cl([in([],value_property,_S)],[in([],property,_S),in([],measure,_S,_T),in([],abstract_thing,_T)],c050),
cl([in([],predicate,_U)],[in([],unterricht,_U)],c051),
cl([in([],lexicon,_U)],[in([],unterricht,_U)],c052),
cl([in([],unterricht,_U)],[in([],predicate,_U),in([],lexicon,_U)],c053),
cl([in([],lexicon,_V)],[in([],kauf,_V)],c054),
cl([in([],transaction,_V)],[in([],kauf,_V)],c055),
cl([in([],concerned,_V,f13(_V))],[in([],kauf,_V)],c056),
cl([in([],thing,f13(_V))],[in([],kauf,_V)],c057),
cl([in([],kauf,_V)],[in([],lexicon,_V),in([],transaction,_V),in([],concerned,_V,_W),in([],thing,_W)],c058),
cl([in([],lexicon,_X)],[in([],schenk,_X)],c059),
cl([in([],transaction,_X)],[in([],schenk,_X)],c060),
cl([in([],concerned,_X,f14(_X))],[in([],schenk,_X)],c061),
cl([in([],thing,f14(_X))],[in([],schenk,_X)],c062),
cl([in([],schenk,_X)],[in([],lexicon,_X),in([],transaction,_X),in([],concerned,_X,_Y),in([],thing,_Y)],c063),
cl([in([],action,_Z)],[in([],transaction,_Z)],c064),
cl([in([],beneficative,_Z,f15(_Z))],[in([],transaction,_Z)],c065),
cl([in([],human,f15(_Z))],[in([],transaction,_Z)],c066),
cl([in([],transaction,_Z)],[in([],action,_Z),in([],beneficative,_Z,_A1),in([],human,_A1)],c067),
cl([in([],lexicon,_B1)],[in([],arbeit,_B1)],c068),
cl([in([],action,_B1)],[in([],arbeit,_B1)],c069),
cl([in([],arbeit,_B1)],[in([],lexicon,_B1),in([],action,_B1)],c070),
cl([in([],write,_C1)],[in([],enter,_C1)],c071),
cl([in([],location_enter,_C1,f16(_C1))],[in([],enter,_C1)],c072),
cl([in([],canvas,f16(_C1))],[in([],enter,_C1)],c073),
cl([in([],enter,_C1)],[in([],write,_C1),in([],location_enter,_C1,_D1),in([],canvas,_D1)],c074),
cl([in([],productive,_E1)],[in([],write,_E1)],c075),
cl([in([],concerned,_E1,f17(_E1))],[in([],write,_E1)],c076),
cl([in([],thing,f17(_E1))],[in([],write,_E1)],c077),
cl([in([],write,_E1)],[in([],productive,_E1),in([],concerned,_E1,_F1),in([],thing,_F1)],c078),
cl([in([],causative,_G1)],[in([],productive,_G1)],c079),
cl([in([],result,_G1,f18(_G1))],[in([],productive,_G1)],c080),
cl([in([],thing,f18(_G1))],[in([],productive,_G1)],c081),
cl([in([],productive,_G1)],[in([],causative,_G1),in([],result,_G1,_H1),in([],thing,_H1)],c082),
cl([in([],action,_I1)],[in([],causative,_I1)],c083),
cl([in([],causative,_I1)],[in([],action,_I1)],c084),
cl([in([],lexicon,_J1)],[in([],werf,_J1)],c085),
cl([in([],action,_J1)],[in([],werf,_J1)],c086),
cl([in([],concerned,_J1,f19(_J1))],[in([],werf,_J1)],c087),
cl([in([],top,f19(_J1))],[in([],werf,_J1)],c088),
cl([in([],werf,_J1)],[in([],lexicon,_J1),in([],action,_J1),in([],concerned,_J1,_K1),in([],top,_K1)],c089),
cl([in([],lexicon,_L1)],[in([],treff,_L1)],c090),
cl([in([],action,_L1)],[in([],treff,_L1)],c091),
cl([in([],treff,_L1)],[in([],lexicon,_L1),in([],action,_L1)],c092),
cl([in([],lexicon,_M1)],[in([],geh,_M1)],c093),
cl([in([],motion,_M1)],[in([],geh,_M1)],c094),
cl([in([],geh,_M1)],[in([],lexicon,_M1),in([],motion,_M1)],c095),
cl([in([],lexicon,_N1)],[in([],fahr,_N1)],c096),
cl([in([],motion_by_means,_N1)],[in([],fahr,_N1)],c097),
cl([in([],fahr,_N1)],[in([],lexicon,_N1),in([],motion_by_means,_N1)],c098),
cl([in([],motion,_O1)],[in([],motion_by_means,_O1)],c099),
cl([in([],means,_O1,f20(_O1))],[in([],motion_by_means,_O1)],c100),
cl([in([],touchable_object,f20(_O1))],[in([],motion_by_means,_O1)],c101),
cl([in([],motion_by_means,_O1)],[in([],motion,_O1),in([],means,_O1,_P1),in([],touchable_object,_P1)],c102),
cl([in([],action,_Q1)],[in([],motion,_Q1)],c103),
cl([in([],destination,_Q1,f21(_Q1))],[in([],motion,_Q1)],c104),
cl([in([],geographical_object,f21(_Q1))],[in([],motion,_Q1)],c105),
cl([in([],source,_Q1,f22(_Q1))],[in([],motion,_Q1)],c106),
cl([in([],geographical_object,f22(_Q1))],[in([],motion,_Q1)],c107),
cl([in([],motion,_Q1)],[in([],action,_Q1),in([],destination,_Q1,_R1),in([],geographical_object,_R1),in([],source,_Q1,_S1),in([],geographical_object,_S1)],c108),
cl([in([],individual,_T1)],[in([],inanimate,_T1)],c109),
cl([in([],material_mod,_T1,f23(_T1))],[in([],inanimate,_T1)],c110),
cl([in([],material,f23(_T1))],[in([],inanimate,_T1)],c111),
cl([in([],inanimate,_T1)],[in([],individual,_T1),in([],material_mod,_T1,_U1),in([],material,_U1)],c112),
cl([in([],concrete_thing,_V1)],[in([],mass_noun,_V1)],c113),
cl([in([],mass_noun,_V1)],[in([],concrete_thing,_V1)],c114),
cl([in([],concrete_thing,_W1)],[in([],individual,_W1)],c115),
cl([in([],relative_mod,_W1,f24(_W1))],[in([],individual,_W1)],c116),
cl([in([],relation,f24(_W1))],[in([],individual,_W1)],c117),
cl([in([],individual,_W1)],[in([],concrete_thing,_W1),in([],relative_mod,_W1,_X1),in([],relation,_X1)],c118),
cl([in([],thing,_Y1)],[in([],concrete_thing,_Y1)],c119),
cl([in([],colour_mod,_Y1,f25(_Y1))],[in([],concrete_thing,_Y1)],c120),
cl([in([],colour,f25(_Y1))],[in([],concrete_thing,_Y1)],c121),
cl([in([],concrete_thing,_Y1)],[in([],thing,_Y1),in([],colour_mod,_Y1,_Z1),in([],colour,_Z1)],c122),
cl([in([],inanimate,_A2)],[in([],geographical_object,_A2)],c123),
cl([in([],origin_mod,_A2,f26(_A2))],[in([],geographical_object,_A2)],c124),
cl([in([],origin,f26(_A2))],[in([],geographical_object,_A2)],c125),
cl([in([],geographical_object,_A2)],[in([],inanimate,_A2),in([],origin_mod,_A2,_B2),in([],origin,_B2)],c126),
cl([in([],animate,_C2)],[in([],human,_C2)],c127),
cl([in([],volition,_C2,f27(_C2))],[in([],human,_C2)],c128),
cl([in([],volitional_sq,f27(_C2))],[in([],human,_C2)],c129),
cl([in([],human,_C2)],[in([],animate,_C2),in([],volition,_C2,_D2),in([],volitional_sq,_D2)],c130),
cl([in([],fss,_E2)],[in([],predicate,_E2)],c131),
cl([in([],subject,_E2,f28(_E2))],[in([],predicate,_E2)],c132),
cl([in([],thing,f28(_E2))],[in([],predicate,_E2)],c133),
cl([in([],purpose,_E2,f29(_E2))],[in([],predicate,_E2)],c134),
cl([in([],predicate,f29(_E2))],[in([],predicate,_E2)],c135),
cl([in([],time,_E2,f30(_E2))],[in([],predicate,_E2)],c136),
cl([in([],time,f30(_E2))],[in([],predicate,_E2)],c137),
cl([in([],illoc,_E2,f31(_E2))],[in([],predicate,_E2)],c138),
cl([in([],speech_act,f31(_E2))],[in([],predicate,_E2)],c139),
cl([in([],cause,_E2,f32(_E2))],[in([],predicate,_E2)],c140),
cl([in([],predicate,f32(_E2))],[in([],predicate,_E2)],c141),
cl([in([],result,_E2,f33(_E2))],[in([],predicate,_E2)],c142),
cl([in([],thing,f33(_E2))],[in([],predicate,_E2)],c143),
cl([in([],location,_E2,f34(_E2))],[in([],predicate,_E2)],c144),
cl([in([],thing,f34(_E2))],[in([],predicate,_E2)],c145),
cl([in([],predicate,_E2)],[in([],fss,_E2),in([],subject,_E2,_F2),in([],thing,_F2),in([],purpose,_E2,_G2),in([],predicate,_G2),in([],time,_E2,_H2),in([],time,_H2),in([],illoc,_E2,_I2),in([],speech_act,_I2),in([],cause,_E2,_J2),in([],predicate,_J2),in([],result,_E2,_K2),in([],thing,_K2),in([],location,_E2,_L2),in([],thing,_L2)],c146),
cl([in([],property_filler,_M2)],[in([],thing,_M2)],c147),
cl([in([],det,_M2,f35(_M2))],[in([],thing,_M2)],c148),
cl([in([],determiner,f35(_M2))],[in([],thing,_M2)],c149),
cl([in([],deitic_mpd,_M2,f36(_M2))],[in([],thing,_M2)],c150),
cl([in([],pointing,f36(_M2))],[in([],thing,_M2)],c151),
cl([in([],named,_M2,f37(_M2))],[in([],thing,_M2)],c152),
cl([in([],atom_codes,f37(_M2))],[in([],thing,_M2)],c153),
cl([in([],thing,_M2)],[in([],property_filler,_M2),in([],det,_M2,_N2),in([],determiner,_N2),in([],deitic_mpd,_M2,_O2),in([],pointing,_O2),in([],named,_M2,_P2),in([],atom_codes,_P2)],c154),
cl([in([],thing,_Q2)],[in([],abstract_thing,_Q2)],c155),
cl([in([],truth_mod,_Q2,f38(_Q2))],[in([],abstract_thing,_Q2)],c156),
cl([in([],top,f38(_Q2))],[in([],abstract_thing,_Q2)],c157),
cl([in([],truth_mod,_Q2,f39(_Q2))],[in([],abstract_thing,_Q2)],c158),
cl([in([],top,f39(_Q2))],[in([],abstract_thing,_Q2)],c159),
cl([in([],abstract_thing,_Q2)],[in([],thing,_Q2),in([],truth_mod,_Q2,_R2),in([],top,_R2),in([],truth_mod,_Q2,_S2),in([],top,_S2)],c160),
cl([in([],lexicon,_T2)],[in([],mein,_T2)],c161),
cl([in([],determiner,_T2)],[in([],mein,_T2)],c162),
cl([in([],mein,_T2)],[in([],lexicon,_T2),in([],determiner,_T2)],c163),
cl([in([],lexicon,_U2)],[in([],dem,_U2)],c164),
cl([in([],definite,_U2)],[in([],dem,_U2)],c165),
cl([in([],dem,_U2)],[in([],lexicon,_U2),in([],definite,_U2)],c166),
cl([in([],definite,_V2)],[in([],die,_V2)],c167),
cl([in([],lexicon,_V2)],[in([],die,_V2)],c168),
cl([in([],die,_V2)],[in([],definite,_V2),in([],lexicon,_V2)],c169),
cl([in([],definite,_W2)],[in([],der,_W2)],c170),
cl([in([],lexicon,_W2)],[in([],der,_W2)],c171),
cl([in([],der,_W2)],[in([],definite,_W2),in([],lexicon,_W2)],c172),
cl([in([],cardinal,_X2)],[in([],fuenfunddreissig,_X2)],c173),
cl([in([],lexicon,_X2)],[in([],fuenfunddreissig,_X2)],c174),
cl([in([],fuenfunddreissig,_X2)],[in([],cardinal,_X2),in([],lexicon,_X2)],c175),
cl([in([],cardinal,_Y2)],[in([],number35,_Y2)],c176),
cl([in([],lexicon,_Y2)],[in([],number35,_Y2)],c177),
cl([in([],number35,_Y2)],[in([],cardinal,_Y2),in([],lexicon,_Y2)],c178),
cl([in([],indefinite,_Z2)],[in([],ein,_Z2)],c179),
cl([in([],lexicon,_Z2)],[in([],ein,_Z2)],c180),
cl([in([],ein,_Z2)],[in([],indefinite,_Z2),in([],lexicon,_Z2)],c181),
cl([in([],determiner,_A3)],[in([],d,_A3)],c182),
cl([in([],lexicon,_A3)],[in([],d,_A3)],c183),
cl([in([],d,_A3)],[in([],determiner,_A3),in([],lexicon,_A3)],c184),
cl([in([],monthly,_B3)],[in([],monat,_B3)],c185),
cl([in([],lexicon,_B3)],[in([],monat,_B3)],c186),
cl([in([],monat,_B3)],[in([],monthly,_B3),in([],lexicon,_B3)],c187),
cl([in([],daily,_C3)],[in([],taeglich,_C3)],c188),
cl([in([],lexicon,_C3)],[in([],taeglich,_C3)],c189),
cl([in([],taeglich,_C3)],[in([],daily,_C3),in([],lexicon,_C3)],c190),
cl([in([],sbone,_D3)],[in([],lexicon,_D3)],c191),
cl([in([],sbone,_E3)],[in([],lexicon,_E3)],c192),
cl([in([],top,_F3)],[in([],sbone,_F3)],c193),
cl([in([],lexicon,_G3)],[in([],was,_G3)],c194),
cl([in([],thing,_G3)],[in([],was,_G3)],c195),
cl([in([],lexicon,_H3)],[in([],was,_H3)],c196),
cl([in([],thing,_H3)],[in([],was,_H3)],c197),
cl([in([],lexicon,_I3)],[in([],auktion,_I3)],c198),
cl([in([],thing,_I3)],[in([],auktion,_I3)],c199),
cl([in([],lexicon,_J3)],[in([],auktion,_J3)],c200),
cl([in([],thing,_J3)],[in([],auktion,_J3)],c201),
cl([in([],touchable_object,_K3)],[in([],result,_K3)],c202),
cl([in([],touchable_object,_L3)],[in([],result,_L3)],c203),
cl([in([],lexicon,_M3)],[in([],kochbuch,_M3)],c204),
cl([in([],touchable_object,_M3)],[in([],kochbuch,_M3)],c205),
cl([in([],lexicon,_N3)],[in([],kochbuch,_N3)],c206),
cl([in([],touchable_object,_N3)],[in([],kochbuch,_N3)],c207),
cl([in([],lexicon,_O3)],[in([],buch,_O3)],c208),
cl([in([],touchable_object,_O3)],[in([],buch,_O3)],c209),
cl([in([],lexicon,_P3)],[in([],buch,_P3)],c210),
cl([in([],touchable_object,_P3)],[in([],buch,_P3)],c211),
cl([in([],vehicle,_Q3)],[in([],motorrad,_Q3)],c212),
cl([in([],lexicon,_Q3)],[in([],motorrad,_Q3)],c213),
cl([in([],vehicle,_R3)],[in([],motorrad,_R3)],c214),
cl([in([],lexicon,_R3)],[in([],motorrad,_R3)],c215),
cl([in([],vehicle,_S3)],[in([],bus,_S3)],c216),
cl([in([],lexicon,_S3)],[in([],bus,_S3)],c217),
cl([in([],vehicle,_T3)],[in([],bus,_T3)],c218),
cl([in([],lexicon,_T3)],[in([],bus,_T3)],c219),
cl([in([],vehicle,_U3)],[in([],fahrrad,_U3)],c220),
cl([in([],lexicon,_U3)],[in([],fahrrad,_U3)],c221),
cl([in([],vehicle,_V3)],[in([],fahrrad,_V3)],c222),
cl([in([],lexicon,_V3)],[in([],fahrrad,_V3)],c223),
cl([in([],human,_W3)],[in([],system,_W3)],c224),
cl([in([],inanimate,_W3)],[in([],system,_W3)],c225),
cl([in([],human,_X3)],[in([],system,_X3)],c226),
cl([in([],inanimate,_X3)],[in([],system,_X3)],c227),
cl([in([],information,_Y3)],[in([],string,_Y3)],c228),
cl([in([],information,_Z3)],[in([],string,_Z3)],c229),
cl([in([],inanimate,_A4)],[in([],information,_A4)],c230),
cl([in([],inanimate,_B4)],[in([],information,_B4)],c231),
cl([in([],lexicon,_C4)],[in([],ort,_C4)],c232),
cl([in([],geographical_object,_C4)],[in([],ort,_C4)],c233),
cl([in([],lexicon,_D4)],[in([],ort,_D4)],c234),
cl([in([],geographical_object,_D4)],[in([],ort,_D4)],c235),
cl([in([],geographical_object,_E4)],[in([],hier,_E4)],c236),
cl([in([],lexicon,_E4)],[in([],hier,_E4)],c237),
cl([in([],geographical_object,_F4)],[in([],hier,_F4)],c238),
cl([in([],lexicon,_F4)],[in([],hier,_F4)],c239),
cl([in([],geographical_object,_G4)],[in([],wald,_G4)],c240),
cl([in([],lexicon,_G4)],[in([],wald,_G4)],c241),
cl([in([],geographical_object,_H4)],[in([],wald,_H4)],c242),
cl([in([],lexicon,_H4)],[in([],wald,_H4)],c243),
cl([in([],lexicon,_I4)],[in([],berlin,_I4)],c244),
cl([in([],town,_I4)],[in([],berlin,_I4)],c245),
cl([in([],lexicon,_J4)],[in([],berlin,_J4)],c246),
cl([in([],town,_J4)],[in([],berlin,_J4)],c247),
cl([in([],lexicon,_K4)],[in([],saarlouis,_K4)],c248),
cl([in([],town,_K4)],[in([],saarlouis,_K4)],c249),
cl([in([],lexicon,_L4)],[in([],saarlouis,_L4)],c250),
cl([in([],town,_L4)],[in([],saarlouis,_L4)],c251),
cl([in([],town,_M4)],[in([],dudweiler,_M4)],c252),
cl([in([],lexicon,_M4)],[in([],dudweiler,_M4)],c253),
cl([in([],town,_N4)],[in([],dudweiler,_N4)],c254),
cl([in([],lexicon,_N4)],[in([],dudweiler,_N4)],c255),
cl([in([],town,_O4)],[in([],saarbruecken,_O4)],c256),
cl([in([],lexicon,_O4)],[in([],saarbruecken,_O4)],c257),
cl([in([],town,_P4)],[in([],saarbruecken,_P4)],c258),
cl([in([],lexicon,_P4)],[in([],saarbruecken,_P4)],c259),
cl([in([],geographical_object,_Q4)],[in([],town,_Q4)],c260),
cl([in([],geographical_object,_R4)],[in([],town,_R4)],c261),
cl([in([],animate,_S4)],[in([],plant,_S4)],c262),
cl([in([],animate,_T4)],[in([],plant,_T4)],c263),
cl([in([],lexicon,_U4)],[in([],person,_U4)],c264),
cl([in([],human,_U4)],[in([],person,_U4)],c265),
cl([in([],lexicon,_V4)],[in([],person,_V4)],c266),
cl([in([],human,_V4)],[in([],person,_V4)],c267),
cl([in([],lexicon,_W4)],[in([],sie,_W4)],c268),
cl([in([],human,_W4)],[in([],sie,_W4)],c269),
cl([in([],lexicon,_X4)],[in([],sie,_X4)],c270),
cl([in([],human,_X4)],[in([],sie,_X4)],c271),
cl([in([],human,_Y4)],[in([],frau,_Y4)],c272),
cl([in([],lexicon,_Y4)],[in([],frau,_Y4)],c273),
cl([in([],human,_Z4)],[in([],frau,_Z4)],c274),
cl([in([],lexicon,_Z4)],[in([],frau,_Z4)],c275),
cl([in([],abstract_thing,_A5)],[in([],number,_A5)],c276),
cl([in([],abstract_thing,_B5)],[in([],number,_B5)],c277),
cl([in([],lexicon,_C5)],[in([],steuerhandlung,_C5)],c278),
cl([in([],tax_action,_C5)],[in([],steuerhandlung,_C5)],c279),
cl([in([],lexicon,_D5)],[in([],steuerhandlung,_D5)],c280),
cl([in([],tax_action,_D5)],[in([],steuerhandlung,_D5)],c281),
cl([in([],abstract_thing,_E5)],[in([],tax_action,_E5)],c282),
cl([in([],abstract_thing,_F5)],[in([],tax_action,_F5)],c283),
cl([in([],abstract_thing,_G5)],[in([],profession,_G5)],c284),
cl([in([],abstract_thing,_H5)],[in([],profession,_H5)],c285),
cl([in([],lexicon,_I5)],[in([],geld,_I5)],c286),
cl([in([],cost,_I5)],[in([],geld,_I5)],c287),
cl([in([],lexicon,_J5)],[in([],geld,_J5)],c288),
cl([in([],cost,_J5)],[in([],geld,_J5)],c289),
cl([in([],lexicon,_K5)],[in([],kosten,_K5)],c290),
cl([in([],cost,_K5)],[in([],kosten,_K5)],c291),
cl([in([],lexicon,_L5)],[in([],kosten,_L5)],c292),
cl([in([],cost,_L5)],[in([],kosten,_L5)],c293),
cl([in([],abstract_thing,_M5)],[in([],cost,_M5)],c294),
cl([in([],abstract_thing,_N5)],[in([],cost,_N5)],c295),
cl([in([],motion_by_means,_O5)],[in([],motion_by_means_content,_O5)],c296),
cl([in([],action_content,_O5)],[in([],motion_by_means_content,_O5)],c297),
cl([in([],motion_by_means,_P5)],[in([],motion_by_means_content,_P5)],c298),
cl([in([],action_content,_P5)],[in([],motion_by_means_content,_P5)],c299),
cl([in([],action_content,_Q5)],[in([],motion_content,_Q5)],c300),
cl([in([],motion,_Q5)],[in([],motion_content,_Q5)],c301),
cl([in([],action_content,_R5)],[in([],motion_content,_R5)],c302),
cl([in([],motion,_R5)],[in([],motion_content,_R5)],c303),
cl([in([],abstract_thing,_S5)],[in([],action_content,_S5)],c304),
cl([in([],action,_S5)],[in([],action_content,_S5)],c305),
cl([in([],abstract_thing,_T5)],[in([],action_content,_T5)],c306),
cl([in([],action,_T5)],[in([],action_content,_T5)],c307),
cl([in([],profession,_U5)],[in([],informatiker,_U5)],c308),
cl([in([],lexicon,_U5)],[in([],informatiker,_U5)],c309),
cl([in([],profession,_V5)],[in([],informatiker,_V5)],c310),
cl([in([],lexicon,_V5)],[in([],informatiker,_V5)],c311),
cl([in([],profession,_W5)],[in([],schreiner,_W5)],c312),
cl([in([],lexicon,_W5)],[in([],schreiner,_W5)],c313),
cl([in([],profession,_X5)],[in([],schreiner,_X5)],c314),
cl([in([],lexicon,_X5)],[in([],schreiner,_X5)],c315),
cl([in([],abstract_thing,_Y5)],[in([],gi,_Y5)],c316),
cl([in([],lexicon,_Y5)],[in([],gi,_Y5)],c317),
cl([in([],abstract_thing,_Z5)],[in([],gi,_Z5)],c318),
cl([in([],lexicon,_Z5)],[in([],gi,_Z5)],c319),
cl([in([],top,_A6)],[in([],voelklingen_name,_A6)],c320),
cl([in([],quality,_B6)],[in([],worth,_B6)],c321),
cl([in([],quality,_C6)],[in([],worth,_C6)],c322),
cl([in([],colour,_D6)],[in([],rot,_D6)],c323),
cl([in([],lexicon,_D6)],[in([],rot,_D6)],c324),
cl([in([],colour,_E6)],[in([],rot,_E6)],c325),
cl([in([],lexicon,_E6)],[in([],rot,_E6)],c326),
cl([in([],lexicon,_F6)],[in([],gross,_F6)],c327),
cl([in([],physical_sq,_F6)],[in([],gross,_F6)],c328),
cl([in([],lexicon,_G6)],[in([],gross,_G6)],c329),
cl([in([],physical_sq,_G6)],[in([],gross,_G6)],c330),
cl([in([],lexicon,_H6)],[in([],klein,_H6)],c331),
cl([in([],physical_sq,_H6)],[in([],klein,_H6)],c332),
cl([in([],lexicon,_I6)],[in([],klein,_I6)],c333),
cl([in([],physical_sq,_I6)],[in([],klein,_I6)],c334),
cl([in([],state_q,_J6)],[in([],physical_sq,_J6)],c335),
cl([in([],state_q,_K6)],[in([],physical_sq,_K6)],c336),
cl([in([],state_q,_L6)],[in([],volitional_sq,_L6)],c337),
cl([in([],state_q,_M6)],[in([],volitional_sq,_M6)],c338),
cl([in([],qualitative,_N6)],[in([],state_q,_N6)],c339),
cl([in([],qualitative,_O6)],[in([],state_q,_O6)],c340),
cl([in([],adjective_property,_P6)],[in([],origin,_P6)],c341),
cl([in([],adjective_property,_Q6)],[in([],origin,_Q6)],c342),
cl([in([],lexicon,_R6)],[in([],haben,_R6)],c343),
cl([in([],property,_R6)],[in([],haben,_R6)],c344),
cl([in([],concept108,_R6)],[in([],haben,_R6)],c345),
cl([in([],lexicon,_S6)],[in([],haben,_S6)],c346),
cl([in([],property,_S6)],[in([],haben,_S6)],c347),
cl([in([],has_property_haben,_S6,f40(_S6))],[in([],haben,_S6)],c348),
cl([in([],thing,f40(_S6))],[in([],haben,_S6)],c349),
cl([in([],lexicon,_T6)],[in([],besitzen,_T6)],c350),
cl([in([],property,_T6)],[in([],besitzen,_T6)],c351),
cl([in([],lexicon,_U6)],[in([],besitzen,_U6)],c352),
cl([in([],property,_U6)],[in([],besitzen,_U6)],c353),
cl([in([],lexicon,_V6)],[in([],sein,_V6)],c354),
cl([in([],property,_V6)],[in([],sein,_V6)],c355),
cl([in([],lexicon,_W6)],[in([],sein,_W6)],c356),
cl([in([],property,_W6)],[in([],sein,_W6)],c357),
cl([in([],deducte,_X6)],[in([],absetzbar,_X6)],c358),
cl([in([],lexicon,_X6)],[in([],absetzbar,_X6)],c359),
cl([in([],deducte,_Y6)],[in([],absetzbar,_Y6)],c360),
cl([in([],lexicon,_Y6)],[in([],absetzbar,_Y6)],c361),
cl([in([],property,_Z6)],[in([],deducte,_Z6)],c362),
cl([in([],property,_A7)],[in([],deducte,_A7)],c363),
cl([in([],predicate,_B7)],[in([],property,_B7)],c364),
cl([in([],predicate,_C7)],[in([],property,_C7)],c365),
cl([in([],lexicon,_D7)],[in([],verursach,_D7)],c366),
cl([in([],reason,_D7)],[in([],verursach,_D7)],c367),
cl([in([],lexicon,_E7)],[in([],verursach,_E7)],c368),
cl([in([],reason,_E7)],[in([],verursach,_E7)],c369),
cl([in([],action,_F7)],[in([],reason,_F7)],c370),
cl([in([],action,_G7)],[in([],reason,_G7)],c371),
cl([in([],lexicon,_H7)],[in([],zahl,_H7)],c372),
cl([in([],transaction,_H7)],[in([],zahl,_H7)],c373),
cl([in([],lexicon,_I7)],[in([],zahl,_I7)],c374),
cl([in([],transaction,_I7)],[in([],zahl,_I7)],c375),
cl([in([],repeat,_J7)],[in([],wiederhol,_J7)],c376),
cl([in([],lexicon,_J7)],[in([],wiederhol,_J7)],c377),
cl([in([],repeat,_K7)],[in([],wiederhol,_K7)],c378),
cl([in([],lexicon,_K7)],[in([],wiederhol,_K7)],c379),
cl([in([],action,_L7)],[in([],repeat,_L7)],c380),
cl([in([],action,_M7)],[in([],repeat,_M7)],c381),
cl([in([],touchable_object,_N7)],[in([],canvas,_N7)],c382),
cl([in([],touchable_object,_O7)],[in([],canvas,_O7)],c383),
cl([in([],quality,_P7)],[in([],weight,_P7)],c384),
cl([in([],quality,_Q7)],[in([],weight,_Q7)],c385),
cl([in([],mass_noun,_R7)],[in([],material,_R7)],c386),
cl([in([],mass_noun,_S7)],[in([],material,_S7)],c387),
cl([in([],adjective_property,_T7)],[in([],relation,_T7)],c388),
cl([in([],adjective_property,_U7)],[in([],relation,_U7)],c389),
cl([in([],quality,_V7)],[in([],colour,_V7)],c390),
cl([in([],quality,_W7)],[in([],colour,_W7)],c391),
cl([in([],qualitative,_X7)],[in([],quality,_X7)],c392),
cl([in([],qualitative,_Y7)],[in([],quality,_Y7)],c393),
cl([in([],adjective_property,_Z7)],[in([],qualitative,_Z7)],c394),
cl([in([],adjective_property,_A8)],[in([],qualitative,_A8)],c395),
cl([in([],lexicon,_B8)],[in([],wohn,_B8)],c396),
cl([in([],state,_B8)],[in([],wohn,_B8)],c397),
cl([in([],concept50,_B8)],[in([],wohn,_B8)],c398),
cl([in([],concept51,_B8)],[in([],wohn,_B8)],c399),
cl([in([],lexicon,_C8)],[in([],wohn,_C8)],c400),
cl([in([],state,_C8)],[in([],wohn,_C8)],c401),
cl([in([],agent,_C8,f41(_C8))],[in([],wohn,_C8)],c402),
cl([in([],human,f41(_C8))],[in([],wohn,_C8)],c403),
cl([in([],location_wohn,_C8,f42(_C8))],[in([],wohn,_C8)],c404),
cl([in([],location,f42(_C8))],[in([],wohn,_C8)],c405),
cl([in([],predicate,_D8)],[in([],state,_D8)],c406),
cl([in([],concept41,_D8)],[in([],state,_D8)],c407),
cl([in([],predicate,_E8)],[in([],state,_E8)],c408),
cl([in([],time,_E8,f43(_E8))],[in([],state,_E8)],c409),
cl([in([],period,f43(_E8))],[in([],state,_E8)],c410),
cl([in([],abstract_thing,_F8)],[in([],atom_codes,_F8)],c411),
cl([in([],abstract_thing,_G8)],[in([],atom_codes,_G8)],c412),
cl([in([],adjective_property,_H8)],[in([],truth_value,_H8)],c413),
cl([in([],adjective_property,_I8)],[in([],truth_value,_I8)],c414),
cl([in([],property_filler,_J8)],[in([],adjective_property,_J8)],c415),
cl([in([],property_filler,_K8)],[in([],adjective_property,_K8)],c416),
cl([in([],fss,_L8)],[in([],property_filler,_L8)],c417),
cl([in([],fss,_M8)],[in([],property_filler,_M8)],c418),
cl([in([],definite,_N8)],[in([],possessive,_N8)],c419),
cl([in([],definite,_O8)],[in([],possessive,_O8)],c420),
cl([in([],definite,_P8)],[in([],demonstrative,_P8)],c421),
cl([in([],definite,_Q8)],[in([],demonstrative,_Q8)],c422),
cl([in([],determiner,_R8)],[in([],definite,_R8)],c423),
cl([in([],determiner,_S8)],[in([],definite,_S8)],c424),
cl([in([],determiner,_T8)],[in([],interrogative,_T8)],c425),
cl([in([],determiner,_U8)],[in([],interrogative,_U8)],c426),
cl([in([],cardinal,_V8)],[in([],number50,_V8)],c427),
cl([in([],lexicon,_V8)],[in([],number50,_V8)],c428),
cl([in([],cardinal,_W8)],[in([],number50,_W8)],c429),
cl([in([],lexicon,_W8)],[in([],number50,_W8)],c430),
cl([in([],indefinite,_X8)],[in([],cardinal,_X8)],c431),
cl([in([],indefinite,_Y8)],[in([],cardinal,_Y8)],c432),
cl([in([],determiner,_Z8)],[in([],indefinite,_Z8)],c433),
cl([in([],determiner,_A9)],[in([],indefinite,_A9)],c434),
cl([in([],fss,_B9)],[in([],determiner,_B9)],c435),
cl([in([],fss,_C9)],[in([],determiner,_C9)],c436),
cl([in([],speech_act,_D9)],[in([],interjection,_D9)],c437),
cl([in([],speech_act,_E9)],[in([],interjection,_E9)],c438),
cl([in([],speech_act,_F9)],[in([],question,_F9)],c439),
cl([in([],speech_act,_G9)],[in([],question,_G9)],c440),
cl([in([],speech_act,_H9)],[in([],assertion,_H9)],c441),
cl([in([],speech_act,_I9)],[in([],assertion,_I9)],c442),
cl([in([],speech_act,_J9)],[in([],order,_J9)],c443),
cl([in([],speech_act,_K9)],[in([],order,_K9)],c444),
cl([in([],fss,_L9)],[in([],speech_act,_L9)],c445),
cl([in([],fss,_M9)],[in([],speech_act,_M9)],c446),
cl([in([],interval,_N9)],[in([],monthly,_N9)],c447),
cl([in([],interval,_O9)],[in([],monthly,_O9)],c448),
cl([in([],interval,_P9)],[in([],daily,_P9)],c449),
cl([in([],interval,_Q9)],[in([],daily,_Q9)],c450),
cl([in([],lexicon,_R9)],[in([],woechentlich,_R9)],c451),
cl([in([],weekly,_R9)],[in([],woechentlich,_R9)],c452),
cl([in([],lexicon,_S9)],[in([],woechentlich,_S9)],c453),
cl([in([],weekly,_S9)],[in([],woechentlich,_S9)],c454),
cl([in([],interval,_T9)],[in([],weekly,_T9)],c455),
cl([in([],interval,_U9)],[in([],weekly,_U9)],c456),
cl([in([],yearly,_V9)],[in([],jaehrlich,_V9)],c457),
cl([in([],lexicon,_V9)],[in([],jaehrlich,_V9)],c458),
cl([in([],yearly,_W9)],[in([],jaehrlich,_W9)],c459),
cl([in([],lexicon,_W9)],[in([],jaehrlich,_W9)],c460),
cl([in([],interval,_X9)],[in([],yearly,_X9)],c461),
cl([in([],interval,_Y9)],[in([],yearly,_Y9)],c462),
cl([in([],time,_Z9)],[in([],interval,_Z9)],c463),
cl([in([],time,_A10)],[in([],interval,_A10)],c464),
cl([in([],time,_B10)],[in([],period,_B10)],c465),
cl([in([],time,_C10)],[in([],period,_C10)],c466),
cl([in([],time,_D10)],[in([],moment,_D10)],c467),
cl([in([],time,_E10)],[in([],moment,_E10)],c468),
cl([in([],fss,_F10)],[in([],time,_F10)],c469),
cl([in([],fss,_G10)],[in([],time,_G10)],c470),
cl([in([],pointing,_H10)],[in([],exact_p,_H10)],c471),
cl([in([],pointing,_I10)],[in([],exact_p,_I10)],c472),
cl([in([],pointing,_J10)],[in([],encircling_p,_J10)],c473),
cl([in([],pointing,_K10)],[in([],encircling_p,_K10)],c474),
cl([in([],pointing,_L10)],[in([],standard_p,_L10)],c475),
cl([in([],pointing,_M10)],[in([],standard_p,_M10)],c476),
cl([in([],pointing,_N10)],[in([],vague_p,_N10)],c477),
cl([in([],pointing,_O10)],[in([],vague_p,_O10)],c478),
cl([in([],fss,_P10)],[in([],pointing,_P10)],c479),
cl([in([],fss,_Q10)],[in([],pointing,_Q10)],c480),
cl([in([],sbone,_R10)],[in([],fss,_R10)],c481),
cl([in([],sbone,_S10)],[in([],fss,_S10)],c482),
cl([in([],sbone,_T10)],[in([],fss,_T10)],c483),
cl([in([],sbone,_U10)],[in([],fss,_U10)],c484)]).
% Clause set fss
% generated from the fss knowledge base
% 14.03.95: Total runtime  943.049 sec.
clauseSet(fss,L) :-
	clauseSet(fssTBox,L90),
	append(L90,
	       [cl([in([],yearly,birthday)],[],c485),
%		cl([in([],speech_act,hello)],[],c486),
%		cl([in([],question,where)],[],c487),
%		cl([in([],question,when)],[],c488),
		cl([in([],question,how)],[],c489),
		cl([in([],thing,car1)],[],c490),
		cl([],[in([],abstract_thing,boat1)],c491),
		cl([in([],cost,boat1)],[],c492),
		cl([in([],thing,plane1)],[],c493)],L).
clauseSet(fss1,
[cl([in([],touchable_object,_A)],[in([],vehicle,_A)],c001),
cl([in([],worth_mod,_A,f8(_A))],[in([],vehicle,_A)],c002),
cl([in([],worth,f8(_A))],[in([],vehicle,_A)],c003),
cl([in([],vehicle,_A)],[in([],touchable_object,_A),in([],worth_mod,_A,_B),in([],worth,_B)],c004),
cl([in([],town,_C)],[in([],voelklingen,_C)],c005)]).
/**********************************************************************
 *
 * @(#) roleFunctions.pl 1.2@(#)
 *
 */

/***********************************************************************
 *
 * getDirectFatherRoles(+EnvName,+MS,+Role,-RL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role        role atom_codes
 *            RL          list of role names
 * RL is the list of all role names which are direct father roles
 * of Role.
 *
 */

getDirectFatherRoles(EnvName,MS,Role,RL) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	getDirectSuperElements(Role,RL,Dag).

/***********************************************************************
 *
 * getAllFatherRoles(+EnvName,+MS,+Role,-RL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role        role atom_codes
 *            RL          list of role names
 * RL is the list of all role names which are father roles of
 * Role
 *
 */

getAllFatherRoles(EnvName,MS,Role,RL) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	getAllSuperElements(Role,RL,[],Dag).

/***********************************************************************
 *
 * getDirectSonRoles(+EnvName,+MS,+Role,-RL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role        role atom_codes
 *            RL          list of role names
 * RL is the list of all role names which are direct father roles
 * of Role
 *
 */

getDirectSonRoles(EnvName,MS,Role,RL) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	getDirectSubElements(Role,RL,Dag).

/***********************************************************************
 *
 * getAllSonRoles(+EnvName,+MS,+Role,-RL)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role        role atom_codes
 *            RL          list of role names
 * RL is the list of all role names which are father roles of 
 * Role
 *
 */

getAllSonRoles(EnvName,MS,Role,RL) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	getAllSubElements(Role,RL,Dag).

/***********************************************************************
 *
 * getRoles(+EnvName,+MS,-RL)
 * Arguments: EnvName     environment identifier
 *            MS     modal context
 *            RL     list of role names
 * RL is the list of all role names in the subsumption hierarchy.
 *
 */

getRoles(EnvName,MS,['top'|RL]) :-
	getAllSonRoles(EnvName,MS,'top',RL).

/***********************************************************************
 *
 * testDirectFatherRole(+EnvName,+MS,+Role1,+Role2,-Role)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role1       role atom_codes
 *            Role2       role atom_codes
 *            Role        role atom_codes
 * Role is Role1 iff Role1 is a direct father role of Role2
 * or
 * Role is Role2 iff Role2 is a direct father role of Role1
 * otherwise
 * the predicate fails
 *
 */

testDirectFatherRole(EnvName,MS,Role1,Role2,Role) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	testDirectSuperElement(Role1,Role2,Role,Dag).

/***********************************************************************
 *
 * testDirectSonRole(+EnvName,+MS,+Role1,+Role2,-Role)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role1       role atom_codes
 *            Role2       role atom_codes
 *            Role        role atom_codes
 * Role is Role1 iff Role1 is a direct subrole of Role2
 * or
 * Role is Role2 iff Role2 is a direct subrole of Role1
 * otherwise
 * the predicate fails
 *
 */

testDirectSonRole(EnvName,MS,Role1,Role2,Role) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	testDirectSuperElement(Role1,Role2,Role,Dag).

/***********************************************************************
 *
 * testFatherRole(+EnvName,+MS,+Role1,+Role2,-Role)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role1       role atom_codes
 *            Role2       role atom_codes
 *            Role        role atom_codes
 * Role is Role1 iff Role1 is a direct father role of Role2
 * or
 * Role is Role2 iff Role2 is a direct father role of Role1
 * otherwise
 * the predicate fails
 *
 */

testFatherRole(EnvName,MS,Role1,Role2,Role) :-
	environment(EnvName,Env,_),
	roleHierarchy(Env,MS,Dag),
	testSuperElement(Role1,Role2,Role,Dag).

/***********************************************************************
 *
 * testSonRole(+EnvName,+MS,+Role1,+Role2,-Role)
 * Arguments: EnvName     environment identifier
 *            MS          modal context
 *            Role1       role atom_codes
 *            Role2       role atom_codes
 *            Role        role atom_codes
 * Role is Role1 iff Role1 is a direct father role of Role2
 * or
 * Role is Role2 iff Role2 is a direct father role of Role1
 * otherwise
 * the predicate fails
 *
 */

testSonRole(Env,MS,Role1,Role2,Role) :-
	roleHierarchy(Env,MS,Dag),
	testSubElement(Role1,Role2,Role,Dag).

/***********************************************************************
 *
 * getCommonFatherRoles(+EnvName,+MS,RL1,RL2)
 * Arguments: EnvName  environment identifier
 *            MS       modal context
 *            RL1      list of role names
 *            RL2      list of role names
 * RL2 is the list of all role names subsuming all roles in RL1.
 *
 */

getCommonFatherRoles(EnvName,MS,RL1,RL2) :-
	hop_map(getAllFatherRoles,[EnvName,MS],RL1,RLL1),
	intersectionOfLists(RLL1,RL2).

/***********************************************************************
 *
 * getCommonSonRoles(+EnvName,+MS,RL1,RL2)
 * Arguments: EnvName  environment identifier
 *            MS       modal context
 *            RL1      list of role names
 *            RL2      list of role names
 * RL2 is the list of all role names which are subsumed by all
 * roles in RL1.
 *
 */

getCommonSonRoles(EnvName,MS,RL1,RL2) :-
	hop_map(getAllSonRoles,[EnvName,MS],RL1,RLL1),
	intersectionOfLists(RLL1,RL2).

/**********************************************************************
 *
 * @(#) revision.pl 1.38@(#)
 *
 */

/**********************************************************************
 *
 * undefconcept(+MS,+CN)
 *
 */


undefconcept(CN) :-
	getCurrentEnvironment(EnvName),
	undefconcept(EnvName,[],CN).

undefconcept(EnvName,CN) :-
	environment(EnvName,_,_),
	!,
	undefconcept(EnvName,[],CN).
undefconcept(MS,CN) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefconcept(EnvName,MS,CN).
undefconcept(CN,CT) :-
	getCurrentEnvironment(EnvName),
	undefconcept(EnvName,[],CN,CT).

undefconcept(EnvName,MS,CN) :-

	environment(EnvName,Env,_),
	(MS = [] ; MS = [_|_]),
	!,
	undefConcept(Env,MS,CN).
undefconcept(MS,CN,CT) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefconcept(EnvName,MS,CN,CT).
undefconcept(EnvName,CN,CT) :-
	undefconcept(EnvName,[],CN,CT).

undefconcept(EnvName,MS,CN,CT) :-
	environment(EnvName,Env,_),
	conceptEqualSets(Env,_user,MS,CN,CT,AX1),
	retractallSpecial(axiom(Env,MS,defconcept(MS,CN,CT))),
 	retractallSpecial(kb_in(Env,_,rn(AX1,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
 	retract_all(query(Env,MS,CN,_CT,_PT,_)),
	retractallSpecial(eq(Env,rn(AX1,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX1,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX1,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX1,_,_,_),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,CN,CT),
	retract(conceptEqualSets(Env,_user,MS,CN,CT,AX1)),
	conceptEqualSets(Env,_,MS,_,not(CN),AX2),
 	retractallSpecial(kb_in(Env,_,rn(AX2,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
 	retract_all(query(Env,MS,CN,_CT,_PT,_)),
	retractallSpecial(eq(Env,rn(AX2,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX2,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX2,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX2,_,_,_),_,_,_,_,_,_)),
	!.

undefConcept(Env,MS,CN) :-
	conceptEqualSets(Env,user,_,CN,_,AX),
	retractallSpecial(axiom(Env,MS,defconcept(MS,CN,_CT1))),
 	retractallSpecial(kb_in(Env,_,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],_,_),_,_))),
   	retract_all(query(Env,MS,CN,_CT,_PT,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,CN,CT),
	retractallSpecial(conceptEqualSets(Env,user,MS,CN,_CT,AX)),
	fail,
	!.
undefConcept(Env,MS,CN) :-
	conceptEqualSets(Env,system,_,_,not(CN),AX),
	retractallSpecial(axiom(Env,MS,defconcept(MS,not(CN),_CT1))),
 	retractallSpecial(kb_in(Env,_,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],_,_),_,_))),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(conceptEqualSets(Env,system,MS,_,_,AX)),
   	retract_all(query(Env,MS,not(CN),_CT,_PT,_)),
	fail,
	!.
undefConcept(_Env,_MS,_CN) :-
	!.

retract_all(kb_in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,_)) :-
	clause(kb_in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_)),_),
	retractallSpecial(kb_in(Env,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
	fail.
retract_all(kb_in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,_)).

retract_all(in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,_)) :-
	clause(in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_)),_),
	member(rn(AX,_,_,_),[Name]),	
	retractallSpecial(in(Env,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
	fail.
retract_all(in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,_)) :-
	retractallSpecial(in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(in(_Name1,rn(AX,_,_,_),_,_,_,_,_,_,_)).

retract_all(query(Env,MS,CN,_CT,_PT,_PT1)) :-
	query(Env,MS,CN1,CT,PT,PT1),
	collect(PT,Liste),
	member(CN,Liste),
	retractallSpecial(query(Env,MS,CN1,CT,PT,PT1)),
	fail.
retract_all(query(Env,MS,CN,_CT,_PT,_PT1)).

/**********************************************************************
 *
 * undefrole(+MS,+CN)
 *
 */
undefrole(RN) :-
	getCurrentEnvironment(EnvName),
	undefrole(EnvName,[],RN).

undefrole(EnvName,RN) :-
	environment(EnvName,_,_),
	!,
	undefrole(EnvName,[],RN).
undefrole(MS,RN) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefrole(EnvName,MS,RN).
undefrole(RN,RT) :-
	getCurrentEnvironment(EnvName),
	undefrole(EnvName,[],RN,RT).

undefrole(EnvName,MS,RN) :-
	environment(EnvName,Env,_),
	(MS = [] ; MS = [_|_]),
	!,
	undefRole(Env,MS,RN).
undefrole(MS,RN,RT) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefrole(EnvName,MS,RN,RT).
undefrole(EnvName,RN,RT) :-
	undefrole(EnvName,[],RN,RT).
undefrole(EnvName,MS,RN,RT) :-
	environment(EnvName,Env,_),
	roleEqualSets(Env,_user,MS,RN,RT,AX),
	retractallSpecial(axiom(Env,MS,defrole(MS,RN,RT))),
 	retractallSpecial(kb_in(Env,_,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),

 	retract_all(query(Env,MS,CN,_CT,_PT,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,RN,RT),
	retract(roleEqualSets(Env,_user,MS,RN,RT,AX)),
	!.
undefRole(Env,MS,RN) :-
	roleEqualSets(Env,user,MS,RN,_,AX),
	retractallSpecial(axiom(Env,MS,defrole(MS,RN,_RT1))),
 	retractallSpecial(kb_in(Env,_,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,RN,_),
	retractallSpecial(roleEqualSets(Env,user,MS,RN,_RT,AX)),
	fail,
	!.
undefRole(_Env,_MS,_RN) :-
	!.

/**********************************************************************
 *
 * undefprimconcept(+MS,+CN)
 *
 */

undefprimconcept(CN) :-
	getCurrentEnvironment(EnvName),
	undefprimconcept(EnvName,CN,_).
undefprimconcept(CN,CT) :-
	getCurrentEnvironment(EnvName),
	!,
	undefprimconcept(EnvName,[],CN,CT).

undefprimconcept(EnvName,CN,CT) :-
	environment(EnvName,_,_),
	!,
	undefprimconcept(EnvName,[],CN,CT).
undefprimconcept(MS,CN,CT) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefprimconcept(EnvName,MS,CN,CT).

undefprimconcept(EnvName,MS,CN,CT) :-	
	environment(EnvName,Env,_),
	conceptSubsets(Env,_user,MS,CN,CT,AX),
	retractallSpecial(axiom(Env,MS,defprimconcept(MS,CN,CT))),
 	retractallSpecial(kb_in(Env,_Name1,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
 	retract_all(query(Env,MS,CN,_CT,_PT,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,lInR),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,lInR),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,CN,CT),
	retract(conceptSubsets(Env,_user,MS,CN,CT,AX)),
	!.
/**********************************************************************
 *
 * undefprimrole(+MS,+CN)
 *
 */
undefprimrole(RN) :-
	getCurrentEnvironment(EnvName),
	undefprimrole(EnvName,[],RN).

undefprimrole(EnvName,RN) :-
	environment(EnvName,_,_),
	!,
	undefprimrole(EnvName,[],RN).
undefprimrole(MS,RN) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefprimrole(EnvName,MS,RN).
undefprimrole(RN,RT) :-
	getCurrentEnvironment(EnvName),
	undefprimrole(EnvName,[],RN,RT).

undefprimrole(EnvName,MS,RN) :-
	environment(EnvName,Env,_),
	(MS = [] ; MS = [_|_]),
	!,
	undefprimRole(Env,MS,RN).
undefprimrole(MS,RN,RT) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	undefprimrole(EnvName,MS,RN,RT).
undefprimrole(EnvName,RN,RT) :-
	undefprimrole(EnvName,[],RN,RT).
undefprimrole(EnvName,MS,RN,RT) :-
	environment(EnvName,Env,_),

	roleSubsets(Env,_user,MS,RN,RT,AX),
	retractallSpecial(axiom(Env,MS,defprimrole(MS,RN,RT))),
 	retractallSpecial(kb_in(Env,_,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
 	retract_all(query(Env,MS,RN,_RT,_PT,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,lInR),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,lInR),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,RN,RT),
	retract(roleSubsets(Env,_user,MS,RN,RT,AX)),
	!.
undefprimRole(Env,MS,RN) :-
	roleSubsets(Env,user,MS,RN,_,AX),
	retractallSpecial(axiom(Env,MS,defprimrole(MS,RN,_RT1))),
 	retract_all(query(Env,MS,RN,_RT,_PT,_)),
 	retractallSpecial(kb_in(Env,_,rn(AX,_,_,_),_,_,_,_,_,_,proved(in([],Name,_),_,_))),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	retractallSpecial(eq(Env,rn(AX,_,_,_),_,_,_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_)),
	retractallSpecial(constraint(Env,rn(AX,_,_,_),_,_,_,_,_,_)),
	change_classifier(EnvName,MS,RN,_),
	retractallSpecial(roleSubsets(Env,user,MS,RN,_RT,AX)),
	fail,
	!.

/** ist in arbeit    */


delete_ind(X,C) :-
	completeParameter([(X,C)],EnvName,MS,_,_),
	delete_ind(EnvName,MS,X,C).
delete_ind(EnvName,X,C) :-
	environment(EnvName,_,_),
	!,
	delete_ind(EnvName,[],X,C).
delete_ind(MS,X,C) :-
	(MS = []; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	delete_ind(EnvName,MS,X,C).
delete_ind(X,Y,R) :-
	getCurrentEnvironment(EnvName),
	delete_ind(EnvName,[],X,Y,R).
delete_ind(EnvName,MS,X,C) :-
	environment(EnvName,Env,_),
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	atomic(X),
	retractallSpecial(axiom(Env,MS,assert_ind(MS,X,C))),
	retract_all(query(Env,MS,_C,_X,_PT,_)),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	constructMLHead(Env,rn(_,_,user,lInR),W1,C,X,_HYPS,_D,_CALLS,abox,InHead),
	not(not((retract((InHead :- call(user:G1))) ;
 	 retract((InHead :- call(G1)))))),
	not(not((retract((conceptElement(Env,_,W1,_,X,C,_) :- call(user:G1))) ;
	 retract((conceptElement(Env,_,W1,_,X,C,_) :- call(G1)))))).
%	 retractallSpecial(((InHead :- call(user:G1)))),
%	 retractallSpecial(((InHead :- call(G1)))),
%	 retractallSpecial(((conceptElement(Env,_,W1,_,X,C,_) :- call(user:G1)))),
%	 retractallSpecial(((conceptElement(Env,_,W1,_,X,C,_) :- call(G1)))).
delete_ind(P1,X,Y,R) :-
	completeParameter([(X,Y,R)],EnvName,MS,_,_),
	delete_ind(EnvName,MS,X,Y,R).
delete_ind(EnvName,MS,X,Y,R) :-
	environment(EnvName,Env,_),
	atomic(X),
	atomic(Y),
	atomic(R),
	retractallSpecial(axiom(Env,MS,assert_ind(MS,X,Y,R))),
	Role1 =.. [R,X,Y],
	retract(Role1),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	constructEqHead(Env,rn(_,_,user,lInR),W1,Y,_FF,R,X,_,_D,CALLS,abox,EqLiteral),
	not(not((retract((EqLiteral :- (checkCallStack(CALLS,true), call(user:G1))));
	 retract((EqLiteral :- (checkCallStack(CALLS,true), call(G1))))))),
	not(not((retract((roleElement(Env,_,W1,I,X,Y,R,_) :- call(user:G1))) ;
	 retract((roleElement(Env,_,W1,I,X,Y,R,_) :- call(G1)))))).
%	retractallSpecial((EqLiteral :- (checkCallStack(CALLS,true), call(user:G1)))),
%	retractallSpecial((EqLiteral :- (checkCallStack(CALLS,true), call(G1)))),
%	retractallSpecial((roleElement(Env,_,W1,X,Y,R,_) :- call(user:G1))),
%	retractallSpecial((roleElement(Env,_,W1,X,Y,R,_) :- call(G1))).

	
/***
*    change_classifier veraendert die Sub.Hierarchie nach undefconcept      
***/
change_classifier(CN,CT) :-
	change_classifier([],CN,CT),
	!.
change_classifier(MS,CN,CT) :-
	getCurrentEnvironment(EnvName),
	environment(EnvName,Env,_),
	change_classifier(EnvName,MS,CN,CT),
	!.

change_classifier(EnvName,MS,CN,CT) :-
	environment(EnvName,Env,_),
	getConceptName(Env,[],CN),
	getAllSubConcepts(EnvName,MS,CN,CL1),
	find_definition(CN,CL2),
 	union1(CL1,CL2,CL),
% removed test output
% uh 31.05.94
% print(CL),
	change_classifier1(Env,MS,CN,CT,CL),
	delete_hierarchy(concepts,Env,MS,CN),
	change_classifier2(Env,MS,CT,CL),
	!.
change_classifier(EnvName,MS,RN,CT) :-
	environment(EnvName,Env,_),
	getRoleName(Env,[],RN),
	getAllSonRoles(EnvName,MS,RN,CL1),
	find_definition(RN,CL2),
 	union1(CL1,CL2,CL),
% removed test output
% uh 31.05.94
% print(CL),
	change_classifier1(Env,MS,RN,CT,CL),
	delete_hierarchy(roles,Env,MS,RN),
	change_classifier2(Env,MS,CT,CL),
	!.
change_classifier(EnvName,MS,CN,CT).

change_classifier1(Env,MS,CR,CT,[]) :-
	!.
change_classifier1(Env,MS,CR,CT,[H|T]) :-
	getConceptName(Env,MS,H),
	(H \== top,H \== bot),
	delete_hierarchy(concepts,Env,MS,H),
	change_classifier1(Env,MS,CR,CT,T),
	!.
change_classifier1(Env,MS,CR,CT,[H|T]) :-
	getRoleName(Env,MS,H),
	(H \== top,H \== bot),
	delete_hierarchy(roles,Env,MS,H),
	change_classifier1(Env,MS,CR,CT,T),
	!.
change_classifier1(Env,MS,CR,CT,[H|T]) :-
	change_classifier1(Env,MS,CR,CT,T),
	!.

change_classifier2(Env,MS,CT,[]) :-
	!.
change_classifier2(Env,MS,CT,[H|T]) :-
	getConceptName(Env,MS,H),
	not(make_succ2(concepts,Env,MS,H)),
	change_classifier2(Env,MS,CT,T),
	!.
change_classifier2(Env,MS,CT,[H|T]) :-
	getRoleName(Env,MS,H),
	not(make_succ2(roles,Env,MS,H)),
	change_classifier2(Env,MS,CT,T),
	!.
change_classifier2(Env,MS,CT,[H|T]) :-
	change_classifier2(Env,MS,CT,T),
	!.
delete_hierarchy(Type,Env,MS,CR) :-
        clause(succ(Type,Env,MS,CR,SC),_),
	clause(succ(Type,Env,MS,PC,CR),_),
	subsume1(Type,Env,MS,PC,SC),
	assert_succ(Type,Env,MS,PC,SC),
	fail.
delete_hierarchy(Type,Env,MS,CR) :-
	retractallSpecial(succ(Type,Env,MS,CR,_)),
	retractallSpecial(succ(Type,Env,MS,_,CR)),
	retractallSpecial(sub(Type,Env,MS,CR,_)),
	retractallSpecial(sub(Type,Env,MS,_,CR)),
	retractallSpecial(nsub(Type,Env,MS,CR,_)),
	retractallSpecial(nsub(Type,Env,MS,_,CR)),
	!.
	
/*****************************************************************************
*      find_definition   sucht alle concepte die irgendwie mit dem 	     *
* 			  zu loeschenden concept verbunden sind.             *
*****************************************************************************/

find_definition(Concept,Liste) :-
	find_definition([],Concept,Liste).
find_definition(MS,Concept,Liste) :-
	getCurrentEnvironment(EnvName),
	environment(EnvName,Env,_),
	find_definition(Env,MS,Concept,Liste),
	!.
find_definition(Env,MS,Concept,Liste) :-
	getConceptName(Env,MS,Concept),
	find_conceptEqualSets(Env,_user,MS,Concept,CT1,_),
	collect(CT1,List1),
	find_conceptSubsets(Env,_user,MS,Concept,CT2,_),
	collect(CT2,List2),
	union1(List1,List2,List3),
	find_Def_concept(MS,Concept,List_of_Concepts),
	union1(List3,List_of_Concepts,Liste),
	!.
find_definition(Env,MS,Role,Liste) :-
	getRoleName(Env,MS,Role),
	find_roleEqualSets(Env,_user,MS,Role,CT1,_),
	collect(CT1,List1),
	find_roleSubsets(Env,_user,MS,Role,CT2,_),
	collect(CT2,List2),
	union1(List1,List2,List3),
	find_Def_role(MS,Role,List_of_Roles),
	union1(List3,List_of_Roles,Liste),
	!.

find_conceptEqualSets(Env,_user,MS,Concept,CT1,_) :-
	conceptEqualSets(Env,_user,MS,Concept,CT1,_),
	!.
find_conceptEqualSets(Env,_user,MS,Concept,[],_).
find_conceptSubsets(Env,_user,MS,Concept,CT2,_) :-
	conceptSubsets(Env,_user,MS,Concept,CT2,_),
	!.
find_conceptSubsets(Env,_user,MS,Concept,[],_).

find_roleEqualSets(Env,_user,MS,Role,CT1,_) :-
	roleEqualSets(Env,_user,MS,Role,CT1,_),
	!.
find_roleEqualSets(Env,_user,MS,Role,[],_).
find_roleSubsets(Env,_user,MS,Role,CT2,_) :-
	roleSubsets(Env,_user,MS,Role,CT2,_),
	!.
find_roleSubsets(Env,_user,MS,Role,[],_).


find_Def_concept(MS,Concept,List_of_Concepts) :-
	getCurrentEnvironment(EnvName),
	environment(EnvName,Env,_),
	find_Def_concept(Env,MS,Concept,List_of_Concepts).
% Removed redundant code 
% 15.02.93 uh
% find_Def_concept(MS,Concept,List_of_Concepts) :-
%	getCurrentEnvironment(EnvName),
%	environment(EnvName,Env,_),
%	find_Def_concept(Env,MS,Concept,List_of_Concepts).
find_Def_concept(Env,MS,Concept,List_of_Concepts) :-
	setofOrNil(CN,find_Def_concept1(Env,MS,Concept,CN),List_of_Concepts),
	!.

find_Def_concept1(Env,MS,Concept,CN) :-
	conceptEqualSets(Env,_user,MS,CN,CT,AX),
	atom(CN),
	not(atom_codes(CN,[99,111,110,99,101,112,116|_])),	
	collect(CT,Liste),
	member(Concept,Liste).
find_Def_concept1(Env,MS,Concept,CN) :-
	conceptSubsets(Env,_user,MS,CN,CT,AX),
	atom(CN),
	not(atom_codes(CN,[99,111,110,99,101,112,116|_])),
	collect(CT,Liste),
	member(Concept,Liste).
find_Def_role(MS,Role,List_of_Roles) :-
	getCurrentEnvironment(EnvName),
	environment(EnvName,Env,_),
	find_Def_role(Env,MS,Role,List_of_Roles).
find_Def_role(Env,MS,Role,List_of_Roles) :-
	setofOrNil(CN,find_Def_role1(Env,MS,Role,CN),List_of_Roles),
	!.
find_Def_role1(Env,MS,Role,CN) :-
	roleEqualSets(Env,_user,MS,CN,CT,AX),
	atom(CN),
	not(atom_codes(CN,[99,111,110,99,101,112,116|_])),	
	collect(CT,Liste),
	member(Role,Liste).
find_Def_role1(Env,MS,Role,CN) :-
	roleSubsets(Env,_user,MS,CN,CT,AX),
	atom(CN),
	not(atom_codes(CN,[99,111,110,99,101,112,116|_])),
	collect(CT,Liste),
	member(Role,Liste).
/****************************************************************************/
/*       collect      sammelt aus einer bel.verschachtelten kette von      
*/
/*                    ausdruecken alle Concept'e oder Role's .             
*/
/***************************************************************************/	

collect(CT,Liste) :-
	collect1(CT,L),
	(isMooOption(prover,Decider) ->
	    Liste = L;
	    collect2(L,Liste)),
	!.
collect2([],[]).
collect2([H|T],[H|L]) :-
	currentEnvironment(Env),
	nonvar(H),
	(clause(conceptName(Env,_,_,H),_);clause(roleName(Env,_,_,H),_)),
	collect2(T,L),
	!.
collect2([H|T],L) :-
	collect2(T,L),
	!.
collect1([],L) :-
	!.
collect1([X|R],L) :-
	(atom(X);number(X)),
	collect1(R,L1),
	union1(X,L1,L),
	!.
collect1([X|R],L) :-
%	isMooOption(prover,_Decider),
	var(X),
	collect1(R,L),
	!.
collect1([[X1|R1]|R],L) :-
	(atom(X1);number(X1)),
	collect1(R1,L1),
	collect1(R,L2),
	union1(L1,L2,L3),
	union1(L3,X1,L),
	!.
collect1([[X1|R1]|R],L) :-
	X1 =.. X2,
	collect1(X2,L2),
	collect1(R1,L1),
	collect1(R,L3),
	union1(L1,L2,L4),
	union1(L4,L3,L),
	!.
collect1([X|R],L3) :-
	X =.. X1,
	collect1(X1,L1),
	collect1(R,L2),
	union1(L1,L2,L3),
	!.
collect1(X,[X|L]) :-
	(atom(X);number(X)),
	currentEnvironment(Env),
	(clause(conceptName(Env,_,_,X),_);clause(roleName(Env,_,_,X),_)),
	!.
collect1(X,[]) :-
%	isMooOption(prover,_Decider),
	var(X),
	!.

collect1(X,[L|L1]) :-
	X =.. X1,
	collect1(X1,L1),!.

delete_conceptName(C) :-
	getCurrentEnvironment(EnvName),
	delete_conceptName(EnvName,_MS,C).
delete_conceptName(MS,C) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	delete_conceptName(EnvName,MS,C).
delete_conceptName(EnvName,C) :-
	delete_conceptName(EnvName,_MS,C).
delete_conceptName(EnvName,MS,C) :-
	environment(EnvName,Env,_),
	retractallSpecial(conceptName(Env,MS,_W,C)),
	!.

delete_roleName(C) :-
	getCurrentEnvironment(EnvName),
	delete_roleName(EnvName,_MS,C).
delete_roleName(MS,C) :-
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	delete_roleName(EnvName,MS,C).
delete_roleName(EnvName,C) :-
	delete_roleName(EnvName,_MS,C).
delete_roleName(EnvName,MS,R) :-
	environment(EnvName,Env,_),
	retractallSpecial(roleName(Env,MS,_W,R)),
	!.
/**********************************************************************
 *
 * @(#) sb2.pl 1.20@(#)

 *
 */

/*-------------------------------------------------------------------------------
 * Der Konstruktor: sb_defenv(EName,Comment)
 * generiert ein neues Environment und bindet dies ans uebergebene Symbol EName,
 * EName wird also zu current environment.
 * Comment kann irgendein string sein.
 *-----------------------------------------*/

  
  sb_defenv(EName,Comment):- makeEnvironment(EName,Comment).


/*-------------------------------------------------------------------------------
 * sb_initenv
 * loescht den Inhalt eines environment, und initialisiert den in sb_defenv schon
 * definierten EName als Tbox-Environment.
 *----------------------------------------*/

 sb_initenv:- 
	initEnvironment.
 sb_initenv(EnvName) :- 
	initEnvironment(EnvName).


/*-------------------------------------------------------------------------------
 * Der 4-stellige Hilfskonstruktor make__primconcept mit folgenden Parametern:
 * (EnvName,MS,CName1,supers(Liste_von_Konzepte))  
 * definiert ein Konzept CName1 als Subkonzept von den in der Liste auftretenden 
 * Superkonzepten in environment EnvName und modal context MS.
 *-------------------------------------------*/


make_primconcept(EnvName,MS,CName1,supers([])).
make_primconcept(EnvName,MS,CName1,supers([X|T])):-
		  defprimconcept(EnvName,MS,CName1,X),
		  make_primconcept(EnvName,MS,CName1,supers(T)).

/*------------------------------------------------------------------------------
 * make_primconcept(EnvName,MS,CName1,restr-inh(RName1,restricts(RName2,
 *                                                     range(CName2,CNameDef))))
 * 
 * definiert ein Konzept CName1, an dem eine Rolle RName2  auf den Rollenfueller
 * CName2 (range) restrigniert wird.
 * Und zwar in evironment=EnvName und modal context MS. 
 * Der neuen Rolle wird das Symbol RName1 zugewiesen,
 * die Domain-Menge dieser neuen Rolle (CNameDom) ist gerade eine Teilmenge von 
 * CName1.
 *----------------------------------------*/
make_primconcept(EnvName,MS,CName1,
                'restr-inh'(RName1,restricts(RName2,range(CName2,CNameDef)))):-
	make_primconcept(EnvName,MS,CName1,
	                 restrict_inh(RName1, restricts(RName2 ,
				 		        range(CName2,CNameDef)))).
make_primconcept(EnvName,MS,CName1,
                'restrict-inh'(RTerm1,restricts(RTerm2,range(CName2,CNameDef)))):-
       make_primconcept(EnvName,MS,CName1,
                        restrict_inh(RTerm1, restricts(RTerm2,
						       range(CName2,CNameDef)))).

make_primconcept(EnvName,MS,CName1,restrict_inh(RTerm1, restricts(RTerm2 ,
						     range(CName2,CNameDef)))):-
	expand_role(EnvName,MS,RTerm1,RName1,_,_,_),
	expand_role(EnvName,MS,RTerm2,RName2,_,_,_),
	environment(EnvName,Env,_),
	defrole(EnvName,MS,RName1 , restr(RName2 , CName2)),
	gensym(concept,CNameDom),
	defconcept(EnvName,MS,CNameDom ,some(RName2 ,top)),
        defprimconcept(EnvName,MS,CNameDom ,CName1),
%	defprimconcept(EnvName,MS,and([some(inverse(RName1),top),
%				       naf(not(CNameDef))]),CNameDef),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleDomain(Env,W1,RName1,CNameDom) :- G1)),
	assertzRE((roleRange(Env,W1,RName1,CName2) :- G1)),
	assertzRE((roleDefault(Env,W1,RName1,CNameDef) :- G1)),
	assertzRE((roleTripel(Env,W1,RName1,CNameDom,CName2,CNameDef))).
   
/*----------------------------------------------------------------------------
 * make_primconcept(EnvName,MS,CName1, nr(RName1,MinNr,MaxNr,DefNr))
 * definiert ein Konzept CName1, an dem eine "number restriction" stattfindet:
 * die Rolle RName1 wird bzgl. ihrer Kardinalitaet restrigniert auf
 * (MinNr,MaxNr,DefNr),
 * und zwar in  environment=EnvName und modal context=MS,
 * die Dom-Menge der Rolle RName1 ist dann ein CNameDom als Teilmenge von CName1.
 *-----------------------------------------*/


make_primconcept(EnvName,MS,CName1 , nr(RTerm1, MinNr,MaxNr,DefNr)):-
	environment(EnvName,Env,_),
	expand_role(EnvName,MS,RTerm1,RName1,CNameDomT,CName2T,CNameDefT),
	gensym(concept,CNameDom),
	defconcept(EnvName,MS,CNameDom, and([atleast(MinNr,RName1),atmost(MaxNr,RName1)])),
	defconcept(EnvName,MS,CNameDom, some(RName1,top)), 
	defprimconcept(EnvName,MS,CNameDom , CName1),
%	gensym(concept,CNameDef),
%	defconcept(EnvName,MS,CNameDef, and([atleast(DefNr,RName1),atmost(DefNr,RName1)])),
%	defprimconcept(EnvName,MS,and([some(inverse(RName1)),naf(not(CNameDef))]),CNameDef),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleNr(Env,W1,RName1,MinNr,MaxNr) :- G1)),
	assertzRE((roleDefNr(Env,W1,RName1,DefNr) :- G1)),
	assertzRE((roleAll(Env,W1,Rname1,CNameDomT,CName2T,CNameDefT,MinNr,MaxNr,DefNr))).



/*------------------------------------------------------------------------------
 *sb_primconcept(CName)
 * definiert ein generelles Konzept CName in modal context [].
 *---------------------------------------*/


 sb_primconcept(CName):- 
	getCurrentEnvironment(EnvName),
	sb_primconcept(EnvName,[],CName).


/*-------------------------------------------------------------------------------
 * Der 2-stellige Konstruktor sb_primconcept mit jeweils folgenden Parametern:
 * (EnvName,CName1), oder (MS,CName1) definiert ein generelles Konzept CName1
 * in invironment EnvName und modal context [], bzw. in current Environment und
 * modal context MS.
 *----------------------------------------*/
  
sb_primconcept(EnvName,Left) :-
	environment(EnvName,_,_),
	!,
	sb_primconcept(EnvName,[],Left),
	!.


sb_primconcept(MS,Left) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_primconcept(EnvName,MS,Left),
	!.



/*-----------------------------------------------------------------------------
 * Der 2-stellige Konstruktor sb_primconcept(CName1,SpecListe) hat als Argumente ein
 * CName1 und eine Liste von bis jetzt eingef"uhrten Pr"adikaten wie:
 * [supers(Liste von concepts) , restr-inh(...) , nr(...)], es werden dann jeweils die
 * entsprechenden Hilfskonstruktoren mit dem einzelnen Listenelement als aktueller Parameter 
 * aktiviert bzw. aufgerufen und zwar in current environment und [] als modal context.
 *-----------------------------------------*/

sb_primconcept(CName1,[]) :-
	!.
sb_primconcept(CName1,[X|T]):-
	getCurrentEnvironment(EnvName),
	sb_primconcept(EnvName,[],CName1,[X|T]),
	!.



/*-----------------------------------------------------------------------------
 * Der 3-stellige Konstruktor sb_primconcept(A,CName1,SpecListe) funktioniert analog
 * nur in A= Environment und [] als modal context, bzw. in current environment und
 * A=MS als modal context.
 *-----------------------------------------*/

sb_primconcept(A,CName1,[]) :-
	!.
sb_primconcept(A,CName1,[X|T]):-
	environment(A,_,_),
	!,
	sb_primconcept(A,[],CName1,[X|T]),
	!.
sb_primconcept(A,CName1,[X|T]):-
	(A = [] ; A = [_|_]),
	getCurrentEnvironment(EnvName),
	!,
	sb_primconcept(EnvName,A,CName1,[X|T]).

/*-------------------------------------------------------------------------------
 * Der 3-stellige Konstruktor von  sb_primconcept mit folgenden Parametern:
 * (Environment,MS,CName1)  
 * definiert ein Konzept CName1 in environment EnvName und modal context MS. 
 *-------------------------------------------*/

sb_primconcept(EnvName,MS,CName):-
	   environment(EnvName,Env,_),
	   (MS = [] ; MS = [_|_]),
	   defprimconcept(EnvName,MS,CName),
	   !.

/*-----------------------------------------------------------------------------
 * Der 4-stellige Konstruktor sb_primconcept(EnvName,MS,CName1,SpecListe) wird aktiviert 
 * mit expliziter Angabe von Environment=EnvName und modal context =MS.
 *-----------------------------------------*/

sb_primconcept(EnvName,MS,CName1,[]) :-
	!.
sb_primconcept(EnvName,MS,CName1,[X|T]):-
	make_primconcept(EnvName,MS,CName1,X),
        sb_primconcept(EnvName,MS,CName1,T),
	!.

/*------------------------------------------------------------------------------
 * make_defconcept(EnvName,MS,CName1,restr-inh(RName1,restricts(RName2,
 *                                          range(CName2,CNameDef))),CNameDom)
 * 
 * definiert ein Konzept CName1, an dem eine Rolle RName2  auf den Rollenfueller
 * CName2 (range) restrigniert wird.
 * Und zwar in evironment=EnvName und modal context MS. 
 * Der neuen Rolle wird das Symbol RName1 zugewiesen,
 * die Domain-Menge dieser neuen Rolle (CNameDom) ist gerade eine Teilmenge von 
 * CName1.
 *----------------------------------------*/

make_defconcept(EnvName,MS,CName1,restrict_inh(RName1, restricts(RName2 ,
				     range(CName2,CNameDef))),CNameDom):-
	make_defconcept(EnvName,MS,CName1,'restr-inh'(RName1, restricts(RName2 ,
                        range(CName2,CNameDef))),CNameDom).
make_defconcept(EnvName,MS,CName1,'restrict-inh'(RName1, restricts(RName2 ,
				     range(CName2,CNameDef))),CNameDom):-
	make_defconcept(EnvName,MS,CName1,'restr-inh'(RName1, restricts(RName2 ,
                        range(CName2,CNameDef))),CNameDom).

make_defconcept(EnvName,MS,CName1,'restr-inh'(RName1, restricts(RName2 ,
				     range(CName2,CNameDef))),CNameDom):-
	environment(EnvName,Env,_),
	defrole(EnvName,MS,RName1 , restr(RName2 , CName2)),
	gensym(concept,CNameDom),
	defconcept(EnvName,MS,CNameDom ,some(RName2 ,top)),
%	defprimconcept(EnvName,MS,and([some(inverse(RName1),top),
%				       naf(not(CNameDef))]),CNameDef),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleDomain(Env,MS,RName1,CNameDom) :- G1)),
	assertzRE((roleRange(Env,MS,RName1,CName2) :- G1)),
	assertzRE((roleDefault(Env,MS,RName1,CNameDef) :- G1)),
	assertzRE((roleTripel(Env,MS,RName1,CNameDom,CName2,CNameDef))).
    
/*----------------------------------------------------------------------------
 * make_defconcept(EnvName,MS,CName1, nr(RName1,MinNr,MaxNr,DefNr),CNameDom)
 * definiert ein Konzept CName1, an dem eine "number restriction" stattfindet:
 * die Rolle RName1 wird bzgl. ihrer Kardinalitaet restrigniert auf
 * (MinNr,MaxNr,DefNr),
 * und zwar in  environment=EnvName und modal context=MS.
 *-----------------------------------------*/


make_defconcept(EnvName,MS,CName1 , nr(RTerm, MinNr,MaxNr,DefNr),CNameDom):-
	environment(EnvName,Env,_),
	expand_role(EnvName,MS,RTerm,RName1,CNameDomT,CNameT,CNameDefT),
	gensym(concept,CNameDom),
	defconcept(EnvName,MS,CNameDom, and([atleast(MinNr,RName1),atmost(MaxNr,RName1)])),
%	defconcept(EnvName,MS,CNameDom, some(RName1,top)), 
%	gensym(concept,CNameDef),
%	defconcept(EnvName,MS,CNameDef, and([atleast(DefNr,RName1),atmost(DefNr,RName1)])),
%	defprimconcept(EnvName,MS,and([some(inverse(RName1)),naf(not(CNameDef))]),CNameDef),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleNr(Env,W1,RName1,MinNr,MaxNr) :- G1)),
	assertzRE((roleDefNr(Env,W1,RName1,DefNr) :- G1)),
	assertzRE((roleAll(Env,W1,RName1,CNameDomT,CNameT,CNameDefT,MinNr,MaxNr,DefNr) :- G1)).

make_defconcept(EnvName,MS,CName1 , necres(RTerm, nec),CNameDom):-
	!,
	environment(EnvName,Env,_),
	expand_role(EnvName,MS,RTerm,RName1,_,_,_),
	gensym(concept,CNameDom),
	defconcept(EnvName,MS,CNameDom,atleast(1,RName1)),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleDomain(Env,W1,RName1,CNameDom) :- G1)),
	!.
make_defconcept(EnvName,MS,CName1 , necres(RTerm, _),CNameDom):-
	!,
	environment(EnvName,Env,_),
	expand_role(EnvName,MS,RTerm,RName1,_,_,_),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleDomain(Env,W1,RName1,CNameDom) :- G1)),
	!.


expand_role(_,_,RTerm,RTerm,_,_,_) :-
	atomic(RTerm),
	!.
expand_role(EnvName,MS1,RTerm,RName1,CName1,CName2,CNameDef) :-
	RTerm = sb_primelemrole(EnvName,MS2,RName1, 'domain-range'(CName1,CName2,CNameDef)),
	!,
	append(MS1,MS2,MS3),
	sb_primelemrole(EnvName,MS3,RName1, 'domain-range'(CName1,CName2,CNameDef)).
expand_role(EnvName,MS1,RTerm,RName1,CName1,CName2,CNameDef) :-
	RTerm = sb_primelemrole(MS2,RName1, 'domain-range'(CName1,CName2,CNameDef)),
	!,
	append(MS1,MS2,MS3),
	sb_primelemrole(MS3,RName1, 'domain-range'(CName1,CName2,CNameDef)).
expand_role(EnvName,MS1,RTerm,RName1,CName1,CName2,CNameDef) :-
	RTerm = sb_primelemrole(RName1, 'domain-range'(CName1,CName2,CNameDef)),
	!,
	sb_primelemrole(MS1,RName1, 'domain-range'(CName1,CName2,CNameDef)).
expand_role(_,_,RTerm,RTerm,_,_,_).


/*-----------------------------------------------------------------------------
 * elem(I,Liste,H) nimmt das I-te Element einer Liste und sieht so aus:
 *-----------------------------------------*/


elem(1,[H|T],H).
elem(I,[H|T],X):- Hilf is I-1,
		  elem(Hilf,T,X).


/*-----------------------------------------------------------------------------
 * Der 2-stellige Konstruktor sb_defconcept(CName1,SpecListe) hat als Argumente ein
 * CName1 und eine Liste von bis jetzt eingef"uhrten Pr"adikaten wie:
 * [supers(Liste von concepts) , restr-inh(...) , nr(...)], es werden dann jeweils die
 * entsprechenden Hilfskonstruktoren mit dem einzelnen Listenelement als aktueller Parameter 
 * aktiviert bzw. aufgerufen und zwar in current environment und [] als modal context.
 *-----------------------------------------*/

sb_defconcept(C1,SpecList):- 
	getCurrentEnvironment(EnvName),
	sb_defconcept(EnvName,[],C1,SpecList),
	!.

/*-----------------------------------------------------------------------------
 * Der 3-stellige Konstruktor sb_defconcept(A,CName1,SpecListe) funktioniert analog
 * nur in A= Environment und [] als modal context, bzw. in current environment und
 * A=MS als modal context.
 *-----------------------------------------*/


sb_defconcept(A,C1,SpecList) :- 
	environment(A,_,_),
	!,
	sb_defconcept(A,[],C1,SpecList),
	!.
sb_defconcept(A,C1,SpecList) :-
	(A = [] ; A = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_defconcept(EnvName,A,C1,SpecList),
	!.

/*-----------------------------------------------------------------------------
 * Der 4-stellige Konstruktor sb_defconcept(EnvName,MS,CName1,SpecListe) wird aktiviert 
 * mit expliziter Angabe von Environment=EnvName und modal context =MS.
 *-----------------------------------------*/


sb_defconcept(EnvName,MS,C1,SpecList) :-
	sb_defconcept(EnvName,MS,C1,SpecList,[]).

sb_defconcept(EnvName,MS,C1,[],[]) :-
	!.
sb_defconcept(EnvName,MS,C1,[],CList) :-
	!,
	defconcept(EnvName,MS,C1,and(CList)),
	!.
sb_defconcept(EnvName,MS,C1,[supers(L)|SpecList],CList1) :-
	!,
	append(L,CList1,CList2),
	sb_defconcept(EnvName,MS,C1,SpecList,CList2).
sb_defconcept(EnvName,MS,C1,[Spec1|SpecList],CList1) :-
	make_defconcept(EnvName,MS,C1,Spec1,Concept),
	sb_defconcept(EnvName,MS,C1,SpecList,[Concept|CList1]).
sb_defconcept(EnvName,MS,C1,supers(L),[]) :-
	!,
	defconcept(EnvName,MS,C1,and(L)).

/*---------------------------------------------------------------------------
 * sb_primelemrole(RName1,domain-range(CName1,CName2,CNameDef))
 * definiert eine neue generelle Rolle RName1 mit CName1 als domain, CName2 
 * als range und CNameDef als "default valueOfCounter restriction" in modal context [].
 *------------------------------------------*/


sb_primelemrole(RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	getCurrentEnvironment(EnvName),
	sb_primelemrole(EnvName,[],RName1, 'domain-range'(CName1,CName2,CNameDef)).

/*---------------------------------------------------------------------------
 * sb_primelemrole(X,RName1,domain-range(CName1,CName2,CNameDef))
 * definiert eine neue generelle Rolle RName1 mit CName1 als domain, CName2 
 * als range und CNameDef als "default valueOfCounter restriction" in modal context []
 * und X=environment bzw. in modal context X=MS und current environment.
 *------------------------------------------*/


sb_primelemrole(X,RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	environment(X,_,_),
	sb_primelemrole(X,[],RName1, 'domain-range'(CName1,CName2,CNameDef)).
sb_primelemrole(X,RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	(X = [] ; X = [_|_]),
	getCurrentEnvironment(EnvName),
	sb_primelemrole(EnvName,X,RName1, 'domain-range'(CName1,CName2,CNameDef)).

/*---------------------------------------------------------------------------
 * sb_primelemrole(EnvName,MS,RName1,domain-range(CName1,CName2,CNameDef))
 * definiert eine neue generelle Rolle RName1 mit CName1 als domain, CName2 
 * als range und CNameDef als "default valueOfCounter restriction" in modal context MS 
 * und environment EnvName.
 *------------------------------------------*/

sb_primelemrole(EnvName,MS,RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	environment(EnvName,Env,_),
	defprimconcept(EnvName,MS,CName1,some(RName1,top)),
	defprimconcept(EnvName,MS,some(inverse(RName1),top),CName2),
%	defprimconcept(ENvName,MS,and([CName2,naf(not(CNameDef))]),CNameDef),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleDomain(Env,W1,RName1,CName1) :- G1)),
	assertzRE((roleRange(Env,W1,RName1,CName2) :- G1)),
	assertzRE((roleDefault(Env,W1,RName1,CNameDef) :- G1)),
	assertzRE((roleTripel(Env,W1,RName1,CName1,CName2,CNameDef) :- G1)),
	!.

/*----------------------------------------------------------------------------
 * sb_defelemrole(RName1,restricts(RName2,range(CName1,CNameDef)))
 * restrigniert die Rolle RName2 bzgl. des Rollenfuellers, auf CName1,
 * in modal context [] und current environment.
 * (CNameDef gibt den Default-Rollenfueller an).
 *------------------------------------------*/

sb_defelemrole(RName1, restricts(RName2, range(CName1,CNameDef))):-
	getCurrentEnvironment(EnvName),
	sb_defelemrole(EnvName,[],RName1,restricts(RName2,range(CName1,CNameDef))),
	!.

/*----------------------------------------------------------------------------
 * sb_defelemrole(X,RName1,restricts(RName2,range(CName1,CNameDef)))
 * restrigniert die Rolle RName2 bzgl. des Rollenfuellers, auf CName1,
 * in modal context [] und X=environment bzw. in modal context X=MS und 
 * current environment.
 *------------------------------------------*/


sb_defelemrole(X,RName1, restricts(RName2, range(CName1,CNameDef))):-
	environment(X,_,_),
	!,
	sb_defelemrole(X,[],RName1, restricts(RName2, range(CName1,CNameDef))).
sb_defelemrole(X,RName1, restricts(RName2, range(CName1,CNameDef))):-
	(X = [] ; X = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_defelemrole(EnvName,X,RName1, restricts(RName2, range(CName1,CNameDef))).

/*----------------------------------------------------------------------------
 * sb_defelemrole(EnvName,MS,RName1,restricts(RName2,range(CName1,CNameDef)))
 * restrigniert die Rolle RName2 bzgl. des Rollenfuellers, auf CName1,
 * in modal context MS und  environment EnvName. 
 *------------------------------------------*/


sb_defelemrole(EnvName,MS,RName1, restricts(RName2, range(CName1,CNameDef))):-
	environment(EnvName,Env,_),
	defrole(EnvName,MS,RName1,restr(RName2,CName1)),
%	defprimconcept(EnvName,MS,and([some(inverse(RName1),top),
%                                      naf(not(CNameDef))]),CNameDef),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleRange(Env,MS,RName1,CName1) :- G1)),
	assertzRE((roleDefault(Env,MS,RName1,CNameDef) :- G1)),
	!.



/*----------------------------------------------------------------------------
 * sb_disjoint(CName1,CName2)
 * definiert generelle Konzepte CName1,CName2 als disjunkt.
 *-------------------------------------------*/

		     
sb_disjoint(CName1,CName2):- 
%	defprimconcept(CName1,not(CName2)),
	defprimconcept(CName2,not(CName1)),
	!.


sb_disjoint(X,CName1,CName2):- 
%	defprimconcept(X,CName1,not(CName2)),
	defprimconcept(X,CName2,not(CName1)),
	!.


sb_disjoint(EnvName,MS,CName1,CName2):- 
%	defprimconcept(EnvName,MS,CName1,not(CName2)),
	defprimconcept(EnvName,MS,CName2,not(CName1)),
	!.



/*----------------------------------------------------------------------------
 * sb_expand(CName1,CName2)
 * erlaubt die Erweiterung der Definition eines bereits existierenden Konzeptes,
 * der Konstruktor fuegt zu einem bestehenden Konzept ein weiteres "Vaterkonzept
 * hinzu, die Moeglichkeit der Erweiterung ist also analog zur Definition der 
 * Konzepte.
 *------------------------------------------*/

 /*? sb_expand(CName1,CName2):- defprimconcept(CName1,CName2)??*/






make_irole(EnvName,MS,ICName1,irole(RName,iname(IRName),
                                    nr(MinNr,MaxNr,DefNr))):-
	environment(EnvName,Env,_),
%       defprimrole(EnvName,MS,IRName,restr(RName,
%	                                    and([atleast(MinNr,RName),
%			  		    atmost(MaxNr,RName),
%					    some(inverse(RName),top)]))),
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	assertzRE((roleNr(Env,W1,IRName,MinNr,MaxNr) :- G1)),
	assertzRE((roleDefNr(Env,W1,IRName,DefNr) :- G1)).
                           


make_irole(EnvName,MS,ICName1,irole(RName,iname(IRName),vr(ICName2))) :-
        environment(EnvName,Env,_),
%	gensym(concept,CName2),
%       defprimrole(EnvName,MS,IRName, restr(RName,
%                 			     CName2)),
	getRoleDomain(Env,MS,RName,CDom),
	getRoleRange(Env,MS,RName,CRang),
	!,
	consistCheck(EnvName,MS,ICName1,CDom),
	!,
	consistCheck(EnvName,MS,ICName2,CRang),
	!,
%	consistCheck(EnvName,MS,ICName2,CName2),
	assert_ind(EnvName,MS,ICName1,ICName2,IRName).

constructRestriction(RName,[],[top]) :-
	!.
constructRestriction(RName,[nr(MinNr,MaxNr,DefNr)|L1],
                     [atleast(MinNr,top), atmost(MaxNr,top) | L2]) :-
	constructRestriction(RName,L1,L2),
	!.
constructRestriction(RName,[vr(ICName2)|L1],[ICName2|L2]) :-
	constructRestriction(RName,L1,L2),
	!.
     
 /*-------------------------------------------------------------------------------
  * make_defelem(ICName,isa(CName))
  * individualisiert ein Konzept CName mit dem Instanz-Namen ICName vom Typ string,
  * d.h. es wird das Abox-Element ICName zu Konzept hinzugefuegt und zwar in modal
  * context [] bzw MS.
  *-----------------------------------------*/


consistCheck(Env,MS,IC,Concept) :- 
% vor dem Test die Normalform von not(Concept) mittels
% normalizeNot(not(Concept),NotConcept)
% bilden und dann
% sb_ask(Env,MS,(isa(IC,NotConcept)))
% aufrufen
			 normalizeNot(not(Concept),NotConcept),
			 sb_ask(Env,MS,(isa(IC,NotConcept))),
			 nl,
			 write('--- impossible --- '),
			 !,
			 fail.

			    



consistCheck(Env,MS,IC,Concept) :-
			          !.



make_defelem(EnvName,MS,ICName,isa(CName)):-
	  consistCheck(EnvName,MS,ICName,CName),
	  assert_ind(EnvName,MS,ICName,CName),
	  !.





/*--------------------------------------------------------------------------------
 * make_defelem(EnvName,MS,ICName1,irole(RName,iname(IRName),[nr(MinNr,MaxNr,DefNr),vr(ICName2)]))
 * erzeugt eine Instanz ICName1 fuer ein Konzept, an dem auch die Rolle RName
 * individualisiert wird mit dem Instanznamen IRName,
 * der Kardinalitaet der indiv. Rolle nr(MinNr,MaxNr,DefNr),
 * dem Rollenfueller der indiv. Rolle vr(ICName2),
 * Und zwar in modal context MS und environment=EnvName.
 *------------------------------------------*/
 



make_defelem(EnvName,MS,ICName1,irole(RName,iname(IRName),SpecList)) :-
	constructRestriction(IRName,SpecList,RestrList),
	defprimrole(EnvName,MS,IRName,restr(RName,and(RestrList))),
        make_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),SpecList)).

make_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),[])).
make_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),[X|T])) :-
	make_irole(EnvName,MS,ICName1,irole(RName,iname(IRName),X)),
	make_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),T)).


/*--------------------------------------------------------------------------------
 * sb_defelem(ICName1,ISpecListe)
 * ISpecListe=[isa(...),irole(iname(...)nr(...)vr(...))]
 * erzeugt eine Instanz ICName1 fuer ein Konzept, an dem auch die Rolle RName
 * individualisiert werden kann mit dem Instanznamen IRName,
 * der Kardinalitaet der indiv. Rolle nr(MinNr,MaxNr,DefNr),
	* dem Rollenfueller der indiv. Rolle vr(ICName2),
 * Und zwar in modal context [] und current environment.
 * Domain dieser Rolle ist eine Teilmenge von indiv. Konzept ICName1.
 *------------------------------------------*/



sb_defelem(ICName1,SpecListe) :-
	getCurrentEnvironment(EnvName),
	sb_defelem(EnvName,[],ICName1,SpecListe).



/*-----------------------------------------------------------------------------
 *Wie oben, nur in A=environment und modal context [], bzw. in current environment
 *und modal context A=MS.
 *-----------------------------------------*/


sb_defelem(A,ICName1,[]).

sb_defelem(A,ICName1,SpecList) :-
	environment(A,_,_),
	!,
	sb_defelem(A,[],ICName1,SpecList).
sb_defelem(A,ICName1,SpecList) :-
	(A = [] ; A = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_defelem(EnvName,A,ICName1,SpecList).


/*-----------------------------------------------------------------------------
 *Wie oben, nur explizit in environment EnvName und modal context MS.
 *-----------------------------------------*/


sb_defelem(EnvName,MS,ICName1,[]).
 
sb_defelem(EnvName,MS,ICName1,[X|T]):-
	make_defelem(EnvName,MS,ICName1,X),
	sb_defelem(EnvName,MS,ICName1,T). 


/************************ sb_ask-Selektoren fuer die TBox **********************/
 

sb_ask(Q) :-
	getCurrentEnvironment(EnvName),
	sb_ask(EnvName,[],Q).

sb_ask(E,Q) :-
	environment(E,_,_),
	!,
	sb_ask(E,[],Q).
sb_ask(M,Q) :-
	(M = [] ; M = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_ask(EnvName,M,Q).

/*----------------------------------------------------------------------
 *
 * sb_ask(supers(CName1,CName2)))
 *
 * ueberprueft, ob CName1 ein direktes Subkonzept von CName2 ist.
 *
 *
 *-----------------------------------------------------------------------*/


 sb_ask(EnvName,MS,(supers(CName1,CName2))) :-
	getDirectSuperConcepts(EnvName,MS,CName1,CL),
	member(CName2,CL).

/*---------------------------------------------------------------------------
 * sb_ask(EnvName,MS,(supers*(CName1,CName2)))
 *
 * ueberprueft auch transitive supers-Beziehungen (Subsumptionsbeziehungen) zwischen
 * Subkonzept CName1 und Superkonzept CName2.
 *-----------------------------------------*/

 sb_ask(EnvName,MS,(supers*(CName1,CName2))) :-
	getAllSuperConcepts(EnvName,MS,CName1,CL),
	member(CName2,CL).


/*------------------------------------------------------------------------------
 * sb_ask(EnvName,MS,(role(RName,CNameDom,CNameRan)))
 *
 * dieser Selektor dient zum Zugriff bzw. zur Anfrage nach Rollenbeziehungen
 * zwischen zwei Konzepten, oder aber auch nach Domain und Range einer Rolle.
 *--------------------------------------------*/

 sb_ask(EnvName,MS,(role(RName,Subconcept,CNameRan))) :-
	  environment(EnvName,Env,_),
	sb_ask(EnvName,MS,(supers*(Subconcept,Superconcept))),
	getRoleDomain(Env,MS,RName,Superconcept),
	getRoleRange(Env,MS,RName,CNameRan).

 sb_ask(EnvName,MS,(role(RName,CNameDom,CNameRan))) :-
	  environment(EnvName,Env,_),
	  !,
	getRoleDomain(Env,MS,RName,CNameDom),
	getRoleRange(Env,MS,RName,CNameRan).



/*-----------------------------------------------------------------------------
 * sb_ask(EnvName,MS,(roleDef(RName,CNameDef)))
 *
 * dient zur Anfrage bzgl. DefaultRange einer Rolle.
 *--------------------------------------------*/


 sb_ask(EnvName,MS,(roleDef(RName,CNameDef))) :-   
	  environment(EnvName,Env,_),
	  !,
	getRoleDefault(Env,MS,RName,CNameDef).

/*----------------------------------------------------------------------------
 * sb_ask(EnvName,MS,(roleNr(RName,MinNr,MaxNr)))
 *
 * der Selektor dient zum Zugriff auf die Number Restriction einer Rolle RName
 * am einem Konzept CName.
 *-------------------------------------------*/


 sb_ask(EnvName,MS,(roleNr(RName,MinNr,MaxNr))) :-  
	  environment(EnvName,Env,_),
	  !,
	getRoleNr(Env,MS,RName,MinNr,MaxNr).
				       
                                       
              

/*----------------------------------------------------------------------------
 * sb_ask(EnvName,MS,(roleDefNr(RName,DefNr)))
 *
 * der Selektor dient zum Zugriff auf die Default- Number Restriction einer Rolle
 * RName am einem Konzept CName.
 *-------------------------------------------*/


 sb_ask(EnvName,MS,(roleDefNr(RName,DefNr))) :-  
	  environment(EnvName,Env,_),
	  !,
	getRoleDefNr(Env,MS,RName,DefNr).



/*----------------------------------------------------------------------------
 ************************* sb_ask-Selektoren fuer die ABox ***********************
 *
 * sb_ask(EnvName,MS,(isa(ICName,CName)))
 *
 * ermoeglicht den Zugriff Initial.-Beziehung einer Instanz ICName zum entsprech-
 * ende generellen Konzept CName.
 *------------------------------------------*/


 sb_ask(EnvName,MS,(isa(ICName,CName))) :- 
	motel_ask(EnvName,MS,elementOf(ICName,CName),_).


sb_ask(EnvName,MS,(attributes(CN,Attribute,Value))) :-
	attribute(concept,EnvName,MS,CN,[Attribute,Value]).
sb_ask(EnvName,MS,(attributes(CN,RN,Attribute,Value))) :-
	attribute(role,EnvName,MS,[CN,RN],[Attribute,Value]).

sb_ask(EnvName,MS,(subrole(Subrole,Superrole))) :-
	getDirectFatherRoles(EnvName,MS,Subrole,RL),
	member(Superrole,RL).

sb_ask(EnvName,MS,(irole(R,X,Y))) :-
	environment(EnvName,Env,_),
	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	EqLiteral = eq(Env,rn(_AX,_RN,_S,_O),modal(W1),Y,CON,A1,X,Pc,call(_CALLS),ab(noAb),Exp,Gd,Od,L1,L2,Anc1,Anc2,Y,_PT),
%	EqLiteral = eq(Env,rn(_AX,_RN,_S,_O),modal(W1),Y,app((FF:R),X),hyp(_HYPS),ab(noAb),call(_CALLS),_PT),
	call(G1),
	call(EqLiteral).


%----------------------------------------------------------------------
% sb_ask(EnvName,MS,(allRoles(+CName,-Info)))
% Arguments: Cname ConceptName
%	     Info is a list consisting of lists with elements:
%               Rnames role-atom_codes
%	        Cnames domain 
% 	        Min    Minimalnr. der role
%              	Max    Maximalnr. der role
%           	Defnr  Defaultnr. der role  
%
% liefert alle rolen,domains,Minnr,Maxnr,Defnr die von einem konzept ausgehen
% bsp : sb_ask(env,ms,allRoles(golf,X))    X = ((has_part golf windshield 1 1 1)(consumes golf gasoline 1 1 1))
% Author: Patrick Brandmeier


sb_ask(EnvName,MS,(allRoles(CName,Info_list))) :-
	setofOrNil(Info,[RName,CNameRan,Info]^(sb_ask(EnvName,MS,(role(RName,CName,CNameRan))),
	 	 sb_ask(EnvName,MS,(allRoles(RName,CName,CNameRan,Info)))),Info_list).
	
sb_ask(EnvName,MS,(allRoles(RName,CName,CNameRan,[RName,CName,CNameRan,Min,Max,Defnr]))) :-
	sb_ask(EnvName,MS,(roleNr(RName,Min,Max))),
	sb_ask(EnvName,MS,(roleDefNr(RName,Defnr))),
	!.
sb_ask(EnvName,MS,(allRoles(RName,CName,CNameRan,[RName,CName,CNameRan]))) :-
	!.


%----------------------------------------------------------------------
% sb_fact(EnvName,MS,(all_roles(+CName,-Info)))
% Arguments: Cname ConceptName
%	     Info is a list consisting of lists with elements:
%               Rnames role-atom_codes
%	        Cnames domain 
% 	        Min    Minimalnr. der role
%              	Max    Maximalnr. der role
%           	Defnr  Defaultnr. der role  
%
% liefert alle rolen,domains,Minnr,Maxnr,Defnr die von einem konzept ausgehen
% bsp : sb_fact(env,ms,allRoles(golf,X))    X = ((has_part golf windshield 1 1 1)(consumes golf gasoline 1 1 1))
% Author: Patrick Brandmeier


sb_fact(EnvName,MS,(allRoles(CName,Info_list))) :-
	setofOrNil(Info,[RName,CNameRan]^(sb_fact(EnvName,MS,(role(RName,CName,CNameRan))),
	 	 sb_fact(EnvName,MS,(allRoles(RName,CName,CNameRan,Info)))),Info_list).
	
sb_fact(EnvName,MS,(allRoles(RName,CName,CNameRan,[RName,CName,CNameRan,Min,Max,Defnr]))) :-
	sb_fact(EnvName,MS,(roleNr(RName,Min,Max))),
	sb_fact(EnvName,MS,(roleDefNr(RName,Defnr))),
	!.
sb_fact(EnvName,MS,(allRoles(RName,CName,CNameRan,[RName,CName,CNameRan]))) :-
	!.


%----------------------------------------------------------------------
% sb_ask(EnvName,MS,(direct_super_role(+-RName,+-CNameDom,+-CNameRan,+-SRName,+-SCNameDom,+-SCNameRan))) :-
% Arguments: Rname RoleName
%	     CNameDom Domain
%            CNameRan Range 
%	     SRName Super-Role-Name
% 	     SRNameDom Super-Role_domain
%            SRNameRan Super-Role-range
%
% ist erfuellt wenn (SRName SCNameDom SCNameRan) die direkte super-rolle von (RName CNameDom CNameRan) ist
%
% Author: Patrick Brandmeier

sb_ask(EnvName,MS,(direct_super_role(RName,CNameDom,CNameRan,RName,SCNameDom,CNameRan))) :-
	var(CNameDom),
	getDirectSubConcepts(EnvName,MS,SCNameDom,CL),
	member(CNameDom,CL),
	!.

sb_ask(EnvName,MS,(direct_super_role(RName,CNameDom,CNameRan,RName,SCNameDom,CNameRan))) :-
	sb_ask(EnvName,MS,(supers(CNameDom,SCNameDom))),
	!.
%	sb_ask(EnvName,MS,(role(SRName,SCNameDom,SCNameRan))),	
%	!.


%----------------------------------------------------------------------
% sb_ask(EnvName,MS,(risa(+-IRName,+-ICNameDom,+-ICNameRan,+-GRName,+-GCNameDom,+-GCNameRan))) :-
% Arguments: IRname    individ.-RoleName
%	     ICNameDom individ.-Domain
%            ICNameRan individ.-Range 
%	     GRName    genereller Super-Role-Name
% 	     GRNameDom genereller Super-Role_domain
%            GRNameRan genereller Super-Role-range
% ist erfuellt wenn (GRName GCNameDom GCNameRan) die generelle - rolle von (IRName ICNameDom ICNameRan) ist
%  
% Author: Patrick Brandmeier

sb_ask(EnvName,MS,(risa(IRName,ICNameDom,ICNameRan,GRName,GCNameDom,GCNameRan))) :-
	environment(EnvName,Env,_),
	getConceptElement(Env,MS,ICNameDom,GCNameDom),
	sb_ask(EnvName,MS,role(GRName,GCNameDom,GCNameRan)).

sb_ask(EnvName,MS,(risa(IRName,ICNameDom,ICNameRan,IRName,GCNameDom,ICNameRan))) :-
	environment(EnvName,Env,_),
	getConceptElement(Env,MS,ICNameDom,GCNameDom),
	!.

%----------------------------------------------------------------------
% sb_ask(EnvName,MS,(rall(+-RName,+-CNameDom,+-CNameRan,CNameDef,+-MinNr,+-MaxNr,+-DefNr))) :-
% Arguments: Rname    RoleName
%	     CNameDom RoleDomain
%            CNameRan RoleRange 
%	     CNameDef ConceptNameDef.
% 	     MinNR    Minim.Nr
%            MaxNr    Maxi. Nr
% 
% ist erfuellt wenn 
%


sb_ask(EnvName,MS1,(rall(RName,CNameDom,CNameRan,CNameDef,MinNr,MaxNr,DefNr))) :-
	environment(EnvName,Env,_),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	convertMS(negative,Env,[[],true],MS3,[],[W1,G1],_),
	call(G1),
	roleAll(Env,W1,RName,CNameDom,CNameRan,CNameDef,MinNr,MaxNr,DefNr),
	!.


/*-----------------------------------------------------------------------------
 */

sb_attributes(CN,AList) :-
	getCurrentEnvironment(EnvName),
	sb_assert_attributes(concept,EnvName,[],CN,AList).
sb_attributes(A1,CN,AList) :-
	environment(A1,_,_),
	!,
	sb_assert_attributes(concept,A1,[],CN,AList).
sb_attributes(A1,CN,AList) :-
	(A1 = [] ; A1 = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_assert_attributes(concept,EnvName,A1,CN,AList).
sb_attributes(CN,R,AList) :-
	getCurrentEnvironment(EnvName),
	sb_assert_attributes(role,EnvName,[],[CN,R],AList).
sb_attributes(A1,A2,CN,AList) :-
	environment(A1,_,_),
	(A2 = [] ; A2 = [_|_]),
	!,
	sb_assert_attributes(concept,A1,A2,CN,AList).
sb_attributes(EnvName,CN,RN,AList) :-
	sb_assert_Attributes(role,EnvName,[],[CN,RN],AList).
sb_attributes(EnvName,MS,CN,RN,AList) :-	
	sb_assert_attributes(role,EnvName,MS,[CN,RN],AList).

sb_assert_attributes(Type,EnvName,MS,Spec,[]) :-
	!.
sb_assert_attributes(Type,EnvName,MS,Spec,[Pair|AList]) :-
	assertzRE(attribute(Type,EnvName,MS,Spec,Pair)),
	sb_assert_attributes(Type,EnvName,MS,Spec,AList).

/*------------------------------------------------------------------------------
 * Die 2- bis 4-stellige Funktion sb_unprimconcept([Env],[MS],CN,SpecListe) erwartet 
 * als letztes Argument  eine Liste von Konstruktoren: supers,restr-inh,nr, die irgendwann
 * mit sb_primconcept bzgl. CN definiert wurde.
 * Die Fkt. sb_unprimconcept eliminiert die entsprechenden Subsumption-Beziehungen wieder 
 * und l"oscht ebenfalls Eintr"age der Rollen wie: roleDomain,roleNr,etc..
 *-----------------------------*/

 

 unmake_primconcept(EnvName,MS,CN,supers([])) :- !.

 unmake_primconcept(EnvName,MS,CN,supers([X|T])) :-
			    environment(EnvName,Env,_),
			    conceptSubsets(Env,_user,MS,CN,X,AX),
			    undefprimconcept(EnvName,MS,CN,X),
			    unmake_primconcept(EnvName,MS,CN,supers(T)).

unmake_primconcept(EnvName,MS,CName1,
		   'restr-inh'(R1,restricts(R2,range(CName2,CNameDef)))):-
          unmake_primconcept(EnvName,MS,CName1,
			    restrict_inh(R1, restricts(R2 ,
							   range(CName2,CNameDef)))).



unmake_primconcept(EnvName,MS,CName1,
		   'restrict-inh'(R1,restricts(R2,range(CName2,CNameDef)))) :-
        unmake_primconcept(EnvName,MS,CName1,
			 restrict_inh(R1, restricts(R2 ,
							range(CName2,CNameDef)))).
 


unmake_primconcept(EnvName,MS,CName1,
	           restrict_inh(R1,restricts(R2,range(CName2,CNameDef)))) :-
	environment(EnvName,Env,_),
	!,
	getRoleDomain(Env,MS,R1,CNameDom),
	!,
	getRoleRange(Env,MS,R1,CName2),
	undefprimconcept(EnvName,MS,CNameDom,CName1),
	retract((roleDomain(Env,MS,R1,CNameDom) :- _)),
	retract((roleRange(Env,MS,R1,CName2) :- _)),
	retract((roleDefault(Env,MS,R1,CNameDef) :- _)),
	retract((roleTripel(Env,MS,R1,CNameDom,CName2,CNameDef))),
        !.



unmake_primconcept(EnvName,MS,CName1 , nr(R1, MinNr,MaxNr,DefNr)) :-
	environment(EnvName,Env,_),
	!,
	getRoleNr(Env,MS,R1,MinNr,MaxNr),
	!,
	getRoleDefNr(Env,MS,R1,DefNr),
	conceptEqualSets(Env,_user,MS,CNameDom,
			and([atleast(MinNr,R1),atmost(MaxNr,R1)]),AX),
        undefconcept(EnvName,MS,CNameDom,and([atleast(MinNr,R1),
	 				      atmost(MaxNr,R1)])),
        undefconcept(EnvName,MS,CNameDom,some(R1,top)),
        undefprimconcept(EnvName,MS,CNameDom,CName1),
        retract((roleNr(Env,MS,R1,MinNr,MaxNr) :- _)),
	retract((roleDefNr(Env,MS,R1,DefNr) :- _)),
	!.



/*------------------------------------------------------------------------
 * sb_unprimconcept(EnvName,MS,CName1,SpecList)
 *
 *------------------------------------------*/


sb_unprimconcept(CName1,[]) :- !.

sb_unprimconcept(CName1,[X|T]) :-
			    getCurrentEnvironment(EnvName),
			    sb_unprimconcept(EnvName,[],CName1,[X|T]),
			    !.



sb_unprimconcept(A,CName1,[X|T]) :-
			     environment(A,_,_),
			     !,
			     sb_unprimconcept(A,[],CName1,[X|T]),
			     !.


sb_unprimconcept(A,CName1,[X|T]) :-
			     (A=[] ; A=[_,_]),
			     getCurrentEnvironment(EnvName),
			     !,
			     sb_unprimconcept(EnvName,A,CName1,[X|T]).



sb_unprimconcept(EnvName,MS,CName1,[]) :- !.

sb_unprimconcept(EnvName,MS,CName1,[X|T]) :-
			     unmake_primconcept(EnvName,MS,CName1,X),
			     sb_unprimconcept(EnvName,MS,CName1,T),
			     !.




/*------------------------------------------------------------------------------
 * Die 4-stellige Fkt. unmake_defconcept(Env,MS,CN,supers(List_of_concepts)) erwartet
 * als letztes Argument  eine Liste (Menge) von Konzepten. Eine Obermenge dieser Menge wurde
 * irgendwann in AND-Verkn"upfung mit CN "aquivalent gemacht und zwar in der Form:
 *
 *    sb_defconcept(CN, [supers([C1,C2,...,Cn]),..]) ----->   defconcept(CN,and([C1,C2,..,Cn])).    
 *
 *-------------------------------------------------*/



unmake_defconcept(EnvName,MS,CName1,restrict_inh(RName1, restricts(RName2 ,
				    range(CName2,CNameDef))),CNameDom):-
        unmake_defconcept(EnvName,MS,CName1,'restr-inh'(RName1, restricts(RName2 ,
			  range(CName2,CNameDef))),CNameDom).


unmake_defconcept(EnvName,MS,CName1,'restrict-inh'(RName1, restricts(RName2 ,
					range(CName2,CNameDef))),CNameDom):-
        unmake_defconcept(EnvName,MS,CName1,'restr-inh'(RName1, restricts(RName2 ,
			  range(CName2,CNameDef))),CNameDom).


unmake_defconcept(EnvName,MS,CName1,'restr-inh'(RName1, restricts(RName2 ,
				  range(CName2,CNameDef))),CNameDom):-

        environment(EnvName,Env,_),
	!,
	roleEqualSets(Env,_user,MS,RName1,restr(RName2,CName2)),
	undefrole(EnvName,MS,RName1,restr(RName2,CName2)),
	!,
	getRoleDomain(Env,MS,RName1,CNameDom),
	!,
	conceptEqualSets(Env,_usr,MS,CNameDom,some(RName2,top)),
	undefconcept(CNameDom,some(RName2,top)),
        retract((roleDomain(Env,MS,RName1,CNameDom) :- _)),
	retract((roleRange(Env,MS,RName1,CName2) :- _)),
	retract((roleDefault(Env,MS,RName1,CNameDef) :- _)),
	retract((roleTripel(Env,MS,RName1,CNameDom,CName2,CNameDef))),
	retract((roleAll(Env,MS,RName1,CNameDom,CName2,CNameDef,_,_,_))),
	!.


unmake_defconcept(EnvName,MS,CName1, nr(RTerm,MinNr,MaxNr,DefNr),CNameDom) :-
	environment(EnvName,Env,_),
        unexpand_role(EnvName,MS,RTerm,R1),
	!,
	conceptEqualSets(Env,_usr,MS,CNameDom,and([atleast(MinNr,R1),
					           atmost(MaxNr,R1)]),AX),
        undefconcept(EnvName,MS,CNameDom,and([atleast(MinNr,R1),
						   atmost(MaxNr,R1)])),
	!,
	conceptEqualSets(Env,_usr,MS,CNameDom,some(R1,top)),
        undefconcept(EnvName,MS,CNameDom,some(R1,top)),       
	retract((roleNr(Env,MS,R1,MinNr,MaxNr) :- _)),
	retract((roleDefNr(Env,MS,R1,DefNr) :- _)),
	!.
        						   
        
	    
unmake_defconcept(EnvName,MS,CName1, necres(RTerm, nec),CNameDom):-
	!,
	environment(EnvName,Env,_),
	unexpand_role(EnvName,MS,RTerm,R1),
	conceptEqualSets(Env,_usr,MS,CNameDom,atleast(1,R1),AX),
	undefconcept(EnvName,MS,CNameDom,atleast(1,R1)),
	retract((roleDomain(Env,MS,R1,CNameDom) :- _)),
	!.



unmake_defconcept(EnvName,MS,CName1 , necres(RTerm, _),CNameDom):-
        !,
	environment(EnvName,Env,_),
	unexpand_role(EnvName,MS,RTerm,R1),
	retract((roleDomain(Env,MS,RName1,CNameDom) :- _)),
	!.


/*---------------------------------------------------------------------
 * unexpand_role(EnvName,MS,RTerm,R1)
 *
 *-------------------------------------*/


unexpand_role(_,_,RTerm,RTerm) :-
	 atomic(RTerm),
	 !.

unexpand_role(EnvName,MS,RTerm,R1) :-
         RTerm = sb_unprimelemrole(EnvName,MS,R1, 'domain-range'(C1,C2,CNameDef)),
         !,
	 call(RTerm).
	   


unexpand_role(EnvName,MS,RTerm,R1) :-
         RTerm = sb_unprimelemrole(MS,R1, 'domain-range'(C1,C2,CNameDef)),
         !,
	 call(RTerm).


unexpand_role(EnvName,MS,RTerm,R1) :-
         RTerm = sb_unprimelemrole(R1, 'domain-range'(C1,C2,CNameDef)),
         !,
	 call(RTerm).



unexpand_role(_,_,RTerm,RTerm).



/**********************************************************************
 *
 * sb_undefconcept(EnvName,MS,CName1,SpecList)
 *
 *
 */

sb_undefconcept(CName1,[]):- !.

sb_undefconcept(CName1,SpecList) :-
         getCurrentEnvironment(EnvName),
	 sb_undefconcept(EnvName,[],CName1,SpecList),
	 !.



sb_undefconcept(A,CName1,SpecList) :-
         environment(A,_,_),
       	 !,
	 sb_undefconcept(A,[],CName1,SpecList),
	 !.


sb_undefconcept(A,CName1,SpecList) :-
         (A=[] ; A=[_,_]),
         getCurrentEnvironment(EnvName),
         !,
         sb_undefconcept(EnvName,A,CName1,SpecList).


sb_undefconcept(EnvName,MS,CName1,SpecList) :-
           sb_undefconcept(EnvName,MS,CName1,SpecList,[]).


sb_undefconcept(EnvName,MS,CName1,[],[]) :- !.

sb_undefconcept(EnvName,MS,CName1,[],HList) :-
	   environment(EnvName,Env,_),
	   !,
	   conceptEqualSets(Env,_user,MS,CName1,and(HList),AX),
	   undefconcept(EnvName,MS,CName1,and(HList)),
	   !.


sb_undefconcept(EnvName,MS,CName1,[supers(L)|SpecList],CL1) :-
	   !,
	   append(L,CL1,CL2),
	   sb_undefconcept(EnvName,MS,CName1,SpecList,CL2).

sb_undefconcept(EnvName,MS,CName1,[Spec1|SpecList],CL1) :-
           unmake_defconcept(EnvName,MS,CName1,Spec1,Concept),
           sb_undefconcept(EnvName,MS,CName1,SpecList,[Concept|CL1]).



sb_undefconcept(EnvName,MS,CName1,supers(L),[]) :-
           environment(EnvName,Env,_),
	   !,
	   conceptEqualSets(Env,_user,MS,CName1,and(L),AX),
	   undefconcept(EnvName,MS,CName1,and(L)).



/**********************************************************************
 *
 * sb_unprimelemrole(EnvName,MS,RName1, 'domain-range'(CName1,CName2,CNameDef)) *
 *
 */


sb_unprimelemrole(RName1, 'domain-range'(CName1,CName2,CNameDef)):-
           getCurrentEnvironment(EnvName),
	   sb_unprimelemrole(EnvName,[],RName1, 'domain-range'(CName1,CName2,CNameDef)).



sb_unprimelemrole(X,RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	   getCurrentEnvironment(X),
	   sb_unprimelemrole(X,[],RName1, 'domain-range'(CName1,CName2,CNameDef)).


sb_unprimelemrole(X,RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	   (X = [] ; X = [_|_]),
	   getCurrentEnvironment(EnvName),
	   sb_unprimelemrole(EnvName,X,RName1, 'domain-range'(CName1,CName2,CNameDef)).




sb_unprimelemrole(EnvName,MS,RName1, 'domain-range'(CName1,CName2,CNameDef)):-
	   environment(EnvName,Env,_),
	   !,
	   conceptSubsets(Env,_usr,MS,CName1,some(RName1,top)),
	   undefprimconcept(EnvName,MS,CName1,some(RName1,top)),
	   !,
	   conceptSubsets(Env,_usr,MS,some(inverse(RName1),top)),
	   undefprimconcept(EnvName,MS,some(inverse(RName1),top),CName2),
	   retract((roleDomain(Env,MS,RName1,CName1) :- _)),
	   retract((roleRange(Env,MS,RName1,CName2) :- _)),
	   retract((roleDefault(Env,MS,RName1,CNameDef) :- _)),
	   retract((roleTripel(Env,MS,RName1,CName1,CName2,CNameDef))),
	   retract((roleAll(Env,MS,RName1,CName1,CName2,CNameDef,_,_,_))),
	   !.


/**********************************************************************
 *
 * sb_undefelemrole(RName1,restricts(RName2,range(CName1,CNameDef)))
 * 
 */


sb_undefelemrole(RName1, restricts(RName2, range(CName1,CNameDef))):-
        getCurrentEnvironment(EnvName),
	sb_undefelemrole(EnvName,[],RName1, restricts(RName2, range(CName1,CNameDef))),
	!.


sb_undefelemrole(X,RName1, restricts(RName2, range(CName1,CNameDef))):-
	getCurrentEnvironment(X),
	!,
	sb_undefelemrole(X,[],RName1, restricts(RName2, range(CName1,CNameDef))),
        !.


sb_undefelemrole(X,RName1, restricts(RName2, range(CName1,CNameDef))):-
        (X = [] ; X = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_undefelemrole(EnvName,X,RName1, restricts(RName2, range(CName1,CNameDef))),
	!.


sb_undefelemrole(EnvName,MS,RName1, restricts(RName2, range(CName1,CNameDef))) :-
        environment(EnvName,Env,_),
	!,
	roleEqualSets(Env,_user,MS,RName1,restr(RName2,CName1)),
	undefrole(EnvName,MS,RName1,restr(RName2,CName1)),
	!,
	roleRange(Env,MS,RName1,CName1),
	!,
	roleDefault(Env,MS,RName1,CNameDef),
	retract((roleRange(Env,MS,RName1,CName1) :- _)),
	retract((roleDefault(Env,MS,RName1,CNameDef) :- _)),
	!.

/*----------------------------------------------*/


unmake_irole(EnvName,MS,ICName1,irole(RName,iname(IRName),
				      nr(MinNr,MaxNr,DefNr))):-
        environment(EnvName,Env,_),
	!,
	roleSubsets(Env,_user,MS,IRName,restr(RName,and([atleast(MinNr,RName),
				            	    atmost(MaxNr,RName),
						    some(inverse(RName),top)]))),

	undefprimrole(EnvName,MS,IRName,restr(RName,
					      and([atleast(MinNr,RName),
					      atmost(MaxNr,RName),
					      some(inverse(RName),top)]))),
        !,
	getRoleNr(Env,MS,IRName,MinNr,MaxNr),
	!,
	getRoleDefNr(Env,MS,IRName,DefNr),
	retract((roleNr(Env,MS,IRName,MinNr,MaxNr) :- _)),
	retract((roleDefNr(Env,MS,IRName,DefNr) :- _)),
	!.

unmake_irole(EnvName,MS,ICName1,irole(RName,iname(IRName),vr(ICName2))) :-
	environment(EnvName,Env,_),
	!,
	roleSubsets(Env,_user,MS,IRName,restr(RName,CName2)),
	undefprimrole(EnvName,MS,IRName, restr(RName,CName2)),
        delete_ind(EnvName,MS,ICName1,ICName2,IRName).

unmake_defelem(EnvName,MS,ICName,isa(CName)):-
	delete_ind(EnvName,MS,ICName,CName),
	!.

unmake_defelem(EnvName,MS,ICName1,irole(RName,iname(IRName),SpecList)) :-
	constructRestriction(IRName,SpecList,RestrList),
	!,
	roleSubsets(Env,_user,MS,IRName,restr(RName,and(RestrList))),
	undefprimrole(EnvName,MS,IRName,restr(RName,and(RestrList))),
	unmake_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),SpecList)).


unmake_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),[])) :-
	!.
unmake_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),[X|T])) :-
	unmake_irole(EnvName,MS,ICName1,irole(RName,iname(IRName),X)),
	unmake_defelem_list(EnvName,MS,ICName1,irole(RName,iname(IRName),T)).



/**********************************************************************
 *
 * sb_undefelem(EnvName,MS,ICName1,[X|T])
 *
 */

sb_undefelem(ICName1,SpecListe) :-
	getCurrentEnvironment(EnvName),
	sb_undefelem(EnvName,[],ICName1,SpecListe).



sb_undefelem(A,ICName1,SpecList) :-
        environment(A,_,_),
	!,
	sb_undefelem(A,[],ICName1,SpecList).

sb_undefelem(A,ICName1,SpecList) :-
	(A = [] ; A = [_|_]),
	!,
	getCurrentEnvironment(EnvName),
	sb_undefelem(EnvName,A,ICName1,SpecList).


sb_undefelem(EnvName,MS,ICName1,[]) :-
	!.

sb_undefelem(EnvName,MS,ICName1,[X|T]):-
	unmake_defelem(EnvName,MS,ICName1,X),
        sb_undefelem(EnvName,MS,ICName1,T).


/**********************************************************************
 *
 * sb_fact(EnvName,MS,elementOf(X,C),P)
 *
 */

sb_fact(P1) :-
	completeParameter([P1],EnvName,MS,Query,Proof),
	sb_fact(EnvName,MS,Query,Proof).
sb_fact(P1,P2) :-
	completeParameter([P1,P2],EnvName,MS,Query,Proof),
	sb_fact(EnvName,MS,Query,Proof).
sb_fact(P1,P2,P3) :-
	completeParameter([P1,P2,P3],EnvName,MS,Query,Proof),
	sb_fact(EnvName,MS,Query,Proof).

sb_fact(EnvName,MS,isa(X,C),Exp) :-
	retractallSpecial(hypothesis(_)),
 	environment(EnvName,Env,_),
 	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
 	getNegatedConcept(C,C1),
 	getFactQuery(Env,W1,C,X,Exp,Goal),
 	call((call(G1), Goal)),
 	atomic(X),
	allowedAnswerConcept(Env,C).
sb_fact(EnvName,MS,(role(RName,CNameDom,CNameRan)),proved(fact,basedOn(tbox))) :-
	environment(EnvName,Env,_),
	!,
	getRoleDomain(Env,MS,RName,CNameDom),
	getRoleRange(Env,MS,RName,CNameRan).
sb_fact(EnvName,MS,(attributes(CN,Attribute,Value)),proved(fact,basedOn(tbox))) :-
	attribute(concept,EnvName,MS,CN,[Attribute,Value]).
sb_fact(EnvName,MS,(attributes(CN,RN,Attribute,Value)),proved(fact,basedOn(tbox))) :-
	attribute(role,EnvName,MS,[CN,RN],[Attribute,Value]).
sb_fact(EnvName,MS,irole(R,X,Y),Exp) :-
	retractallSpecial(hypothesis(_)),
	environment(EnvName,Env,_),
	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	getFactQuery(Env,W1,Y,R,X,Exp,Goal),
	call(G1), 
	call(Goal).
	
getFactQuery(Env,W1,C0,X,Exp,Goal) :-
	constructMLHead(Env,_RN1,W1,C0,CON,A1,X,Pc,_CALLS,_D,Exp,Gd,Od,L1,L2,Anc1,Anc2,Y,PT,InHead),
%	constructMLHead(Env,_RN1,W1,C0,X,_HYPS,_D,_CALLS,PT,InHead),
	getExplanation(InHead,Exp),
	Goal = (clause(InHead,Body), ((PT == abox), call(Body))),
	!.
getFactQuery(Env,W1,Y,R,X,PT,Goal) :-
	constructEqHead(Env,_RN1,W1,Y,CON,A1,X,Pc,_CALLS,_D,Exp,Gd,Od,L1,L2,Anc1,Anc2,Y,PT,EqHead),
%	constructEqHead(Env,_RN1,W1,Y,_F,R,X,_HYPS,_D,_CALLS,PT,EqHead),
	Goal = (clause(EqHead,Body), ((PT == abox), call(Body))),
	!.

getRoleDomain(Env,MS1,RName,CDom) :-
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	clause(roleDomain(Env,W1,RName,CDom),_),
	once((call(G1),roleDomain(Env,W1,RName,CDom))).

getRoleRange(Env,MS1,RName,CRange) :-
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	clause(roleRange(Env,W1,RName,CRange),_),
	once((call(G1),roleRange(Env,W1,RName,CRange))).

getRoleDefault(Env,MS1,RName,CNameDef) :-
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	clause(roleDefault(Env,W1,RName,CNameDef),_),
	once((call(G1),roleDefault(Env,W1,RName,CNameDef))).

getRoleNr(Env,MS1,RName,MinNr,MaxNr) :- 
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	clause(roleNr(Env,W1,RName,MinNr,MaxNr),_),
	once((call(G1),roleNr(Env,W1,RName,MinNr,MaxNr))).

getRoleDefNr(Env,MS1,R1,DefNr) :-
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	clause(roleDefNr(Env,W1,R1,DefNr),_),
	once((call(G1),roleDefNr(Env,W1,R1,DefNr))).

getRoleTripel(Env,MS1,RName1,CNameDomT,CNameT,CNameDefT) :-
	convertMS(Env,[[],true],MS1,[],[W1,G1],_),
	clause(roleTripel(Env,W1,RName1,CNameDomT,CNameT,CNameDefT),_),
	once((call(G1),roleTripel(Env,W1,RName1,CNameDomT,CNameT,CNameDefT))).

getConceptElement(Env,MS1,X,C) :-
	convertMS(Env,[[],true],MS1,[],[W1,G1],_),
	clause(conceptElement(Env,_W1,_,X,C,_),_),
	once((call(G1),conceptElement(Env,W1,_,X,C,_))).
/**********************************************************************
 *
 * @(#) tellConcept.pl 1.12@(#)
 *
 */

/***********************************************************************
 *
 * assertConceptRInL(+ModalSequence,+CT1,+CT2,+AxiomName)
 * asserts membership clauses for the inclusion of CT2 into CT1 in 
 * modal context ModalSequence.
 *
 */

assertConceptRInL(Env,Name,MS,CT1,CT2) :-
	assertConceptLInR(Env,Name,MS,CT2,CT1).

/***********************************************************************
 *
 * assertConceptLInR(+ModalSequence,+ConceptName,+Constraint,+AxiomName)
 * asserts membership clauses for the inclusion of ConceptName into
 * Constraint in modal context ModalSequence.
 *
 */

assertConceptLInR(_Env,rn(_,_,_),_MS,_CN,or([])) :- 
	!.
assertConceptLInR(Env,rn(AxiomName,Source,Orientation),MS,CN,or([CT1|CTs])) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	hop_map(negate,[CT1|CTs],NCTs),
	convertInAntecedentList(Env,rn(AxiomName,_AnySource1,Orientation),
                                bodyMC(W1),headMC(W1),NCTs,X,
				HYPS,AB,CALLS,PTL,INCTs),
	convertInAntecedent(Env,rn(AxiomName,_AnySource2,Orientation),
                            bodyMC(W1),headMC(W1),
			    CN,X,HYPS,AB,CALLS,PT1,Body),
	assertOrConceptLInR(Env,rn(AxiomName,Source,Orientation),
                            MS,PT1,Body,W1,G1,X,HYPS,AB,CALLS,
                            or([CT1|CTs]),[],[],PTL,INCTs).
assertConceptLInR(_Env,rn(_,_,_),_MS,_CN,and([])) :-
	!.
assertConceptLInR(Env,rn(AxiomName,O2,Orientation2),MS,CN1,and([CN2|CTs])) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation2),
                            bodyMC(W1),headMC(W1),
			    CN1,X,HYPS,AB,CALLS,PT1,Body),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O2,Orientation2,RN2),
	convertInConsequence(Env,pr(3),RN2,MS,W1,CN2,X,HYPS,AB,CALLS,PT1,InHead2),
	constructMLMark(InHead2,Mark2),
%	assertaRE((InHead2 :- (checkCallStack(CALLS,Mark2), (call(G1), onceOrMore(Body))))),
	assertaRE((InHead2 :- (checkCallStack(CALLS,Mark2), (call(G1), Body)))),
	assertConceptLInR(Env,rn(AxiomName,O2,Orientation2),MS,CN1,and(CTs)),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,set(Set1)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,set(Set1),X,HYPS,AB,CALLS,PT1,InHead1),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
			    bodyMC(W1),headMC(W1),
	                    CN,X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), onceOrMore(Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,not(set(Set1))) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,not(set(Set1)),X,HYPS,AB,CALLS,PT1,InHead1),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
			    bodyMC(W1),headMC(W1),
	                    CN,X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), onceOrMore(Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,not(D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,not(D),X,HYPS,AB,CALLS,PT1,InHead1),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
			    bodyMC(W1),headMC(W1),
	                    CN,X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), onceOrMore(Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,naf(D)) :-
	% in the consequence not and naf have the same meaning
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,not(D),X,HYPS,AB,CALLS,PT1,InHead1),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
			    bodyMC(W1),headMC(W1),
	                    CN,X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), onceOrMore(Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,all(R,D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,all(R,D),X,HYPS,AB,CALLS,PT1,
	                     (EqLiteral, InHead1)),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
                            bodyMC(W1),headMC(W1),CN,X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), (EqLiteral, Body))))),
	gensym(rule,RuleName2),
	ruleName(AxiomName,RuleName2,O,Orientation,RN2),
	convertInConsequence(Env,pr(3),RN2,MS,W1,not(normalWorld(R)),X,
			     HYPS,AB,CALLS,PT2,InHead2),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
                            bodyMC(W1),headMC(W1),not(D),aaa,HYPS,AB,CALLS,PT1,Body2),
        constructMLMark(InHead2,Mark2),
        assertaRE((InHead2 :- (checkCallStack(CALLS,Mark2), Body2))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,some(R,set([X]))) :-
	nonvar(X),
	!,
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName3),
	ruleName(AxiomName,RuleName3,user,lInR,RN3),
	constructEqHead(Env,RN3,W1,X,SF1,R,Y,HYPS,AB,CALLS,PT1,EqLiteral2),
	constructEqMark(RN3,W1,X,SF1,R,Y,HYPS,AB,CALLS,EqMark2),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
	                    bodyMC(W1),headMC(W1),CN,Y,HYPS,AB,CALLS,PT1,Body),
	assertaRE((EqLiteral2 :- checkCallStack(CALLS,EqMark2), Body)),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,some(R,D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName1),
	ruleName(AxiomName,RuleName1,O,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,some(R,D),X,
	                     HYPS,AB,CALLS,PT1,(EqLiteral, InHead1)),
	constructMLMark(InHead1,Mark1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
	                    bodyMC(W1),headMC(W1),CN,X,HYPS,AB,CALLS,PT1,Body),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), (EqLiteral, Body))))),
	gensym(rule,RuleName2),
	ruleName(AxiomName,RuleName2,system,Orientation,RN2),
	convertInConsequence(Env,pr(3),RN2,MS,W1,normalWorld(R),X,
			     HYPS,AB,CALLS,PT2,InHead2),
	constructMLMark(InHead2,Mark2),
	assertaRE((InHead2 :- checkCallStack(CALLS,Mark2), (call(G1), Body))),
%% experimental code
%% Ullrich Hustadt 03.06.94
%% x in CN => R(X,sk(X)) for some skolem function sk
%	gensymbol(skolem,[X],SF1),
%	gensymbol(object,[X],SO1),
%	gensym(rule,RuleName3),
%	ruleName(AxiomName,RuleName3,user,lInR,RN3),
%	constructEqHead(Env,RN3,W1,SO1,SF1,R,X,HYPS,AB,CALLS,PT1,EqLiteral2),
%	constructEqMark(RN3,W1,SO1,SF1,R,X,HYPS,AB,CALLS,EqMark2),
%	assertaRE((EqLiteral2 :- checkCallStack(CALLS,EqMark2), Body)),
%% experimental code
%% Ullrich Hustadt 03.06.94
%% x in CN => D(sk(X))   for some skolem function sk
%	gensym(rule,RuleName4),
%	ruleName(AxiomName,RuleName4,O,Orientation,RN4),
%	convertInConsequence(Env,pr(3),RN4,MS,W1,D,SO1,HYPS,AB,CALLS,PT1,InHead4),
%	constructEqCall(Env,rn(AN4,RN4,_S4,_O4),bodyMC(W1),headMC(W1),Y,SF1,R,X,HYPS,AB,CALLS,PT4,EqCall4),
%	constructMLMark(InHead4,Mark4),
%	assertaRE((InHead4 :- (checkCallStack(CALLS,Mark4), (call(G1), (EqCall4, Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,_S,Orientation),MS,CN,atleast(N,R)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
	                    bodyMC(W1),headMC(W1),CN,X,HYPS,AB,CALLS,PT1,Body),
	typeOfDefinition(Env,MS,R,S1),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,S1,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,atleast(N,R),X,
			     HYPS,AB,CALLS,PT1,InHead1),
	constructConMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), onceOrMore(Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,atmost(N,R)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
                            bodyMC(W1),headMC(W1),CN,X,HYPS,AB,CALLS,PT1,Body),
	typeOfDefinition(Env,MS,R,O1),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O1,Orientation,RN1),
	convertInConsequence(Env,pr(3),RN1,MS,W1,atmost(N,R),X,
			     HYPS,AB,CALLS,PT1,InHead1),
	constructConMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), onceOrMore((call(G1), Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,b(MOp,P1,D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	genagent(P1,free,P),
	C1 = rel(Env,_,m(MOp,P),W1,W2),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
	                    bodyMC(W1),headMC(W2),CN,X,HYPS,AB,CALLS,PT1,Body),
	constructMLHead(Env,RN1,W2,D,X,HYPS,AB,CALLS,and([C1,PT1]),InHead1),
	constructMLMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), (C1, Body))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,bc(MOp,C,D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RuleName),
	ruleName(AxiomName,RuleName,O,Orientation,RN1),
	genagent(P1,free,P),
	C1 = rel(Env,_,m(MOp,P),W1,W2),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
	                    bodyMC(W1),headMC(W2),CN,X,HYPS,AB,CALLS,PT1,Body1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource2,Orientation),
			    bodyMC(W1),headMC(W2),C,P,HYPS,AB,CALLS,PT2,Body2),
	constructMLHead(Env,RN1,W2,D,X,HYPS,AB,CALLS,and([C1,PT1,PT2]),InHead1),
	constructMLMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), (C1, (Body1, Body2)))))),
	!.
assertConceptLInR(Env,rn(AxiomName,_S1,Orientation),MS,CN,d(MOp,P1,D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],WVL),
	gensym(rule,RuleName),
	typeOfDefinition(Env,MS,D,S2),
	ruleName(AxiomName,RuleName,S2,Orientation,RN1),
	gensym(wp,WP),
	WPTerm =.. [WP,WVL],
	genagent(P1,skolemize,P),
	W2 = app(WPTerm:m(MOp,P),W1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
                            bodyMC(W1),headMC(W2),CN,X,HYPS,AB,CALLS,PT1,Body),
	constructMLHead(Env,RN1,W2,D,X,HYPS,AB,CALLS,
			PT1,InHead1),
	constructMLMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), Body)))),
	!.
assertConceptLInR(Env,rn(AxiomName,_S1,Orientation),MS,CN,dc(MOp,C,D)) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],WVL),
	gensym(rule,RuleName),
	typeOfDefinition(Env,MS,D,S2),
	ruleName(AxiomName,RuleName,S2,Orientation,RN1),
	gensym(wp,WP),
	WPTerm =.. [WP,WVL],
	genagent(P1,skolemize,P),
	W2 = app(WPTerm:m(MOp,P),W1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource1,Orientation),
                            bodyMC(W1),headMC(W2),CN,X,HYPS,AB,CALLS,PT1,Body1),
	convertInAntecedent(Env,rn(AxiomName,_AnySource2,Orientation),
                            bodyMC(W1),headMC(W2),C,P,HYPS,AB,CALLS,PT2,Body2),
	constructMLHead(Env,RN1,W2,D,X,HYPS,AB,CALLS,
			and([PT1,PT2]),InHead1),
	constructMLMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), (call(G1), (Body1, Body2))))),
	!.
assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,ConceptTerm) :-
	assertConceptLInR(Env,rn(AxiomName,O,Orientation),MS,CN,and([ConceptTerm])).

/***********************************************************************
 * 
 * assertOrConceptLInR(Env,MS,InHead,or([CT1|CTs]),[INCT|CTs]),AxiomName).
 *
 */

assertOrConceptLInR(_Env,rn(_,_,_),_MS,_PT1,_InHead,_W1,_G1,_X,_HYPS,_,_CALLS,
		    or([]),_FPTL,_First,_PTL,_INCTs) :-
	!.
assertOrConceptLInR(Env,rn(AxiomName,O,Orientation),
                    MS,PT2,InHead2,W1,G1,X,HYPS,AB,CALLS,or([CT1|CTs]),
	            FPTL,First,[PT1|PTL1],[INCT1|INCTs]) :-
	append([InHead2|First],INCTs,L1),
	append([PT2|FPTL],PTL1,PTL),
%	hop_map(getInExplanation,L1,PTL),
	constructBody(L1,Body),
	gensym(rule,RuleName),
	typeOfDefinition(Env,MS,CT1,S1),
	ruleName(AxiomName,RuleName,S1,Orientation,RN1),
	constructMLHead(Env,RN1,W1,CT1,X,HYPS,AB,CALLS,and(PTL),InHead1),
	constructMLMark(InHead1,Mark1),
	assertaRE((InHead1 :- (checkCallStack(CALLS,Mark1), onceOrMore((call(G1), Body))))),
	append(First,[INCT1],L2),
	append(FPTL,[PT1],FPTL2),
	!,
	assertOrConceptLInR(Env,rn(AxiomName,O,Orientation),
                            MS,PT2,InHead2,W1,G1,X,HYPS,AB,CALLS,or(CTs),
                            FPTL2,L2,PTL1,INCTs).

constructBody([],true) :-
	!.
constructBody([I1],I1) :-
	!.
constructBody([I1|IL],(I1,B1)) :-
	constructBody(IL,B1).


/***********************************************************************
 *
 * convertAndList(+ModalSequence,+ConceptTermList,
 *                   -X,-CallStack,-InTermStructure,+AxiomName)
 *
 */

convertAndList(_,_,_,_,[],_X,_HYPS,_,_CALLS,true,[]).
convertAndList(Env,Name,MC1,MC2,[CTerm],X,HYPS,AB,CALLS,InCTerm,[PT1]) :-
	convertInAntecedent(Env,Name,MC1,MC2,
                            CTerm,X,HYPS,AB,CALLS,PT1,InCTerm).
convertAndList(Env,Name,MC1,MC2,[CTerm|CTermList],X,HYPS,AB,CALLS,
	       (InCTerm,InCTermList),[PT1|PTL]) :-
	convertInAntecedent(Env,Name,MC1,MC2,
                            CTerm,X,HYPS,AB,CALLS,PT1,InCTerm),
	convertAndList(Env,Name,MC1,MC2,CTermList,X,
		       HYPS,AB,CALLS,InCTermList,PTL).

/***********************************************************************
 *
 * convertOrList(+ModalSequence,+ConceptTermList,
 *                   -X,-CallStack,-InTermStructure,+AxiomName)
 *
 */

convertOrList(_,_,_,[],_X,_HYPS,_AB,_CALLS,_AX,false,[]).
convertOrList(Env,Name,MC1,MC2,[CTerm],X,HYPS,AB,CALLS,InCTerm,[PT1]) :-
	convertInAntecedent(Env,Name,MC1,MC2,
                            CTerm,X,HYPS,AB,CALLS,PT1,InCTerm),
	!.
convertOrList(Env,Name,bodyMC(W1),MC2,[CTerm|CTermList],X,
	      HYPS,AB,CALLS,
              (InCTerm ; (InCTermList)),[PT1|PTL]) :-
	HYPS = [or(H1),rl(H2),fl(H3)],
	Name = rn(AX,_S,_O),
	convertInAntecedent(Env,Name,bodyMC(W1),MC2,
                            CTerm,X,HYPS,AB,CALLS,PT1,InCTerm),
	convertOrList(Env,Name,bodyMC(W1),MC2,CTermList,X,
		      HYPS,AB,CALLS,InCTermList,PTL).
%convertOrList(Env,Name,bodyMC(W1),MC2,[CTerm|CTermList],X,
% 	      HYPS,AB,CALLS,
%               (InCTerm ; (NewH1 = [HypTerm|H1], InCTermList)),[PT1|PTL]) :-
% 	HYPS = [or(H1),rl(H2),fl(H3)],
% 	Name = rn(AX,_S,_O),
% 	convertInAntecedent(Env,Name,bodyMC(W1),MC2,
%                             CTerm,X,HYPS,AB,CALLS,PT1,InCTerm),
% 	negate(CTerm,CTermN),
% 	constructMLHead(Env,rn(AX,_RN1,_S1,_O1),W1,CTermN,X,
% 			HYPS,AB,_CALLS,_,HypMLTerm),
% 	constructMLMark(HypMLTerm,HypTerm),
% 	convertOrList(Env,Name,bodyMC(W1),MC2,CTermList,X,
%		      [or(NewH1),rl(H2),fl(H3)],AB,CALLS,InCTermList,PTL).

/***********************************************************************
 *
 * convertInAntecedent(Env,+ModalSequence,+ConceptTerm,-Variable,
 *              -Hypotheses,-CallStack,+AxiomName,-InLiteral)
 *
 */

convertInAntecedent(Env,rn(AX,S1,_O),MC1,MC2,D,X,HYPS,AB,CALLS,PT1,InHead) :-
	(var(D) ; atomic(D)),
	!,
	constructMLCall(Env,rn(AX,_RN1,S1,_O1),MC1,MC2,
	                D,X,HYPS,AB,CALLS,PT1,InHead).
convertInAntecedent(Env,rn(AX,Source,_O),MC1,MC2,set(S1),X,HYPS,AB,CALLS,PT1,Body) :-
	constructMLCall(Env,rn(AX,_RN1,Source,_O1),MC1,MC2,
	                set(S1),X,HYPS,AB,CALLS,PT1,InHead1),
	Body = ((nonvar(S1), (nongeneric(X), member(X,S1))) ; InHead1),
	!.
convertInAntecedent(Env,rn(AX,Source,_O),MC1,MC2,not(set(S1)),X,HYPS,AB,CALLS,PT1,Body) :-
	constructMLCall(Env,rn(AX,_RN1,Source,_O1),MC1,MC2,
	                not(set(S1)),X,HYPS,AB,CALLS,PT1,InHead1),
	Body = ((nonvar(S1), (atomic(X), (nongeneric(X), not(member(X,S1)))) ; InHead1)),
	!.
convertInAntecedent(Env,Name,MC1,MC2,and(L),X,HYPS,AB,CALLS,and(PTL),Body) :-
	convertAndList(Env,Name,MC1,MC2,L,X,HYPS,AB,CALLS,Body,PTL),
	!.
convertInAntecedent(Env,Name,MC1,MC2,or(L),X,HYPS,AB,CALLS,or(PTL),Body) :-
	convertOrList(Env,Name,MC1,MC2,L,X,HYPS,AB,CALLS,Body,PTL),
	!.
convertInAntecedent(Env,rn(AX,S1,_O1),MC1,MC2,
	            not(D),X,HYPS,AB,CALLS,PT1,Body) :-
	constructMLCall(Env,rn(AX,_RN,S1,_O2),MC1,MC2,
	                not(D),X,HYPS,AB,CALLS,PT1,InHead),
	Body = InHead,
	!.
convertInAntecedent(Env,rn(AX,S1,_O1),bodyMC(MS1),MC2,
	            naf(D),X,HYPS,AB,CALLS,PT1,Body) :-
	% in the antecedent `x in naf(D) is provable' means 
	% `x in D is not provable'
	atomic(D),
	!,
	HYPS = [or(H1),rl(H2),fl(H3)],
	NewHYPS = [or(H1),rl([]),fl(H3)],
	constructMLHead(Env,rn(AX,_RN3,_S3,_O3),MS1,naf(D),X,
			HYPS,AB,_CALLS,_,DefaultMLTerm),
	convertInAntecedent(Env,rn(AX,S1,_O1),bodyMC(MS1),MC2,D,X,NewHYPS,
			    AB,CALLS,PT2,BodyD),
	PT1 = byDefault(in(MS1,not(D),X),hyp(NewHYPS),basedOn([])),
	constructMLMark(DefaultMLTerm,DefaultTerm),
	L1 = addDefaultML(DefaultTerm,H3),
	constructMLMark(BodyD,MarkD),
	Body = (member(MarkD,HYPS) ; (nongeneric(X), (not(member(DefaultMLTerm,CALLS)), (not(BodyD), nongeneric(X), L1)))),
	!.
convertInAntecedent(Env,rn(AX,S1,_O1),bodyMC(MS1),MC2,
	            naf(D),X,HYPS,AB,CALLS,PT1,Body) :-
	% in the antecedent `x in naf(D) is provable' means 
	% `x in D is not provable'
	HYPS = [or(H1),rl(H2),fl(H3)],
	NewHYPS = [or(H1),rl([]),fl(H3)],
	convertInAntecedent(Env,rn(AX,S1,_O1),bodyMC(MS1),MC2,D,X,NewHYPS,
			    AB,CALLS,PT2,BodyD),
	constructMLMark(BodyD,MarkD),
	normalizeNot(not(D),D1),
	PT1 = byDefault(in(MS1,D1,X),hyp(NewHYPS),basedOn([])),
	constructMLHead(Env,rn(AX,_RN3,_S3,_O3),MS1,D1,X,
			HYPS,AB,_CALLS,_,DefaultMLTerm),
	constructMLMark(DefaultMLTerm,DefaultTerm),
	L1 = addDefaultML(DefaultTerm,H3),
%	L1 = assertaRE(hypothesis(in(Env,modal(MS1),D1,X,hyp(HYPS),ab(AB),PT1))),
	Body = (nongeneric(X), (not(BodyD), nongeneric(X), L1)),
	!.
convertInAntecedent(Env,rn(AX,S1,_O1),MC1,MC2,
	            all(R,D),X,HYPS,AB,CALLS,or([and([PT2,PT1]),PT3]),
                    ((EqLiteral, Body); (InHead2; (C1, (C2, C3))))) :-
	% create a new skolem constant 
	gensymbol(skolem,[X,Y],SF),
	% construct equational literal
	constructEqCall(Env,rn(AX,_RN1,_S2,_O2),MC1,MC2,Y,SF,R,X,HYPS,AB,CALLS,PT2,EqLiteral),
	convertInAntecedent(Env,rn(AX,S1,_O3),MC1,MC2,D,Y,HYPS,AB,CALLS,PT1,Body),
	constructMLCall(Env,rn(AX,_RN4,_S4,_O4),MC1,MC2,not(normalWorld(R)),X,HYPS,AB,CALLS,PT3,InHead2),
	MC1 = bodyMC(W1),
	C1 = closed(Env,MS,X,_,R),
	C2 = collectAllFillers(Env,W1,R,X,HYPS,D,CALLS,S),
	C3 = mapGoal(Body,Y,S),
	!.
convertInAntecedent(Env,rn(AX,S1,_O1),MC1,MC2,
 	            some(R,D),X,HYPS,AB,CALLS,and([PT2,PT1]),(EqLiteral, onceOrMore((Body, ground(Y,true))))) :-
	/* construct equational literal */
	constructEqCall(Env,rn(AX,_RN1,S1,_O2),MC1,MC2,Y,_FF,R,X,
			HYPS,AB,CALLS,PT2,EqLiteral),
	convertInAntecedent(Env,rn(AX,_S2,_O3),MC1,MC2,D,Y,
			    HYPS,AB,CALLS,PT1,Body),
	!.
convertInAntecedent(Env,rn(AX,_S,_O1),bodyMC(MS1),headMC(MS2),
	            atleast(N,R),X,HYPS,AB,CALLS,PT1,Body) :-
	% construct equational literal
	constructSolveConMark(rn(AX,_RN1,_S1,_O2),MS2,_FF1,R,X,'>=',N,
			 HYPS,AB,CALLS,Mark),
	Body = solveConstraint(Env,MS1,(card,app((_FF2:R),X),'>=',N),_,
			       hyp(HYPS),ab(AB),call([Mark|CALLS]),PT1),
	!.
convertInAntecedent(Env,rn(AX,_S,_O),bodyMC(MS1),headMC(MS2),
	            atmost(N,R),X,HYPS,AB,CALLS,PT1,Body) :-
	/* construct right term */
        constructSolveConMark(rn(AX,_RN1,_S1,_O1),MS2,_FF1,R,X,'=<',N,
			 HYPS,AB,CALLS,Mark),
	Body = solveConstraint(Env,MS1,(card,app((_FF2:R),X),'=<',N),_,
			       hyp(HYPS),ab(AB),call([Mark|CALLS]),PT1),
	!.
convertInAntecedent(Env,rn(AX,S1,_O),bodyMC(MSnew),headMC(MSold),
	            b(MOp,P1,D),X,HYPS,AB,CALLS,PT1,InHead) :-
	/* construct right term */
	gensym(wp,WP),
	genagent(P1,skolemize,P),
	MS1 = app(WP:m(MOp,P),MSnew),
        constructMLCall(Env,rn(AX,_RN1,S1,_O1),bodyMC(MS1),headMC(MSold),
	                D,X,HYPS,AB,CALLS,PT1,InHead),
	!.
convertInAntecedent(Env,rn(AX,S1,_O),bodyMC(MSnew),headMC(MSold),
	            bc(MOp,C,D),X,HYPS,AB,CALLS,and([PT1,PT2]),(InHead, Body)) :-
	/* construct right term */
	gensym(wp,WP),
	genagent(P1,skolemize,P),
	MS1 = app(WP:m(MOp,P),MSnew),
        constructMLCall(Env,rn(AX,_RN1,S1,_O1),bodyMC(MS1),headMC(MSold),
	                D,X,HYPS,AB,CALLS,PT1,InHead),
	convertInAntecedent(Env,rn(AX,_RN2,_S2),bodyMC(MSold),headMC(MSold),
			    C,P,HYPS,AB,CALLS,PT2,Body),
	!.
convertInAntecedent(Env,rn(AX,S1,_O),bodyMC(MSnew),headMC(MSold),
	            d(MOp,P1,D),X,HYPS,AB,CALLS,PT1,InHead) :-
	/* construct right term */
        genagent(P1,free,P),
        MS1 = app(_FF:m(MOp,P),MSnew),
        constructMLCall(Env,rn(AX,_RN1,S1,_O1),bodyMC(MS1),headMC(MSold),
	                D,X,HYPS,AB,CALLS,PT1,InHead),
	!.
convertInAntecedent(Env,rn(AX,S1,_O),bodyMC(MSnew),headMC(MSold),
	            dc(MOp,C,D),X,HYPS,AB,CALLS,and([PT1,PT2]),(InHead, Body)) :-
	/* construct right term */
        genagent(P1,free,P),
        MS1 = app(_FF:m(MOp,P),MSnew),
        constructMLCall(Env,rn(AX,_RN1,S1,_O1),bodyMC(MS1),headMC(MSold),
	                D,X,HYPS,AB,CALLS,PT1,InHead),
	convertInAntecedent(Env,rn(AX,_RN2,_S2),bodyMC(MSold),headMC(MSold),
			    C,P,HYPS,AB,CALLS,PT2,Body),
	!.
convertInAntecedent(Env,rn(AX,S,_O),MC1,MC2,D,X,HYPS,AB,CALLS,PT1,InHead) :-
	CON = X,
	constructMLCall(Env,rn(AX,_RN1,S,_O1),MC1,MC2,
	                D,CON,HYPS,AB,CALLS,PT1,InHead),
	!.

convertInAntecedentList(_Env,_,_,_,[],_X,_HYPS,_AB,_CALLS,[],[]) :-
	!.
convertInAntecedentList(Env,Name,MC1,MC2,[NCT],X,HYPS,AB,CALLS,[PT1],[INCT]) :-
	convertInAntecedent(Env,Name,MC1,MC2,NCT,X,HYPS,AB,CALLS,PT1,INCT),
	!.
convertInAntecedentList(Env,Name,MC1,MC2,[NCT|NCTs],X,
                        HYPS,AB,CALLS,[PT1|PTL],[INCT|INCTs]) :-
	convertInAntecedent(Env,Name,MC1,MC2,NCT,X,HYPS,AB,CALLS,PT1,INCT),
	convertInAntecedentList(Env,Name,MC1,MC2,NCTs,X,
				HYPS,AB,CALLS,PTL,INCTs).


/***********************************************************************
 *
 * convertInConsequence(Env,+ModalSequence,+ConceptTerm,-X,
 *               -Hypotheses, -CallStack, +AxiomName,
 *               -InLiteral)
 *
 */

convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,D,X,HYPS,AB,CALLS,PT1,InHead) :-
	(var(D) ; atomic(D)),
	!,
	typeOfDefinition(Env,MS,D,S2),
	constructKBHead(Env,Pr,rn(AX,RN,S2,O),W1,D,X,HYPS,AB,CALLS,PT1,InHead).
convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,some(R,D),X,
                     HYPS,AB,CALLS,PT1,(EqLiteral, InHead)) :-
	% construct equational literal
	gensymbol(skolem,[X,Y],SF),
	constructEqCall(Env,rn(AX,_RN2,_S2,_O2),bodyMC(W1),headMC(W1),
	                Y,SF,R,X,HYPS,AB,CALLS,PT2,EqLiteral),
	typeOfDefinition(Env,MS,D,S2),
	convertInConsequence(Env,Pr,rn(AX,RN,S2,O),MS,W1,D,Y,HYPS,AB,CALLS,
                             and([PT1,PT2]),InHead),
	!.
convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,all(R,D),X,
                     HYPS,AB,CALLS,PT1,((EqCall, ground(Y,true)), InHead)) :-
	% construct equation literal
	constructEqCall(Env,rn(AX,_RN2,_S2,_O2),bodyMC(W1),headMC(W1),
	                Y,_FF,R,X,HYPS,AB,CALLS,PT2,EqCall),
	typeOfDefinition(Env,MS,D,S2),
	convertInConsequence(Env,Pr,rn(AX,RN,S2,O),MS,W1,D,Y,HYPS,AB,CALLS,
                             and([PT1,PT2]),InHead),
	!.
convertInConsequence(Env,_Pr,Name,_MS,W1,atleast(N,R),X,
                     HYPS,AB,CALLS,PT1,InHead) :-
	/* construct role term */
        constructConHead(Env,Name,W1,_FF,R,X,'>=',N,HYPS,AB,CALLS,PT1,InHead),
	!.
convertInConsequence(Env,_Pr,Name,_MS,W1,atmost(N,R),X,HYPS,AB,CALLS,PT1,InHead) :-
	/* construct role term */
        constructConHead(Env,Name,W1,_FF,R,X,'=<',N,HYPS,AB,CALLS,PT1,InHead),
	!.
convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,not(D),X,
                     HYPS,AB,CALLS,PT1,InHead) :-
	typeOfDefinition(Env,MS,D,S2),
	constructKBHead(Env,Pr,rn(AX,RN,S2,O),W1,not(D),X,
			HYPS,AB,CALLS,PT1,InHead),
	!.
convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,naf(D),X,
                     HYPS,AB,CALLS,PT1,InHead) :-
	% in the consequence not and naf have the same meaning
	typeOfDefinition(Env,MS,D,S2),
	constructKBHead(Env,Pr,rn(AX,RN,S2,O),W1,not(D),X,
			HYPS,AB,CALLS,PT1,InHead),
	!.
convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,set(Set1),X,
                     HYPS,AB,CALLS,PT1,InHead) :-
	typeOfDefinition(Env,MS,D,S2),
	constructKBHead(Env,Pr,rn(AX,RN,S2,O),W1,set(Set1),X,
			HYPS,AB,CALLS,PT1,InHead),
	!.
%convertInConsequence(Env,rn(AX,RN,_S,O),MS,W1,b(MOp,P,D),X,
%                      HYPS,AB,CALLS,PT1,InHead) :-
%	gensym(wp,WP),
%	MS1 = app(WP:m(MOp,P),W1),
%	typeOfDefinition(Env,MS,D,S2),
%	constructMLHead(Env,rn(AX,RN,S2,O),MS1,D,X,HYPS,AB,CALLS,PT1,InHead),
%	!.
%convertInConsequence(Env,rn(AX,RN,_S,O),MS,W1,d(MOp,P,D),X,HYPS,CALLS,PT1,InHead) :-
%	MS1 = app(WP:m(MOp,P),W1),
%	typeOfDefinition(Env,MS,D,S2),
%	constructMLHead(Env,rn(AX,RN,S2,O),MS1,D,X,HYPS,AB,CALLS,PT1,InHead),
%	!.
convertInConsequence(Env,Pr,rn(AX,RN,_S,O),MS,W1,D,X,HYPS,AB,CALLS,PT1,InHead) :-
	/* add loop check to control list */
        CON = X,
	typeOfDefinition(Env,MS,D,S2),
	constructKBHead(Env,Pr,rn(AX,RN,S2,O),W1,D,CON,HYPS,AB,CALLS,PT1,InHead).

convertInConsequenceList(_Env,_Pr,_Name,_MS,[],_X,_HYPS,_AB,_CALLS,no,[]) :-
	!.
convertInConsequenceList(Env,Pr,Name,MS,[NCT],X,HYPS,AB,CALLS,[INCT]) :-
	convertInConsequence(Env,Pr,Name,MS,NCT,X,HYPS,AB,CALLS,INCT),
	!.
convertInConsequenceList(Env,Pr,Name,MS,[NCT|NCTs],X,
                         HYPS,AB,CALLS,[INCT|INCTs]) :-
	convertInConsequence(Env,Pr,Name,MS,NCT,X,HYPS,AB,CALLS,INCT),
	convertInConsequenceList(Env,Pr,Name,MS,NCTs,X,HYPS,AB,CALLS,INCTs).

/***********************************************************************
 *
 * convert_loop(LoopTerm,+CALLS,+Constraint,-CALLS)
 *
 */

convert_loop(no,CALLS,_,CALLS).
convert_loop(_,CALLS,CON,[CON|CALLS]).

convertToGoal(Env,RN,MS1,CN,X,HYPS,AB,CALLS,PT,G) :-
	convertMS(negative,Env,[[],true],MS1,[],[W1,G1],_),
	getQuery(Env,W1,CN,X,PT,G),
%	G = call((in(Env,RN,modal(W1),CN,X,hyp(HYPS),ab(AB),call(CALLS),PT), G1)),
	!.

	
nongeneric(X) :-
	var(X),
	!.
nongeneric(aaa) :-
	!,
	fail.
nongeneric(_) :-
	!.


ground(T,Result) :-
	var(T),
	!,
	Result = false.
ground(T,Result) :-
	atomic(T),
	!,
	Result = true.
ground(T,Result) :-
	T =.. [F|Args],
	map(ground,Args,Results),
	member(false,Results),
	!,
	Result = false.
ground(T,true) :-
	!.
/**********************************************************************
 *
 * @(#) tellRole.pl 1.8@(#)
 *
 */

/***********************************************************************
 *
 * assertRoleLInR(Env,+MS,+RN,+RT,+AN)
 *
 */

assertRoleLInR(Env,MS,R1,inverse(R2),AN) :-
	!,
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN),
	ruleName(AN,RN,user,lInR,Name),
	constructEqHead(Env,Name,W1,X,inverse(F),R2,app((F:R1),X),HYPS,AB,CALLS,true,EqLiteral1), 
%	assertaRE((EqLiteral1 :- G1)),
	constructEqHead(Env,Name,W1,X,F,R2,app((inverse(F):R1),X),HYPS,AB,CALLS,true,EqLiteral2), 
%	assertaRE((EqLiteral2 :- G1)),
	gensym(rule,RN3),
	constructEqHead(Env,rn(AN,RN3,user,rInL),W1,X,inverse(F),inverse(R2),
			Y,HYPS,AB,CALLS,PT1,EqLiteral3),
	constructEqCall(Env,rn(AN,RN3,_S3,_O3),bodyMC(W1),headMC(W1),X,F,R1,Y,
	                HYPS,AB,CALLS,PT1,EqLiteral4),
%	assertaRE((EqLiteral3 :- checkCallStack(CALLS,true), (call(G1), EqLiteral4))),
	gensym(rule,RN4),
	constructEqHead(Env,rn(AN,RN4,user,rInL),W1,Y,inverse(F1),R2,X,HYPS,AB,CALLS,
			PT2,EqLiteral5),
	constructEqMark(rn(AN,RN4,_S3,_O3),W1,X,F1,R1,Y,HYPS,AB,CALLS,EqMark2),
	constructEqCall(Env,rn(AN,RN4,_S3,_O3),bodyMC(W1),headMC(W1),
			X,F1,R1,Y,HYPS,AB,CALLS,PT2,EqLiteral6),
	assertaRE((EqLiteral5 :- checkCallStack(CALLS,EqMark2), (call(G1), EqLiteral6))),
	true.
assertRoleLInR(Env,MS,R1,and(RL),AN) :-
	!,
	assertAndConstraintLInR(Env,MS,R1,and(RL),AN),
        assertAndRoleLInR(Env,MS,R1,and(RL),AN).
assertRoleLInR(Env,MS,R1,restr(R2,C),AN) :-
	!,
	assertRoleLInRRestr1(Env,MS,R1,restr(R2,C),AN),
	assertRoleLInRRestr3(Env,MS,R1,restr(R2,C),AN),
	getComplementRole(Env,MS,R1,restr(R2,C),R3,restr(R2,CNF)),
	assertRoleLInRRestr4(Env,MS,R1,restr(R2,C),R3,restr(R2,CNF),AN).
assertRoleLInR(Env,MS,R1,R2,AN) :-
	!,
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensymbol(skolem,[X,Y],SF1),
	gensym(rule,RN1),
	ruleName(AN,RN1,user,lInR,Name1),
	constructEqHead(Env,Name1,W1,Y,SF1,R2,X,HYPS,AB,CALLS,PT1,EqLiteral2),
	constructEqMark(rn(AN,RN1,_S2,_O2),W1,Y,SF1,R2,X,HYPS,AB,CALLS,EqMark2),
	constructEqCall(Env,rn(AN,RN1,_S3,_O3),bodyMC(W1),headMC(W1),Y,_FF,R1,X,HYPS,AB,CALLS,PT1,EqLiteral1),
	assertaRE((EqLiteral2 :- (checkCallStack(CALLS,EqMark2), (call(G1), EqLiteral1)))),
	gensymbol(skolem,[X,Y],SF2),
	gensym(rule,RN2),
	constructConHead(Env,rn(AN,RN2,user,lInR),W1,SF2,R2,X,'>=',N,
                         HYPS,AB,CALLS,PT1,C2),
	constructConMark(C2,Mark2),
	constructSolveConMark(rn(AN,RN2,_S4,_O4),W1,_FF3,R1,X,'>=',N,HYPS,AB,CALLS,Mark1),
	C1 = solveConstraint(Env,W1,(card,app((_FF:R1),X),'>=',N),_,hyp(HYPS),ab(AB),call([Mark1|CALLS]),PT1),
	assertaRE((C2 :- (checkCallStack(CALLS,Mark2), (call(G1), C1)))),
	gensym(rule,RN5),
	gensym(skolem,SF3),
	constructConHead(Env,rn(AN,RN5,user,lInR),W1,SF3,R1,X,'=<',N,
                         HYPS,AB,CALLS,PT1,C4),
	constructConMark(C4,Mark4),
	constructSolveConMark(rn(AN,RN5,_S6,_O6),W1,_FF4,R2,X,'=<',N,HYPS,AB,CALLS,Mark5),
	C5 = solveConstraint(Env,MS,(card,app((_FF2:R2),X),'=<',N),_,hyp(HYPS),ab(AB),call([Mark5|CALLS]),PT1),
	assertaRE((C4 :- (checkCallStack(CALLS,Mark4), (call(G1), C5)))).
	
/**********************************************************************
 *
 * assertRoleLInRRestr1(+MS,+R1,restr(+R2,+C),+AN)
 * handles the case R1 is included in restr(R2,C).
 * asserts the constraints and membership clauses describing the 
 * relationship of R1 and R2.
 *
 */

assertRoleLInRRestr1(Env,MS,R1,restr(R2,C),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN1),
	typeOfDefinition(Env,MS,C,S1),
	constructMLHead(Env,rn(AN,RN1,S1,lInR),W1,C,Y,HYPS,AB,CALLS,PT1,InHead),
	constructMLMark(InHead,InMark),
% uh (06.04.94)
% adding InMark to the call stack is wrong
%	constructEqCall(Env,rn(AN,RN1,_S2,_O2),bodyMC(W1),headMC(W1),
%	                Y,F,R1,X,HYPS,AB,[InMark|CALLS],PT1,EqLiteral11),
% new version:
	constructEqCall(Env,rn(AN,RN1,_S2,_O2),bodyMC(W1),headMC(W1),
	                Y,F,R1,X,HYPS,AB,[InMark|CALLS],PT1,EqLiteral11),
	assertaRE((InHead :- (checkCallStack(CALLS,InMark), (call(G1), (EqLiteral11, ground(Y,true)))))),
	gensym(skolem,SF),
	gensym(rule,RN2),
	typeOfDefinition(Env,MS,C,S2),
	constructEqHead(Env,rn(AN,RN2,S2,lInR),W1,Y,SF,R2,X,
                        HYPS,AB,CALLS,PT2,EqLiteral2),
	constructEqMark(rn(AN,RN2,_S3,_O3),W1,Y,SF,R2,X,HYPS,AB,CALLS,EqMark2),
% uh (06.04.94)
% adding EqMark2 to the call stack is wrong
%	constructEqCall(Env,rn(AN,RN2,_S4,_O4),bodyMC(W1),headMC(W1),
%                        Y,F,R1,X,HYPS,AB,[EqMark2|CALLS],PT2,EqLiteral21),
% new version:
	constructEqCall(Env,rn(AN,RN2,_S4,_O4),bodyMC(W1),headMC(W1),
                        Y,F,R1,X,HYPS,AB,CALLS,PT2,EqLiteral21),
	assertaRE((EqLiteral2 :- (checkCallStack(CALLS,EqMark2), (call(G1), EqLiteral21)))),
	!.


assertRoleLInRRestr3(Env,MS,R1,restr(R2,C),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN1),
	typeOfDefinition(Env,MS,C,S1),
	constructConHead(Env,rn(AN,RN1,S1,lInR),W1,G,R2,X,'>=',N,
	                 HYPS,AB,CALLS,and([PT2,PT4]),C1),
	constructConMark(C1,Mark1),
	constructSolveConMark(rn(AN,_RN2,_S2,_O2),
                         W1,_FF1,R1,X,'>=',N,HYPS,AB,CALLS,Mark2),
	C2 = solveConstraint(Env,W1,(card,app((F:R1),X),'>=',N),_,hyp(HYPS),ab(AB),call([Mark2|CALLS]),PT2),
	assertaRE((C1 :- (checkCallStack(CALLS,Mark1), (call(G1), C2)))),
	gensym(rule,RN3),
	constructConHead(Env,rn(AN,RN3,S1,lInR),W1,G,R1,X,'=<',N,
                         HYPS,AB,CALLS,PT4,C3),
	constructConMark(C3,Mark3),
	constructSolveConMark(rn(AN,RN3,_S4,_O4),
                         W1,_FF3,R2,X,'=<',N,HYPS,AB,CALLS,Mark4),
	C4 = solveConstraint(Env,W1,(card,app((F:R2),X),'=<',N),_,hyp(HYPS),ab(AB),call([Mark4|CALLS]),PT4),
	assertaRE((C3 :- (checkCallStack(CALLS,Mark3), (call(G1), C4)))).


/**********************************************************************
 *
 * assertRoleLInRRestr2(Env,+MS,+R1,restr(+R2,+C1),
 *                          +R3,restr(+R2,+C2),+AN)
 * handles the case R1 is included in restr(R2,C).
 * asserts the constraints describing the relationship between 
 * R1 = restr(R2,C1), R3 = restr(R2,not(C1)) and R2.
 *
 */

assertRoleLInRRestr4(Env,MS,R1,restr(R2,_C),R3,restr(R2,_CNF),AN1) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN),
	constructConHead(Env,rn(AN1,RN,user,lInR),W1,_FF,R1,X,'=<',N1,
	                 HYPS,AB,CALLS,and([PT2,PT3]),C1),
	constructConMark(C1,Mark1),
	constructSolveConMark(rn(AN1,RN,_S2,_O2),W1,FF1,R2,X,'=<',N2,HYPS,AB,CALLS,Mark2),
	C2 = solveConstraint(Env,W1,(card,app((FF1:R2),X),'=<',N2),_,hyp(HYPS),ab(AB),call([Mark2|CALLS]),PT2),
	constructSolveConMark(rn(AN1,RN,_S3,_O3),W1,FF2,R3,X,'>=',N3,HYPS,AB,CALLS,Mark3),
	C3 = solveConstraint(Env,W1,(card,app((FF2:R3),X),'>=',N3),_,hyp(HYPS),ab(AB),call([Mark3|CALLS]),PT3),
	assertaRE((C1 :- (checkCallStack(CALLS,Mark1), (call(G1), (C2, (C3, (subtractRestrictions(N2,N3,M), comparisonForRestriction('=<',M,N1)))))))),
	!.




/***********************************************************************
 *
 * assertAndRoleLInR(+MS,+Lit,+X,+Y,+RT,+CALLS,+AN)
 *
 */

assertAndRoleLInR(_,_MS,_,and([]),_AN) :-
	!.
assertAndRoleLInR(Env,MS,R1,and([R2|RL]),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(skolem,SF),
	gensym(rule,RN),
	constructEqHead(Env,rn(AN,RN,user,lInR),
                        W1,Y,SF,R2,X,HYPS,AB,CALLS,PT1,EqLiteral2),
	constructEqMark(rn(AN,RN,_S1,_O1),W1,Y,SF,R2,X,HYPS,AB,CALLS,EqMark2),
% uh (06.04.94)
% adding EqMark2 to the call stack is wrong
%	constructEqCall(Env,rn(AN,RN,_S2,_O2),bodyMC(W1),headMC(W1),Y,_F,R1,X,
%	                HYPS,AB,[EqMark2|CALLS],PT1,EqLiteral1),
% new version:
	constructEqCall(Env,rn(AN,RN,_S2,_O2),bodyMC(W1),headMC(W1),Y,_F,R1,X,
	                HYPS,AB,CALLS,PT1,EqLiteral1),
	assertaRE((EqLiteral2 :- (checkCallStack(CALLS,EqMark2), (call(G1), EqLiteral1)))),
	assertAndRoleLInR(Env,MS,R1,and(RL),AN).

/***********************************************************************
 *
 * assertAndConstraintLInR(+MS,+RN,+RT,+AN)
 *
 */

assertAndConstraintLInR(_,_MS,_,and([]),_AN) :-
	!.
assertAndConstraintLInR(Env,MS,R1,and([R2|RL]),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN),
	ruleName(AN,RN,user,lInR,Name),
	constructConHead(Env,Name,W1,_FF,R1,X,Rel,N,HYPS,AB,CALLS,PT2,C1),
	constructConMark(C1,Mark1),
	constructSolveConMark(rn(AN,RN,_S1,_O1),W1,_FF2,R2,X,Rel,N,HYPS,AB,CALLS,Mark2),	
	gensymbol(skolem,[X],SF),
	C2 = solveConstraint(Env,W1,(card,app((SF:R2),X),Rel,N),_,hyp(HYPS),ab(AB),call([Mark2|CALLS]),PT2),
	assertaRE((C1 :- checkCallStack(CALLS,Mark1), (call(G1), C2))),
	assertAndConstraintLInR(Env,MS,R1,and(RL),AN).

/***********************************************************************
 *
 * assertAndConstraintRInL(+MS,+RN,+RT,+AN)
 *
 */

assertAndConstraintRInL(_,_MS,_,and([]),_AN) :-
	!.
assertAndConstraintRInL(Env,MS,R1,and([R2|RL]),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN),
	constructConHead(Env,rn(AN,RN,user,rInL),W1,_FF,R2,X,'>=',N,
	                 HYPS,AB,CALLS,PT2,C1),
	constructConMark(C1,Mark1),
	constructSolveConMark(rn(AN,RN,_S1,_O1),W1,_FF1,R1,X,'>=',N,HYPS,AB,CALLS,Mark2),
	gensymbol(skolem,[X],SF),
	C2 = solveConstraint(Env,W1,(card,app((SF:R1),X),'>=',N),_,hyp(HYPS),ab(AB),call([Mark2|CALLS]),PT2),
	assertaRE((C1 :- checkCallStack(CALLS,Mark1), (call(G1), C2))),
	assertAndConstraintRInL(Env,MS,R1,and(RL),AN).


/***********************************************************************
 *
 * assertRoleRInL(Env,+MS,+RN,+RT,+AN)
 *
 */

assertRoleRInL(Env,MS,R1,inverse(R2),_AN) :-
	!,
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN1),
	constructEqHead(Env,rn(AN,RN1,user,rInL),W1,X,F,R1,
                        app((inverse(F):R2),X),HYPS,AB,CALLS,
			true,EqLiteral1),
%	assertaRE((EqLiteral1 :- call(G1))),
	gensym(rule,RN2),
	constructEqHead(Env,rn(AN,RN2,user,rInL),
                        W1,X,inverse(F),R1,app((F:R2),X),HYPS,AB,CALLS,
			true,EqLiteral2),
%	assertaRE((EqLiteral2 :- call(G1))),
	gensym(rule,RN3),
	constructEqHead(Env,rn(AN,RN3,user,rInL),W1,Y,inverse(F),inverse(R2),
			X,HYPS,AB,CALLS,PT1,EqLiteral3),
	constructEqCall(Env,rn(AN,RN3,_S3,_O3),bodyMC(W1),headMC(W1),X,F,R1,Y,
	                HYPS,AB,CALLS,PT1,EqLiteral4),
%	assertaRE((EqLiteral3 :- checkCallStack(CALLS,true), (call(G1), EqLiteral4))),
	gensym(rule,RN4),
	constructEqHead(Env,rn(AN,RN4,user,rInL),W1,Y,inverse(F1),R1,X,HYPS,AB,CALLS,
			PT2,EqLiteral5),
	
        constructEqMark(rn(AN,RN4,_S3,_O3),W1,X,F1,R2,Y,HYPS,AB,CALLS,EqMark2),
	constructEqCall(Env,rn(AN,RN4,_S3,_O3),bodyMC(W1),headMC(W1),
			X,F1,R2,Y,HYPS,AB,CALLS,PT2,EqLiteral6),
	assertaRE((EqLiteral5 :- checkCallStack(CALLS,EqMark2), (call(G1), EqLiteral6))).
assertRoleRInL(Env,MS,R1,restr(R2,C), AN) :-
	!,
	assertRoleRInLRestr1(Env,MS,R1,restr(R2,C),AN),
	getComplementRole(Env,MS,R1,restr(R2,C),R3,restr(R2,CNF)),
	assertRoleRInLRestr2(Env,MS,R1,restr(R2,C),R3,restr(R2,CNF),AN),
	assertRoleRInLRestr3(Env,MS,R1,restr(R2,C),AN),
	assertRoleRInLRestr4(Env,MS,R1,restr(R2,C),R3,restr(R2,CNF),AN).
assertRoleRInL(Env,MS,R1,and(RL),AN) :-
	!,
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensymbol(skolem,[X,Y],SF),
	gensym(rule,RN1),
	roleBody(Env,W1,and(RL),X,Y,HYPS,AB,CALLS,AN,Body,PTL),
	constructEqHead(Env,rn(AN,RN1,user,rInL),
                        W1,Y,SF,R1,X,HYPS,AB,CALLS,and([PTL]),EqLiteral1),
	constructEqMark(rn(AN,RN1,_S2,_O2),W1,Y,SF,R1,X,HYPS,AB,CALLS,EqMark1),
	assertaRE((EqLiteral1 :- (checkCallStack(CALLS,EqMark1), (call(G1), Body)))),
	assertAndConstraintRInL(Env,MS,R1,and(RL),AN).
assertRoleRInL(Env,MS,R1,R2,AN) :-
	!,
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensymbol(skolem,[X,Y],SF),
	gensym(rule,RN1),
	constructEqHead(Env,rn(AN,RN1,user,rInL),W1,X,SF,R1,Y,
	                HYPS,AB,CALLS,PT1,EqLiteral1),
	constructEqMark(rn(AN,RN1,_S2,_O2),W1,X,SF,R1,Y,HYPS,AB,CALLS,EqMark1),
	constructEqCall(Env,rn(AN,RN1,_S3,_O3),bodyMC(W1),headMC(W1),X,_F,R2,Y,
	                HYPS,AB,CALLS,PT1,EqLiteral2),
	assertaRE((EqLiteral1 :- (checkCallStack(CALLS,EqMark1), (call(G1), EqLiteral2)))),
	gensym(rule,RN2),
	constructConHead(Env,rn(AN,RN2,user,rInL),W1,_FF5,R1,X,'>=',N,
	                 HYPS,AB,CALLS,PT1,C2),
	constructConMark(C2,Mark2),
	constructSolveConMark(rn(AN,RN2,_S4,_O4),W1,_FF3,R2,X,'>=',N,HYPS,AB,CALLS,Mark1),
	C1 = solveConstraint(Env,W1,(card,app((_FF:R2),X),'>=',N),_,hyp(HYPS),ab(AB),call([Mark1|CALLS]),PT1),
	assertaRE((C2 :- (checkCallStack(CALLS,Mark2), (call(G1), C1)))),
	gensym(rule,RN5),
	gensym(skolem,SF3),
	constructConHead(Env,rn(AN,RN5,user,rInL),W1,SF3,R2,X,'=<',N,
	                 HYPS,AB,CALLS,PT5,C4),
	constructConMark(C4,Mark4),
	constructSolveConMark(rn(AN,RN5,_S6,_O6),W1,_FF4,R1,X,'=<',N,HYPS,AB,CALLS,Mark5),
	C5 = solveConstraint(Env,W1,(card,app((_FF2:R1),X),'=<',N),_,hyp(HYPS),ab(AB),call([Mark5|CALLS]),PT5),
	assertaRE((C4 :- (checkCallStack(CALLS,Mark4), (call(G1), C5)))).

/**********************************************************************
 *
 * getComplementRole(+MS,restr(+R2,C),-R3,restr(+R2,-CNF))
 * CNF is the normalform of not(C).
 * If there is already a role atom_codes R for restr(R2,CNF) then R3
 * will be instantiated with R.
 * If there is no role atom_codes for restr(R2,CNF) then a role atom_codes R
 * is generated, clauses for R will be provided, and R3 will be
 * instantiated with R.
 *
 */
 
getComplementRole(Env,MS,_R1,restr(R2,C),R3,restr(R2,CNF)) :-
	negate(C,CN),
	convertToLogicalCNF(CN,CNF),
	roleEqualSets(Env,system,MS,R3,restr(R2,CNF),_AX),
	!.
getComplementRole(Env,MS,_R1,restr(R2,C),R3,restr(R2,CNF)) :-
	gensym(role,R3),
	negate(C,CN),
	convertToLogicalCNF(CN,CNF),
	gensym(axiom,AN),
	assertaRE(roleEqualSets(Env,system,MS,R3,restr(R2,CNF),AN)),
	assertRoleLInRRestr1(Env,MS,R3,restr(R2,CNF),AN),
	assertRoleLInRRestr3(Env,MS,R3,restr(R2,CNF),AN),
	assertRoleRInLRestr1(Env,MS,R3,restr(R2,CNF),AN),
%	assertRoleRInLRestr2(Env,MS,R1,restr(R2,CNF),R3,restr(R2,C),AN),
	assertRoleRInLRestr3(Env,MS,R3,restr(R2,CNF),AN),
	!.
	

/**********************************************************************
 *
 * assertRoleRInLRestr1(+MS,+R1,restr(+R2,C),+AN)
 * handles the case restr(R2,C) is included in R1.
 * asserts the constraints and membership clauses describing the 
 * relationship of R1 and R2.
 *
 */

assertRoleRInLRestr1(Env,MS,R1,restr(R2,C),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensymbol(skolem,[X,Y],SF),
	gensym(rule,RN),
	constructEqHead(Env,rn(AN,RN,user,rInL),
                        W1,Y,SF,R1,X,HYPS,AB,CALLS,and([PTEq2,PTIn]),EqLiteral1),
	constructEqMark(rn(AN,RN,_S1,_O1),
                        W1,Y,SF,R1,X,HYPS,AB,CALLS,EqMark1),
	constructEqCall(Env,rn(AN,RN,_S2,_O2),
                        bodyMC(W1),headMC(W1),Y,_FF,R2,X,HYPS,AB,CALLS,PTEq2,EqLiteral2),
	constructMLCall(Env,rn(AN,RN,_S3,_O3),
                        bodyMC(W1),headMC(W1),C,Y,HYPS,AB,CALLS,PTIn,InHead),
	assertaRE((EqLiteral1 :- (checkCallStack(CALLS,EqMark1), (call(G1), (EqLiteral2, (ground(Y,true), onceOrMore(InHead))))))).


assertRoleRInLRestr2(Env,MS,R1,restr(R2,_C),R3,restr(R2,_CNF),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN),
	constructConHead(Env,rn(AN,RN,user,rInL),W1,_FF,R1,X,'>=',N1,
	                 HYPS,AB,CALLS,and([PT2,PT3]),D1),
	constructConMark(D1,Mark1),
	constructSolveConMark(rn(AN,RN,_S1,_O1),W1,_FF2,R2,X,'>=',_N2,HYPS,AB,CALLS,Mark2),
	D2 = solveConstraint(Env,W1,(card,app((_FF3:R2),X),'>=',N2),_,hyp(HYPS),ab(AB),call([Mark2|CALLS]),PT2),
	constructSolveConMark(rn(AN,RN,_S3,_O3),W1,_FF4,R3,X,'=<',_N3,HYPS,AB,CALLS,Mark3),
	D3 = solveConstraint(Env,W1,(card,app((_FF5:R3),X),'=<',N3),_,hyp(HYPS),ab(AB),call([Mark3|CALLS]),PT3),
	assertaRE((D1 :- (checkCallStack(CALLS,Mark1), (call(G1), (D2, (D3, (subtractRestrictions(N2,N3,M), comparisonForRestriction('>=',M,N1)))))))),
	!.
	
	
assertRoleRInLRestr3(Env,MS,R1,restr(R2,C),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	negate(C,CN),
	convertToLogicalCNF(CN,CNF),
	gensym(rule,RN),
	typeOfDefinition(Env,W1,CNF,S),
	constructMLHead(Env,rn(AN,RN,S,user),
                        W1,CNF,Y,HYPS,AB,CALLS,and([PT1,PT2]),InHead),
	constructMLMark(InHead,Mark),
%	constructConMark(rn(AN,RN,_S2,_O2),W1,_FF2,R2,X,'>=',_N2,
%	                 HYPS,CALLS,Mark2),
%	D2 = solveConstraint(Env,MS,(card,app((_FF4:R2),X),'>=',N2),(M2,L2),
%	                     hyp(HYPS),ab(AB),call([Mark2|CALLS]),PT3),
	constructSolveConMark(rn(AN,RN,_S1,_O1),W1,_FF1,R1,X,'=<',_N1,
	                 HYPS,AB,CALLS,Mark1),
	D1 = solveConstraint(Env,W1,(card,app((_FF3:R1),X),'=<',N1),(M1,L1),
	                     hyp(HYPS),ab(AB),call([Mark1|CALLS]),PT2),
	constructEqCall(Env,rn(AN,RN,_S3,_O3),bodyMC(W1),headMC(W1),
                        Y,_FF,R2,X,HYPS,AB,CALLS,PT1,EqLiteral2),
% Removed this rule for test purposes
% uh 03.10.92
%	assertaRE((InHead :- (checkCallStack(CALLS,Mark), (call(G1), (EqLiteral2, (ground(Y,true), (D1, (not(member((Y,_),L1)), N1 = M1)))))))),
	!.

assertRoleRInLRestr4(Env,MS,R1,restr(R2,_C),R3,restr(R2,_CNF),AN) :-
	convertMS(positive,Env,[[],true],MS,[],[W1,G1],_),
	gensym(rule,RN),
	constructConHead(Env,rn(AN,RN,user,rInL),W1,_FF2,R2,X,Rel,N2,
	                 HYPS,AB,CALLS,and([PT1,PT3]),D2),
	constructConMark(D2,Mark2),
	constructSolveConMark(rn(AN,RN,_S1,_O1),W1,_FF1,R1,X,Rel,_N1,
	                 HYPS,AB,CALLS,Mark1),
	D1 = solveConstraint(Env,W1,(card,app((_FF4:R1),X),Rel,N1),_,
	                     hyp(HYPS),ab(AB),call([Mark1|CALLS]),PT1),
	constructSolveConMark(rn(AN,RN,_S3,_O3),W1,_FF3,R3,X,Rel,_N3,
	                 HYPS,AB,CALLS,Mark3),
	D3 = solveConstraint(Env,W1,(card,app((_FF5:R3),X),Rel,N3),_,
	                     hyp(HYPS),ab(AB),call([Mark3|CALLS]),PT3),
	assertaRE((D2 :- (checkCallStack(CALLS,Mark2), (call(G1), (D1, (D3, (addRestrictions(N1,N3,M), comparisonForRestriction(Rel,M,N2)))))))),
	!.
	

/***********************************************************************
 *
 * roleBody(+MS,+RT,+X,+Y,+CALLS,+AN,-Body)
 *
 */

roleBody(_,_MS,and([]),_X,_Y,_,_,_,_,true,[]) :- 
	!.
roleBody(Env,MS,and([R1]),X,Y,HYPS,AB,CALLS,AN,Body,[PT1]) :-
	constructEqCall(Env,rn(AN,_RN,_S1,_O1),bodyMC(MS),headMC(MS),Y,_FF,R1,X,HYPS,AB,CALLS,PT1,Body),
	!.
roleBody(Env,MS,and([R1|RL]),X,Y,HYPS,AB,CALLS,AN,(EqLiteral, Body),[PT1|PTL]) :-
	constructEqCall(Env,rn(AN,_RN1,_S1,_O1),
                        bodyMC(MS),headMC(MS),Y,_FF,R1,X,HYPS,AB,CALLS,PT1,EqLiteral),
	roleBody(Env,MS,and(RL),X,Y,HYPS,AB,CALLS,AN,Body,PTL).










/**********************************************************************
 *
 * @(#) testMotel.pl 1.6@(#)
 *
 */

testMotel :-
	testAllMotelExamples(1),
	!.

testMotel(N) :-
	testAllMotelExamples(N),
	!.

testAllMotelExamples(87) :-
	print('Test complete'), nl, nl,
	!.
testAllMotelExamples(N) :-
	initialize,
	print('Example '), print(N), nl, example(N),
	once(testMotelExample(N)),
	M is N + 1,
	testAllMotelExamples(M).

testMotelExample(1) :-	
	print('No goal for this example'), nl.
testMotelExample(2) :-
	printTime(setof(C,E^deduce(ex2,[],elementOf(mary,C),E),L1)), print(L1), nl,
	printTime(setof(D,F^deduce(ex2,[],elementOf(tom,D),F),L2)), print(L2), nl.
testMotelExample(3) :-
	tryGoal(inconsistent(ex3)),
	print('Failure expected in example 3.'), nl.
testMotelExample(4) :-
	print('No goal for this example'), nl.
testMotelExample(5) :-
	tryGoal(not(subsumes([],c1,c2))),
	tryGoal(subsumes([],c2,c1)).
testMotelExample(6) :-
	tryGoal(not(subsumes([],c1,c2))),
	tryGoal(subsumes([],c2,c1)).
testMotelExample(7) :-
	print('No goal for this example'), nl.
testMotelExample(8) :-
	tryGoal(deduce(elementOf(tom,heterosexual))).
testMotelExample(9) :-
	tryGoal(deduce(elementOf(chris,male))).
testMotelExample(10) :-
	tryGoal(deduce(elementOf(tom,c2))).
testMotelExample(11) :-
	tryGoal(inconsistent(ex11)),
	print('Failure expected in example 11.'), nl.
testMotelExample(12) :-
	tryGoal(subsumes([],c1,c2)),
	print('Failure expected in example 12.'), nl,
	tryGoal(not(subsumes([],c2,c1))),
	print('Failure expected in example 12.'), nl.
testMotelExample(13) :-
	tryGoal(subsumes([],c1,c2)).
testMotelExample(14) :-
%	initialize, print('Example 14'), nl, example(14),
%	tryGoal(subsumes([],c2,c1)),
	!.
testMotelExample(15) :-
	tryGoal(subsumes([],c2,c1)),
	print('Failure expected in example 15.'), nl.
testMotelExample(16) :-
	tryGoal(subsumes([],c2,c1)).
testMotelExample(17) :-
	tryGoal(subsumes([],c2,c1)).
testMotelExample(18) :-
	tryGoal(deduce(elementOf(mary,c4))).
testMotelExample(19) :-
	tryGoal(deduce(elementOf(amy,female))),
	print('Failure expected in example 19.'), nl.
testMotelExample(20) :-
	tryGoal(inconsistent(ex20)),
	print('Failure expected in example 20.'), nl.
testMotelExample(21) :-
	print('No goal for this example'), nl,
% 	deduce(elementOf(betty,female)),
	!.
testMotelExample(22) :-
% 	deduce(elementOf(amy,female)),
	print('No goal for this example'), nl.
testMotelExample(23) :-
% 	deduce(elementOf(amy,female))
	print('No goal for this example'), nl.
testMotelExample(24) :-
	tryGoal(deduce(elementOf(audi,c3))).
testMotelExample(25) :-
	tryGoal(not(deduce(elementOf(audi,c3)))).
testMotelExample(26) :-
	tryGoal(not(subsumes([],c1,c2))),
	tryGoal(subsumes([],c2,c1)),
	print('Failure expected in example 26.'), nl.
testMotelExample(27) :-
	tryGoal(not(subsumes([],c1,c2))),
	tryGoal(subsumes([],c2,c1)),
	print('Failure expected in example 27.'), nl.
testMotelExample(28) :-
	tryGoal(deduce([b(believe,john)],elementOf(audi,auto),_P)).
testMotelExample(29) :-
	print('No goal for this example'), nl.
testMotelExample(30) :-
	print('No goal for this example'), nl.
testMotelExample(31) :-
	tryGoal(deduce(elementOf(tom,onlyMaleChildren))).
testMotelExample(32) :-
	tryGoal(abduce(_H1,elementOf(robin,male),_E1)),
	tryGoal(abduce(_H2,elementOf(robin,female),_E2)).
testMotelExample(33) :-
	tryGoal(abduce(_H3,elementOf(nixon,dove),_E3)),
	tryGoal(abduce(_H4,elementOf(nixon,hawk),_E4)).
testMotelExample(34) :-
	tryGoal(inconsistent(ex34)).
testMotelExample(35) :-
	tryGoal(abduce(ex35,[],_H5,elementOf(john,fly),_E5)),
	tryGoal(not(abduce(ex35,[],_H8,elementOf(tweety,fly),_E8))).
testMotelExample(36) :-
	tryGoal(abduce(ex36,[],_H6,elementOf(nixon,dove),_E6)),
	tryGoal(abduce(ex36,[],_H7,elementOf(nixon,hawk),_E7)).
testMotelExample(37) :-
	print('No goal for this example'), nl.
testMotelExample(38) :-
	tryGoal(deduce(elementOf(ideaste,c2))).
testMotelExample(39) :-
	tryGoal(deduce(elementOf(lucky,female))),
	tryGoal(assert_ind(lucky,male)),
	tryGoal(consistent([])).
testMotelExample(40) :-
	tryGoal(deduce(elementOf(peter,richPerson))),
	tryGoal(assert_ind(peter,poorPerson)),
	tryGoal(consistent([])),
	tryGoal(not(subsumes(richPerson,doctor))).
testMotelExample(41) :-
	tryGoal(deduce(elementOf(tom,richPerson))),
	tryGoal(assert_ind(tom,poorPerson)),
	tryGoal(consistent([])).
testMotelExample(42) :-
	tryGoal(deduce(elementOf(audi,fourWheels))),
	tryGoal(assert_ind(audi,fiveWheels)),
	tryGoal(consistent([])).
testMotelExample(43) :-
	tryGoal(deduce(elementOf(r,red))),
	tryGoal(deduce(elementOf(r,redOrYellow))),
	tryGoal(deduce(elementOf(r,colors))).
testMotelExample(44) :-
	tryGoal(subsumes(c2,c12)),
	print('Failure expected in example 44.'), nl.
testMotelExample(45) :-
	print('No goal for this example'), nl.
testMotelExample(46) :-
	print('No goal for this example'), nl.
testMotelExample(47) :-
	tryGoal(deduce(elementOf(bmw,c3))),
	print('Failure expected in example 47.'), nl.
testMotelExample(48) :-
	print('No goal for this example'), nl.
testMotelExample(49) :-
	tryGoal(not(deduce(elementOf(p,c4)))).
testMotelExample(50) :-
	tryGoal(deduce(elementOf(peter,c0))).
testMotelExample(51) :-
	tryGoal(deduce(posInfl(a,d))),
	tryGoal(deduce(posInfl(b,d))),
	tryGoal(bagof(Y1,deduce(posInfl(a,Y1)),Y1s)),
	tryGoal(verifySolution(Y1s,[b,c,d,g])),
	tryGoal(deduce(infl(a,d,1.0))),
	tryGoal(bagof((X1,W1),deduce(infl(X1,e,W1)),X1W1Pairs)),
	tryGoal(verifySolution(X1W1Pairs,[(a,0.0),(b,-1.0),(g,1.0)])),
	tryGoal(deduce(simultInfl([a,h],d,2.0))),
	tryGoal(deduce(change(d,1.0))),
	tryGoal(bagof(X2,deduce(increase(X2)),X2s)),
	tryGoal(verifySolution(X2s,[b,c,d,g,a])).
testMotelExample(52) :-
	tryGoal(deduce(negInfl(withRebate,hasOverallCost))),
	tryGoal(deduce(posInfl(hasListPrice,hasOverallCost))),
	tryGoal(deduce(posInfl(hasCubicCapacity,hasPrice))),
	tryGoal(deduce(posInfl(hasCubicCapacity,hasOverallCost))),
	tryGoal(deduce(posInfl(hasCatConverter,hasOverallCost))),
	tryGoal(deduce(simultInfl([hasCubicCapacity,hasCatConverter],hasOverallCost,3.0))),
	tryGoal(deduce(simultInfl([hasCubicCapacity,hasCatConverter],hasMaxSpeed,-1.0))),
	tryGoal(deduce(leastInfl(hasCubicCapacity,hasMaxSpeed))),
	tryGoal(deduce(leastInfls([hasCatConverter,hasCubicCapacity],hasMaxSpeed))),
	tryGoal(deduce(maxPosInfl(hasCubicCapacity,hasOverallCost,2.0))),
	tryGoal(bagof((X1,W1),deduce(maxNegInfl(X1,hasMaxSpeed,W1)),X1W1Pairs)),
	tryGoal(verifySolution(X1W1Pairs,[(hasCatConverter,-1.0),(hasWeight,-1.0)])),
	tryGoal(bagof(X2,deduce(increase(X2)),X2s)),
	tryGoal(verifySolution(X2s,[hasFuelConsumption,hasListPrice,hasOverallCost,hasPrice,hasWeight,hasCubicCapacity])),
	tryGoal(bagof((X3,W3),(deduce(leastInfl(X3,hasMaxSpeed)),abduce(change(X3,W3),change(hasMaxSpeed,1.0))),X3W3s)),
	tryGoal(verifySolution(X3W3s,[(hasCatConverter,-1.0)])).
testMotelExample(53) :-
	print('No goal for this example'), nl.
testMotelExample(54) :-
	print('No goal for this example'), nl.
testMotelExample(55) :-
	print('No goal for this example'), nl.
testMotelExample(56) :-
	print('No goal for this example'), nl.
testMotelExample(57) :-
	print('No goal for this example'), nl.
testMotelExample(58) :-
	print('No goal for this example'), nl.
testMotelExample(59) :-
	tryGoal(sb_ask(isa(harry,parent))),
	tryGoal(sb_ask(isa(harry,person))),
	printTime(setof((X,Y),sb_ask(role(child,X,Y)),L1)), print(L1), nl,
	printTime(setof(X,sb_ask(roleDef(child,X)),L2)), print(L2), nl,
	printTime(setof((X,Y),sb_ask(roleNr('marys-child',X,Y)),L3)), print(L3), nl,
	printTime(setof(X,sb_ask(roleDefNr('marys-child',X)),L4)), print(L4), nl.
testMotelExample(60) :-
	tryGoal(deduce(ex60,[b(believe,peter)],elementOf(tom,richPerson),E)),
	tryGoal(assert_ind([b(believe,peter)],tom,not(richPerson))),
	tryGoal(inconsistent([b(believe,peter)])).
testMotelExample(61) :-
	tryGoal(deduce(elementOf(tweety,fly))),
	tryGoal(deduce(elementOf(tweety,nest))),
	tryGoal(deduce(elementOf(tweety,not(emu)))),
	tryGoal(deduce(elementOf(tweety,not(cuckoo)))),
	tryGoal(consistent([])).
testMotelExample(62) :-
	tryGoal(deduce(elementOf(tweety,fly))),
	tryGoal(deduce(elementOf(tweety,nest))),
	tryGoal(not(deduce(elementOf(tweety,not(emu))))),
	tryGoal(not(deduce(elementOf(tweety,not(cuckoo))))),
	tryGoal(not(deduce(elementOf(tweety,emu)))),
	tryGoal(not(deduce(elementOf(tweety,cuckoo)))),
	tryGoal(consistent([])).
testMotelExample(63) :-
	tryGoal(deduce(elementOf(tweety,fly))),
	tryGoal(deduce(elementOf(tweety,nest))),
	tryGoal(deduce(elementOf(tweety,not(emu)))),
	tryGoal(deduce(elementOf(tweety,not(cuckoo)))),
	tryGoal(deduce(elementOf(tweety,sparrow))),
	tryGoal(consistent([])).
testMotelExample(64) :-
	tryGoal(deduce(elementOf(peter,leftHandUsable))),
	tryGoal(deduce(elementOf(peter,rightHandUsable))),
	tryGoal(deduce(elementOf(peter,oneHandUsable))),
	tryGoal(deduce(elementOf(peter,bothHandsUsable))),
	tryGoal(not(deduce(elementOf(peter,not(bothHandsUsable))))).
testMotelExample(65) :-
	tryGoal(deduce(elementOf(peter,leftHandUsable))),
        tryGoal(deduce(elementOf(peter,rightHandUsable))),
	tryGoal(deduce(elementOf(peter,not(bothHandsUsable)))),
	tryGoal(deduce(elementOf(peter,oneHandUsable))).
testMotelExample(66) :-
	tryGoal(deduce(elementOf(peter,leftHandUsable))),
	tryGoal(deduce(elementOf(peter,rightHandUsable))),
	tryGoal(deduce(elementOf(peter,oneHandUsable))),
	tryGoal(deduce(elementOf(peter,not(bothHandsUsable)))),
	tryGoal(not(deduce(elementOf(peter,bothHandsUsable)))),
	tryGoal(not(deduce(elementOf(peter,not(oneHandUsable))))).
testMotelExample(67) :-
	print('No goal for this example'), nl.
testMotelExample(68) :-
	print('No goal for this example'), nl.
testMotelExample(69) :-
	tryGoal(deduce(elementOf(tweety,bird))),
	tryGoal(not(deduce(elementOf(tweety,not(bird))))),
	tryGoal(not(deduce(elementOf(tweety,fly)))),
	tryGoal(not(deduce(elementOf(tweety,not(fly))))),
	tryGoal(not(deduce(elementOf(tweety,nest)))),
	tryGoal(not(deduce(elementOf(tweety,not(nest))))).
testMotelExample(70) :-
	tryGoal(deduce(elementOf(b,clearTop))),
	tryGoal(deduce(elementOf(b,clearTop))),
	tryGoal(not(deduce(elementOf(a,clearTop)))),
	tryGoal(not(deduce(elementOf(a,not(clearTop))))).
testMotelExample(71) :-
	print('No goal for this example'), nl.
testMotelExample(72) :-
	print('No goal for this example'), nl.
testMotelExample(73) :-
	print('No goal for this example'), nl.
testMotelExample(74) :-
	print('No goal for this example'), nl.
testMotelExample(75) :-
	tryGoal(setof(C,motel_ask([b(believe,ps),b(believe,pc)],elementOf(beetle,C)),L1)),
	tryGoal(setof(C,motel_ask([b(believe,ps),b(believe,pc)],elementOf('bmw735',C)),L2)),
	tryGoal(assert_ind([b(believe,ps),b(believe,pc)],'bmw735',has_cat_conv)),
	tryGoal(setof(C,motel_ask([b(believe,ps),b(believe,pc)],elementOf('bmw735',C)),L3)),
	tryGoal(assert_ind([b(believe,ps),b(believe,pc)],'bmw735',not(slow))),
	tryGoal(setof(C,motel_ask([b(believe,ps),b(believe,pc)],elementOf('bmw735',C)),L4)),
	tryGoal(assert_ind([b(believe,ps),b(want,pc)],beetle,not(has_spoiler))),
	tryGoal(assert_ind([b(believe,ps),b(want,pc)],beetle,not(has_sliding_roof))),
	tryGoal(delete_ind([b(believe,ps)],pc,racer)),
	tryGoal(assert_ind([b(believe,ps)],pc,creeper)),
	tryGoal(setof(C,motel_ask([b(believe,ps),b(believe,pc)],elementOf(beetle,C)),L5)),
	tryGoal(motel_ask([b(believe,ps),b(believe,pc),b(believe,pc)],elementOf(beetle,not(slow)))),
	tryGoal(modalAxioms(kd5,believe,all)),
	tryGoal(not(motel_ask([b(believe,ps),b(believe,pc),b(believe,pc)],elementOf(beetle,not(slow))))).
testMotelExample(76) :-
	print('No goal for this example'), nl.
testMotelExample(77) :-
	tryGoal(deduce(elementOf(mary,grandparent),L1)),
	tryGoal(abduce(H,elementOf(mary,grandparent),L2)).
testMotelExample(78) :-
	print('No goal for this example'), nl.
testMotelExample(79) :-
	print('No goal for this example'), nl.
testMotelExample(80) :-
	print('No goal for this example'), nl.
testMotelExample(81) :-
	tryGoal(deduce([b(believe,ps),b(believe,pc)],elementOf(audi,car))),
	tryGoal(deduce([b(believe,ps),b(believe,pc),b(believe,pc)],elementOf(audi,car))),
	tryGoal(not(deduce([b(believe,pc),b(believe,pc)],elementOf(audi,car)))),
	tryGoal(not(deduce([b(believe,ps),b(believe,ps)],elementOf(audi,car)))),
	tryGoal(not(deduce([b(believe,pc),b(believe,ps)],elementOf(audi,car)))).
testMotelExample(82) :-
	tryGoal(deduce(elementOf(car1,car))),
	tryGoal(deduce(elementOf(car1,atleast(1,restr(hasPart,seat))))),
	tryGoal(deduce(elementOf(car1,all(restr(hasPart,seat),some(hasAttribute,heatable))))).
testMotelExample(83) :-
	print('No goal for this example'), nl.
testMotelExample(84) :-
	print('No goal for this example'), nl.
testMotelExample(85) :-
	print('No goal for this example'), nl.
testMotelExample(86) :-
	print('No goal for this example'), nl.


tryGoal(G) :-
	call(G),
	!,
	print('Goal '), print(G), print(' succeeded'), nl.
tryGoal(G) :-
	print('Goal '), print(G), print(' failed'), nl.

/***********************************************************************
 *
 * verifySolution(+TestSol,+ExpectedSol)
 *
 *	prints an error message if TestSol and ExpectedSol do not
 *	match.
 */

verifySolution(TestSol,ExpectedSol) :-
	nonvar(ExpectedSol),
	nonvar(TestSol),
	!,
	TestSol = ExpectedSol.
verifySolution(TestSol,ExpectedSol) :-
	print('Solutions differ: test solution is '),
	print(TestSol),
	print(', while expected solution is '),
	print(ExpectedSol).

/**********************************************************************
 *
 * @(#) unfold.pl 1.5@(#)
 *
 */

/***********************************************************************
 *
 * unfold(Env,+Type,+CT,+List1,-CN,-List2)
 * Parameter: Type      'concept' or 'role'
 *            CT        concept term
 *            List1     List of tuples (Origin,T,T1,T2)
 *                      where Origin is either 'user' or 'system'
 *                            T      is either 'concept' or 'role'
 *                            T1     is a concept term or role term
 *                            T2     is a concept term or role term
 *            CN        concept atom_codes
 *            List2     List of triples (Origin,CN,CT)
 * unfolds concept terms or role terms so that in List2 for all tuples
 * (O,T,CN,all(R1,C1)), (O,T,CN,and([C1,...,Cn])), 
 * (O,T,RN,and([R1,...,Rn])), ...
 * CN and the Ci are concept names and RN and the Ri are role names.
 *
 * 130892   UH   (c)
 *
 */


unfold(_Env,O,_Side,_Type,CT,DL1,O,CT,DL1) :-
	atomicConcept(CT),
	!.
unfold(_Env,_O,_Side,concept,not(CT),DL1,system,not(CT),DL1) :-
	atomicConcept(CT),
	!.
%unfold(Env,_O,_Side,concept,CT,DL1,user,C,DL1) :-
%	conceptEqualSets(Env,system,_,C,CT,_),
%	clause(conceptName(Env,_,_C),_),
%	!.
%unfold(Env,_O,_Side,concept,CT,DL1,system,C,DL1) :-
%	conceptEqualSets(Env,system,_,C,CT,_),
%	!.
unfold(Env,_O,left,concept,CT,DL1,system,CT1,DL2) :-
	gensym(concept,C),
	unfold(Env,[(system,concept,C,CT)],[(_,concept,C,CT,CT1)|DL]),
	append(DL1,DL,DL2).
unfold(Env,_O,right,concept,CT,DL1,system,C,DL2) :-
	gensym(concept,C),
	unfold(Env,[(system,concept,C,CT)],[(system,concept,C,CT,CT1)|DL]),
	append(DL1,[(system,concept,C,CT,CT1)|DL],DL2).
unfold(Env,_O,_Side,role,RT,DL1,system,R,DL2) :-
	gensym(role,R),
	unfold(Env,[(system,role,R,RT)],[(system,role,R,RT,RT1)|DL]),
	append(DL1,[(system,role,R,RT,RT1)|DL],DL2).

/***********************************************************************
 *
 * unfold(Env,+List1,-List2)
 * Parameter: List1     List of tuples (Origin,Type,T1,T2)
 *                      where Origin is either 'user' or 'system'
 *                            T      is either 'concept' or 'role'
 *                            T1     is a concept or role term
 *                            T2     is a concept or role term
 *            List2     List of tuples (Origin,Type,CN,CT)
 * unfolds concept terms or role terms so that in List2 for all tuples
 * (O,T,CN,all(R1,C1)), (O,T,CN,and([C1,...,Cn])), 
 * (O,T,RN,and([R1,...,Rn])), ...
 * CN and the Ci are concept names and RN and the Ri are role names.
 *
 * 130892   UH   (c)
 *
 */

unfold(Env,[(Origin,concept,A,all(R,B))|L1],[(NewOrigin,concept,A1,all(R,B),all(R1,B1))|DL3]) :-
	unfold(Env,L1,L2),
	unfold(Env,Origin,left,concept,A,L2,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,role,R,DL1,_NewOriginR1,R1,DL2),
	unfold(Env,Origin,right,concept,B,DL2,_NewOriginB1,B1,DL3),
        !.
unfold(Env,[(Origin,concept,A,some(R,B))|L1],[(NewOrigin,concept,A1,some(R,B),some(R1,B1))|DL3]) :-
	unfold(Env,L1,L2),
	unfold(Env,Origin,left,concept,A,L2,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,role,R,DL1,_NewOriginR1,R1,DL2),
	unfold(Env,Origin,right,concept,B,DL2,_NewOriginB1,B1,DL3),
        !.
unfold(Env,[(Origin,concept,A,atmost(N,R))|L1],[(NewOrigin,concept,A1,atmost(N,R),atmost(N,R1))|DL2]) :-
	integer(N),
	unfold(Env,L1,L2),
	unfold(Env,Origin,left,concept,A,L2,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,role,R,DL1,_NewOriginR1,R1,DL2),
        !.
unfold(Env,[(Origin,concept,A,atleast(N,R))|L1],[(NewOrigin,concept,A1,atleast(N,R),atleast(N,R1))|DL2]) :-
	integer(N),
	unfold(Env,L1,L2),
	unfold(Env,Origin,left,concept,A,L2,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,role,R,DL1,_NewOriginR1,R1,DL2),
        !.
unfold(Env,[(Origin,Type,A,and(L1))|L2],[(NewOrigin,Type,A1,and(L1),and(L3))|L5]) :-
	unfold(Env,L2,DL1),
	unfold(Env,Origin,left,Type,A,DL1,NewOrigin,A1,L4),
	unfoldList(Env,Type,L1,L3,CL3),
	append(L4,CL3,L5),
	!.
unfold(Env,[(Origin,Type,A,set(L1))|L2],[(NewOrigin,Type,A1,set(L1),C)|L4]) :-
	unfold(Env,L2,DL1),
	unfoldSetToConcept(set(L1),C),
	unfold(Env,Origin,left,Type,A,DL1,NewOrigin,A1,L4),
	!.
unfold(Env,[(Origin,concept,A,or(L1))|L2],[(NewOrigin,concept,A1,or(L1),or(L3))|L5]) :-
	unfold(Env,L2,DL1),
	unfold(Env,Origin,left,concept,A,DL1,NewOrigin,A1,L4),
	unfoldList(Env,concept,L1,L3,CL3),
	append(L4,CL3,L5),
	!.
unfold(Env,[(Origin,concept,A,not(B))|L2],[(NewOrigin,concept,A1,not(B),not(B1))|L3]) :-
	unfold(Env,L2,L4),
	unfold(Env,Origin,left,concept,A,L4,NewOrigin,A1,L5),
	unfold(Env,Origin,right,concept,B,L5,_NewOriginB,B1,L3),
	!.
unfold(Env,[(Origin,concept,A,naf(B))|L2],[(NewOrigin,concept,A1,naf(B),naf(B1))|L3]) :-
	unfold(Env,L2,L4),
	unfold(Env,Origin,left,concept,A,L4,NewOrigin,A1,L5),
	unfold(Env,Origin,right,concept,B,L5,_NewOriginB,B1,L3),
	!.
unfold(Env,[(Origin,concept,A,b(O,P,B))|L2],[(NewOrigin,concept,A1,b(O,P,B),b(O,P,B1))|L3]) :-
	unfold(Env,L2,L4),
	unfold(Env,Origin,left,concept,A,L4,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,concept,B,DL1,_NewOriginB1,B1,L3),
	!.
unfold(Env,[(Origin,concept,A,bc(O,C,B))|L2],[(NewOrigin,concept,A1,bc(O,P,B),bc(O,C1,B1))|L5]) :-
	unfold(Env,L2,L4),
	unfold(Env,Origin,left,concept,A,L4,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,concept,C,DL1,_NewOriginB1,C1,L3),
	unfold(Env,Origin,right,concept,B,DL1,_NewOriginB1,B1,L4),
	append(L3,L4,L5),
	!.
unfold(Env,[(Origin,concept,A,dc(O,C,B))|L2],[(NewOrigin,concept,A1,dc(O,P,B),bc(O,C1,B1))|L5]) :-
	unfold(Env,L2,L4),
	unfold(Env,Origin,left,concept,A,L4,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,concept,C,DL1,_NewOriginB1,C1,L3),
	unfold(Env,Origin,right,concept,B,DL1,_NewOriginB1,B1,L4),
	append(L3,L4,L5),
	!.
unfold(Env,[(Origin,concept,A,d(O,P,B))|L2],[(NewOrigin,concept,A1,d(O,P,B1),d(O,P,B1))|L3]) :-
	unfold(Env,L2,L4),
	unfold(Env,Origin,left,concept,A,L4,NewOrigin,A1,DL1),
	unfold(Env,Origin,right,concept,B,DL1,_NewOriginB1,B1,L3),
	!.
unfold(Env,[(Origin,role,RN,restr(R,C))|L1],[(NewOrigin,role,RN1,restr(R,C),restr(R1,C1))|L2]) :-
	unfold(Env,L1,L3),
	unfold(Env,Origin,left,role,RN,L3,NewOrigin,RN1,L4),
	unfold(Env,Origin,right,role,R,L4,_NewOriginR1,R1,L5),
	unfold(Env,Origin,right,concept,C,L5,_NewOriginC1,C1,L2),
        !.
unfold(Env,[(Origin,role,RN,inverse(R))|L1],[(NewOrigin,role,RN1,inverse(R),inverse(R1))|L5]) :-
	unfold(Env,L1,L3),
	unfold(Env,Origin,left,role,RN,L3,NewOrigin,RN1,L4),
	unfold(Env,Origin,right,role,R,L4,_NewOriginR1,R1,L5),
        !.
unfold(_Env,[(Origin,Type,A,B)],[(Origin,Type,A,B,B)]) :-
	atomicConcept(B),
	!.
unfold(_Env,[],[]) :- !.
	

unfoldList(_Env,_,[],[],[]) :- !.
unfoldList(Env,Type,[CT1|CTL1],[CT1|CTL2],DL1) :-
	atomicConcept(CT1),
	unfoldList(Env,Type,CTL1,CTL2,DL1),
	!.
%unfoldList(Env,Type,[CT1|CTL1],[CN|CNL2],DL3) :-
%	conceptEqualSets(Env,system,_,CN,CT1,_),
%	!,
%	unfoldList(Env,Type,CTL1,CNL2,DL3).
unfoldList(Env,Type,[CT1|CTL1],[CN|CNL2],DL1) :-
	gensym(Type,CN),
	unfold(Env,[(system,Type,CN,CT1)],DL),
	unfoldList(Env,Type,CTL1,CNL2,DL3),
	append(DL,DL3,DL1).


/**********************************************************************
 *
 * atomicConcept(+CT) 
 * succeeds if the concept term CT can be regarded as a atomic concept
 * for our translation. In the current implementation variables, 
 * identifiers, singleton sets, and their negation are regarded as 
 * atomic.
 *
 * 130892   UH   (c)
 * 140892   UH   Added clauses for sets and negation of variables
 * 140892   UH   Documented
 *
 */

atomicConcept(CT) :-
	var(CT),
	!.
atomicConcept(CT) :-
	atomic(CT),
	!.
atomicConcept(not(CT)) :-
	var(CT),
	!.
atomicConcept(not(CT)) :-
	atomic(CT),
	!.
atomicConcept(set([E1])) :-
	!.
%atomicConcept(not(set([E1]))) :-
%	!.
	
/**********************************************************************
 *
 * unfoldElementToSet(+Set,-CT)
 * for a given set Set the concept term CT consisting of a disjunktion 
 * of all singleton set contained in Set is computed.
 *
 * 130892   UH   (c)  
 * 140892   UH   Documented
 *
 */

unfoldElementToSet(E1,set([E1])).

unfoldSetToConcept(set([]),bot) :-
	!.
unfoldSetToConcept(set([E1]),set([E1])) :-
	!.
unfoldSetToConcept(set([E1|L1]),or(L2)) :-
	hop_map(unfoldElementToSet,[E1|L1],L2),
	!.


/**********************************************************************
 *
 * @(#) userInterface.pl 1.46@(#)
 *
 */

/***********************************************************************
 *
 * initialize
 * cleans TBox, ABox, hierarchies, ...
 *
 */

initialize :-
	retractCompiledPredicates(_),
	retractallSpecial(_,axiom/3),
	retractallSpecial(_,in/9),
	retractallSpecial(_,kb_in/10),
	retractallSpecial(_,eq/9),
	retractallSpecial(_,constraint/8),
	retractallSpecial(_,rel/5),
	retractallSpecial(_,closed/5),
	retractallSpecial(_,compiledPredicate/2),
	retractallSpecial(_,conceptElement/7),
	retractallSpecial(_,conceptEqualSets/6),
	retractallSpecial(_,conceptHierarchy/3),
	retractallSpecial(_,conceptName/4),
	retractallSpecial(_,conceptSubsets/6),
	retractallSpecial(_,environment/3),
	retractallSpecial(_,given_change/4),
	retractallSpecial(_,given_inflLink/4),
	retractallSpecial(_,modalAxioms/7),
	retractallSpecial(_,roleAttributes/5),
	retractallSpecial(_,roleDefault/4),
	retractallSpecial(_,roleDefNr/4),
	retractallSpecial(_,roleDomain/4),
	retractallSpecial(_,roleElement/8),
	retractallSpecial(_,roleEqualSets/6),
	retractallSpecial(_,roleHierarchy/3),
	retractallSpecial(_,roleName/4),
	retractallSpecial(_,roleNr/4),
	retractallSpecial(_,roleRange/4),
	retractallSpecial(_,roleSubsets/6),
	retractallSpecial(_,sub/4),
	retractallSpecial(_,succ/4),
	retractallSpecial(_,abductiveDerivation/3),
	retractallSpecial(_,consistencyDerivation/3),
	retractallSpecial(_,hypothesis/1),
	retractallSpecial(_,inconsistencyCheck/3),
	retractallSpecial(_,isMooOption/2),
	retractallSpecial(sub(_,_,_,_,_)),
	retractallSpecial(nsub(_,_,_,_,_)),
	retractallSpecial(succ(_,_,_,_,_)),
	retractallSpecial(_,sub3/2),
	retractallSpecial(_,nsub3/2),
	retractallSpecial(_,succ3/2),
	retractallSpecial(_,valueOfCounter/2),
	retractallSpecial(_,query/6),
	assertaRE(environment(initial,env(e0),'Initial Environment')),
	assertaRE(currentEnvironment(env(e0))),
	initEnvironment(initial),
	!.

retractRoles(Env) :-
 	clause(roleName(Env,_MS,_,RN),_),
 	Head =.. [RN,_,_],
 	retractallSpecial(Head),
	fail.
retractRoles(_).


/**********************************************************************
 *
 * loadKB(+FileName)
 * 
 */

loadKB(FileName) :-
	see(FileName),
	repeat,
	read(Goal),
	doFileGoal(Goal),
	!.
loadKB(_) :-
	seen,
	!,
	fail.

loadKB(FileName,EnvName) :-
	var(EnvName),
	loadKB(FileName),
	% The file FileName should contain a call to makeEnvironment
	% Due to the definition of makeEnvironment the new environment
	% should be described by the first environment/3 fact in the
	% database.
	environment(EnvName,_,_),
	!.


doFileGoal('end_of_file') :-
	seen,
	!.
doFileGoal(Goal) :-
	once(call(Goal)),
	fail.

/**********************************************************************
 *
 * getKB(+Name,-Set)
 * Set contains all terminological and assertional axioms in 
 * knowledge base Name.
 *
 */

getKB(Set) :- 
	getCurrentEnvironment(Name),
	getKB(Name,Set),
	!.

getKB(EnvName,Set08) :-
	environment(EnvName,Name,_Comment),
	bagofOrNil(Clause1,
                   [MS,K1,C1,MOp1,A1]^(modalAxioms(Name,MS,user,K1,C1,MOp1,A1), 
                   Clause1 = modalAxioms(MS,K1,MOp1,A1)),Set1),
	bagofOrNil(Clause2,
                   [MS2,W1,G1,A2,C2,Ax2]^(clause(conceptElement(Name,MS2,W1,user,A2,C2,Ax2),G1),
                   Clause2 = assert_ind(MS2,A2,C2)),Set2),
	bagofOrNil(Clause3,
                   [MS3,W1,G1,A3,B3,R3,Ax3]^(clause(roleElement(Name,MS3,W1,user,A3,B3,R3,Ax3)),
	           Clause3 = assert_ind(MS3,A3,B3,R3)),Set3),
	bagofOrNil(Clause4,
                   [MS4,CN4,CT4,Ax4]^(conceptEqualSets(Name,user,MS4,CN4,CT4,Ax4),
                   Clause4 = defconcept(MS4,CN4,CT4)),Set4),
	bagofOrNil(Clause5,
                   [MS5,CN5,CT5,Ax5]^(conceptSubsets(Name,user,MS5,CN5,CT5,Ax5),
                   Clause5 = defprimconcept(MS5,CN5,CT5)),Set5),
	bagofOrNil(Clause6,
		   [MS6,CN6,CT6,Ax6]^(roleEqualSets(Name,user,MS6,CN6,CT6,Ax6),
                   Clause6 = defrole(MS6,CN6,CT6)),Set6),
	bagofOrNil(Clause7,
                   [MS7,CN7,CT7,Ax7]^(roleSubsets(Name,user,MS7,CN7,CT7,Ax7),
		   Clause7 = defprimrole(MS7,CN7,CT7)),Set7),
	bagofOrNil(Clause8,
		   [MS8,X8,Y8,R8]^(closed(Name,MS8,X8,Y8,R8),
		   Clause8 = defclosed(MS8,X8,Y8,R8)),Set8),
	append(   [],Set1,Set01),
	append(Set01,Set2,Set02),
	append(Set02,Set3,Set03),
	append(Set03,Set4,Set04),
	append(Set04,Set5,Set05),
	append(Set05,Set6,Set06),
	append(Set06,Set7,Set07),
	append(Set07,Set8,Set08),
	!.

/**********************************************************************
 *
 * saveKB(+EnvName,+FileName)
 *
 */

saveKB(FileName) :-
	getCurrentEnvironment(EnvName),
	!,
	saveKB(EnvName,FileName).

saveKB(EnvName,FileName) :-
	environment(EnvName,Env,C),
	tell(FileName),
	writeq(makeEnvironment(EnvName,C)), write('.'), nl,
	writeq(initEnvironment(EnvName)), write('.'), nl,
	transformAndWrite(axiom(Env,_,Axiom),Axiom),
	transformAndWrite(modalAxioms(Env,MC71,user,AS72,AC73,MO74,_A75),
                          modalAxioms(EnvName,MC71,AS72,MO74,AC73)),
	transformAndWrite(roleAttributes(Env,A71,B71,C71),
			  (environment(EnvName,NewEnv,_), assertzRE(roleAttributes(NewEnv,A71,B71,C71)))),
	transformAndWrite(roleDefault(Env,A81,B81,C81),
			  (environment(EnvName,NewEnv,_), assertzRE(roleDefault(NewEnv,A81,B81,C81)))),
	transformAndWrite(roleDefNr(Env,A91,B91,C91),
			  (environment(EnvName,NewEnv,_), assertzRE(roleDefNr(NewEnv,A91,B91,C91)))),
	transformAndWrite(roleDomain(Env,A82,B82,C82),
			  (environment(EnvName,NewEnv,_), assertzRE(roleDomain(NewEnv,A82,B82,C82)))),
	transformAndWrite(roleNr(Env,A83,B83,C83),
			  (environment(EnvName,NewEnv,_), assertzRE(roleNr(NewEnv,A83,B83,C83)))),
	transformAndWrite(roleRange(Env,A84,B84,C84),
			  (environment(EnvName,NewEnv,_), assertzRE(roleRange(NewEnv,A84,B84,C84)))),
        told,
        !.
saveKB(_,_) :-
	told,
	!,
	fail.
			  
transformAndWrite(G1,Var,Test,G2) :-
	clause(G1,_Body),
	call(Test),
	writeeq(G2), write('.'), nl,
	fail.
transformAndWrite(_,_,_,_) :-
	!.

transformAndWrite(G1,G2) :-
	clause(G1,_Body),
	writeq(G2), write('.'), nl,
	fail.
transformAndWrite(_,_) :-
	!.


/***********************************************************************
 *
 * deduce(EnvName,MS,Query,Proof)
 *
 */

deduce(P1) :-
	completeParameter([P1],EnvName,MS,Query,Proof),
	deduce(EnvName,MS,Query,Proof).
deduce(P1,P2) :-
	completeParameter([P1,P2],EnvName,MS,Query,Proof),
	deduce(EnvName,MS,Query,Proof).
deduce(P1,P2,P3) :-
	completeParameter([P1,P2,P3],EnvName,MS,Query,Proof),
	deduce(EnvName,MS,Query,Proof).

deduce(EnvName,MS,elementOf(X,C),Exp) :-
	isMooOption(prover,setheo),
	!,
	deduceSetheo(EnvName,MS,elementOf(X,C),Exp).
/* deduce(EnvName,MS,elementOf(X,C),Exp) :-
	deduceMOTEL(EnvName,MS,elementOf(X,C),Exp).
*/
deduce(EnvName,MS,X,Exp) :-
	deduceMOTEL(EnvName,MS,X,Exp).
deduceMOTEL(EnvName,MS,elementOf(X,C),Exp) :-
	isMooOption(queryCaching,on),
	retractallSpecial(hypothesis(_)),
 	environment(EnvName,Env,_),
 	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	clause(query(Env,W1,C,X,Exp,Goal),_).
deduceMOTEL(EnvName,MS,elementOf(X,CT),Exp) :-
	retractallSpecial(hypothesis(_)),
	removeDefinitionOfConceptname(queryconcept),
	defineEquivalentConceptname(EnvName,MS,CT,query,C),
 	environment(EnvName,Env,_),
 	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
 	getNegatedConcept(C,C1),
	constructMLMark(rn(_AN5,_RN5,_S5,_O5),W1,C1,X,_HYPS,_D1,InHead1),
 	getQuery(Env,W1,C,X,Exp,Goal),
	performQuery(X,G1,Goal),
	allowedAnswerConcept(Env,C),
% 	anlegen einer clausel die in undefconcept wieder geloescht wird...
 	setQuery(Env,W1,CT,X,Exp,Goal).
deduceMOTEL(EnvName,MS,roleFiller(X,R1,L,N),Exp) :-
	retractallSpecial(hypothesis(_)),
	removeDefinitionOfRolename(queryrole),
%	defineEquivalentRolename(EnvName,MS,R1,R),
	R = R1,
	environment(EnvName,Env,_),
	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	call(G1),
	defineEquivalentRolename(EnvName,MS,R,query,R1),
	solveConstraint(Env,W1,(card,app((_FF:R1),X),'>=',_N1),(_N,L),
	                hyp([or([]),rl([]),fl([])]),ab(noAb),call([]),Exp),
	nonvar(X),
	length(L,N).
deduceMOTEL(EnvName,MS,roleConstraints(X,R1,['>=',N1,'=<',N2,L,N3]),Exp) :-
	retractallSpecial(hypothesis(_)),
	removeDefinitionOfRolename(queryrole),
%	defineEquivalentRolename(EnvName,MS,R1,R),
	R = R1,
	environment(EnvName,Env,_),
	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	call(G1),
	defineEquivalentRolename(EnvName,MS,R,query,R1),
	solveConstraint(Env,W1,(card,app((_FF:R1),X),'>=',N1),(_,L),
	                hyp([or([]),rl([]),fl([])]),ab(noAb),call([]),Exp1),
	solveConstraint(Env,W1,(card,app((_FF:R1),X),'=<',N2),(Exp3,L),
	                hyp([or([]),rl([]),fl([])]),ab(noAb),call([]),Exp2),
	Exp = proved(MS,and([card(R1,X,>=,N1),
			     card(R1,X,=<,N2),
			     inst(R1,X,L)]),
		     basedOn(and([Exp1,Exp2,Exp3]))),
	nonvar(X),
	length(L,N3).

%----------------------------------------------------------------------
% defineEquivalentRolename(+EnvName,+MS,+RoleTerm,-RoleName)
% Arguments: EnvName   environment atom_codes
%            MS        modal context (in list form)
%            RoleTerm  role term (possibly non-atomic)
%            RoleName  role atom_codes
% if RoleTerm is either a variable or a role atom_codes, then RoleName is equal to
% RoleTerm. Otherwise, a role RoleName equivalent to RoleTerm is defined.

defineEquivalentRolename(_,_,R,_,R) :-
	var(R),
	!.
defineEquivalentRolename(_,_,R,_,R) :-
	atomic(R),
	!.
defineEquivalentRolename(EnvName,MS,R,query,queryrole) :-
	defrole(EnvName,MS,queryrole,R),
	!.
defineEquivalentRolename(EnvName,MS,R,_,R1) :-
	gensym(role,R1),
	defrole(EnvName,MS,R1,R),
	!.

%----------------------------------------------------------------------
% defineEquivalentConceptname(+EnvName,+MS,+RoleTerm,-RoleName)
% Arguments: EnvName   environment atom_codes
%            MS        modal context (in list form)
%            ConceptTerm  role term (possibly non-atomic)
%            ConceptName  role atom_codes
% if ConceptTerm is either a variable or a concept atom_codes, then ConceptName is 
% equal to ConceptTerm. Otherwise, a role ConceptName equivalent to 
% ConceptTerm is defined.

defineEquivalentConceptname(_,_,C,_,C) :-
	var(C),
	!.
defineEquivalentConceptname(_,_,C,_,C) :-
	atomic(C),
	!.
defineEquivalentConceptname(EnvName,MS,C,query,C1) :-
	C1 = queryconcept,
	defconcept(EnvName,MS,queryconcept,C),
	!.
defineEquivalentConceptname(EnvName,MS,C,_,C1) :-
	gensym(concept,C1),
	defconcept(EnvName,MS,C1,C),
	!.

removeDefinitionOfConceptname(C) :-
	conceptEqualSets(Env,_,MS,C,_,_),
	environment(EnvName,Env,_),
	undefconcept(EnvName,MS,C),
	fail.
removeDefinitionOfConceptname(C) :-
	!.


%----------------------------------------------------------------------
% removeDefinitionOfRolename(+EnvName,+MS,+RoleName)
% Arguments: EnvName   environment atom_codes
%            MS        modal context (in list form)
%            RoleTerm  role term (possibly non-atomic)
%            RoleName  role atom_codes
% removes the definition of RoleName.

removeDefinitionOfRolename(R) :-
	roleEqualSets(Env,_,MS,R,_,_),
	environment(EnvName,Env,_),
	undefrole(EnvName,MS,R),
	fail.
removeDefinitionOfRolename(R) :-
	!.

deduceSetheo(EnvName,MS,elementOf(X,C),Exp) :-
 	environment(EnvName,Env,_),
 	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	getQuery(Env,MS,C,X,GL),
	write('Trying '), print(X), write(' in '), print(C), write('.'),nl,
	tell('/tmp/aaa.lop'),
	envToFOL(Env,CL),
	printSystemSyntax(CL),
	printSystemSyntax(GL),
	told,
	shell('/HG/local/provers/setheo/bin.sun4/inwasm -cons -nosgreord /tmp/aaa',S1),
	S1 = 0,
	shell('/HG/local/provers/setheo/bin.sun4/wasm /tmp/aaa',S2),
	S2 = 0, 
	shell('/HG/local/provers/setheo/bin.sun4/sam -dr -cons /tmp/aaa',S3),
	S3 = 0.

deduceDecider(EnvName,MS,elementOf(X,C),Exp) :-
 	environment(EnvName,Env,_),
 	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
%	getQuery(Env,MS,C,X,GL),
%	write('Trying '), print(X), write(' in '), print(C), write('.'),nl,
%	tell('/tmp/aaa.lop'),
	setMooOption(prover,decider),
	setMooOption(translationMode,relational),	
	envToFOL(Env,CL1),
	modTranslateInDecide(CL1,CL),
%	printSystemSyntax(CL),
%	printSystemSyntax(GL),
%	told,
	modInferenceClauseList(CL,Exp),	
	!.

setQuery(Env,W1,C,X,Exp,Goal) :-
	not(clause(query(Env,W1,C,X,Exp,_Goal),_)),
	assertzRE(query(Env,W1,C,X,Exp,Goal)),
	!.
setQuery(Env,W1,C,X,Exp,Goal) :-
	!,
	fail.

splitGoal([(in(A1,B1,C1) <- true)],[(false <- in(A1,B1,C1))]) :-
	!.
splitGoal([(~ in(A1,B1,C1) <- true)],[(false <- ~ in(A1,B1,C1))]) :-
	!.
splitGoal([B|C],[B|D]) :-
	splitGoal(C, D).
splitGoal([],[]).

getQuery(Env,MS1,C0,X,C3) :-
	var(C0),
	var(X),
	clause(conceptName(Env,_,_,C0),_),
        conceptElement(Env,_,_,user,X,_,_),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	axiomToFOL(MS3,[X],_,in,C0,F),
	translate(F,C1),
	clausesToSystemSyntax(C1,C2),
	splitGoal(C2,C3).
getQuery(Env,MS1,C0,X,C3) :-
	var(C0),
	var(X),
	clause(conceptName(Env,_,_,C0),_),
        conceptElement(Env,_,_,user,X,_,_),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	axiomToFOL(MS3,[X],_,in,not(C0),F),
	translate(F,C1),
	clausesToSystemSyntax(C1,C2),
	splitGoal(C2,C3).
getQuery(Env,MS1,C0,X,C3) :-
	var(C0),
	nonvar(X),
	setof(F1,[A1,A2,A3]^clause(conceptName(Env,A1,A2,F1),A3),L1),
	member(C0,L1),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	axiomToFOL(MS3,[X],_,in,C0,F),
	translate(F,C1),
	clausesToSystemSyntax(C1,C2),
	splitGoal(C2,C3).
getQuery(Env,MS1,C0,X,C3) :-
	var(C0),
	nonvar(X),
	setof(F1,[A1,A2,A3]^clause(conceptName(Env,A1,A2,F1),A3),L1),
	member(C0,L1),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	axiomToFOL(MS3,[X],_,in,not(C0),F),
	translate(F,C1),
	clausesToSystemSyntax(C1,C2),
	splitGoal(C2,C3).
getQuery(Env,MS1,C0,X,C3) :-
	nonvar(C0),
	var(X),
        conceptElement(Env,_,_,user,X,_,_),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	axiomToFOL(MS3,[X],_,in,C0,F),
	translate(F,C1),
	clausesToSystemSyntax(C1,C2),
	splitGoal(C2,C3).
getQuery(Env,MS1,C0,X,C3) :-
	nonvar(C0),
	nonvar(X),
	hop_map(negate,MS1,MS2),
	hop_map(normalizeNot,MS2,MS3),
	axiomToFOL(MS3,[X],_,in,C0,F),
	translate(F,C1),
	clausesToSystemSyntax(C1,C2),
	splitGoal(C2,C3).
getQuery(Env,W1,C0,X,Exp,Goal) :-
	var(C0),
	clause(conceptName(Env,_,_,C0),_),
	constructMLCall(Env,rn(no,_RN1,user,_O1),bodyMC(W1),headMC(_),
			C0,X,[or([]),rl([]),fl(_DML1)],noAb,[],Exp,Goal).

performQuery(X,G1,Goal) :-
	nonvar(X),
	not(isMooOption(allProofs,yes)),
	!,
 	once((call((call(G1), Goal)), atomic(X))).
performQuery(X,G1,Goal) :-
	!,
 	call((call(G1), Goal)), 
	atomic(X).

/***********************************************************************
 *
 * deduce(+EnvName,+MS,:+-Info,-E)
 *
 *	If instantiated, Info is one of 
 *		infl(+-X,+-Y,+-W),
 *		posInfl(+-X,+-Y), negInfl(+-X,+-Y), noInfl(+-X,+-Y),
 *		simultInfl(+-Xs,+-Y,+-W), 
 *		simultPosInfl(+-Xs,+-Y), simultNegInfl(+-Xs,+-Y), 
 *		simultNoInfl(+-Xs,+-Y), 
 *		change(+-X,+-W),
 *		increase(+-X), decrease(+-X), noChange(+-X).
 *
 *	Succeeds if Info can be inferred by deduction.
 */

deduce(EnvName,MS,infl(X,Y,W),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	infl(Env,World,X,Y,W).
deduce(EnvName,MS,simultInfl(X,Y,W),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	simultInfl(Env,World,X,Y,W).
deduce(EnvName,MS,leastInfl(X,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	leastInfl(Env,World,X,Y).
deduce(EnvName,MS,leastInfls(Xs,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	leastInfls(Env,World,Xs,Y).
deduce(EnvName,MS,greatestInfl(X,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	greatestInfl(Env,World,X,Y).
deduce(EnvName,MS,greatestInfls(Xs,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	greatestInfls(Env,World,Xs,Y).
deduce(EnvName,MS,maxPosInfl(X,Y,W),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	maxPosInfl(Env,World,X,Y,W).
deduce(EnvName,MS,maxNegInfl(X,Y,W),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	maxNegInfl(Env,World,X,Y,W).
deduce(EnvName,MS,change(Y,W),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	change(Env,World,Y,W).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

deduce(EnvName,MS,posInfl(X,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	posInfl(Env,World,X,Y).
deduce(EnvName,MS,negInfl(X,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	negInfl(Env,World,X,Y).
deduce(EnvName,MS,simultPosInfl(Xs,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	simultPosInfl(Env,World,Xs,Y).
deduce(EnvName,MS,simultNegInfl(Xs,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	simultNegInfl(Env,World,Xs,Y).
deduce(EnvName,MS,simultNoInfl(Xs,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	simultNoInfl(Env,World,Xs,Y).
deduce(EnvName,MS,noInfl(X,Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	noInfl(Env,World,X,Y).
deduce(EnvName,MS,increase(X),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	increase(Env,World,X).
deduce(EnvName,MS,decrease(X),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	decrease(Env,World,X).
deduce(EnvName,MS,noChange(Y),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	noChange(Env,World,Y).




getQuery(Env,W1,C0,X,Exp,Goal) :-
	var(C0),
	clause(conceptName(Env,_,_,C0),_),
	constructMLCall(Env,rn(no,_RN1,user,_O1),bodyMC(W1),headMC(_),
			C0,X,[or([]),rl([]),fl(_DML1)],noAb,[],Exp,Goal).
getQuery(Env,W1,C0,X,Exp,Goal) :-
	var(C0),
	clause(conceptName(Env,_,_,C1),_),
	C0 = not(C1),
	constructMLCall(Env,rn(no,_RN1,user,_O1),bodyMC(W1),headMC(_),
			C0,X,[or([]),rl([]),fl(_DML1)],noAb,[],Exp,Goal).
%getQuery(Env,W1,C0,X,Exp,Goal) :-
% 	var(C0),
%	!,
%	constructMLCall(Env,rn(no,_RN1,user,_O1),bodyMC(W1),headMC(_),
%			C0,X,[or([]),rl([]),fl(_DML1)],noAb,[],Exp,Goal),
%	!.
getQuery(Env,W1,C0,X,Exp,Goal) :-
	nonvar(C0),
	convertInAntecedent(Env,rn(no,user,_O1),bodyMC(W1),headMC(_),
			    C0,X,[or([]),rl([]),fl(_DML1)],noAb,[],Exp,Goal),
	!.

/***********************************************************************
 *
 * abduce(+-Hypothesis,+-Consequent).
 *
 *	Succeeds if Consequent follows under the hypothesis Hypothesis.
 */
abduce(Hyps,elementOf(X,Y)) :-
	!,
	getCurrentEnvironment(EnvName),
	abduce(EnvName,[],Hyps,elementOf(X,Y),_).
abduce(Hypothesis,Consequent) :-
        getCurrentEnvironment(EnvName),
	abduce(EnvName,[],Hypothesis,Consequent,[]).

/***********************************************************************
 *
 * abduce(+EnvName,+-Hypothesis,+-Consequent).
 *
 *	Succeeds if Consequent follows under the hypothesis Hypothesis.
 */

abduce(EnvName,Hypothesis,elementOf(X,C)) :-
	nonvar(EnvName),
	environment(EnvName,_,_),
	!,
	abduce(EnvName,[],elementOf(X,C),_Exp).
abduce(MS,Hypothesis,elementOf(X,C)) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
        getCurrentEnvironment(EnvName),
	!,
	abduce(EnvName,MS,Hypothesis,elementOf(X,C),_Exp).
abduce(Hypothesis,elementOf(X,C),Exp) :-
	getCurrentEnvironment(EnvName),
	!,
	abduce(EnvName,[],Hypothesis,elementOf(X,C),Exp).
abduce(EnvName,Hypothesis,Consequent) :-
        environment(EnvName,_,_),
	!,
	abduce(EnvName,[],Hypothesis,Consequent,[]).
abduce(MS,Hypothesis,Consequent) :-
	nonvar(MS),
        (MS = [] ; MS = [_|_]),
        getCurrentEnvironment(EnvName),
	!,
	abduce(EnvName,MS,Hypothesis,Consequent,[]).

abduce(EnvName,Hyps,elementOf(X,Y),Exp) :-
	nonvar(EnvName),
	environment(EnvName,_,_),
	!,
	abduce(EnvName,[],Hyps,elementOf(X,Y),Exp).
abduce(MS,Hyps,elementOf(X,Y),Exp) :-
	nonvar(MS),
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	!,
	abduce(EnvName,MS,Hyps,elementOf(X,Y),Exp).
abduce(EnvName,MS,Hyps,elementOf(X,Y)) :-
	!,
	abduce(EnvName,MS,Hyps,elementOf(X,Y),_Exp).

abduce(EnvName,MS,Hyps,elementOf(X,C),Exp) :-
	environment(EnvName,Env,_),
	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	constructMLCall(Env,rn(no,_RN1,user,_O1),bodyMC(W1),headMC(_),
			C,X,[or([]),rl([]),fl(_DML1)],D,[],_Exp1,InHead),
	call((call(G1), InHead)),
	ifMooOption(traceOutput,yes,(print('Hypotheses '), print(D), nl)),
	getConstraint(InHead,X),
	atomic(X),
	allowedAnswerConcept(Env,C),
	getAbductionHyps(D,GL),
	once((doConsistencyCheck([],GL),doMinimalityCheck([],GL))),
	getExplanation(InHead,Exp),
	getAbductionHypotheses(D,Hyps).

getAbductionHypotheses(L,[]) :-
	var(L),
	!.
getAbductionHypotheses([],[]) :-
	!.
getAbductionHypotheses([in(Env,RN,modal(MS),C,X,_,_,_,_)|L1],
	                [assert_ind(MS1,X,C)|L2]) :- 
	!,
	translateModalContext(MS,MS1),
	getAbductionHypotheses(L1,L2).
getAbductionHypotheses([C1|L1],
	                [C1|L2]) :- 
	!,
	getAbductionHypotheses(L1,L2).


translateModalContext([],[]) :-
	!.
translateModalContext(app([WP,_]:m(M,A),W),MS) :-
	var(WP),
	!,
	translateAgent(A,A1),
	translateModalContext(W,MS2),
	append(MS2,[d(M,A1)],MS).
translateModalContext(app([WP,_]:m(M,A),W),MS) :-
	!,
	translateAgent(A,A1),
	translateModalContext(W,MS2),
	append(MS2,[b(M,A1)],MS).

translateAgent(A,all) :-
	var(A),
	!.
translateAgent(A,A) :-
	!.

/***********************************************************************
 *
 * abduce(+EnvName,+MS,+-change(+-X,+-Wx),+-change(+-Y,+-Wy),[]).
 *
 *	Succeeds if, under the hypothesis of change(+-X,+-Wx), 
 *	change(+-Y,+-Wy) follows.
 */

abduce(EnvName,MS,change(X,Wx),change(Y,Wy),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	wellDefined_ChangeWeight(Wx),
	infl(Env,World,X,Y,Wxy),
	not(given_change(Env,World,X,_)),
	bagof(W,Z^changingInfl(Env,World,Z,Y,W),Ws),
	weightOf_change(Wx,Wxy,Wy1),
	weightOf_SimultChange([Wy1|Ws],Wy).

abduce(EnvName,MS,change(X,Wx),change(Y,Wy),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	var(Wx),
	wellDefined_ChangeWeight(Wy),
	infl(Env,World,X,Y,Wxy),
	not(given_change(Env,World,X,_)),
	bagof(W,Z^changingInfl(Env,World,Z,Y,W),Ws),
	weightOf_SimultChange([Wy1|Ws],Wy),
	weightOf_change(Wx,Wxy,Wy1).

abduce(EnvName,MS,change(X,Wx),change(Y,Wy),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	infl(Env,World,X,Y,Wxy),
	not(given_change(Env,World,_,_)),
	weightOf_change(Wx,Wxy,Wy).

abduce(EnvName,MS,change(X,Wx),change(X,Wx),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	wellDefined_attribute(Env,World,X),
	not(given_change(Env,World,X,_)),
	wellDefined_ChangeWeight(Wx).

/***********************************************************************
 *
 * abduce(+EnvName,+MS,+-Hypothesis,+-Consequent).
 *
 *	Succeeds if Consequent follows under the hypothesis Hypothesis.
 *
 *	Hypothesis and Consequent are of the form:
 *		increase(+-X), decrease(+-X), noChange(+-X). 
 */

abduce(EnvName,MS,Hypothesis,Consequent,[]) :-
	var(Hypothesis),
	nonvar(Consequent),
	once(default_change(Consequent,WeightedConsequent)),
	abduce(EnvName,MS,change(X,Wx),WeightedConsequent,[]),
	once(default_change(Hypothesis,change(X,Wx),[])).

abduce(EnvName,MS,Hypothesis,Consequent,[]) :-
	nonvar(Hypothesis),
%	var(Consequent),
	once(default_change(Hypothesis,WeightedHypothesis)),
	abduce(EnvName,MS,WeightedHypothesis,change(Y,Wy),[]),
	once(default_change(Consequent,change(Y,Wy))).

/***********************************************************************
 *
 * abduce(+EnvName,+MS,+Changes,+-change(+-Y,+-W)).
 *
 *	Succeeds if change(+-Y,+-W) follows under the hypotheses of 
 *	Changes.
 *	Changes is a list of changes of the form change(+-X,+W).
 */

abduce(EnvName,MS,Hs,change(Y,W),[]) :-
	get_Env_World(EnvName,MS,Env,World),
	nonvar(Hs),
	aux_abduce(Env,World,Hs,change(Y,W),Ws),
	wellDefined_SimultChanges(Hs),
	weightOf_SimultChange(Ws,W).

/***********************************************************************
 *
 * abduce(+EnvName,+MS,+-Hypotheses,+-Consequent).
 *
 *	Succeeds if Consequent follows under the hypotheses Hypotheses.
 *
 *	Hypotheses  is a list of 
 *		increase(+-X), decrease(+-X), noChange(+-X). 
 *	predicates and Consequent is one of these.
 */

abduce(EnvName,MS,Hypotheses,Consequent,[]) :-
	nonvar(Hypotheses),
	nonvar(Consequent),
	once(default_changes(Hypotheses,WeightedHypotheses)),
	once(default_change(Consequent,WeightedConsequent)),
	abduce(EnvName,MS,WeightedHypotheses,WeightedConsequent,[]).

abduce(EnvName,MS,Hypotheses,Consequent,[]) :-
	nonvar(Hypotheses),
%	var(Consequent),
	once(default_changes(Hypotheses,WeightedHypotheses)),
	abduce(EnvName,MS,WeightedHypotheses,change(Y,Wy),[]),
	once(default_change(Consequent,change(Y,Wy))).

/***********************************************************************
 *
 * abduce(+EnvName,+MS,+-Change,+-Changes).
 *
 *	Succeeds if Changes are hold under the hypothesis that Change
 *	holds.
 *
 *	Changes (respectively Change) is a list of changes 
 *	(respectively a change) of the form change(+-X,+-W).
 */

abduce(EnvName,MS,Change,Changes,[]) :-
	nonvar(Changes),
	aux2_abduce(EnvName,MS,Change,Changes).

/***********************************************************************
 *
 * abduce(EnvName,MS,+-Hypothesis,+-Consequents).
 *
 *	Succeeds if Consequents follow under the hypothesis Hypothesis.
 *
 *	Hypothesis is of the form:
 *		increase(+-X), decrease(+-X), noChange(+-X). 
 *	Consequents is a list of these.
 */

abduce(EnvName,MS,Hypothesis,Consequents,[]) :-
	nonvar(Hypothesis),
	nonvar(Consequents),
	once(default_change(Hypothesis,WeightedHypothesis)),
	once(default_changes(Consequents,WeightedConsequents)),
	abduce(EnvName,MS,WeightedHypothesis,WeightedConsequents,[]).

abduce(EnvName,MS,Hypothesis,Consequents,[]) :-
	var(Hypothesis),
	nonvar(Consequents),
	once(default_changes(Consequents,WeightedConsequents)),
	abduce(EnvName,MS,change(X,Wx),WeightedConsequents,[]),
	once(default_change(Hypothesis,change(X,Wx))).





/***********************************************************************
 *
 * allowedAnswerConcept(+C)
 * true iff C is a concept introduced by the user. No concept names
 * introduces by the system or concept terms are allowed as answer.
 *
 */

allowedAnswerConcept(Env,C) :-
	atomic(C),
	!,
	clause(conceptName(Env,_,_,C),_),
	!.
% allowedAnswerConcept(Env,C) :-
%	atomic(C),
%	conceptEqualSets(Env,user,_,C,_,_),
%	!.
% allowedAnswerConcept(Env,C) :-
%	atomic(C),
%	conceptEqualSets(Env,user,_,_,C,_),
%	!.
%allowedAnswerConcept(Env,C) :-
%	atomic(C),
%	conceptSubsets(Env,user,_,C,_,_),
%	!.
%allowedAnswerConcept(Env,C) :-
%	atomic(C),
%	conceptSubsets(Env,user,_,_,C,_).
allowedAnswerConcept(Env,C) :-
	nonvar(C),
	C = not(D),
	!,
	nonvar(D),
	not(D = not(E)),
	!,
	allowedAnswerConcept(Env,D).
allowedAnswerConcept(_,normalWorld(_)) :-
	!,
	fail.
allowedAnswerConcept(_,not(normat(_))) :-
	!,
	fail.
allowedAnswerConcept(Env,C) :-
	not(atomic(C)),
	!.

/***********************************************************************
 *
 * inconsistent(+EnvName)
 *
 */


inconsistent :-
	getCurrentEnvironment(EnvName),
	inconsistent(EnvName,[]).

inconsistent(EnvName) :-
	nonvar(EnvName),
	environment(EnvName,_,_),
	inconsistent(EnvName,[]).
inconsistent(MS) :-
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	inconsistent(EnvName,MS).

inconsistent(EnvName,MS) :-
	environment(EnvName,Env,_),
	convertMS(negative,Env,[[],true],MS,[],[W1,G1],_),
	constructMLHead(Env,rn(_AX1,_RN1,user,_O1),W1,C,X,[or([]),rl([]),fl(_DML1)],noAb,[],_,InHead1),
	call((call(G1), InHead1)),
	getConstraint(InHead1,X),
	atomic(X),
	constructMLHead(Env,rn(_AX2,_RN2,_S2,_O2),W1,not(C),X,[or([]),rl([]),fl(_DML1)],noAb,[],_,InHead2),
	call((call(G1), InHead2)).

/***********************************************************************
 *
 * consistent(+EnvName)
 *
 */

consistent :-
	not(inconsistent).

consistent(EnvName) :-
	nonvar(EnvName),
	environment(EnvName,_,_),
	not(inconsistent(EnvName,[])).
consistent(MS) :-
	(MS = [] ; MS = [_|_]),
	getCurrentEnvironment(EnvName),
	not(inconsistent(EnvName,MS)).

consistent(EnvName,MS) :-
	not(inconsistent(EnvName,MS)).

/***********************************************************************
 *
 *
 */

metaReasoning :-
	constructMLHead(Env,rn(ti,ti,system,lInR),W1,C,X,
			_HYPS,_D,_CALLS,inconsistency,InHead1),
	constructMLHead(Env,rn(ti,ti,system,lInR),W1,not(C),X,
			_HYPS,_D,_CALLS,inconsistency,InHead2),
	Lit11 = not(inconsistencyCheck(_,_,_)),
	Lit13 = assertaRE(InHead2),
	Lit14 = assertaRE(inconsistencyCheck(MS,C,X)),
	Lit15 = tryInconsistency(MS,C,X,InHead2),
	assertzRE((InHead1 :- atomic(C), atomic(X), Lit11, Lit13, Lit14, Lit15)),
	Lit23 = assertaRE(InHead1),
	Lit24 = assertaRE(inconsistencyCheck(MS,C,X)),
	Lit25 = tryInconsistency(MS,C,X,InHead1),
	assertzRE((InHead2 :- atomic(C), atomic(X), Lit11, Lit23, Lit24, Lit25)).


tryInconsistency(MS,C,X,InHead) :-
	inconsistent(MS),
	!,
	retract(inconsistencyCheck(MS,C,X)),
	retract(InHead).
tryInconsistency(MS,C,X,InHead) :-
	!,
	retract(inconsistencyCheck(MS,C,X)),
	retract(InHead),
	!,
	fail.

/**********************************************************************
 *
 *
 *
 */

% realize(EnvName,MS,X,CL) :-
% 	environment(EnvName,Env,_),
%	conceptHierarchy(Env,MS,Tree1),
% 	conceptElement(Env,MS,_,user,X,C1,_),
%	search(C1,Tree1,TreeList),
%	realizeArgs(EnvName,MS,X,TreeList,CL).
realize(EnvName,MS,X,CL) :-
	setofOrNil(C,deduce(EnvName,MS,elementOf(X,C)),CL).

realizeDag(EnvName,MS,X,node(CL,AL),CL1) :-
	realizeArgs(EnvName,MS,X,AL,CL0),
	realizeNode(EnvName,MS,X,CL,CL0,CL1).

realizeArgs(_,_,_,[],[]) :-
	!.
realizeArgs(EnvName,MS,X,[C|AL],CL3) :-
	realizeDag(EnvName,MS,X,C,CL1),
	realizeArgs(EnvName,MS,X,AL,CL2),
	append(CL1,CL2,CL3).

realizeNode(EnvName,MS,X,_CL,[C0|CL0],[C0|CL0]) :-
	!.
realizeNode(EnvName,MS,X,[C|CL],[],CL1) :-
	deduce(EnvName,MS,elementOf(X,C),_),
	!,
	CL1 = [C|CL].
realizeNode(_,_,_,_,_,[]) :-
	!.

sbAsk(EnvName,MS,X,CL) :-
	environment(EnvName,Env,_),
	conceptHierarchy(Env,MS,Tree1),
	askDag(EnvName,MS,X,Tree1,CL).

askDag(EnvName,MS,X,node(CL,AL),CL1) :-
	askArgs(EnvName,MS,X,AL,CL0),
	askNode(EnvName,MS,X,CL,CL0,CL1).

askArgs(_,_,_,[],[]) :-
	!.
askArgs(EnvName,MS,X,[C|AL],CL3) :-
	askDag(EnvName,MS,X,C,CL1),
	askArgs(EnvName,MS,X,AL,CL2),
	append(CL1,CL2,CL3).

askNode(_EnvName,_MS,_esX,CL,[C0|CL0],CL1) :-
	!,
	append([C0|CL0],CL,CL1).
askNode(EnvName,MS,X,[C|CL],[],CL1) :-
	deduce(EnvName,MS,elementOf(X,C),_),
	!,
	CL1 = [C|CL].
askNode(_,_,_,_,_,[]) :-
	!.

/**********************************************************************
 *
 * completeParameter(+ParameterList,-EnvName,-MS,-Query,-Proof)
 * takes a list of parameters ParameterList and instantiates the
 * variables EnvName,MS,Query,Proof correctly.
 *
 */

completeParameter([Query],EnvName,[],Query,_Proof) :-
	getCurrentEnvironment(EnvName),
	!.
completeParameter([P1,P2],P1,_MS,P2,_Proof) :-
	var(P1),
	!.
completeParameter([P1,P2],P1,_MS,P2,_Proof) :-
	nonvar(P1),
	atomic(P1),
	P1 \== [],
	!.
completeParameter([P1,P2],EnvName,P1,P2,_Proof) :-
	nonvar(P1),
	(P1 = [] ; P1 = [_|_]),
	!,
	getCurrentEnvironment(EnvName).
completeParameter([P1,P2],EnvName,[],P1,P2) :-
	nonvar(P1),
	!,
	getCurrentEnvironment(EnvName).
completeParameter([P1,P2,P3],P1,P2,P3,_Proof) :-
	var(P1),
	var(P2),
	!.
completeParameter([P1,P2,P3],P1,P2,P3,_Proof) :-
	nonvar(P1),
	atomic(P1),
	P1 \== [],
	var(P2),
	!.
completeParameter([P1,P2,P3],EnvName,P1,P2,P3) :-
	nonvar(P1),
	(P1 = [] ; P1 = [_|_]),
	!,
	getCurrentEnvironment(EnvName).
completeParameter([P1,P2,P3],P1,P2,P3,_Proof) :-
	nonvar(P2),
	(P2 = [] ; P2 = [_|_]),
	!.
completeParameter([P1,P2,P3],P1,[],P2,P3) :-
	nonvar(P1),
	atomic(P1),
	P1 \== [],
	!.
completeParameter([P1,P2,P3],P1,[],P2,P3) :-
	!.
completeParameter([P1,P2,P3,P4],P1,P2,P3,P4) :-
	!.


/***********************************************************************
 *
 * getCurrentConcepts(-LC)
 *  list of all concepts in the current knowledge base
 * getCurrentRoles(-LR)
 *  list of all roles in the current knowledge base
 * getCurrentAxioms(-LAx)
 *  list of all axioms in the current knowledge base
 * 
 */


getCurrentConcepts(LC) :-
    getCurrentEnvironment(EnvName), 
    environment(EnvName, Env,_), 
    setofOrNil(C,[MS,W,B]^clause(conceptName(Env,MS,W,C),B),LC).
getCurrentRoles(LR) :-
    getCurrentEnvironment(EnvName), 
    environment(EnvName, Env,_), 
    setofOrNil(R,[MS,W,B]^clause(roleName(Env,MS,W,R),B),LR).
getCurrentAxioms(LAx) :-
    getCurrentEnvironment(EnvName), 
    environment(EnvName, Env,_), 
    setofOrNil(defprimconcept(MS1,C1,D1),[Ax1,B1]^clause(conceptSubsets(Env,user,MS1,C1,D1,Ax1),B1),LAx1),
    setofOrNil(defconcept(MS2,C2,D2),[Ax2,B2]^clause(conceptEqualSets(Env,user,MS2,C2,D2,Ax2),B2),LAx2),
    setofOrNil(defprimrole(MS3,R3,S3),[Ax3,B3]^clause(roleSubsets(Env,user,MS3,R3,S3,Ax3),B3),LAx3),
    setofOrNil(defrole(MS4,R4,S4),[Ax4,B4]^clause(roleEqualSets(Env,user,MS4,R4,S4,Ax4),B4),LAx4),
    setofOrNil(assert_ind(MS5,X5,C5),[Ax5,B5,W5]^clause(conceptElement(Env,MS5,W5,user,X5,C5,Ax5),B5),LAx5),
    setofOrNil(assert_ind(MS6,X6,Y6,R6),[Ax6,B6,W6]^clause(roleElement(Env,MS6,W6,user,X6,Y6,R6,Ax6),B6),LAx6),
    append(LAx1,LAx2,LAx12),
    append(LAx3,LAx4,LAx34),
    append(LAx5,LAx6,LAx56),
    append(LAx12,LAx34,LAx14),
    append(LAx14,LAx56,LAx).


/**********************************************************************
 *
 * @(#) initCall.pl 1.6@(#)
 *
 */

:- nl, nl.
:- write('Welcome to MOTEL (Version 0.8.11 Feb 1994)').
:- nl.
:- write('Copyright (c) 1993, Patrick Brandmeier, Ullrich Hustadt').
:- nl.
:- write('                    Renate Schmidt, Jan Timm. All rights preserved.').
:- nl, nl.
:- write('MOTEL is distributed in the hope that it will be useful, but').
:- nl.
:- write('WITHOUT ANY WARRANTY;  without even the implied warranty of,').
:- nl.
:- write('MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.').
:- nl, nl.
:- initialize.

% ======================================================================
% Purpose:
% This takes logical sentence FmlIn and turns treated_as_function/1s into predicates except inside not_treated_as_function_while_inside/1.
% ======================================================================
% :-include('moo_header.pl').

:-dynamic(not_treated_as_function_while_inside/1).
:-dynamic(treated_as_function/1).
:-dynamic(is_a_function/1).
       

% Functional Normal Form - Removes Functions and replaces with NewVars then puts them in Flags with information
getFunctionalForm(Axiom,NewFlags,NewVars,OTerm):-
       % true,
	logOnFailure(getFunctionFlags(toplevel,1,GFlags,Axiom)),!,
	% true,
	logOnFailure(setFunctionFlags(GFlags,Axiom,NewFlags,NewVars,OTerm)),!. % apply flags

setFunctionFlags([],Axiom,[],[],Axiom):-!.

setFunctionFlags([dom(V,D)|MoreFlags],Axiom,[dom(V,D)|NewFlags],NewVars,OTerm):-  %Skip Over flags
		setFunctionFlags(MoreFlags,Axiom,NewFlags,NewVars,OTerm),!.

setFunctionFlags([fun(Caller,ArgN,F,Term)|MoreFlagsIn],Axiom,NewFlags,NewVars,OTerm):-
	subst(Axiom,Term,NewVar,MAxiom),
	Axiom==MAxiom, !,% Function Gone Already (Do nothing)
	%writeq(notfound(fun(Caller,ArgN,F,Term),Axiom)),nl,
	setFunctionFlags(MoreFlagsIn,MAxiom,NewFlags,NewVars,OTerm),!.

setFunctionFlags([fun(Caller,ArgN,F,Term)|MoreFlagsIn],Axiom,[dom(NewVar,[Caller:ArgN,F:range])|NewFlags],[NewVar|NewVars],OTerm):-
	pvar_gen(NewVar),
	subst(Axiom,Term,NewVar,MAxiom),
	%writeq(found(fun(Caller,ArgN,F,Term),Axiom)),nl,
	Term =.. TermL,
	append(TermL,[NewVar],FunctionL),!,
	Holds=..[holds|FunctionL],
	%subst(MoreFlagsIn,Term,NewVar,MoreFlags),
	setFunctionFlags(MoreFlagsIn,(Holds) => MAxiom,NewFlags,NewVars,OTerm),!.

setFunctionFlags([NF|MoreFlags],Axiom,[NF|NewFlags],NewVars,OTerm):-  %Skip Over flags
		setFunctionFlags(MoreFlags,Axiom,NewFlags,NewVars,OTerm),!.
		
getFunctionFlags(Caller,ArgN,[dom(Term,[Caller:ArgN])],Term):- isSlot(Term),!.

getFunctionFlags(Caller,ArgN,[],Term):- not(compound(Term)),!. % catches Term=[].

getFunctionFlags(Caller,ArgN,Flags,Term):-
	Term=..['holds',F|ArgS],!,
	logOnFailure(getFunctionFlags_l(F,1,Flags,ArgS)).

getFunctionFlags(Caller,ArgN,Flags,Term):-
	Term=..['AssignmentFn',F|ArgS],!,
	logOnFailure(getFunctionFlags_l(F,1,Flags,ArgS)).

getFunctionFlags(Caller,ArgN,Flags,Term):-
	Term=..[Q,V|MTerm],memberchk(Q,[forall,exists]),!,
	logOnFailure(getFunctionFlags_l(toplevel,1,Flags,MTerm)).

getFunctionFlags(Caller,ArgN,Flags,[A|ArgS]):-!, %true,
	logOnFailure(getFunctionFlags_l(Caller,ArgN,Flags,[A|ArgS])).

getFunctionFlags(Caller,ArgN,Flags,Term):-
	Term=..[F|ArgS],hlPredicateAttribute(F,'Function'),!,
	logOnFailure(getFunctionFlags_l(F,1,FlagsM,ArgS)),
	append(FlagsM,[fun(Caller,ArgN,F,Term)],Flags).
		
		
% Special case for Instance
getFunctionFlags(Caller,ArgN,[dom(A,['$instanceof':Class])],instance(A,Class)):-isSlot(A),atom(Class),!.

getFunctionFlags(Caller,ArgN,Flags,Term):-!, %true,
	Term=..[F|ArgS],
	logOnFailure(getFunctionFlags_l(F,1,Flags,ArgS)).
	
getFunctionFlags_l(Caller,N,[],[]).
getFunctionFlags_l(Caller,N,Flags,[Arg|S]):-
	getFunctionFlags(Caller,N,Flags1,Arg),
	NN is N+1,
	getFunctionFlags_l(Caller,NN,Flags2,S),
	append(Flags1,Flags2,Flags),!.

   
test_extend_functions(Term):-
     %  numbervars(Term,'$VAR',15,_),
	extend_rewrites(Term,Best),!,
	format('<pre><B><font color=green>~w</font></B>\n',['Original']),
	write_conj_test_function(KRVars,Term),
	format('<pre><B><font color=green>~w</font></B>\n',['Functions']),
	write_conj_test_function(KRVars,Best),
	format('<B><font size color=red>Compiled</font></B>\n'),
	getAssertionClauses(Context,Term,Clauses,KRVars,How),!,
	write_conj_test_function(KRVars,Clauses),
	format('\n\n</pre>').
				
write_conj_test_function(KRVars,A):-(write_conj_test_function1(KRVars,A)).

write_conj_test_function1(KRVars,A):-isSlot(A),format('~q\n',A),!.
write_conj_test_function1(KRVars,and(A,B)):-
	write_conj_test_function1(KRVars,A),!,
	write_conj_test_function1(KRVars,B).
write_conj_test_function1(KRVars,Term):-
	toMarkUp(kif,Term,KRVars,O),!,
	format('<pre>\n\n~w\n\n</pre>',[O]).
	

remove_true(O,O):-isSlot(O),!.
remove_true(I,O):-remove_true1(I,M),!,
	((M==I,O=I);remove_true(M,O)),!.

remove_true1(O,O):-isSlot(O),!.
remove_true1(O,O):-not(compound(O)),!.

% true => Fact -> Fact
remove_true1('=>'(True,Original),Out):-
	True==true,!,
	remove_true1(Original,Out).

/*
% Fact => Fact -> true
remove_true1('=>'(True,Original),true):-
	True==Original,!.
*/
% true <=> Fact
remove_true1('<=>'(True,Original),Out):-
	True==true,!,
	remove_true1(Original,Out).

% Original <=> true -> Original
remove_true1('<=>'(Original,True),Out):-
	True==true,!,
	remove_true1(Original,Out).

/*
% Original <=> Original -> Original
remove_true1('<=>'(True,Original),Out):-
	True==Original,!,
	remove_true(Original,Out).
*/
remove_true1([A|AL],[B|BL]):-
	remove_true1(A,B),
	remove_true1(AL,BL).

remove_true1(Term,Out):-
	Term=..[Save|List],
	remove_true1(List,OutL),!,
	Out=..[Save|OutL].
	
remove_true1(O,O).


% ======================================================================
% Code for Holds Expansion
% ======================================================================
/*
  (=>
          (instance ?PROCESS Process) 
          (exists
             (?CAUSE) 
             (effector ?PROCESS ?CAUSE) ) )


  (entails 
          (instance ?PROCESS Process) 
          (exists
             (?CAUSE) 
             (effector ?PROCESS (skolemFn (EffectorProcessSKFn ?PROCESS))
	     


(entails 
        (instance ?PROCESS Process) 
	(if-else (effector ?PROCESS ?CAUSE)) (equals ?CAUSE (

	(effector ?PROCESS (skolemFn (EffectorProcessSKFn ?PROCESS))
	     


	     


*/

extend_rewrites(A,A):-!.


extend_rewrites(A,C):-
	get_do_job(A,B),!,
	((A==B,!,C=B);extend_rewrites(B,C)),!.	 


get_do_job(Original,Original):-isSlot(Original),!.
		
get_do_job(Original,Done):-
	get_job_sent(Original,Original,[],Tasks),!,
	do_job_until_done(Tasks,Original,Done),!.
	
get_do_job(Original,Original):-!.


% Skip getPrologVars and some terms
get_job_sent(Original,Term,In,Tasks):-
	((isSlot(Term);
	atom(Term);
	list(Term);
	number(Term))),!,fail.

% ( ....... ....... .......)
get_job_sent(Original,Holds,In,Tasks):-
	Holds=..[Start,Pred|Args],!,
	get_job_sent_t(Original,Holds,Start,Pred,Args,In,Tasks).

	
	
	% (holds .......)
	get_job_sent_t(Original,Holds,holds,Pred,Args,In,Tasks):-
		get_job_sent_holds(Original,Holds,Pred,Args,In,Tasks).
	
				% (holds ?Relation ............... )  Catches has_sub_jobs
				get_job_sent_holds(Original,Holds,Pred,Args,In,Tasks):-
					is_a_var(Pred),!,
					get_job_sent_holds_args(Original,Holds,Pred,Args,In,Tasks).
				
				% (holds equals ?? ??) Rewrite ( equals ?? ??)
				get_job_sent_holds(Original,Holds,equals,[A,B],[subst(Holds,equals(A,B)),restart]):-!.      		
					
				% (holds someFn A ) 
				get_job_sent_holds(Original,Term,FnA,Args,In,Tasks):-
					hlPredicateAttribute(FnA,'Function'),
					get_job_sent_holds_args_fn(Original,Term,FnA,!,Args,In,Tasks).
					
				
			get_job_sent_holds_args_fn(Original,Term,Funct,N,[],[]):-!.
			get_job_sent_holds_args_fn(Original,Term,Funct,N,[Node|Rgs],[Todo|Tasks]):-
					get_job_sent_term_fn(Original,Term,Funct,N,Node,Todo),NN is N+1,
					get_job_sent_holds_args(Original,Term,Funct,NN,Rgs,In,Tasks),!.

			%get_job_sent_term_fn(Original,Term,Funct,N,Node,In,[addconstraint()]):-isSlot()
			get_job_sent_term_fn(Original,Term,Funct,N,Node,In,In):-not(compound(Node)),!.
			get_job_sent_term_fn(Original,Term,Funct,N,Node,In,In):-is_list(Node),!.
			get_job_sent_term_fn(Original,Term,Funct,N,Node,[subst(Node,NewVar),addprecond(NTerm),domain(NTerm)]):-
					fn_to_holds(Node,[T|ErmL],NewVar,NTerm),
					hlPredicateAttribute(T,'Function'),!.
			get_job_sent_term_fn(Original,Term,Funct,Node,In,In):-!.	
					
				
				% (holds pred ????) Catches has_sub_jobs
				get_job_sent_holds(Original,Holds,Pred,Args,In,Tasks):-
					get_job_sent_holds_args(Original,Holds,Pred,1,Args,In,Tasks).


					get_job_sent_holds_args_pred(Original,Holds,Pred,N,[],[]):-!.
					get_job_sent_holds_args_pred(Original,Holds,Pred,N,[Node|Rgs],[Todo|Tasks]):-
							get_job_sent_term(Original,Holds,Pred,N,Node,Todo),NN is N+1,
                                                        get_job_sent_holds_args(Original,Holds,Pred,NN,Rgs,In,Tasks),!.


      			
		  

      		

	% (AssignmentFn .......)
	get_job_sent_t(Original,Holds,'AssignmentFn',Funct,Args,In,Tasks):-
		Holds=..['AssignmentFn',Funct|Args],!,
		get_job_sent_AssignmentFn(Original,Holds,Funct,Args,In,Tasks).

				% (AssignmentFn ?? Fn)
				get_job_sent_AssignmentFn(Original,Holds,Funct,Args,In,Tasks):-
					has_sub_job(Original,Args),
					get_job_sent(Original,Args,In,Tasks),!.
						
				% (AssignmentFn ?? ?Args)
				get_job_sent_AssignmentFn(Original,Holds,Funct,Args,[subst(Holds,FNTerm),addprocond(Holds),restart]):-
					is_a_var(Funct),
					append([holds,Funct|Args],[NewVar],HoldsL),
					Predicate =.. PredicateL,!.
				
				% (AssignmentFn Fn ?Args)
				get_job_sent_AssignmentFn(Original,Holds,Funct,Args,[subst(Holds,NewVar),addcons(Holds),restart]):-
					hlPredicateAttribute(Funct,'Function'),
					append([holds,Funct|Args],[NewVar],HoldsL),
					Predicate =.. PredicateL,!.

	% (FnA ............)  % Catches has_sub_jobs
	get_job_sent_t(Original,Holds,FnA,Funct,Args,In,Tasks):-
		hlPredicateAttribute(FnA,'Function'),!,
		get_job_sent_function(Original,Holds,FnA,[Funct|Args],In,Tasks),!.
		
			% (FnA ????)  % Catches has_sub_jobs
			get_job_sent_function(Original,Holds,FnA,Args,In,Tasks):-
				get_job_sent(Original,Args,In,Tasks),!.
			
			% (FnA ?Args)
			get_job_sent_function(Original,Holds,FnA,Args,[subst(Holds,NewVar),addprecond(FHolds),restart]):-
				fn_to_holds(Holds,NewVar,FHolds),!.


	% (equals ............ )
	get_job_sent_t(Original,Holds,equals,A,[B],In,Tasks):-
		get_equals_job(Original,Holds,A,B,In,Tasks).				
				

				% (equals ?X ?X)   (equals (FnA ?X) (FnA ?X)) 
				get_equals_job(Original,Holds,A,B,[delete(Holds)]):-A==B,!.
				
				% (equals ?A ?B) 
				get_equals_job(Original,Holds,A,B,[delete(Holds),subst(A,B)]):-
					isSlot(A),isSlot(B),!.
				
				% (equals (FnA (FnA ?X)) ??)
				get_equals_job(Original,Holds,A,B,subfuncts):-isEntityFunction(A,FnA,ArgsA),has_sub_job(Original,A),!,fail.
				
				% (equals ?? (FnB (FnA ?X)) )
				get_equals_job(Original,Holds,A,B,subfuncts):-isEntityFunction(B,FnB,ArgsB),has_sub_job(Original,B),!,fail.
				
				get_equals_job(Original,Holds,A,B,In,Tasks):-
					isEntityFunction(A,FnA,ArgsA),
					isEntityFunction(B,FnB,ArgsB),
					get_job_sent_equal_fns(Original,Holds,A,FnA,ArgsA,B,FnB,ArgsB,In,Tasks),!.
				
				% (equals (FnA ?X) (FnB ?Y))
				get_job_sent_equal_fns(Original,Holds,A,FnA,ArgsA,B,FnB,ArgsB,[delete(Holds),subst(A,NV),subst(B,NV),addcons(AH <=> BH)]):-
					fn_to_holds(B,NV,AH),
					fn_to_holds(A,NV,BH),!.
					
				% (equals (FnA ??) ?B)
				get_equals_job(Original,Holds,A,B,[delete(Holds),subst(A,B),addprecond(AH)]):-
					isEntityFunction(A,FnA,ArgsA),isSlot(B),
					fn_to_holds(A,B,AH),!.
					
				% (equals ?A (FnB ?X))
				get_equals_job(Original,Holds,A,B,[delete(Holds),subst(B,A),addprecond(BH)]):-
					isEntityFunction(B,FnB,ArgsB),isSlot(A),
					fn_to_holds(B,A,BH),!.


% Recurse downward
get_job_sent(Original,Holds,In,Tasks):-
	Holds=..[_|Args],!,
	get_job_sent(Original,Args,In,Tasks).

has_sub_job(Original,Args):- (not(not(get_job_sent(Original,Args,_)))),!.
no_sub_job(Original,Arg):-((Arg=..[_|Args],!,no_sub_job(Original,Args))).
no_sub_job(Original,Args):-((not(get_job_sent(Original,Args,_)))),!.


% ===========================================================
% do_job(+Tasks,+Original,?Done)
% do_job_w_status(+Tasks,+Original,?Done,?HasTasksLeft)
% ===========================================================
not_a_function(F):-not(hlPredicateAttribute(F,'Function')).

not_part_of(Term,Original):-subst(Original,Term,foo,Changed),!,Original==Changed.


do_job_until_done(Tasks,Original,Done):-
	do_job_w_status(Tasks,Original,Mid,HasTasksLeft),!,
	 (HasTasksLeft -> do_job_until_done(Tasks,Mid,Done) ; Done=Mid),!.		

do_job_w_status(Tasks,Original,Done,HasTasksLeft):-
	do_job(Tasks,Original,Original,Done),!,
		(Original==Done -> HasTasksLeft=fail ;HasTasksLeft=true),!.


do_job(Tasks,Original,Done):-
	do_job(Tasks,Original,Original,Done),!.

do_job([],Original,Done,Done):-!.
do_job(_,Original,Done,Done):-isSlot(Done),!.
do_job([Task|List],Original,Start,Done):-
	do_job(Task,Original,Start,Lunch),
	do_job(List,Original,Lunch,Done),!.
	
do_job(subst(This,That),Original,Start,Done):-subst(Start,This,That,Done),!.
do_job(replace(This,That),Original,Start,Done):-subst(Start,This,That,Done),!.
do_job(delete(That),Original,Start,Done):-!,do_job(subst(That,true),Original,Start,Done),!.
do_job(delete(That),Original,Start,Done):-!,do_job(subst(That,true),Original,Start,Done),!.
do_job(addprecond(That),Original,Start,Done):-
	do_job(delete(That,true),Original,Start,Mid),
	do_job(simplify,Original,entails(That,Mid),Done).

do_job(simplify,Original,Start,Done):-getLogicalReduction(Start,Done).

do_job(Tasks,Original,Done,Done):-!.


% funct
do_job(funct,Original,Found,Out):-
	once((fn_to_holds(Found,NewVar,Holds),
	replc(Original,equal(Found,NewVar),Holds,Out))),
	Out\==Original,!.
do_job(funct,Original,Found,Out):-
	once((fn_to_holds(Found,NewVar,Holds),
	replc(Original,equal(NewVar,Found),Holds,Out))),
	Out\==Original,!.
do_job(funct,Original,Found,(Holds=>Out)):-
	fn_to_holds(Found,NewVar,Holds),
	subst(Original,Found,NewVar,Out),!.
do_job(funct,Original,Found,Original).	

fn_to_holds(Term,[T|ErmL],NewVar,Holds):-
      Term=..[T|ErmL],
	append([holds|TermL],[NewVar],HoldsL),
	Holds=..HoldsL,!.

fn_to_holds(Term,NewVar,Holds):-
      Term=..TermL,
	append([holds|TermL],[NewVar],HoldsL),
	Holds=..HoldsL,!.
	
is_a_equals(V):-isSlot(V),!,fail.
is_a_equals(equal).


% ======================================================================
% Testing
% ======================================================================
				 
ef0:-test_extend_functions(equal('AFn'(A),'1Fn'(A))).
ef1:-catch(test_extend_functions('AFn'(A)),E,write(E)).
ef2:-test_extend_functions(equal('AFn'(A),'1Fn'(B))).
ef3:-test_extend_functions(=>(equal('SquareRootFn'(A), B), equal('MultiplicationFn'(B, B), A))).
ef4:-test_extend_functions(=>(instance(A, 'NegativeRealNumber'), equal('SignumFn'(A), -1))).
ef5:-test_extend_functions(=>(instance(A, 'NegativeRealNumber'), equal('SignumFn'(A), 'SignumFn'(-1)))).
ef6:-test_extend_functions(instance(fooFn, 'FunctionRealNumber')).
ef7:-test_extend_functions(equal(fooFn, 66)).
ef8:-test_extend_functions(=>(equal(V, 66),isa(V,'Number'))).
ef8i:-test_extend_functions(=>(isa(V,'Number'),equal(V,66))).
ef9:-test_extend_functions(=>(equal('EndFn'(A), B), forall(C, =>(and(temporalPart(C, A), not(equal(C, B))), before(C, B))))).
ef10:-test_extend_functions(=>(origin(A, B), located('WhereFn'(A, 'BeginFn'('WhenFn'(A))), 'WhereFn'(B, 'BeginFn'('WhenFn'(B)))))).
ef11:-test_extend_functions(=>(instance(A, human), exists(B, part(B, A)))).

% ===================================================================
% COMPLIER OPTIONS
% ===================================================================

% ==================================================
% Intrinsic Keywords (used by compile_conditionals)
% ==================================================

% Gets compiled as Formula connectives 
:-dynamic(hlPredicateAttribute/2).


hlPredicateAttribute(X,'SententialOperator'):-
	hlPredicateAttribute(X,connective).
hlPredicateAttribute(X,connective):-
	hlPredicateAttribute(X,quantifier).

% FOL Quantifiers
hlPredicateAttribute(forall,quantifier).
hlPredicateAttribute(forall,not(exists)).
hlPredicateAttribute(exists,quantifier).
hlPredicateAttribute(exists,not(forall)).

% FOL Quantifiers
hlPredicateAttribute(possible,modop).
hlPredicateAttribute(possible,not(necessary)).
hlPredicateAttribute(necessary,modop).
hlPredicateAttribute(necessary,not(possible)).


hlPredicateAttribute(some,quantifier).
hlPredicateAttribute(some,notimplemented).
hlPredicateAttribute(some,quantifier).
hlPredicateAttribute(some,notimplemented).

% Junctions
hlPredicateAttribute(and,connective).
hlPredicateAttribute(and,not(or)).

hlPredicateAttribute(or,connective).
hlPredicateAttribute(or,not(and)).

% Implication/Equivalence/Entailment
hlPredicateAttribute((=>),connective).
hlPredicateAttribute((<=>),connective).
hlPredicateAttribute((entails),connective).

%Negation
hlPredicateAttribute(not,connective). % Explicit Negation
hlPredicateAttribute(naf,connective). % Negation by failure (prolog)

hlPredicateAttribute(instance,no_holds).

hlPredicateAttribute(instance,dag(subclass)).
hlPredicateAttribute(element,dag(subset)).

hlPredicateAttribute(subclass,no_holds).
hlPredicateAttribute(subrelation,no_holds).

hlPredicateAttribute(X,no_holds):-
	hlPredicateAttribute(X,hierarchical).

hlPredicateAttribute(holds,prefix(holds)).

hlPredicateAttribute(X,hierarchical):-
	hlPredicateAttribute(_,dag(X)).


hlPredicateAttribute(X,hierarchical):-atom(X),atom_concat('sub',_,X).
hlPredicateAttribute(X,'SkolemFunction'):-atom(X),atom_concat(_,'SkFn',X).
hlPredicateAttribute(X,'Function'):-atom(X),atom_concat(_,'Fn',X).

					 

ontology_hlPredicateAttribute(logicalConnective,holdsDuring).
ontology_hlPredicateAttribute(logicalConnective,skolem).
ontology_hlPredicateAttribute(logicalConnective,believes).
ontology_hlPredicateAttribute(logicalConnective,knows).
ontology_hlPredicateAttribute(logicalConnective,desires).
ontology_hlPredicateAttribute(logicalConnective,wants).
ontology_hlPredicateAttribute(logicalConnective,'KappaFn').

ontology_structure_functor('instance').

         
:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).



:- dynamic(count_beliefs_pred/1).
:- dynamic(trace_search_progress_pred/1).
:- dynamic(compile_explaination_printing/0).
:- dynamic(ncalls/1).
:- dynamic(dynamic_lemma/3).
:- dynamic(static_lemma/3).
:- dynamic(lemma_handling_flag/0).
:- dynamic(lemma_mode_parameter/1).
:- dynamic(lemma_format_parameter/1).
:- dynamic(lemma_type_parameter/1).
:- dynamic(body_hooks_flag/0).
:- dynamic(pred_hooks_flag/0).
:- dynamic(delta_ordering/1).
:- dynamic(verbose_flag/0).
:- dynamic(compile_complete_search/0).
	

count_beliefs_pred(flag(ncalls,NCalls,NCalls+1)).


trace_search :-                         % enables search progress reports
        retract(trace_search_progress_pred(_)),
        fail.
trace_search :-
        assert(trace_search_progress_pred(write_search_progress)).

dont_trace_search :-                    % disables search progress reports
        retract(trace_search_progress_pred(_)),
        fail.
dont_trace_search :-
        assert(trace_search_progress_pred(nop)).



request(M) :-                             % call request with depth bound M
	(compile_complete_search, compile_explaination_printing , lemma_handling_flag) ->
	        request(M,_N,_LemExplaination,_LemExplainationEnd,_Explaination,_ExplainationEnd);
        (compile_complete_search, (compile_explaination_printing ; lemma_handling_flag)) -> 
                request(M,_N,_Explaination,_ExplainationEnd);
        compile_complete_search ->
                request(M,_N).

request :-                                % unbounded search of request
        (compile_complete_search ->
	    request(1000000);
	%true ->
	    ((compile_explaination_printing , lemma_handling_flag) ->
	         request(_LemExplaination,_LemExplainationEnd,_Explaination,_ExplainationEnd);
	     (compile_explaination_printing ; lemma_handling_flag) -> 
		 request(Explaination,_ExplainationEnd);
             %true ->
		 request)).
	    



xtry:-
	mooCache(_ ,nnf(X,Flags,Id), _, _, _, _, _, _, _),
	format('~q.~n',[X]),fail.


mkm:-
	tell(mkm),
	show_relations,
	told.

get_relations(Context,Ctx):-
	retractall(fact_relation(_)),
	retractall(rule_relation(_,_)),
	fail.
	
/*
get_relations(Context,Ctx):-
	mooCache(R, _, Axiom, Vars, Context, Ctx, Tracking, User, Status),
	get_relation(R),
	Axiom = subrelation(W,_),
	get_relation(W),
	fail.
*/

	


get_relations(Context,Ctx):-
	mooCache(R,Cons, Ante, _, Logic, Context, Ctx, Explaination),
	get_relation(R),
	get_r_relation(R,Logic),
	fail.

get_relations(Context,Ctx):-listing(rule_relation),listing(fact_relation).

:-dynamic(rule_relation/2).
:-dynamic(fact_relation/1).

get_relation(R):-var(R),!,fail.

get_relation(R):-fact_relation(R),!.
get_relation(R):-rule_relation(R,_),!.
get_relation(R):-assert(fact_relation(R)).

get_r_relation(R,_):-var(R),!,fail.
get_r_relation(R,Logic):-
	rule_relation(R,Logic),!.
get_r_relation(R,Logic):-
	retractall(fact_relation(R)),
	asserta(rule_relation(R,Logic)),!.
	



mk_length(R,A,P):-
	getArity(R,A),!,
	length(L,A),
	numbervars(L,'$VAR',0,_),
	P=..[R|L].

getArity(R,A):-
	mooCache(valence, surface, valence(R,A), Vars, ContextName, Context, Tracking, User, Status).
getArity(R,A):-
	mooCache(R, surface, P, Vars, ContextName, Context, Tracking, User, Status),
	functor(P,R,A).
getArity(R,A):-
	mooCache(R, GAF, Vars, ContextName, Context, Tracking, User),
	functor(GAF,holds,HF),
	A is HF-1,!.
	
getArity(R,2):-!.

show_relations(R):-
	mk_length(R,A,P),!,
	show_relations(R,A,P).

show_relations(R,A,P):-	shown_rel(R,A),!.
show_relations(R,A,P):-	
	assert(shown_rel(R,A)),
	format(
'% ~q/~w
mapping_nt(~q,undefined).

',[R,A,P]),!.

/*
	
        time(dpttp1(X,Y:Z),'Compilation Phase I'),
	time(dpttp2(Name,Y:Z),'Compilation Phase II'),
	time(dpttp3(Name),'Compilation Phase III').
*/

%%% ----------------------------------------------------------------------
%%% XRay: THE ACTUAL COMPILATION PROCEDURES
%%%

xray(Name) :-
	read_theory(Name,Context),
	dpttp(Name,Context).
	

dpttp(Name,X) :-
        time(dpttp1(X,Y:Z),'Compilation Phase I'),
	time(dpttp2(Name,Y:Z),'Compilation Phase II'),
	time(dpttp3(Name),'Compilation Phase III').

dpttp(X) :-
	Name = 'temp',
	dpttp(Name,X).

dpttp1(X,Y:C) :-
        
        writeSTDERR('XRay input formulas:'),
        apply_to_conjuncts(X,write_clause,_),
        

	constants(X,H),
	(H = [] ->
	    true,writeSTDERR('Empty Herbrand universe.');
	 %true ->
	    true,writeSTDERR('Herbrand universe':H)),

	classical_clauses(X,C0),
	cnf(C0,C1),
	make_matrix(C1,C2),
	instantiation(C2,H,C3),
	matrix_reduction(C3,C),

        (verbose_flag ->
	     
	     writeSTDERR('Classical output formulas:'),
	     apply_to_list(C,write_clause,_),
	     true;
	%true ->
	     true),dpttp1(X,C,Y:C).

dpttp1(X,C,Y:C) :- 
	request_clause(X,Q0),
	variables(Q0,Vars),
	(Vars=[] ->
	         cnf(Q0,Q1),
		 make_matrix(Q1,Q2),
		 matrix_reduction(Q2,Q),

		 XQ=X;
	%true ->
		 Q = [],

		 apply_to_conjuncts(X,add_answer_preds,XQ)),

        (verbose_flag ->
	     
	     writeSTDERR('Request formula:'),
	     apply_to_conjuncts(Q0,write_clause,_),
	     
	     writeSTDERR('      compiled:'),
	     apply_to_list(Q,write_clause,_),
	     true,true;
	%true ->
	     true), dpttp1(XQ,Q,C,Y:C).

dpttp1(X,Q,C,Y:C) :- 
        clauses(X,XC,1),

	constants(X,H),
	(H = [] ->
	    XH=true,
	    X0=XC;
	 %true ->
	    herbrand_preds(H,XH),
	    apply_to_conjuncts(XC,add_herbrand_preds,X0)),

        apply_to_conjuncts(X0,add_count_beliefs,X1),
        apply_to_conjuncts(X1,add_ancestor,X2),
        predicates(X2,Preds0),
        reverse(Preds0,Preds),
	procedures_with_tests(Preds,X2,X3),
	/* all contrapositives available */
        apply_to_conjuncts(X3,add_sound_unification,X4),
	apply_to_conjuncts(X4,add_consistency_checking,X5),
        (compile_complete_search ->
	    apply_to_conjuncts(X5,add_complete_search,X6);
	%true ->
	    X5=X6),
	apply_to_conjuncts(X6,add_lemmatization,XL), /* relies on 'deduce_by */
	(compile_explaination_printing ->
                apply_to_conjuncts(XL,add_explaination_recording,X7);
	%true ->
                X7 = XL),
	add_model_structure(X7,Q,C,X8),

	apply_to_conjuncts(X8,add_body_hooks,XD),

	apply_to_conjuncts(X,prolog_clause,XP),
	conjoin(XP,XD,XR),

	conjoin(XH,XR,Y),

        (verbose_flag -> 
	     
	     writeSTDERR('XRay output formulas:'),
	     apply_to_conjuncts(Y,write_clause,_),
	     true;
	%true ->
	     true),
	!.

dpttp1(X) :-
	dpttp1(X,_).

dpttp2(Name,Y:Z) :-
        
        writeSTDERR('XRay writing compiled clauses ... '),
        write_ctheory(Name,Y),
	write_cmm(Name,Z),
	writeSTDERR('done.'),
	!.

dpttp2(Y:Z) :-
	Name = 'temp',
	dpttp2(Name,Y:Z).

dpttp3(Name) :-
	
        writeSTDERR('XRay compiling clauses ... '),
        compile_ctheory(Name),
	writeSTDERR('done.'),
        
        writeSTDERR('XRay compiling request ... '),
        compile_request(Name),
	writeSTDERR('done.'),
        
        !.
dpttp3 :-
	Name = 'temp',
	dpttp3(Name).


%%% ----------------------------------------------------------------------
%%% PTTP CONFIGURATION

%%% complete search facilities are turned (during compile-time)
%%%  on by do_compile_complete_search,
%%% off by dont_compile_complete_search.
%%%
%%% do_compile_complete_search or dont_compile_complete_search *must* be
%%% executed before the problem is compiled.

do_compile_complete_search :-
        retract(compile_complete_search),
        fail.
do_compile_complete_search :-
        assert(compile_complete_search).

dont_compile_complete_search :-
        retract(compile_complete_search),
        fail.
dont_compile_complete_search.


%%% Explaination printing is (better) turned (during compile-time)
%%%  on by   do_compile_explaination_printing (print_explaination),
%%% off by dont_compile_explaination_printing (dont_print_explaination).
%%%
%%% do_compile_explaination_printing or dont_compile_explaination_printing *must* be
%%% executed before the problem is compiled.

do_compile_explaination_printing   :- print_explaination.
dont_compile_explaination_printing :- dont_print_explaination.


%%% Explaination printing is turned on by print_explaination,
%%% off by dont_print_explaination.
%%%
%%% print_explaination or dont_print_explaination should be
%%% executed before the problem is compiled.

print_explaination :-                          % enable explaination printing
        retract(compile_explaination_printing),
        fail.
print_explaination :-
        assert(compile_explaination_printing).

dont_print_explaination :-                     % disable explaination printing
        retract(compile_explaination_printing),
        fail.
dont_print_explaination.


%%% Belief counting is turned
%%%  on by   do_compile_count_beliefs (count_beliefs),
%%% off by dont_compile_count_beliefs (dont_count_beliefs).
%%%
%%% Beliefs are counted by retracting the current count
%%% and asserting the incremented count, so belief counting
%%% is very slow.

do_compile_count_beliefs   :- count_beliefs.
dont_compile_count_beliefs :- dont_count_beliefs.


pttp_configuration :-
	true,format('PTTP CONFIGURATION:'),
	(count_beliefs_pred(true) ->
	    format('PTTP counts no beliefs.');
	    format('PTTP counts beliefs!')),
        (trace_search_progress_pred(nop) ->
	    format('PTTP does not true search progress.');
	    format('PTTP traces search progress!')),
	(compile_explaination_printing ->
	    format('PTTP compiles explaination printing!');
	    format('PTTP does not compile explaination printing.')),
	(compile_complete_search ->
	    format('PTTP compiles complete search!');
	    format('PTTP does not compile complete search.')).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                           %%
%%      Version:  1.00   Date: 24/04/95   File: lemma.pl                     %%
%% Last Version:                          File:                              %%
%% Changes:                                                                  %%
%% 04/04/95 Created                                                          %%
%%                                                                           %%
%% Purpose:                                                                  %%
%%                                                                           %%
%% Maintainer:  Torsten Schaub                                                   %%
%%                                                                           %%
%% Usage:   prolog lemma.pl                                                  %%
%%                                                                           %%
%%                                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%% ----------------------------------------------------------------------
%%% LEMMA CONFIGURATION

lemma_configuration :-
	true,writeSTDERR('LEMMA CONFIGURATION:'),
	
	writeSTDERR('Lemma handling'),
	writeSTDERR(' = '),
	(lemma_handling_flag ->
	    writeSTDERR(on),
	    
	
	    writeSTDERR(lemma_format),
	    writeSTDERR(' = '),
	    (lemma_format_parameter(P), writeSTDERR(P),writeSTDERR(' '),fail ; writeSTDERR('.')),
	    
	    
	    writeSTDERR(lemma_mode),
	    writeSTDERR(' = '),
	    (lemma_mode_parameter(M),   writeSTDERR(M),writeSTDERR(' '),fail ; writeSTDERR('.')),
	    
	    
	    writeSTDERR(lemma_type),
	    writeSTDERR(' = '),
	    (lemma_type_parameter(T),   writeSTDERR(T),writeSTDERR(' '),fail ; writeSTDERR('.')),
	    true;
	%true ->
	    writeSTDERR(off)),
	true.

%%% Lemma handling is turned on by lemma_handling,
%%% off by no_lemma_handling.

lemma_handling :-                          % enable lemma handling
        retract(lemma_handling_flag),
        fail.
lemma_handling :-
        assert(lemma_handling_flag).

no_lemma_handling :-                       % disable lemma handling
        retract(lemma_handling_flag),
        fail.
no_lemma_handling.

%%% Lemma mode indicates the usage of dynamic, static
%%% or dystatic modes of lemmas
%%% depending on lemma_mode_parameter(dynamic),lemma_mode_parameter(static), 
%%% and lemma_mode_parameter(dystatic)

lemma_mode(dynamic) :-                          % enable DYNAMIC lemmas
        retract(lemma_mode_parameter(_)),
        fail.
lemma_mode(dynamic) :-
        assert(lemma_mode_parameter(dynamic)).

lemma_mode(dystatic) :-                         % enable DYSTATIC  lemmas
        retract(lemma_mode_parameter(_)),
        fail.
lemma_mode(dystatic) :-
        assert(lemma_mode_parameter(dystatic)).

lemma_mode(static) :-                           % enable STATIC  lemmas
        retract(lemma_mode_parameter(_)),
        fail.
lemma_mode(static) :-
        assert(lemma_mode_parameter(static)).

%%% Dynamic lemma handling is alternatively turned on by dynamic_lemmas,
%%% off by no_dynamic_lemmas.

dynamic_lemmas :- lemma_mode(dynamic).                       % enable  DYNAMIC lemma handling

add_dynamic_lemmas :-                                        % add     DYNAMIC lemma handling
        retract(lemma_mode_parameter(dynamic)),
        fail.
add_dynamic_lemmas :-
        assert(lemma_mode_parameter(dynamic)).

no_dynamic_lemmas :-                                         % disable DYNAMIC lemma handling
        retract(lemma_mode_parameter(dynamic)),
        fail.
no_dynamic_lemmas.

%%% Static lemma handling is alternatively turned on by static_lemmas,
%%% off by no_static_lemmas.

static_lemmas :- lemma_mode(static).                        % enable  STATIC lemma handling

add_static_lemmas :-                                        % add     STATIC lemma handling
        retract(lemma_mode_parameter(static)),
        fail.
add_static_lemmas :-
        assert(lemma_mode_parameter(static)).

no_static_lemmas :-                                         % disable STATIC lemma handling
        retract(lemma_mode_parameter(static)),
        fail.
no_static_lemmas.

%%% Dystatic lemma handling is alternatively turned on by dystatic_lemmas,
%%% off by no_dystatic_lemmas.
%%% dystatic lemmas are static lemmas stemming from dynamic ones

dystatic_lemmas :- lemma_mode(dystatic).                    % enable  DYSTATIC lemma handling

add_dystatic_lemmas :-                                      % add     DYSTATIC lemma handling
        retract(lemma_mode_parameter(dystatic)),
        fail.
add_dystatic_lemmas :-
        assert(lemma_mode_parameter(dystatic)).

no_dystatic_lemmas :-                                       % disable DYSTATIC lemma handling
        retract(lemma_mode_parameter(dystatic)),
        fail.
no_dystatic_lemmas.

%%% some macros for easier lemma configuration.

lemma_flag :- lemma_mode_parameter(X).
dynamic_lemma_flag  :- lemma_mode_parameter(dynamic).
static_lemma_flag   :- lemma_mode_parameter(static).
dystatic_lemma_flag :- lemma_mode_parameter(dystatic).

no_lemmas :- no_dynamic_lemmas,no_static_lemmas,no_dystatic_lemmas.

%%% Lemma type indicates the location of the lemmatization predicates
%%%   DELTA lemmas are attached to rules stemming from default rules
%%%                ( Head =.. [gamma|-] or deduce_by(default(_)) )
%%%   OMEGA lemmas are attached to rules stemming from classical rules
%%%                ( deduce_by(extension(_) )
%%% depends on lemma_type_parameter(delta),lemma_type_parameter(omega), 
%%% and lemma_type_parameter(all)

lemma_type(delta) :-                          % enable DELTA lemmas
        retract(lemma_type_parameter(_)),
        fail.
lemma_type(delta) :-
        assert(lemma_type_parameter(delta)).

lemma_type(omega) :-                          % enable OMEGA  lemmas
        retract(lemma_type_parameter(_)),
        fail.
lemma_type(omega) :-
        assert(lemma_type_parameter(omega)).

lemma_type(all) :-                            % enable ALL  lemmas
        retract(lemma_type_parameter(_)),
        fail.
lemma_type(all) :-
        assert(lemma_type_parameter(delta)),
        assert(lemma_type_parameter(omega)).

%%% Delta lemma handling is alternatively added  by delta_lemmas,
%%% disabled by no_delta_lemmas.

add_delta_lemmas :-                                        % add     DELTA lemma handling
        retract(lemma_type_parameter(delta)),
        fail.
add_delta_lemmas :-
        assert(lemma_type_parameter(delta)).

no_delta_lemmas :-                                         % disable DELTA lemma handling
        retract(lemma_type_parameter(delta)),
        fail.
no_delta_lemmas.

%%% Omega lemma handling is alternatively added  by omega_lemmas,
%%% disabled by no_omega_lemmas.

add_omega_lemmas :-                                        % add     OMEGA lemma handling
        retract(lemma_type_parameter(omega)),
        fail.
add_omega_lemmas :-
        assert(lemma_type_parameter(omega)).

no_omega_lemmas :-                                         % disable OMEGA lemma handling
        retract(lemma_type_parameter(omega)),
        fail.
no_omega_lemmas.

%%% Lemma format indicates the usage of unit or disjunctive lemmas
%%% depending on lemma_format_parameter(unit) and lemma_format_parameter(disj)

lemma_format(unit) :-                          % enable UNIT lemmas
        retract(lemma_format_parameter(_)),
        fail.
lemma_format(unit) :-
        assert(lemma_format_parameter(unit)).

lemma_format(disj) :-                          % enable DISJUNCTIVE  lemmas
        retract(lemma_format_parameter(_)),
        fail.
lemma_format(disj) :-
        assert(lemma_format_parameter(disj)).


% --- special purpose predicates



%%% ----------------------------------------------------------------------
%%% XRay CONFIGURATION

xray_configuration :-
	true,writeSTDERR('XRay CONFIGURATION:'),
	
	writeSTDERR(delta_ordering),
	writeSTDERR(' = '),
	(delta_ordering(O), writeSTDERR(O),writeSTDERR(' '),fail ; writeSTDERR('.')),
	
	
	writeSTDERR(verbose_mode),
	writeSTDERR(' = '),
	(verbose_flag, writeSTDERR('on') ; writeSTDERR('off')),
	true.

%%% delta_ordering stears the order of admissibility 
%%% and compatibility checking in delta rules
%%% at compile-time

switch_delta_ordering :-
	delta_ordering(compatibility>admissibility),
	admissibility_first.
switch_delta_ordering :-
	delta_ordering(admissibility>compatibility),
	compatibility_first.

compatibility_first :-                      % check compatibility first
        retract(delta_ordering(_)),
        fail.
compatibility_first :-
        assert(delta_ordering(compatibility>admissibility)).

admissibility_first :-                      % check admissibility first
        retract(delta_ordering(_)),
        fail.
admissibility_first :-
        assert(delta_ordering(admissibility>compatibility)).

%%% Verbose explaination printing is turned on by verbose_mode,
%%% off by dont_verbose_mode.
%%% works during compile- and run-time

verbose_mode :-                          % enable explaination printing
        retract(verbose_flag),
        fail.
verbose_mode :-
        assert(verbose_flag).

no_verbose_mode :-                     % disable explaination printing
        retract(verbose_flag),
        fail.
no_verbose_mode.


configuration :-
	hook_configuration,
	lemma_configuration,
	pttp_configuration,
	xray_configuration.




prolog_clause((Head :- Body),(Head :- Body)) :-
	functor(Head,Pred,_),
	builtin_predicate(Pred),!.
	
prolog_clause(Fact,(Fact:-true)) :-
	functor(Fact,Pred,_),
	Pred \=( ':-'),builtin_predicate(Pred),!.
prolog_clause(_,true).




%%% ----------------------------------------------------------------------
%%% HOOKS CONFIGURATION

hook_configuration :-
	true,writeSTDERR('HOOK CONFIGURATION:'),
	
	writeSTDERR('body hook handling     '),
	writeSTDERR(' = '),
	(body_hooks_flag -> writeSTDERR(on) ; writeSTDERR(off)),
	

	writeSTDERR('predicate hook handling'),
	writeSTDERR(' = '),
	(pred_hooks_flag -> writeSTDERR(on) ; writeSTDERR(off)),
	true.

%%% Hook handling is turned off by no_hook_handling

no_hook_handling :- no_body_hooks, no_pred_hooks.

%%% Body hooks are turned on by body_hooks.
%%% off by no_body_hooks.

body_hooks :-                          % enable body hooks
        retract(body_hooks_flag),
        fail.
body_hooks :-
        assert(body_hooks_flag).

no_body_hooks :-                       % disable body hooks
        retract(body_hooks_flag),
        fail.
no_body_hooks.

%%% Predicate hooks are turned on by pred_hooks.
%%% off by no_pred_hooks.

pred_hooks :-                          % enable predicate hooks
        retract(pred_hooks_flag),
        fail.
pred_hooks :-
        assert(pred_hooks_flag).

no_pred_hooks :-                       % disable predicate hooks
        retract(pred_hooks_flag),
        fail.
no_pred_hooks.

%%% SETTINGS for HOOKS HANDLING
%%%


%%% pttp is the PTTP compiler top-level predicate.

pttp(X) :-
        time(pttp1(X),'Compilation').

pttp1(X) :-
        
        writeSTDERR('PTTP input formulas:'),
        apply_to_conjuncts(X,write_clause,_),
        
        clauses(X,X0,1),
        apply_to_conjuncts(X0,add_count_beliefs,X1),
        apply_to_conjuncts(X1,add_ancestor,X2),
        predicates(X2,Preds0),
        reverse(Preds0,Preds),
        procedures_with_ancestor_tests(Preds,X2,X3),
        apply_to_conjuncts(X3,add_sound_unification,X4),
        apply_to_conjuncts(X4,add_complete_search,X5),
        (compile_explaination_printing ->
                apply_to_conjuncts(X5,add_explaination_recording,Y);
        %true ->
                Y = X5),
        
        writeSTDERR('PTTP output formulas:'),
        apply_to_conjuncts(Y,write_clause,_),
        
        

        File = 'temp.prolog',                     % Quintus Prolog on Sun
%       File = 'darwin:>stickel>pttp>temp.prolog',% change file atom_codes for other systems

        open(File,writeSTDERR,OutFile),
        write_clause_to_file(Y,OutFile),
        close(OutFile),
        compile(File),
        
        !.

write_clause_to_file((A,B),OutFile) :-
	write_clause_to_file(A,OutFile),
	write_clause_to_file(B,OutFile),
        !.
write_clause_to_file(A,OutFile) :-
	true(OutFile),
	writeSTDERR(OutFile,A),
	writeSTDERR(OutFile,.),
	!.


request(M) :-                             % call request with depth bound M
        compile_explaination_printing -> 
                request(M,_N,_Explaination,_ExplainationEnd);
        %true ->
                request(M,_N).

request :-                                % unbounded search of request
        request(1000000).

negated_functor(F,NotF) :-
        atom_codes(F,L),
        atom_codes(not_,L1),
        (append(L1,L2,L) ->
                true;
        %true ->
                append(L1,L,L2)),
        atom_codes(NotF,L2).

negated_literal(Lit,NotLit) :-
        Lit =.. [F1|L1],
        negated_functor(F1,F2),
        (var(NotLit) ->
                NotLit =.. [F2|L1];
        %true ->
                NotLit =.. [F2|L2],
                L1 == L2).

negative_functor(F) :-atom_concat( 'not_', _, F),!.
negative_literal(Lit) :-
        functor(Lit,F,_),
        negative_functor(F).


write_clause(A) :-
        
        writeSTDERR(A),
        writeSTDERR(.).

write_clause(A,_) :-                    % 2-ary predicate can be used as
        write_clause(A).                % argument of apply_to_conjuncts

%%% Belief counting is turned on by count_beliefs,
%%% off by dont_count_beliefs.
%%%
%%% Beliefs are counted by retracting the current count
%%% and asserting the incremented count, so belief counting
%%% is very slow.




add_count_beliefs((Head :- Body),(Head :- Body1)) :-
        functor(Head,request,_) ->
                Body1 = Body;
        %true ->
                count_beliefs_pred(P),
                conjoin(P,Body,Body1).

%%% Search tracing is turned on by trace_search,
%%% off by dont_trace_search.

write_search_progress(Level) :-
        flag(ncalls,N,N),
        (N > 0 -> writeSTDERR(N) , writeSTDERR(' beliefs so far.') ; true),
        
        writeSTDERR('Begin cost '),
        writeSTDERR(Level),
        writeSTDERR(' search...  ').

%%% A request can be timed by time(request).

time(X) :-
        time(X,'Execution').

time(X,Type) :-
        flag(ncalls,_,0),

        prolog_statistics(runtime,[T1,_]),     % Quintus Prolog on Sun
%        T1 is get-internal-run-time,  % Common KIF time function

        call(X),

        prolog_statistics(runtime,[T2,_]),     % Quintus Prolog on Sun
        Secs is (T2 - T1) / 1000.0,     % Quintus measures runtime in milliseconds
%        T2 is get-internal-run-time,  % Common KIF time function
%        Secs is (T2 - T1) / 977.0,      % internal-time-units-per-second on Darwin

        
        writeSTDERR(Type),
        writeSTDERR(' time: '),
        flag(ncalls,N,N),
        (N > 0 -> writeSTDERR(N) , writeSTDERR(' beliefs in ') ; true),
        writeSTDERR(Secs),
        writeSTDERR(' seconds, including printing'),
        true.



%%% ----------------------------------------------------------------------
%%% BODY HOOKS

add_body_hooks((Head :- Body),(Head :- Body2)) :-
	body_hooks_flag,
	!,
	(bhook1_p(Head :- Body) ->
	    conjoin((bhook1(Head :- Body)),Body,Body1);
        %true ->
	    Body1=Body),
	(bhook2_p(Head :- Body) ->
	    conjoin(Body1,(bhook2(Head :- Body)),Body2);
        %true ->
	    Body2=Body1).
add_body_hooks((Head :- Body),(Head :- Body)).

%%% COMPILE-TIME conditions for body hook insertion

bhook1_p(Head :- Body) :-
	true.
bhook2_p(Head :- Body) :-
	true.

%%% RUN-TIME predicates for body hooks

bhook1(Head :- Body) :-
	(Head = _) ->
	    Head =.. [P|_],
	    true,writeSTDERR(b1:(P));
        %true ->
	     true.
bhook2(Head :- Body) :-
	(Head = _) ->
	    Head =.. [P|_],
	    true,writeSTDERR(b2:(P));
        %true ->
	     true.

%%% ----------------------------------------------------------------------
%%% BODY HOOKS

%%% COMPILE-TIME conditions for PREDICATE hook insertion

phook_tests(P,N,TestsA,Proc,ProcP) :-
	pred_hooks_flag,
	!,
	
	phook1_tests(P,N,Tests1),
	conjoin(Tests1,TestsA,Tests1A),
	
	phook2_tests(P,N,Tests2),
	conjoin(Tests1A,Tests2,Tests1A2),

	phook3_tests(P,N,Tests3),
	conjoin(Proc,Tests3,Proc3),

	conjoin(Tests1A2,Proc3,ProcP).
phook_tests(_,_,TestsA,Proc,ProcP) :-
	conjoin(TestsA,Proc,ProcP).

phook1_p(P,N) :-
	true.
phook2_p(P,N) :-
	true.
phook3_p(P,N) :-
	true.

%%% COMPILE-TIME predicates PREDICATE hook insertion

phook1_tests(P,N,Result) :-
	phook1_p(P,N),
	!,
	head(P,N,Head),
	Body=(true,writeSTDERR(p1:P),fail),
	Result = (Head :- Body).
phook1_tests(_,_,true).

phook2_tests(P,N,Result) :-
	phook2_p(P,N),
	!,
	head(P,N,Head),
	Body=(true,writeSTDERR(p2:P),fail),
	Result = (Head :- Body).
phook2_tests(_,_,true).

phook3_tests(P,N,Result) :-
	phook3_p(P,N),
	!,
	head(P,N,Head),
	Body=(true,writeSTDERR(p3:P),fail),
	Result = (Head :- Body).
phook3_tests(_,_,true).

head(P,N,Head) :-
	P == request ->
                Head = request;
	%true ->
		functor(Head,P,N).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                           %%
%%      Version:  1.00   Date:  4/04/95   File: parser.pl                    %%
%% Last Version:                          File:                              %%
%% Changes:                                                                  %%
%%  4/04/95 Created                                                          %%
%%                                                                           %%
%% Purpose:                                                                  %%
%%                                                                           %%
%% Maintainer:  Torsten Schaub                                                   %%
%%                                                                           %%
%% Usage:   prolog parser.pl                                                 %%
%%                                                                           %%
%%                                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% reads the knowledge base from the file 'Name.theory'

read_theory(Name,Wff) :-
	concat_atom(Name,'.theory',ContextFile),
	read_clauses(ContextFile,Wff).	

read_ctheory(Name,Wff) :-
	concat_atom(Name,'.ctheory',CContextFile),
	read_clauses(CContextFile,Wff).	

read_que(Name,Wff) :-
	concat_atom(Name,'.que',QFile),
	read_clauses(QFile,Wff).	

read_clauses(File,Wff) :-
	open(File,read,Stream),
	read_wff_loop(Stream,Wff),
	close(Stream).

read_wff_loop(Stream,Wff) :-
	read(Stream,Wff1),
	(Wff1 == end_of_file ->
	           Wff = true;
	 %true               ->
		   read_wff_loop(Stream,Wff2),
		   conjoin(Wff1,Wff2,Wff)).

read_matrix(File,Wff) :-
	open(File,read,Stream),
	read_matrix_loop(Stream,Wff),
	close(Stream).

read_matrix_loop(Stream,Matrix) :-
	read(Stream,Elem),
	(Elem == end_of_file ->
	           Matrix = [];
	%true                ->
		   read_matrix_loop(Stream,L),
		   Matrix = [Elem|L]).

% writes a compiled knowledge base consisting of contrapositives only
% to the file 'Name.ctheory'

write_ctheory(File,Context) :-
	concat_atom(File,'.ctheory',ContextFile),
	open(ContextFile,writeSTDERR,ContextStream),
	concat_atom(File,'.que',QFile),
	open(QFile,writeSTDERR,QStream),
        write_contrapositives(streams(ContextStream,QStream),Context),
        close(ContextStream),
        close(QStream),
	get_file_info(ContextFile,size,ContextFileSize),
	get_file_info(QFile,size,QFileSize),
	
	writeSTDERR(ContextFile),writeSTDERR(' written '),writeSTDERR(ContextFileSize),format(' bytes'),
	writeSTDERR(QFile), writeSTDERR(' written '),writeSTDERR(QFileSize), format(' bytes'),
	!.

write_cmm(File,Matrix) :-
	concat_atom(File,'.cmm',MFile),
	open(MFile,writeSTDERR,MStream),
        write_matrix(MStream,Matrix),
        close(MStream),
	!.

write_request(File,Request) :-
	concat_atom(File,'.que',QFile),
	open(QFile,writeSTDERR,QStream),
        write_request_only(QStream,Request),
        close(QStream),
	!.

write_request_only(Stream,(A,B)) :-
	!,
        write_request_only(Stream,A),
        write_request_only(Stream,B).
write_request_only(Stream,(A:-B)) :-
	functor(A,request,_) ->
		write_clauses(Stream,(A:-B));
	%true ->
		true.


write_contrapositives(Streams,(A,B)) :-
	!,
        write_contrapositives(Streams,A),
        write_contrapositives(Streams,B).
write_contrapositives(streams(ContextStream,QStream),(A:-B)) :-
	functor(A,request,_) ->
		write_clauses(QStream,(A:-B));
	%true ->
		write_clauses(ContextStream,(A:-B)).	


write_clauses(Stream,(A,B)) :-
        write_clauses(Stream,A),
        write_clauses(Stream,B),
        !.
write_clauses(Stream,A) :-
        writeSTDERR(Stream,A),
        writeSTDERR(Stream,.),
        true(Stream),
        !.
write_clauses(A) :-
	File = 'temp.pl',
	open(File,writeSTDERR,Stream),
	write_clauses(Stream,A),
	close(Stream).


write_matrix(Stream,[]) :-
	true(Stream),
        !.
write_matrix(Stream,[E|L]) :-
        writeSTDERR(Stream,E),
        writeSTDERR(Stream,.),
        true(Stream),
	write_matrix(Stream,L),
        !.
write_matrix(L) :-
	File = 'temp.pl',
	open(File,writeSTDERR,Stream),
	write_matrix(Stream,L),
	close(Stream).


compile_ctheory(File) :-	
	concat_atom(File,'.ctheory',ContextFile),
	compile(ContextFile).

compile_request(File) :-	
	concat_atom(File,'.que',QFile),
	compile(QFile).

ask(Name,Request) :-
	(variables(Request,[]) ->
	         classical_clauses(Request,Q0),
		 cnf(Q0,Q1),
		 make_matrix(Q1,Q2),
		 matrix_reduction(Q2,Q);
	%true ->
		 Q = []),

	concat_atom(Name,'.cmm',MFile),
	read_matrix(MFile,Matrix),
	
	dpttp1((request:-Request),Q,Matrix,Request1:Matrix),

	
        writeSTDERR('XRay writing request ... '),
        write_request(Name,Request1),
	writeSTDERR('done.'),

	
        writeSTDERR('XRay compiling request ... '),
        compile_request(Name),
	writeSTDERR('done.'),
        
        !.

tell(Name,Wff) :-	
	read_theory(Name,Context),
	conjoin(Wff,Context,NewContext),
	dpttp(Name,NewContext).

write_proved(Explaination,ExplainationEnd) :-
        writeSTDERR('proved'),
	verbose_flag ->
	        writeSTDERR(' by:'),
		write_explaination(Explaination,ExplainationEnd);
	%true->
		length(Explaination,X),
		writeSTDERR(' qed ;-) ':X).

write_explaination(Explaination,ExplainationEnd) :-
        Explaination == ExplainationEnd,
        !.
write_explaination([X|Y],ExplainationEnd) :-
	
        writeSTDERR(' '),
        writeSTDERR(X),
        write_explaination(Y,ExplainationEnd).

%%% SETTINGS for LEMMA HANDLING
%%%
%%% ----------------------------------------------------------------------
%%% LEMMA GENERATION during COMPILATION

%%% Add extra arguments to each goal so that information
%%% on what beliefs were made in the explaination can be printed
%%% at the end.

add_lemmatization((Head :- Body),(Head1 :- Body1)) :-
	lemma_handling_flag,
	!,
        Head =.. L,
        append(L,[ExplainationOut,ExplainationEnd],L1),
        Head1 =.. L1,
        add_lemmatization_args(Body,Explaination,ExplainationEnd,Body2,Lemma),
        (Lemma = true ->
	    Body1 = Body2,
	    ExplainationOut = Explaination;
	 add_lemmatization_p(Head :- Body) ->
	    Lemmatization =.. [lemmatize,Lemma,Explaination,ExplainationOut,ExplainationEnd],
	    conjoin(Body2,Lemmatization,Body1),
	    verbose('Lemmatization ':Lemma);
        %true ->
             Body1 = Body2,
             ExplainationOut = Explaination).
add_lemmatization((Head :- Body),(Head :- Body)).

add_lemmatization_p(Head :- Body) :-
	lemma_flag,
	!,
	(functor(Head,request,_) -> fail;
         functor(Head,alpha,_) -> fail;
	 functor(Head,gamma,_) -> lemma_type_parameter(delta);
	 true ->                  lemma_type_parameter(omega)).
         
add_lemmatization_args(Body,Explaination,ExplainationEnd,Body1,Lemma) :-
        Body = (A , B) ->
                add_lemmatization_args(A,Explaination,Explaination1,A1,L1),
                add_lemmatization_args(B,Explaination1,ExplainationEnd,B1,L2),
                conjoin(A1,B1,Body1),
                conjoin(L1,L2,Lemma);
        Body = (A ; B) ->
                add_lemmatization_args(A,Explaination,ExplainationEnd,A1,L1),
                add_lemmatization_args(B,Explaination,ExplainationEnd,B1,L2),
                disjoin(A1,B1,Body1),
                conjoin(L1,L2,Lemma);
        Body = deduce_by(X) ->
	        add_lemmatization_belief(X,Explaination,ExplainationEnd,Record,Lemma),
		conjoin(Body,Record,Body1);
        Body =.. [search,Goal|L] ->
                add_lemmatization_args(Goal,Explaination,ExplainationEnd,Goal1),
                Body1 =.. [search,Goal1|L],
                Lemma = true;
        Body = fail ->
                Body1 = Body,
                Lemma = true;
        builtin(Body) ->
                Explaination = ExplainationEnd,
                Body1 = Body,
                Lemma = true;
        %true ->
                Body =.. L,
                append(L,[Explaination,ExplainationEnd],L1),
                Body1 =.. L1,
                Lemma = true.

add_lemmatization_belief(Belief,Explaination,ExplainationEnd,Record,Lemma) :-
	Belief = reduction(_) ->
	    /* ancestor test */
	    Lemma = true,
            (lemma_type_parameter(omega) ->
		Record = (Explaination = [Belief|ExplainationEnd]);
	    %true ->
		Explaination = ExplainationEnd,
		Record = true);
        Belief = extension(_) ->
            /* omega rule */
	    Explaination = ExplainationEnd,
	    Record = true,
	    (lemma_type_parameter(omega) ->
		Lemma = Belief;
	    %true ->
		Lemma = true);
	Belief = default(_) ->
	    /* delta rule */
	    Lemma = Belief,
	    ((static_lemma_flag;dystatic_lemma_flag) ->
		Record = (Explaination = [Belief|ExplainationEnd]);
	    %true ->
		Explaination = ExplainationEnd,
		Record =true);
	Belief = static_lemma(_) ->
	    /* static lemma test (implicit (dy)static_lemma_flag)*/
	    Record = (Explaination = [Belief|ExplainationEnd]),
	    Lemma = true;
	Belief = dynamic_lemma(_) ->
	    /* dynamic lemma test */
	    Lemma = true,
	    ((static_lemma_flag;dystatic_lemma_flag) ->
		Record = (Explaination = [Belief|ExplainationEnd]);
	    %true ->
		Explaination = ExplainationEnd,
		Record =true);
	%true ->
            /* unit. etc */
	    Explaination = ExplainationEnd,
	    Record = true,
	    Lemma = true.


lemma_tests_p(P,N) :-
	lemma_handling_flag, (dynamic_lemma_test_p(P,N) ; static_lemma_test_p(P,N)).

dynamic_lemma_test_p(P,N) :-
	(dynamic_lemma_flag;dystatic_lemma_flag),
	!,
	(P == request -> fail;
         P == alpha -> fail;
	 P == gamma -> lemma_type_parameter(delta);
	 true       -> lemma_type_parameter(omega)).

static_lemma_test_p(P,N) :-
	(static_lemma_flag;dystatic_lemma_flag),
	!,
	(P == request -> fail;
         P == alpha -> fail;
	 P == gamma -> lemma_type_parameter(delta);
	 true       -> lemma_type_parameter(omega)).

lemma_tests(P,N,Result) :-
	lemma_handling_flag,
	lemma_tests_p(P,N),     % for avoiding problems with request/0
	!,
	N3 is N - 3,            % N - 3 due to 3 ancestor-lists
	functor(Head3,P,N3),
	Head3 =.. [P|Args1],
	append(Args1,[_,_,_],Args),
	Head =.. [P|Args],
	
	(dynamic_lemma_test_p(P,N) ->
	    dynamic_lemma_test(Head,Head3,DynamicLemmaBody);
	%true ->
	    DynamicLemmaBody=true),

	(static_lemma_test_p(P,N) ->
	    static_lemma_test(Head,Head3,StaticLemmaBody);
	%true ->
	    StaticLemmaBody=true),

	conjoin(DynamicLemmaBody,StaticLemmaBody,Result).
lemma_tests(_,_,true).

dynamic_lemma_test(Head,Head3,Test) :-
	lemma_format_parameter(unit) ->
	     ((static_lemma_flag;dystatic_lemma_flag) ->
		 Body = (deduce_by(dynamic_lemma(Head3:Assumptions)),
		         dynamic_lemma(Head3,false,Assumptions)) ;
	     %true ->
        	 Body = (deduce_by(dynamic_lemma(Head3)),
		         dynamic_lemma(Head3,false,[]))),
	     Test = (Head :- Body,!); /* REQUIRES FULLY INSTANTIIATED SUBGOALS */
	lemma_format_parameter(disj) ->
	%true              ->
	        not_yet_implemented.
		          
static_lemma_test(Head,Head3,Test) :-
	lemma_format_parameter(unit) ->
        	Body = (deduce_by(static_lemma(Head3:Assumptions)),
		        static_lemma(Head3,false,Assumptions),
			justification(Assumptions)),
		Test = (Head :- Body);
	lemma_format_parameter(disj) ->
	%true              ->
	        not_yet_implemented.

%%% ----------------------------------------------------------------------
%%% LEMMA UTILIZATION during RUN-TIME

lemmatize(default(N:(Gamma :- _)),Explaination,ExplainationOut,ExplainationEnd) :-
	verbose('Using static lemma code: ':lemmatize),
        !,
        remove_reductions(Explaination,ExplainationOut),
        default_assumptions(ExplainationOut,ExplainationEnd,Ass),
        lemmatize_dynamically(gamma(N,Gamma),false,Ass).
%        lemmatize_statically(gamma(N,Gamma),false,Ass).
lemmatize(extension(_N:Goal),Explaination,ExplainationOut,ExplainationEnd) :-
	verbose('Using static lemma code: ':lemmatize),
        !,
        skim_reductions(Goal,Explaination,ExplainationOut,ExplainationEnd,Ancs),
        default_assumptions(ExplainationOut,ExplainationEnd,Ass),
        lemmatize_dynamically(Goal,Ancs,Ass).
%        lemmatize_statically(Goal,Ancs,Ass).
lemmatize(_Lemmatization,_Explaination,_ExplainationOut,_ExplainationEnd) :-
        error_in_lemmatize.

lemmatize_statically(Goal,Ancestors,Assumptions) :-
        static_lemma(Goal,Ancestors,Assumptions),            % UNIFY, ==, ... ???
        !.
lemmatize_statically(Goal,Ancestors,Assumptions) :-
        assert(static_lemma(Goal,Ancestors,Assumptions)),
        verbose(static_lemma(Goal,Ancestors,Assumptions)).

lemmatize_dynamically(Goal,Ancestors,_) :-
        dynamic_lemma(Goal,Ancestors,_),                        % UNIFY, ==, ... ???
        !.
%lemmatize_dynamically(Goal,Ancestors,[]) :-               <=== only if cases below
%        !,
%        assert(dynamic_lemma(Goal,Ancestors,[])),
%        lemmatize_statically(Goal,Ancestors,[]),
%        verbose(dynamic_lemma(Goal,Ancestors)).
lemmatize_dynamically(Goal,Ancestors,Assumptions) :-
        (assert(dynamic_lemma(Goal,Ancestors,Assumptions)),
         verbose(activated:(dynamic_lemma(Goal,Ancestors,[Assumptions])));
         retract(dynamic_lemma(Goal,Ancestors,Assumptions)),
         verbose(deactivated:(dynamic_lemma(Goal,Ancestors,[Assumptions]))),
%         lemmatize_statically(Goal,Ancestors,Assumptions), <=== only if cases below
         !,
         fail).

% No check for ExplainationEnd, since default(...) should be contained
% Because only invoked in case of default belief

remove_reductions([default(X)|Explaination],[default(X)|Explaination]) :- 
        !.
remove_reductions([static_lemma(X)|Explaination],[static_lemma(X)|ExplainationOut]) :- 
        !,
        remove_reductions(Explaination,ExplainationOut).
remove_reductions([dynamic_lemma(X)|Explaination],[dynamic_lemma(X)|ExplainationOut]) :- 
	/* ==> when using static lemmas <== */
        !,
        remove_reductions(Explaination,ExplainationOut).
remove_reductions(Explaination,ExplainationOut) :-
        Explaination = [_|RestExplaination],
        remove_reductions(RestExplaination,ExplainationOut).

skim_reductions(_Goal,Explaination,Explaination,ExplainationEnd,false) :-
        Explaination == ExplainationEnd,
        !.
skim_reductions(_Goal,Explaination,Explaination,_ExplainationEnd,false) :-
        Explaination = [default(_)|_],
        !.
skim_reductions(Goal,[reduction(Anc)|Explaination],Explaination1,ExplainationEnd,Ancs) :-
        Goal == Anc,
        skim_reductions(Goal,Explaination,Explaination1,ExplainationEnd,Ancs),
        !.
skim_reductions(Goal,[reduction(Anc)|Explaination],[reduction(Anc)|Explaination1],ExplainationEnd,Ancs1) :-
        !,
        skim_reductions(Goal,Explaination,Explaination1,ExplainationEnd,Ancs),
        disjoin1(Anc,Ancs,Ancs1).
skim_reductions(Goal,[static_lemma(X)|Explaination],[static_lemma(X)|Explaination1],ExplainationEnd,Ancs) :-
        skim_reductions(Goal,Explaination,Explaination1,ExplainationEnd,Ancs).
skim_reductions(Goal,[dynamic_lemma(X)|Explaination],[dynamic_lemma(X)|Explaination1],ExplainationEnd,Ancs) :-
	/* ==> when using static lemmas <== */
        skim_reductions(Goal,Explaination,Explaination1,ExplainationEnd,Ancs).

%%% ----------------------------------------------------------------------
%%% default_assumptions/3 
%%%         extracts all neccessary default assunptions from a explaination
%%%

default_assumptions(Explaination,ExplainationEnd,[]) :-
        Explaination == ExplainationEnd,
        !.
default_assumptions([default(_N:(_ :- _ : Just))|Explaination],ExplainationEnd,Assumptions) :-
        !,
        default_assumptions(Explaination,ExplainationEnd,Justs),
        combine_clauses(Just,Justs,Assumptions).
default_assumptions([static_lemma(_  : Just)|Explaination],ExplainationEnd,Assumptions) :-
        !,
        default_assumptions(Explaination,ExplainationEnd,Justs),
        combine_clauses(Just,Justs,Assumptions).
default_assumptions([dynamic_lemma(_ : Just)|Explaination],ExplainationEnd,Assumptions) :-
	/* ==> when using static lemmas <== */
        !,
        default_assumptions(Explaination,ExplainationEnd,Justs),
        combine_clauses(Just,Justs,Assumptions).
default_assumptions([_|Explaination],ExplainationEnd,Wff) :-
        default_assumptions(Explaination,ExplainationEnd,Wff).

%%% A is supposed to be a literal
%%% disjoin2 removes A from B; results in C

disjoin1(A,B,C) :-
        disjoin2(A,B,C1),
        disjoin(A,C1,C).

disjoin2(A,(B ; C),D) :-
        !,
        disjoin2(A,B,B1),
        disjoin2(A,C,C1),
        disjoin(B1,C1,D).
disjoin2(A,B,false) :-
        A == B,
        !.
disjoin2(_,B,B).


%%% ----------------------------------------------------------------------
%%% SOME helpful IO-Routines

write_lemmas(File) :-   
        concat_atom(File,'.lem',LFile),
        open(LFile,writeSTDERR,LStream),
        !,
        (static_lemma(X,Y,Z),
         write_clauses(LStream,static_lemma(X,Y,Z)),
         fail;
         close(LStream)).

show_lemmas :-  
        show_dynamic_lemmas,fail;
        true,show_static_lemmas.

show_dynamic_lemmas :- 
        (dynamic_lemma(X,Y,Z),
         writeSTDERR(dynamic_lemma(X,Y,Z)),
         
         fail;
         true).
show_static_lemmas :-
        (static_lemma(X,Y,Z),
         writeSTDERR(static_lemma(X,Y,Z)),
         
         fail;
         true).

remove_lemmas :-
        remove_static_lemmas,
        remove_dynamic_lemmas.
remove_dynamic_lemmas :-
        retractall(dynamic_lemma(_,_,_)).
remove_static_lemmas :-
        retractall(static_lemma(_,_,_)).
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                           %%
%%      Version:  1.00   Date: 13/07/96   File: lemma:config.pl              %%
%% Last Version:                          File:                              %%
%% Changes:                                                                  %%
%% 13/07/96 Created                                                          %%
%%                                                                           %%
%% Purpose:                                                                  %%
%%                                                                           %%
%% Maintainer:  Torsten Schaub                                                   %%
%%                                                                           %%
%% Usage:   prolog lemma:config.pl                                           %%
%%                                                                           %%
%%                                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

add_lemmatization_p(Head :- Body) :-
	lemma_flag,
	!,
	(functor(Head,request,_) -> fail;
         functor(Head,alpha,_) -> fail;
	 functor(Head,gamma,_) -> lemma_type_parameter(delta);
	 true ->                  lemma_type_parameter(omega)).

dynamic_lemma_test_p(P,N) :-
	dynamic_lemma_flag,
	!,
	(P == request -> fail;
         P == alpha -> fail;
	 P == gamma -> lemma_type_parameter(delta);
	 true       -> lemma_type_parameter(omega)).

static_lemma_test_p(P,N) :-
	(static_lemma_flag;dystatic_lemma_flag),
	!,
	(P == request -> fail;
         P == alpha -> fail;
	 P == gamma -> lemma_type_parameter(delta);
	 true       -> lemma_type_parameter(omega)).
	 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                           %%
%%      Version:  1.00   Date: 13/07/96   File: lemmaflex.pl
%% Last Version:                          File:                              %%
%% Changes:                                                                  %%
%% 11/07/96 Created                                                          %%
%% 13/07/96 added compilation
%%                                                                           %%
%% Purpose:                                                                  %%
%%                                                                           %%
%% Maintainer:  Torsten Schaub                                                   %%
%%                                                                           %%
%% Usage:   prolog lemmaflex.pl                                              %%
%%                                                                           %%
%%                                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

lemma_runtime_procedures(Result) :-
	lemmatize_procedure(Lemmatization0),

	lemmatize_dynamically_procedure(DynamicLemmatization),
	lemmatize_statically_procedure(StaticLemmatization),
	conjoin(DynamicLemmatization,StaticLemmatization,Lemmatization1),

	conjoin(Lemmatization0,Lemmatization1,Lemmatization),

	default_assumptions_procedure(DefaultHandler),

	conjoin(Lemmatization,DefaultHandler,Result).

lemmatize_procedure(Result) :-
	lemma_handling_flag,
	!,

	/* DEFAULTHANDLER */
        ((static_lemma_flag;dystatic_lemma_flag)        % compile-flag 
	       ->
	          DefaultHandler   = default_assumptions(ExplainationOut,ExplainationEnd,Ass);
	 %true ->
		  DefaultHandler   = true,
		  Ass              = []
	),

	/* DELTA LEMMATIZE */
	(lemma_type_parameter(delta) ->
	    HeadD = lemmatize(default(N:(Gamma :- _)),Explaination,ExplainationOut,ExplainationEnd),
	    /* REDUCTIONHANDLER */
	    (lemma_type_parameter(omega) ->
		ReductionHandlerD = remove_reductions(Explaination,ExplainationOut);
	    %true ->
		ReductionHandlerD = true,
		ExplainationOut=Explaination),
	    conjoin(ReductionHandlerD,DefaultHandler,BodyD1),
	    /* LEMMAHANDLER   */
	    lemma_handler(gamma(N,Gamma),false,Ass,LemmaHandlerD),
	    conjoin(BodyD1,LemmaHandlerD,BodyD),
	    RuleD = (HeadD :- !,BodyD);
	%true ->
	    RuleD = true),

	/* OMEGA LEMMATIZE */
	(lemma_type_parameter(omega) ->
	    HeadO             = lemmatize(extension(_:Goal),Explaination,ExplainationOut,ExplainationEnd),
	    /* REDUCTIONHANDLER */
	    ReductionHandlerO = skim_reductions(Goal,Explaination,ExplainationOut,ExplainationEnd,Ancs),
	    conjoin(ReductionHandlerO,DefaultHandler,BodyO1),
	    /* LEMMAHANDLER   */
	    lemma_handler(Goal,Ancs,Ass,LemmaHandler1),
	    (lemma_format_parameter(unit) ->
		LemmaHandlerO = (Ancs=false -> LemmaHandler1 ; verbose(skipping:Goal:Ancs));
	    %true ->
		LemmaHandlerO = LemmaHandler1),
	    conjoin(BodyO1,LemmaHandlerO,BodyO),
	    RuleO = (HeadO :- !,BodyO);
	%true ->
	    RuleO = true),

	/* ignore LEMMATIZE */
        HeadI = lemmatize(Belief,Explaination,Explaination,ExplainationEnd),
	BodyI = verbose('lemmatize/4: Ignoring belief':Belief),
	RuleI = (HeadI :- BodyI),

	/* RESULTING CODE */
        conjoin(RuleD,RuleO,Result1),
        conjoin(Result1,RuleI,Result).
lemmatize_procedure(Result) :-
	/* no_lemma_handling */
	Result = (lemmatize(_,_,_,_)).

lemma_handler(Goal,Ancs,Ass,LemmaHandler) :-
	((dynamic_lemma_flag;dystatic_lemma_flag) ->
	    DynamicLemmaHandler = lemmatize_dynamically(Goal,Ancs,Ass);
        %true ->
	    DynamicLemmaHandler = true),
	(static_lemma_flag ->
	    StaticLemmaHandler = lemmatize_statically(Goal,Ancs,Ass);
        %true ->
	    StaticLemmaHandler = true),
	conjoin(DynamicLemmaHandler,StaticLemmaHandler,LemmaHandler).

lemmatize_dynamically_procedure(Result) :-
	lemma_handling_flag,
	lemma_mode_parameter(Mode),
	(Mode = (dynamic) ; Mode = dystatic),
	!,

	Head0 = lemmatize_dynamically(Goal,Ancestors,_),
	Body0 = dynamic_lemma(Goal,Ancestors,_),           % UNIFY ?!
	Rule0 = (Head0 :- Body0, !),
	
	(dystatic_lemma_flag ->

	    Head1  = lemmatize_dynamically(Goal,Ancestors,[]),
	    Body1A = assert(dynamic_lemma(Goal,Ancestors,[])),
	    Body1S = lemmatize_statically(Goal,Ancestors,[]),
	    Rule1  = (Head1 :- !, Body1A, Body1S),

	    Body2S = lemmatize_statically(Goal,Ancestors,Assumptions);

	%true ->
	    Rule1  = true,
	    Body2S = true),

	conjoin(Rule0,Rule1,Rule01),

	Head2  = lemmatize_dynamically(Goal,Ancestors,Assumptions),
	Body2A =  assert(dynamic_lemma(Goal,Ancestors,Assumptions)),
	Body2R = retract(dynamic_lemma(Goal,Ancestors,Assumptions)),
	conjoin(Body2R,Body2S,Body2RS),
	Rule2  = (Head2 :- Body2A ; (Body2RS, ! , fail)),

	conjoin(Rule01,Rule2,Result).


lemmatize_dynamically_procedure(Rule) :-
	Head = lemmatize_dynamically(_,_,_),
	Body = (writeSTDERR(lemmatize_dynamically*not_in_charge),true,fail),
	Rule = (Head :- Body).

lemmatize_statically_procedure(Result) :-
	lemma_handling_flag,
	lemma_mode_parameter(Mode),
	(Mode = static ; Mode = dystatic),
	!,

	Head0  = lemmatize_statically(Goal,Ancestors,Assumptions),
	Body0  = static_lemma(Goal,Ancestors,Assumptions),           % UNIFY ?!
	Rule0  = (Head0 :- Body0, !),
	
	Head1  = lemmatize_statically(Goal,Ancestors,Assumptions),
	Body1A = assert(static_lemma(Goal,Ancestors,Assumptions)),
	Rule1  = (Head1 :- Body1A),

	Result = (Rule0,Rule1).
lemmatize_statically_procedure(Rule) :-
	Head = lemmatize_statically(_,_,_),
	Body = (writeSTDERR(lemmatize_statically*not_in_charge),true,fail),
	Rule = (Head :- Body).

default_assumptions_procedure(Result) :-
	lemma_handling_flag,
	lemma_mode_parameter(Mode),
	(Mode = static ; Mode = dystatic),
	!,
	
	Head0 = default_assumptions(Explaination,ExplainationEnd,[]),
	Body0 = (Explaination == ExplainationEnd),
	Rule0 = (Head0 :- Body0, !),

	BodyR = default_assumptions(Explaination,ExplainationEnd,Justs),

	Body123 = (BodyR,combine_clauses(Just,Justs,Assumptions)),

	Head1 = default_assumptions([default(_:(_ :- _: Just))|Explaination],ExplainationEnd,Assumptions),
	Head2 = default_assumptions([static_lemma(_   : Just) |Explaination],ExplainationEnd,Assumptions),
	Head3 = default_assumptions([dynamic_lemma(_  : Just) |Explaination],ExplainationEnd,Assumptions),

	Rule1 = (Head1 :- !, Body123),
	conjoin(Rule0,Rule1,Rule01),

	Rule2  = (Head2 :- !, Body123),
	Rule3  = (Head3 :- !, Body123),
	Rule23 = (Rule2,Rule3),
	conjoin(Rule01,Rule23,Rule0123),

	Head4 = default_assumptions([_|Explaination],ExplainationEnd,Justs),
	Rule4 = (Head4 :- BodyR),

	conjoin(Rule0123,Rule4,Result).
default_assumptions_procedure(Rule) :- 
	Head = default_assumptions(_,_,_),
	Body = (writeSTDERR(default_assumptions*not_in_charge),true,fail),
	Rule = (Head :- Body).

%%% Compilation of run-time procedures for lemma handling
%%%

compile_lemma_handling(Name) :-
	lemma_runtime_procedures(LemmaProcs),
	write_lem(Name,LemmaProcs),
	compile_lem(Name).

read_lem(Name,Wff) :-
	concat_atom(Name,'.lem',LFile),
	read_clauses(LFile,Wff).	
write_lem(File,LemmaProcs) :-
	concat_atom(File,'.lem',LemmaFile),
	open(LemmaFile,writeSTDERR,LemmaStream),
        write_clauses(LemmaStream,LemmaProcs),
        close(LemmaStream),
	!.
compile_lem(File) :-	
	concat_atom(File,'.lem',ContextFile),
	compile(ContextFile).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%                                                                           %%
%%      Version:  1.00   Date: 28/06/96   File: model.pl
%% Last Version:                          File:                              %%
%% Changes:                                                                  %%
%% 26/06/95 Created                                                          %%
%% 25/06/96 moved compatible from defaults.pl
%% 28/06/96 updated cnf,make_matrix, make_clause
%%                                                                           %%
%% Purpose:                                                                  %%
%%                                                                           %%
%% Maintainer:  Torsten Schaub                                                   %%
%%                                                                           %%
%% Usage:   prolog model.pl                                                  %%
%%                                                                           %%
%%                                                                           %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



%%% ----------------------------------------------------------------------
%%% model_initialization/2
%%%     generates an initial model

model_initialization(Matrix,cmm(Model,NewMatrix)) :-
	model_generation(matrix([],Matrix),NewMatrix,Model),
%	display_cmm('INITIALIZATION',cmm(Model,NewMatrix)),
	!.

%%% Runtime predicate for consistency checking
%%%

compatible(MatrixJ,cmm(Model,ModelMatrix),cmm(NewModel,NewModelMatrix)) :-
	satisfy_matrix(MatrixJ,Model,NewModel) ->
	        append_matrix(MatrixJ,ModelMatrix,NewModelMatrix),
%		display_cmm('CHECKING - satisfy':MatrixJ,cmm(NewModel,NewModelMatrix)),
		verbose('+ satisfiability check');
	adjoin_matrix(MatrixJ,ModelMatrix,ModelMatrix1) ->
%	        display_cmm('CHECKING - generation I':MatrixJ,cmm(Model,ModelMatrix)),
		model_generation(ModelMatrix1,NewModelMatrix,NewModel);
%		display_cmm('CHECKING - generation II':MatrixJ,cmm(NewModel,NewModelMatrix));
	%true ->
%		display_cmm('CHECKING - failure':MatrixJ,cmm(Model,ModelMatrix)),
		verbose('- compatible *failure*'),
		fail.

%%% ----------------------------------------------------------------------
%%% satisfy_matrix/3
%%%     checks whether a given model, ModelI, satisfies
%%%     a formula in matrix form, Matrix, or whether the model
%%%     can be extended to a model, ModelO
%%%

satisfy_matrix([],Model,Model).
satisfy_matrix([Clause],ModelI,ModelO) :-
	!,
	satisfy_clause(Clause,ModelI,ModelO).
satisfy_matrix([C1,C2],ModelI,ModelO) :-
	!,
	satisfy_clause(C1,ModelI,Model1),
	satisfy_clause(C2,Model1,ModelO).
satisfy_matrix([C1,C2,C3|M],ModelI,ModelO) :-
	satisfy_clause(C1,ModelI,Model1),
	satisfy_clause(C2,Model1,Model2),
	satisfy_clause(C3,Model2,Model3),
	satisfy_matrix(M,Model3,ModelO).

satisfy_clause([],_,_) :- 
	!,
	fail.
satisfy_clause([L],ModelI,ModelO) :-
	!,
	satisfy_literal(L,ModelI,ModelO).
satisfy_clause([L1,L2],ModelI,ModelO) :-
	satisfy_literal(L1,ModelI,ModelO);
	satisfy_literal(L2,ModelI,ModelO).
satisfy_clause([L1,L2,L3|C],ModelI,ModelO) :-
	satisfy_literal(L1,ModelI,ModelO);
	satisfy_literal(L2,ModelI,ModelO);
	satisfy_literal(L3,ModelI,ModelO);
	satisfy_clause(C,ModelI,ModelO).

satisfy_literal(L,ModelI,ModelO) :-
        identical_member(L,ModelI) ->
	       ModelO = ModelI;
	%true  ->
	       negated_literal(L,NegL),
	       \+ identical_member(NegL,ModelI),
	       ModelO = [L|ModelI].


%%% ----------------------------------------------------------------------
%%% model_generation/2

model_generation(matrix(Units,Matrix),matrix(Units2,M1),Model) :-
	unit_extraction(Matrix,M1,Units1),
%	format(unit_extraction),display_matrix(Matrix),display_matrix(M1),display_units(Units1),
	dp(M1,Model1),
	append(Units,Units1,Units2),
/*	union(Units,Units1,Units2), append allows for multiple occurrences */
	append(Units2,Model1,Model),
	verbose('* model generation').

dp([],[]) :- !.
dp(M,_) :-
	member([],M),
	!,
	fail.
dp(M,NewMod) :-
	M=[[L|_]|_],
	split(M,L,M1,M2),
	unit_extraction(M1,M3,U3),
	unit_extraction(M2,M4,U4),
	(dp(M3,Mod),
         KK = [L|U3];
	 dp(M4,Mod),
         negated_literal(L,K),
	 KK = [K|U4]),
        append(KK,Mod,NewMod).


split([],_,[],[]).
split([C|M],L,M3,M4) :-
	split(M,L,M1,M2),
	negated_literal(L,NegL),
	(select(L,C,RestC) ->
	      M3=M1,
	      M4=[RestC|M2];
	select(NegL,C,RestC) ->
	      M3=[RestC|M1],
	      M4=M2;
        %true ->
	      M3=[C|M1],
	      M4=[C|M2]).

%%% ----------------------------------------------------------------------
%%% cnf/2

cnf(NNF,CNF) :-
	NNF = (F1,F2) ->
	    cnf(F1,CNF1),
	    cnf(F2,CNF2),
	    conjoin(CNF1,CNF2,CNF);
        NNF = (F1;(F2,F3)) ->
	    cnf((F1;F2),CNF1),
	    cnf((F1;F3),CNF2),
	    conjoin(CNF1,CNF2,CNF);
        NNF = ((F1,F2);F3) ->
	    cnf((F1;F3),CNF1),
	    cnf((F2;F3),CNF2),
	    conjoin(CNF1,CNF2,CNF);
	NNF = (F1;F2) ->
	    cnf(F1,CNF1),
	    cnf(F2,CNF2),
            (cnf_p(CNF1,CNF2,F1,F2) ->
	           disjoin(CNF1,CNF2,CNF);
	    %true ->
		   disjoin(CNF1,CNF2,CNF12),
	           cnf(CNF12,CNF));
	%true ->
	    NNF=CNF.

cnf_p(CNF1,CNF2,F1,F2) :-
	(F1=(_,_);F2=(_,_)) ->
	         fail;
		 F1=CNF1,F2=CNF2.

make_matrix(Wff,Matrix) :-
	Wff = (A,B) ->
	      make_matrix(A,MA),
	      make_matrix(B,MB),
	      append(MA,MB,Matrix);
	Wff = true ->
	      Matrix = [];
	Wff = false ->
	      Matrix = [[]];
	%true ->
	      make_clause(Wff,Clause),
	      Matrix=[Clause].

make_clause(Wff,Clause) :-
	Wff = (A;B) ->
	      make_clause(A,CA),
	      make_clause(B,CB),
	      append(CA,CB,Clause);
	%true ->
	      Clause=[Wff].

%%% ----------------------------------------------------------------------
%%% combine_clauses\3
%%%       merges two CNFs into one while simplifying the resulting CNF
%%%       CARE: C1 is supposed to be smaller than C2

combine_clauses(C,[],C) :-
	!,
	verbose('  trivial combination').
combine_clauses([[L]],C1,[[L]|C2]) :-
	!,
	verbose('  1 unit combination'),
	simplify(L,C1,C2).	
combine_clauses([[L1],[L2]],C1,[[L1],[L2]|C3]) :-
	!,
	verbose('  2 unit combinations'),
	simplify(L1,C1,C2),
	simplify(L2,C2,C3).
combine_clauses(C1,C2,C) :-	
	verbose('  general combination'),
	append(C1,C2,C3),
	unit_reduction(C3,C4),
	subs_reduction(C4,C).

%%% ----------------------------------------------------------------------
%%% adjoin/3
%%%
/* adjoin guarantees         that the new information
          is satisfied by the current unit clauses
   adjoin does not guarantee that the new information 
                                  together with the current matrix
          is satisfied by the current unit clauses
   So you better watch for new unit clauses stemming from reducing the
   new matrix

   Nonetheless: whenever a unit is added to the unit list, this literal
   has been removed (by simplify) from the matrix.
*/
      
adjoin_matrix([[L]],matrix(Units,_),_) :-
	verbose('  1 unit adjunction *failure*'),
	negated_literal(L,NegL),
	identical_member(NegL,Units),
	!,fail.
adjoin_matrix([[L]],matrix(Units,Matrix1),matrix([L|Units],Matrix2)) :-
	!,
	verbose('  1 unit adjunction'),
	simplify(L,Matrix1,Matrix2).
adjoin_matrix([[L1],[L2]],matrix(Units,_),_) :-
						% supposition not(negated_literal(L1,L2))
	verbose('  2 unit adjunction *failure*'),
	(negated_literal(L1,NegL) ; negated_literal(L2,NegL)),
	identical_member(NegL,Units),
	!,fail.
adjoin_matrix([[L1],[L2]],matrix(Units,Matrix1),matrix([L1,L2|Units],Matrix3)) :-
						% supposition not(negated_literal(L1,L2))
	!,
	verbose('  2 unit adjunctions'),
	simplify(L1,Matrix1,Matrix2),
	simplify(L2,Matrix2,Matrix3).
adjoin_matrix(Matrix1,matrix(Units,Matrix2),matrix(Units,Matrix3)) :-
	satisfy_matrix(Matrix1,Units,_) ->
	       	verbose('  full adjunction'),
		append(Matrix1,Matrix2,Matrix3);
	% true ->
		verbose('  weak satisfaction *failure*'),
		fail.


append_matrix([[L]],matrix(Units,Matrix),matrix(Units,[[L]|Matrix])) :-
						% allows for multiple occurrences
	verbose('  1 unit appendage'),
	!.
append_matrix([[L1],[L2]],matrix(Units,Matrix),matrix(Units,[[L1],[L2]|Matrix])) :-
						% allows for multiple occurrences
	verbose('  2 unit appendage'),
	!.
append_matrix(Matrix1,matrix(Units,Matrix2),matrix(Units,Matrix3)) :-
	verbose('  full appendage'),
	append(Matrix1,Matrix2,Matrix3).

%%% ----------------------------------------------------------------------
%%% matrix_reduction/2
%%%      bunch of matrix reductions
%%%

matrix_reduction(C1,C) :-
	taut_reduction(C1,C2),
	mult_reduction(C2,C3),
	unit_reduction(C3,C4),
	subs_reduction(C4,C).

%%% ----------------------------------------------------------------------
%%% unit_reduction/2
%%%      unit reduction
%%%

unit_reduction(M,[[L]|M1]) :-
	member([L],M),
	!,
	simplify(L,M,M2),
	unit_reduction(M2,M1).
unit_reduction(M,M).

%%% unit_extraction/3 
%%%        is a special purpose reduction for model-finding
%%%          2nd arg gives matrix without unit clauses
%%%          3rd arg gives literals in unit clauses

unit_extraction(M,M1,[L|R]) :-
	member([L],M),
	!,
	simplify(L,M,M2),
	unit_extraction(M2,M1,R).
unit_extraction(M,M,[]).


simplify(_L, [], [] ) .
simplify( L, [C|Cs] , NewCs ) :-
	member(L,C),
	!,
	simplify(L,Cs,NewCs).
simplify( L, [C|Cs], [NewC|NewCs] ) :-
	negated_literal(L,NegL),
	select(NegL,C,NewC),
	!,
	simplify(L,Cs,NewCs).
simplify( L, [C|Cs], [C|NewCs]    ) :-
	simplify(L,Cs,NewCs).

%%% ----------------------------------------------------------------------
%%% subs_reduction/2
%%%      subs reduction
%%%

subs_reduction([],[]).
subs_reduction([C1|M1],M) :-
	subs_reduction(M1,M2),
	(subsumes(C1,M2,M3) ->
	    M = [C1|M3];
	%true ->
	    M = M2).

subsumes(_,[],[]).
subsumes(C1,[C2|_],_) :-
	subset(C2,C1),
	!,
	fail.
subsumes(C,[C1|M1],M) :-
	subsumes(C,M1,M2),
	!,
	(subset(C,C1) ->
	        M=M2;
	%true ->
		M=[C1|M2]).

%%% ----------------------------------------------------------------------
%%% taut_reduction/2
%%%      taut reduction
%%%

taut_reduction([],[]) :- !.
taut_reduction([C|M1],M2) :-
	taut_reduction(M1,M3),
	(taut_clause(C) ->
	    M2 = M3;
	%true ->
	    M2 = [C|M3]
	).

taut_clause(C) :-
	member(L,C),
	negated_literal(L,K),
	member(K,C).
	
%%% ----------------------------------------------------------------------
%%% mult_reduction/2
%%%     mult reduction
%%%

mult_reduction([],[]).
mult_reduction([C|M1],[NewC|M3]) :-
	mult_reduction(M1,M3),
	remove_dups(C,NewC).

remove_dups([],[]).
remove_dups([L|RestC],NewC) :-
	remove_dups(RestC,NewRestC),
	(member(L,NewRestC) ->
	    NewC = NewRestC;
	%true ->
	    NewC = [L|NewRestC]
	).





%%% Sound unification.
%%%
%%% `add_sound_unification' transforms a clause so that its
%%% head has no repeated variables.  Unifying a goal with
%%% the clause head can then be done soundly without the occurs
%%% check.  The rest of the unification can then be done in
%%% the body of the transformed clause, using the sound `unify'
%%% predicate.
%%%
%%% For example,
%%%    p(X,Y,f(X,Y)) :- true.
%%% is transformed into
%%%    p(X,Y,f(X1,Y1)) :- unify(X,X1), unify(Y,Y1).

add_sound_unification((Head :- Body),(Head1 :- Body1)) :-
        linearize(Head,Head1,[],_,true,Matches),
        conjoin(Matches,Body,Body1).

linearize(TermIn,TermOut,VarsIn,VarsOut,MatchesIn,MatchesOut) :-
        nonvar(TermIn) ->
                functor(TermIn,F,N),
                functor(TermOut,F,N),
                linearize_args(TermIn,TermOut,VarsIn,VarsOut,MatchesIn,MatchesOut,1,N);
        identical_member(TermIn,VarsIn) ->
                VarsOut = VarsIn,
                conjoin(MatchesIn,unify(TermIn,TermOut),MatchesOut);
        %true ->
                TermOut = TermIn,
                VarsOut = [TermIn|VarsIn],
                MatchesOut = MatchesIn.

linearize_args(TermIn,TermOut,VarsIn,VarsOut,MatchesIn,MatchesOut,I,N) :-
        I > N ->
                VarsOut = VarsIn,
                MatchesOut = MatchesIn;
        %true ->
                arg(I,TermIn,ArgI),
                linearize(ArgI,NewArgI,VarsIn,Vars1,MatchesIn,Matches1),
                arg(I,TermOut,NewArgI),
                I1 is I + 1,
                linearize_args(TermIn,TermOut,Vars1,VarsOut,Matches1,MatchesOut,I1,N).

%%% Sound unification algorithm with occurs check that is called
%%% by code resulting from the `add_sound_unification' transformation.
%%% This should be coded in a lower-level language for efficiency.

unify(X,Y) :- unify_with_occurs_check(X,Y).


%%% Depth-first iterative-deepening search.
%%%
%%% `add_complete_search' adds arguments DepthIn and DepthOut
%%% to each PTTP literal to control bounded depth-first
%%% search.  When a literal is called,
%%% DepthIn is the current depth bound.  When
%%% the literal exits, DepthOut is the new number
%%% of levels remaining after the solution of
%%% the literal (DepthIn - DepthOut is the number
%%% of levels used in the solution of the goal.)
%%%
%%% For clauses with empty bodies or bodies
%%% composed only of builtin functions,
%%% DepthIn = DepthOut.
%%%
%%% For other clauses, the depth bound is
%%% compared to the cost of the body.  If the
%%% depth bound is exceeded, the clause fails.
%%% Otherwise the depth bound is reduced by
%%% the cost of the body.
%%%
%%% p :- q , r.
%%% is transformed into
%%% p(DepthIn,DepthOut) :-
%%%     DepthIn >= 2, Depth1 is DepthIn - 2,
%%%     q(Depth1,Depth2),
%%%     r(Depth2,DepthOut).
%%%
%%% p :- q ; r.
%%% is transformed into
%%% p(DepthIn,DepthOut) :-
%%%     DepthIn >= 1, Depth1 is DepthIn - 1,
%%%     (q(Depth1,DepthOut) ; r(Depth1,DepthOut)).

add_complete_search((Head :- Body),(Head1 :- Body1)) :-
        Head =.. L,
        append(L,[DepthIn,DepthOut],L1),
        Head1 =.. L1,
        (functor(Head,request,_) ->
                add_complete_search_args(Body,DepthIn,DepthOut,Body1);
        nonzero_search_cost(Body,Cost) ->
                add_complete_search_args(Body,Depth1,DepthOut,Body2),
                conjoin((DepthIn >= Cost , Depth1 is DepthIn - Cost),Body2,Body1);
        %true ->
                add_complete_search_args(Body,DepthIn,DepthOut,Body1)).

add_complete_search_args(Body,DepthIn,DepthOut,Body1) :-
        Body = (A , B) ->
                add_complete_search_args(A,DepthIn,Depth1,A1),
                add_complete_search_args(B,Depth1,DepthOut,B1),
                conjoin(A1,B1,Body1);
        Body = (A ; B) ->
                search_cost(A,CostA),
                search_cost(B,CostB),
                (CostA < CostB ->
                        add_complete_search_args(A,DepthIn,DepthOut,A1),
                        add_complete_search_args(B,Depth1,DepthOut,B2),
                        Cost is CostB - CostA,
                        conjoin((DepthIn >= Cost , Depth1 is DepthIn - Cost),B2,B1);
                CostA > CostB ->
                        add_complete_search_args(A,Depth1,DepthOut,A2),
                        add_complete_search_args(B,DepthIn,DepthOut,B1),
                        Cost is CostA - CostB,
                        conjoin((DepthIn >= Cost , Depth1 is DepthIn - Cost),A2,A1);
                %true ->
                        add_complete_search_args(A,DepthIn,DepthOut,A1),
                        add_complete_search_args(B,DepthIn,DepthOut,B1)),
                disjoin(A1,B1,Body1);
        Body = search(Goal,Max,Min,Inc) ->
                PrevInc is Min + 1,
                add_complete_search_args(Goal,DepthIn1,DepthOut1,Goal1),
                DepthIn = DepthOut,
                Body1 = search(Goal1,Max,Min,Inc,PrevInc,DepthIn1,DepthOut1);
        Body = search(Goal,Max,Min) ->
                add_complete_search_args(search(Goal,Max,Min,1),DepthIn,DepthOut,Body1);
        Body = search(Goal,Max) ->
                add_complete_search_args(search(Goal,Max,0),DepthIn,DepthOut,Body1);
        Body = search(Goal) ->
                add_complete_search_args(search(Goal,1000000),DepthIn,DepthOut,Body1);
        functor(Body,search_cost,_) ->
                DepthIn = DepthOut,
                Body1 = true;
        builtin(Body) ->
                DepthIn = DepthOut,
                Body1 = Body;
        %true ->
                Body =.. L,
                append(L,[DepthIn,DepthOut],L1),
                Body1 =.. L1.

nonzero_search_cost(Body,Cost) :-
        search_cost(Body,Cost),
        Cost > 0.

%%% Search cost is computed by counting literals in the body.
%%% It can be given explicitly instead by including a number, as in
%%%   p :- search_cost(3).     (ordinarily, cost would be 0)
%%%   p :- search_cost(1),q,r. (ordinarily, cost would be 2)
%%%   p :- search_cost(0),s.   (ordinarily, cost would be 1)
%%%
%%% Propositional goals are not counted into the search cost so
%%% that fully propositional problems can be solved without
%%% deepening when iterative-deepening search is used.

search_cost(Body,N) :-
        Body = search_cost(M) ->
                N = M;
        Body = (A , B) ->
                (A = search_cost(M) ->  % if first conjunct is search_cost(M),
                        N = M;          % search cost of the entire conjunction is M
                %true ->
                        search_cost(A,N1),
                        search_cost(B,N2),
                        N is N1 + N2);
        Body = (A ; B) ->
                search_cost(A,N1),
                search_cost(B,N2),
                min(N1,N2,N);
        builtin(Body) ->
                N = 0;
        functor(Body,_,2) ->  % zero-cost 2-ary (0-ary plus ancestor lists) predicates
                N = 0;        % heuristic for propositional problems
        %true ->
                N = 1.

%%% Depth-first iterative-deepening search can be
%%% specified for a goal by wrapping it in a call
%%% on the search predicate:
%%%    search(Goal,Max,Min,Inc)
%%% Max is the maximum depth to search (defaults to a big number),
%%% Min is the minimum depth to search (defaults to 0),
%%% Inc is the amount to increment the bound each time (defaults to 1).
%%%
%%% Depth-first iterative deepening search can be
%%% specified inside the PTTP formula by compiling
%%%   request :- search(p(b,a,c),Max,Min,Inc)
%%% and executing
%%%   request.
%%% or directly by the user by compiling
%%%   request :- p(b,a,c))
%%% and executing
%%%   search(request,Max,Min,Inc).
%%%
%%% The search(Goal,Max,Min,Inc) predicate adds
%%% DepthIn and DepthOut arguments to its goal argument.

search(Goal,Max,Min,Inc) :-
        PrevInc is Min + 1,
        add_complete_search_args(Goal,DepthIn,DepthOut,Goal1),
        (compile_explaination_printing ->
                add_explaination_recording_args(Goal1,_Explaination,_ExplainationEnd,Goal2);
        %true ->
                Goal2 = Goal1),
        !,
        search(Goal2,Max,Min,Inc,PrevInc,DepthIn,DepthOut).

search(Goal,Max,Min) :-
        search(Goal,Max,Min,1).

search(Goal,Max) :-
        search(Goal,Max,0).

search(Goal) :-
        search(Goal,1000000).

%%% Actual search driver predicate.
%%% Note that depth-bounded execution of Goal is enabled by
%%% the fact that the DepthIn and DepthOut arguments of
%%% search are also the DepthIn and DepthOut arguments of Goal.

search(_Goal,Max,Min,_Inc,_PrevInc,_DepthIn,_DepthOut) :-
        Min > Max,
        !,
        fail.
search(Goal,_Max,Min,_Inc,PrevInc,DepthIn,DepthOut) :-
        trace_search_progress_pred(P1),
        L1 =.. [P1,Min],
        call(L1),
        DepthIn = Min,
        call(Goal),
        DepthOut < PrevInc.   % fail if this solution was found in previous search
search(Goal,Max,Min,Inc,_PrevInc,DepthIn,DepthOut) :-
        Min1 is Min + Inc,
        search(Goal,Max,Min1,Inc,Inc,DepthIn,DepthOut).

%%% Complete belief.
%%%
%%% Model elimination reduction operation and
%%% identical ancestor goal pruning.
%%%
%%% Two arguments are added to each literal, one
%%% for all the positive ancestors, one for all
%%% the negative ancestors.
%%%
%%% Unifiable membership is checked in the list 
%%% of opposite polarity to the goal
%%% for performing the reduction operation.
%%%
%%% Identity membership is checked in the list
%%% of same polarity as the goal
%%% for performing the ancestor goal pruning operation.
%%% This is not necessary for soundness or completeness,
%%% but is often effective at substantially reducing the
%%% number of beliefs.
%%%
%%% The current head goal is added to the front
%%% of the appropriate ancestor list during the
%%% call on subgoals in bodies of nonunit clauses.

add_ancestor((Head :- Body),(Head1 :- Body1)) :-
        functor(Head,request,_) ->
                Head1 = Head,
                add_ancestor_args(Body,[[],[]],Body1);
        %true ->
                Head =.. L,
                append(L,[PosAncestors,NegAncestors],L1),
                Head1 =.. L1,
                add_ancestor_args(Body,[NewPosAncestors,NewNegAncestors],Body2),
                (Body == Body2 ->
                        Body1 = Body2;
                negative_literal(Head) ->
                        NewPosAncestors = PosAncestors,
                        conjoin((NewNegAncestors = [Head|NegAncestors]),Body2,Body1);
                %true ->
                        NewNegAncestors = NegAncestors,
                        conjoin((NewPosAncestors = [Head|PosAncestors]),Body2,Body1)).

add_ancestor_args(Body,AncestorLists,Body1) :-
        Body = (A , B) ->
                add_ancestor_args(A,AncestorLists,A1),
                add_ancestor_args(B,AncestorLists,B1),
                conjoin(A1,B1,Body1);
        Body = (A ; B) ->
                add_ancestor_args(A,AncestorLists,A1),
                add_ancestor_args(B,AncestorLists,B1),
                disjoin(A1,B1,Body1);
        Body =.. [search,Goal|L] ->
                add_ancestor_args(Goal,AncestorLists,Goal1),
                Body1 =.. [search,Goal1|L];
        builtin(Body) ->
                Body1 = Body;
        %true ->
                Body =.. L,
                append(L,AncestorLists,L1),
                Body1 =.. L1.

ancestor_tests(P,N,Result) :-
        P == request ->
                Result = true;
        %true ->
                negated_functor(P,NotP),
                N2 is N - 2,            % N - 2 due to two ancestor-list arguments
                functor(Head1,P,N2),
                Head1 =.. [P|Args1],
                Head2 =.. [NotP|Args1],
                append(Args1,[PosAncestors,NegAncestors],Args),
                Head =.. [P|Args],
                (negative_functor(P) ->
                        C1Ancestors = NegAncestors, C2Ancestors = PosAncestors;
                %true ->
                        C1Ancestors = PosAncestors, C2Ancestors = NegAncestors),
                C1 = (Head :- identical_member(Head1,C1Ancestors), !, fail),
                count_beliefs_pred(IncNcalls),
                (N2 = 0 ->              % special case for propositional calculus
                        conjoin((identical_member(Head2,C2Ancestors) , !),IncNcalls,V);
                %true ->
                        conjoin(unifiable_member(Head2,C2Ancestors),IncNcalls,V)),
                (compile_explaination_printing ->
                        conjoin(V,deduce_by(red),V1);
                %true ->
                        V1 = V),
                C2 = (Head :- V1),
                conjoin(C1,C2,Result).

procedures_with_ancestor_tests([[P,N]|Preds],Clauses,Procs) :-
        procedure(P,N,Clauses,Proc1),
        ancestor_tests(P,N,Tests),
        conjoin(Tests,Proc1,Proc),
        procedures_with_ancestor_tests(Preds,Clauses,Procs2),
        conjoin(Proc,Procs2,Procs).
procedures_with_ancestor_tests([],_Clauses,true).


%%% Explaination Printing.
%%%
%%% Add extra arguments to each goal so that information
%%% on what beliefs were made in the explaination can be printed
%%% at the end.

add_explaination_recording((Head :- Body),(Head1 :- Body1)) :-
        Head =.. L,
        append(L,[Explaination,ExplainationEnd],L1),
        Head1 =.. L1,
        add_explaination_recording_args(Body,Explaination,ExplainationEnd,Body2),
        (functor(Head,request,_) ->
                conjoin(Body2,write_proved(Explaination,ExplainationEnd),Body1);
        %true ->
                Body1 = Body2).

add_explaination_recording_args(Body,Explaination,ExplainationEnd,Body1) :-
        Body = (A , B) ->
                add_explaination_recording_args(A,Explaination,Explaination1,A1),
                add_explaination_recording_args(B,Explaination1,ExplainationEnd,B1),
                conjoin(A1,B1,Body1);
        Body = (A ; B) ->
                add_explaination_recording_args(A,Explaination,ExplainationEnd,A1),
                add_explaination_recording_args(B,Explaination,ExplainationEnd,B1),
                disjoin(A1,B1,Body1);
        Body =.. [search,Goal|L] ->
                add_explaination_recording_args(Goal,Explaination,ExplainationEnd,Goal1),
                Body1 =.. [search,Goal1|L];
        Body = deduce_by(X) ->
                Body1 = (Explaination = [X|ExplainationEnd]);
        Body = fail ->
                Body1 = Body;
        builtin(Body) ->
                Explaination = ExplainationEnd,
                Body1 = Body;
        %true ->
                Body =.. L,
                append(L,[Explaination,ExplainationEnd],L1),
                Body1 =.. L1.

write_proved(Explaination,ExplainationEnd) :-
        writeSTDERR('proved by'),
        write_explaination(Explaination,ExplainationEnd).

write_explaination(Explaination,ExplainationEnd) :-
        Explaination == ExplainationEnd,
        !.
write_explaination([X|Y],ExplainationEnd) :-
        writeSTDERR(' '),
        writeSTDERR(X),
        write_explaination(Y,ExplainationEnd).

/*
%%% Negation normal form to Prolog clause translation.
%%% Include a literal in the body of each clause to
%%% indicate the number of the formula the clause came from.

clauses((A , B),L,WffNum) :-
        !,
        clauses(A,L1,WffNum),
        WffNum2 is WffNum + 1,
        clauses(B,L2,WffNum2),
        conjoin(L1,L2,L).
clauses(A,L,WffNum) :-
        head_literals(A,Lits),
        clauses(A,Lits,L,WffNum).

clauses(A,[Lit|Lits],L,WffNum) :-
        body_for_head_literal(Lit,A,Body1),
        (compile_explaination_printing ->
                conjoin(deduce_by(WffNum),Body1,Body);
        %true ->
                Body = Body1),
        clauses(A,Lits,L1,WffNum),
        conjoin((Lit :- Body),L1,L).
clauses(_,[],true,_).

*/
head_literals(Wff,L) :-
        Wff = (A :- B) ->               % contrapositives are not formed for A :- ... inputs
                head_literals(A,L);
        Wff = (A , B) ->
                head_literals(A,L1),
                head_literals(B,L2),
                union(L1,L2,L);
        Wff = (A ; B) ->
                head_literals(A,L1),
                head_literals(B,L2),
                union(L1,L2,L);
        %true ->
                L = [Wff].

body_for_head_literal(Head,Wff,Body) :-
        Wff = (A :- B) ->
                body_for_head_literal(Head,A,A1),
                conjoin(A1,B,Body);
        Wff = (A , B) ->
                body_for_head_literal(Head,A,A1),
                body_for_head_literal(Head,B,B1),
                disjoin(A1,B1,Body);
        Wff = (A ; B) ->
                body_for_head_literal(Head,A,A1),
                body_for_head_literal(Head,B,B1),
                conjoin(A1,B1,Body);
        Wff == Head ->
                Body = true;
        negated_literal(Wff,Head) ->
                Body = false;
        %true ->
                negated_literal(Wff,Body).

%%% predicates returns a list of the predicates appearing in a formula.

predicates(Wff,L) :-
        Wff = (A :- B) ->
                predicates(A,L1),
                predicates(B,L2),
                union(L2,L1,L);
        Wff = (A , B) ->
                predicates(A,L1),
                predicates(B,L2),
                union(L2,L1,L);
        Wff = (A ; B) ->
                predicates(A,L1),
                predicates(B,L2),
                union(L2,L1,L);
        functor(Wff,search,_) ->        % list predicates in first argument of search
                arg(1,Wff,X),
                predicates(X,L);
        builtin(Wff) ->
                L = [];
        %true ->
                functor(Wff,F,N),
                L = [[F,N]].

%%% procedure returns a conjunction of the clauses
%%% with head predicate P/N.

procedure(P,N,Clauses,Proc) :-
        Clauses = (A , B) ->
                procedure(P,N,A,ProcA),
                procedure(P,N,B,ProcB),
                conjoin(ProcA,ProcB,Proc);
        (Clauses = (A :- B) , functor(A,P,N)) ->
                Proc = Clauses;
        %true ->
                Proc = true.

%%% ----------------------------------------------------------------------
%%% XRay COMPILATION (patches pttp)

%%% Negation normal form/Defaults to Prolog clause translation.
%%% Include a literal in the body of each clause to
%%% indicate the number of the formula the clause came from.

clauses((A , B),L,WffNum) :-
        !,
        clauses(A,L1,WffNum),
        WffNum2 is WffNum + 1,
        clauses(B,L2,WffNum2),
        conjoin(L1,L2,L).
clauses( (Gamma :- Alpha : Beta) , L , WffNum ) :-
	!,
	clauses((Gamma :- gamma(WffNum,Gamma)),L1,WffNum),
	clauses((alpha(WffNum,Alpha) :- Alpha),L2,WffNum),
	conjoin(L1,L2,L3),
	conjoin(Gamma,Beta,C0),                             % ConDL-specific
	cnf(C0,C1),
	make_matrix(C1,C2),
	matrix_reduction(C2,Justification),
	(delta_ordering(compatibility>admissibility) ->
	    conjoin(justification(Justification),
	            alpha(WffNum,Alpha),
		    Body);
	%true ->
	    conjoin(alpha(WffNum,Alpha),
		    justification(Justification),
	            Body)),
	(compile_explaination_printing ->
	    Record = deduce_by(default(WffNum:(Gamma :- Alpha : Justification)));
	%true ->
	    Record = true),
	conjoin(Record,Body,Body1),
	DRule= (gamma(WffNum,Gamma) :- Body1),
	conjoin(DRule,L3,L).

clauses(A,L,WffNum) :-
        head_literals(A,Lits),
        clauses(A,Lits,L,WffNum).

clauses(A,[Lit|Lits],L,WffNum) :-
        body_for_head_literal(Lit,A,Body1),
        ((compile_explaination_printing,Body1 = true) ->
                Record = deduce_by(unit(WffNum:Lit));
         compile_explaination_printing ->
                Record = deduce_by(extension(WffNum:Lit));
        %true ->
		Record = true),
	conjoin(Record,Body1,Body),
        clauses(A,Lits,L1,WffNum),
        conjoin((Lit :- Body),L1,L).
clauses(_,[],true,_).

%%% This patches the original predicate
%%%
%%%

add_ancestor((Head :- Body),(Head1 :- Body1)) :-
        functor(Head,request,_) ->
                Head1 = Head,
                add_ancestor_args(Body,[[],[],[]],Body1);
	functor(Head,gamma,_) ->                      
                Head =.. L,                             
                append(L,[_,_,Defaults],L1),                             
                Head1 =.. L1,                                   
                add_ancestor_args(Body,[[],[],NewDefaults],Body2),
		conjoin((NewDefaults = [Head|Defaults]),Body2,Body1); 
	functor(Head,alpha,_) ->                      
                Head =.. L,                             
                append(L,[_,_,Defaults],L1),                             
                Head1 =.. L1,                                   
                add_ancestor_args(Body,[[],[],Defaults],Body1); 
        %true ->
                Head =.. L,
                append(L,[PosAncestors,NegAncestors,Defaults],L1),
                Head1 =.. L1,
                add_ancestor_args(Body,[NewPosAncestors,NewNegAncestors,Defaults],Body2),
                (Body == Body2 ->
                        Body1 = Body2;
                negative_literal(Head) ->
                        NewPosAncestors = PosAncestors,
                        conjoin((NewNegAncestors = [Head|NegAncestors]),Body2,Body1);
                %true ->
                        NewNegAncestors = NegAncestors,
                        conjoin((NewPosAncestors = [Head|PosAncestors]),Body2,Body1)).


ancestor_tests(P,N,Result) :-
        P == request ->
                Result = true;
	P == gamma ->
		Head = gamma(DefaultID,DefaultConseq,_,_,Defaults),
		Default = gamma(DefaultID,DefaultConseq),
		Result = (Head :- identical_member(Default,Defaults), !, fail);
	P == alpha ->
		Result = true;          % ??? <== Please, VERIFY !
        %true ->
                negated_functor(P,NotP),
                N3 is N - 3,            % N - 3 due to 3 ancestor-lists
                functor(Head1,P,N3),
                Head1 =.. [P|Args1],
                Head2 =.. [NotP|Args1],
                append(Args1,[PosAncestors,NegAncestors,_],Args),
                Head =.. [P|Args],
                (negative_functor(P) ->
                        C1Ancestors = NegAncestors, 
			C2Ancestors = PosAncestors;
                %true ->
                        C1Ancestors = PosAncestors, 
			C2Ancestors = NegAncestors),
                C1 = (Head :- identical_member(Head1,C1Ancestors), !, fail),
                count_beliefs_pred(IncNcalls),
                (N3 = 0 ->              % special case for propositional calculus
                        conjoin((identical_member(Head2,C2Ancestors) , !),IncNcalls,V);
                %true ->
                        conjoin(unifiable_member(Head2,C2Ancestors),IncNcalls,V)),
                (compile_explaination_printing ->
                        conjoin(V,deduce_by(reduction(Head2)),V1);
                %true ->
                        V1 = V),
                C2 = (Head :- V1),
                conjoin(C1,C2,Result).


procedures_with_tests([[P,N]|Preds],Clauses,Procs) :-
        procedure(P,N,Clauses,Proc0),

        ancestor_tests(P,N,TestsA),
	lemma_tests(P,N,TestsL),
	conjoin(TestsA,TestsL,Tests),

	phook_tests(P,N,Tests,Proc0,ProcP),

        procedures_with_tests(Preds,Clauses,ProcsPs),
        conjoin(ProcP,ProcsPs,Procs).
procedures_with_tests([],_Clauses,true).


bhook1_p(Head :- Body) :-
	Body = (true,writeSTDERR(_),fail) ->
	     /* eliminates predicate hooks */
	     false;
	functor(Head,request,_) ->
	     false;
	%true ->
	     true.
bhook1(Head :- Body) :-
	functor(Head,gamma,_)  ->
	     Head =.. [Pred,Arg1,Arg2|_],
	     true,writeSTDERR(trial:gamma(Arg1,Arg2));
        functor(Head,alpha,_)  ->
	     Head =.. [Pred,Arg1,Arg2|_],
	     true,writeSTDERR(trial:alpha(Arg1,Arg2));
        Head = _ ->
	     Head =.. [Pred|_],
	     true,writeSTDERR(trial:(Pred));
        %true ->
	     true.

bhook2_p(Head :- Body) :-
	bhook1_p(Head :- Body).
bhook2(Head :- Body) :-
	functor(Head,gamma,_)  ->
	     Head =.. [Pred,Arg1,Arg2|_],
	     true,writeSTDERR(success:gamma(Arg1,Arg2));
        functor(Head,alpha,_)  ->
	     Head =.. [Pred,Arg1,Arg2|_],
	     true,writeSTDERR(success:alpha(Arg1,Arg2));
        Head = _ ->
	     Head =.. [Pred|_],
	     true,writeSTDERR(success:(Pred));
        %true ->
	     true.

phook1_p(P,N) :-
	P == request ->
                false;
	%true ->
		true.
phook2_p(P,N) :-
	phook1_p(P,N).
phook3_p(P,N) :-
	phook1_p(P,N).


phook1_tests(P,N,Result) :-
	phook1_p(P,N),
	!,
	head3(P,N,Head,Head3),
	(P = gamma ->
	    Head =.. [Pred,Arg1,Arg2|_],
	    Body=(true,writeSTDERR(enter*predicate:gamma(Arg1,Arg2)),fail);
	 P = alpha ->
	    Head =.. [Pred,Arg1,Arg2|_],
	    Body=(true,writeSTDERR(enter*predicate:alpha(Arg1,Arg2)),fail);
	%true ->
	    Body=(true,writeSTDERR(enter*predicate:Head3),fail)),
	Result = (Head :- Body).
phook1_tests(_,_,true).

phook2_tests(P,N,Result) :-
	phook2_p(P,N),
	!,
	head3(P,N,Head,Head3),
	(P = gamma ->
	    Head =.. [Pred,Arg1,Arg2|_],
	    Body=(true,writeSTDERR(end_of_tests*predicate:gamma(Arg1,Arg2)),fail);
	 P = alpha ->
	    Head =.. [Pred,Arg1,Arg2|_],
	    Body=(true,writeSTDERR(end_of_tests*predicate:alpha(Arg1,Arg2)),fail);
	%true ->
	    Body=(true,writeSTDERR(end_of_tests*predicate:Head3),fail)),
	Result = (Head :- Body).
phook2_tests(_,_,true).

phook3_tests(P,N,Result) :-
	phook3_p(P,N),
	!,
	head3(P,N,Head,Head3),
	(P = gamma ->
	    Head =.. [Pred,Arg1,Arg2|_],
	    Body=(true,writeSTDERR(failure*predicate:gamma(Arg1,Arg2)),fail);
	 P = alpha ->
	    Head =.. [Pred,Arg1,Arg2|_],
	    Body=(true,writeSTDERR(failure*predicate:alpha(Arg1,Arg2)),fail);
	%true ->
	    Body=(true,writeSTDERR(failure*predicate:Head3),fail)),
	Result = (Head :- Body).
phook3_tests(_,_,true).

head3(P,N,Head,Head3) :-
	P == request ->
                Head = request;
	%true ->
		N3 is N - 3,
                functor(Head3,P,N3),
                Head3 =.. [P|Args3],
                append(Args3,[_,_,_],Args),
                Head =.. [P|Args].
add_herbrand_preds((Head :- Body),(Head :- Body1)) :-
	herbrandize_variables(Body,[],BodyVars,false,_),
	herbrandize_variables(Head,BodyVars,_,true,Matches),
        conjoin(Matches,Body,Body1).
	

herbrandize_variables(Term,VarsIn,VarsOut,MatchesIn,MatchesOut) :-
        builtin(Term) ->
	        VarsOut = VarsIn,
                MatchesOut = MatchesIn;
        %true ->
	        nonvar(Term) ->
                       functor(Term,_,N),
		       herbrandize_args(Term,VarsIn,VarsOut,MatchesIn,MatchesOut,1,N);
	        identical_member(Term,VarsIn) ->
	               VarsOut = VarsIn,
		       MatchesOut = MatchesIn;
	        %true ->
		       VarsOut = [Term|VarsIn],
		       conjoin(MatchesIn,herbrand(Term),MatchesOut).

herbrandize_args(Term,VarsIn,VarsOut,MatchesIn,MatchesOut,I,N) :-
        I > N ->
                VarsOut = VarsIn,
                MatchesOut = MatchesIn;
        %true ->
                arg(I,Term,Arg),
                herbrandize_variables(Arg,VarsIn,Vars1,MatchesIn,Matches1),
                I1 is I + 1,
                herbrandize_args(Term,Vars1,VarsOut,Matches1,MatchesOut,I1,N).

herbrand_universe(U) :-
	setof(X,herbrand(X),U).

herbrand_preds([],true).
herbrand_preds([C|Cs],Wff) :-
	herbrand_preds(Cs,Wffs),
	conjoin((herbrand(C):-true),Wffs,Wff).

add_answer_preds((request :- Request),(request :- (Request,true,true,writeSTDERR(answer:Vars)))) :-
	!,
	variables(Request,Vars).
add_answer_preds(R,R).

%%% constants returns a list of the constants appearing in a formula.

constants(Wff,L) :-
        Wff = (A :- B) ->
                constants(A,L1),
                constants(B,L2),
                union(L2,L1,L);
        Wff = (A , B) ->
                constants(A,L1),
                constants(B,L2),
                union(L2,L1,L);
        Wff = (A ; B) ->
                constants(A,L1),
                constants(B,L2),
                union(L2,L1,L);
        Wff = (A : B) ->
                constants(A,L1),
                constants(B,L2),
                union(L2,L1,L);
        functor(Wff,search,_) ->        % list constants in first argument of search
                arg(1,Wff,X),
                constants(X,L);
        builtin(Wff) ->
                L = [];
        %true ->
                functor(Wff,_,N),
                (N > 0 ->
		   constantize_args(Wff,[],L,1,N);
		 %true ->
                   L = []).

constantize_args(Term,FnsIn,FnsOut,I,N) :-
	var(Term) ->
		FnsOut = FnsIn;
	atom(Term) ->
	        FnsOut = [Term|FnsIn];
        I > N ->
                FnsOut = FnsIn;
        %true ->
                arg(I,Term,ArgI),
		(var(ArgI) ->
		        Fns1 = [];
		%true ->
		        functor(ArgI,_,NI),
                        constantize_args(ArgI,FnsIn,Fns1,1,NI)),
                I1 is I + 1,
                constantize_args(Term,Fns1,FnsOut,I1,N).

%%% variables returns a list of the variables appearing in a formula.

variables(Wff,L) :-
        Wff = (A :- B) ->
                variables(A,L1),
                variables(B,L2),
                union(L2,L1,L);
        Wff = (A , B) ->
                variables(A,L1),
                variables(B,L2),
                union(L2,L1,L);
        Wff = (A ; B) ->
                variables(A,L1),
                variables(B,L2),
                union(L2,L1,L);
        Wff = (A : B) ->
                variables(A,L1),
                variables(B,L2),
                union(L2,L1,L);
        functor(Wff,search,_) ->        % list variables in first argument of search
                arg(1,Wff,X),
                variables(X,L);
        builtin(Wff) ->
                L = [];
        %true ->
                functor(Wff,_,N),
                (N > 0 ->
		   variablize_args(Wff,[],L,1,N);
		 %true ->
                   L = []).

variablize_args(Term,FnsIn,FnsOut,I,N) :-
	atom(Term) ->
		FnsOut = FnsIn;
	var(Term) ->
	        FnsOut = [Term|FnsIn];
        I > N ->
                FnsOut = FnsIn;
        %true ->
                arg(I,Term,ArgI),
		(var(ArgI) ->
		        union([ArgI],FnsIn,Fns1);
		%true ->
		        functor(ArgI,_,NI),
                        variablize_args(ArgI,FnsIn,Fns1,1,NI)),
                I1 is I + 1,
                variablize_args(Term,Fns1,FnsOut,I1,N).


variablize_clause(Clause,Vars) :-
	ClauseTerm =.. [clause|Clause],
	variables(ClauseTerm,Vars).

instance([],_,Clause).
instance(Vars,Cons,Clause) :-
	select(V,Vars,V1s),
	member(V,Cons),
	instance(V1s,Cons,Clause).

skolem([],Term,Term).
skolem([Var|Vars],Term,SkTerm) :-
	skolem(Vars,Term,Term1),
	SkTerm=(Var^Term1).

instances(Clause,Terms,Instances) :-
	variablize_clause(Clause,Vars),
	skolem(Vars,instance(Vars,Terms,Clause),DoIt),
	setof(Clause,DoIt,Instances).

instantiation([],_,[]) :-
	!.
instantiation(Matrix,[],Matrix) :-
	!.
instantiation([Clause|Matrix],Terms,MatrixInstances) :-
	instances(Clause,Terms,Instances),
	instantiation(Matrix,Terms,IMatrix),
	combine_clauses(Instances,IMatrix,MatrixInstances).




%%% Consistency checking.
%%%
%%% Add extra arguments to each goal so that information
%%% on what assumptions were made in the explaination can be checked
%%% at each step/the end.
%%%
%%% I suppose Wff has to be replaced by cmm(Model,ModelStructure) ...
%%% [all this is a quick copy of add_explaination_recording ...]

add_consistency_checking((Head :- Body),(Head1 :- Body1)) :-
        functor(Head,request,_) ->
                Head1 = Head,
		conjoin(model_initialization(MM0),Body,Body2),
		add_consistency_checking_args(Body2,MM0,MMOut,Body1);
        %true ->
		Head =.. L,
		append(L,[MMIn,MMOut],L1),
		Head1 =.. L1,
		add_consistency_checking_args(Body,MMIn,MMOut,Body1).

add_consistency_checking_args(Body,MMIn,MMOut,Body1) :-
        Body = (A , B) ->
                add_consistency_checking_args(A,MMIn,MMIn1,A1),
                add_consistency_checking_args(B,MMIn1,MMOut,B1),
                conjoin(A1,B1,Body1);
        Body = (A ; B) ->
                add_consistency_checking_args(A,MMIn,MMOut,A1),
                add_consistency_checking_args(B,MMIn,MMOut,B1),
                disjoin(A1,B1,Body1);
        Body =.. [search,Goal|L] ->
                add_consistency_checking_args(Goal,MMIn,MMOut,Goal1), % ???
                Body1 =.. [search,Goal1|L];
        Body = justification(X) ->
		Body1 = compatible(X,MMIn,MMOut);
        Body = fail ->
                Body1 = Body;
        builtin(Body) ->
                MMIn = MMOut,
                Body1 = Body;
        %true ->
                Body =.. L,
                append(L,[MMIn,MMOut],L1),
                Body1 =.. L1.

add_model_structure(WffI,Q,C,WffO) :-
	WffI = (A , B) ->
                add_model_structure(A,Q,C,A1),
                add_model_structure(B,Q,C,B1),
		conjoin(A1,B1,WffO);
        WffI = (A ; B) ->
                add_model_structure(A,Q,C,A1),
                add_model_structure(B,Q,C,B1),
		disjoin(A1,B1,WffO);
        WffI = (A :- B) ->
                add_model_structure(B,Q,C,B1),
		WffO = (A :- B1);
	WffI = model_initialization(Var) ->
	        combine_clauses(Q,C,Matrix),
		WffO = model_initialization(Matrix,Var);
        %true ->
	        WffO = WffI.

classical_clauses(WffI,WffO) :-
        WffI = (A , B) ->
                classical_clauses(A,A1),
                classical_clauses(B,B1),
		conjoin(A1,B1,WffO);
        WffI = (A ; B) ->
                classical_clauses(A,A1),
                classical_clauses(B,B1),
		disjoin(A1,B1,WffO);
        WffI = (A :- B) ->                        % ??? (special case request elim. TS Apr04)
	        WffO = true;
        builtin(WffI) ->
                WffO = true;
        %true ->
	        WffI = WffO.

request_clause(WffI,WffO) :-
        WffI = (A , B) ->
	        (request_clause(A,WffO);
                 request_clause(B,WffO));
        WffI = (A ; B) ->
                (request_clause(A,WffO);
                 request_clause(B,WffO));
        WffI = (A :- B) ->
	        (A = request ->
                      classical_clauses(B,WffO);
		 %true ->
                      fail);
        %true ->
	        fail.



%%% verbose predicate, chatting if verbose_mode is turned on
verbose(X) :-
	verbose_flag ->
	        writeSTDERR(X);
	%true->
		true.

%%% PRINT CONFIGURATION
%%%


%:- set_flag(print_depth,1000).
%:- set_flag(variable_names,off).

%:- dont_compile_count_beliefs.

:- do_compile_explaination_printing.            % default is to compile explaination printing
:- do_compile_complete_search.            % default is to compile complete search
:- admissibility_first.                     % default is to check admissibility first
:- verbose_mode.                         % default is to print explaination
:- body_hooks.
:- no_body_hooks.                      % default is no body hooks
:- pred_hooks.
:- no_pred_hooks.                      % default is no predicate hooks
:- print_explaination.                         % default is to print explaination
:- dont_trace_search.                        % default is to true searching

:- lemma_handling.                         % default is LEMMA HANDLING
:- lemma_mode(dynamic).                    % default is to use DYNAMIC lemmas only
:- lemma_type(delta).                      % default is to use DELTA lemmas only
:- lemma_type(all).
:- lemma_format(unit).                     % default is to use UNIT lemmas only


:-add_dystatic_lemmas.

%:- no_lemma_handling,lemma_configuration.   % indicated by lemma_handling_flag


:-configuration.


%%% This list can be added to as required.

builtin(T) :-
	nonvar(T),
        functor(T,F,N),
        builtin(F,N).

builtin(!,0).
builtin(true,0).
builtin(fail,0).
builtin(succeed,0).
builtin(true,0).
builtin(atom,1).
builtin(integer,1).
builtin(number,1).
builtin(atomic,1).
builtin(constant,1).
builtin(functor,3).
builtin(arg,3).
builtin(var,1).
builtin(nonvar,1).
builtin(call,1).
builtin(=,2).
builtin(\=,2).
builtin(==,2).
builtin(\==,2).
builtin(>,2).
builtin(<,2).
builtin(>=,2).
builtin(=<,2).
builtin(is,2).
builtin(display,1).
builtin(writeSTDERR,1).
builtin(true,0).
builtin(deduce_by,_).
builtin(write_proved,_).
builtin(search,_).
builtin(search_cost,_).
builtin(unify,_).
builtin(identical_member,_).
builtin(unifiable_member,_).
builtin(inc_ncalls,0).
% --- compatibility predicates
builtin(justification,_).
builtin(compatible,_).
builtin(model_initialization,_).
% --- variable handling predicates
builtin(herbrand,1).
% hooks handling predicates
builtin(hook1,1).
builtin(hook2,1).
% --- lemma handling predicates
builtin(lemmatize,_).
builtin(dynamic_lemma,_).
builtin(static_lemma,_).
% --- misc
builtin(\+,1).

% --- special purpose predicates
builtin(P,_) :-
	builtin_predicate(P).
builtin_predicate(P) :-
	name(P,L),
        (name('_pl',L1);
	 name('_db',L1)
        ),
        append(_,L1,L).
	/*
	
predicate_property( 
	transparent)
	
*/



% ===================================================================
% File 'moo_reader.pl' 
% Maintainer: Douglas Miles
% Contact: dmiles@users.sourceforge.net ;  
% Version: 2.0.0 
% 
% Purpose: is to provide forall character processing and transliteration for CycL, KIF, Prolog
% ===================================================================
%:-module(moo_reader,[readKIF/2,readKIF/1,readKIF_priv/2]).

% :-include(moo_header).

% TODO make reader more robust

:-dynamic reading_in_comment/0.
:-dynamic reading_in_string/0.
:-dynamic read_in_atom/0.
:-dynamic prev_char/1.

readKIF(CHARS)  :-       !,
         readKIF(user_input,CHARS).


readKIF(Stream,[])  :-at_end_of_stream(Stream).     
readKIF(Stream,CHARS)  :-
		kifReadStatePopParens,!,
		retractall(reading_in_comment),
		retractall(reading_in_string),!,
		once(readKIFChars_p0(Stream,CHARS)),!.

readKIF_priv(Stream,[])  :-at_end_of_stream(Stream).     
readKIF_priv(Stream,CHARS)  :-  
		kifReadStatePopParens,!,
		unset_g(reading_in_comment),
		unset_g(reading_in_string),!, %true,
		call_with_depth_limit(readKIFChars_p0_priv(Stream,CHARS),40000,_),!.

readKIFChars_p0_priv(Stream,[]):-at_end_of_stream(Stream),!.
readKIFChars_p0_priv(Stream,[Char|Chars]):- !,
        logOnFailure(peekKIFCharCode(Stream,C)),!,
	logOnFailure(term_to_atom(C,CS)),
	logOnFailure(kifUpdateReadState(CS)),!,
	(readKIFChars_next(C,Char,Stream,Chars)),!.
	
%peekKIFCharCode(Stream,10):-at_end_of_stream(Stream),!,dw('[at_end_of_stream]').
peekKIFCharCode(Stream,10):-peek_byte(Stream,13),!,skipKIFChar(Stream),dw('[ln]'),!.
peekKIFCharCode(Stream,10):-peek_byte(Stream,10),!,skipKIFChar(Stream),dw('[ln]'),!.
peekKIFCharCode(Stream,46):-peek_byte(Stream,46),!,skipKIFChar(Stream),dw('[dot]'),!.
peekKIFCharCode(Stream,32):-peek_byte(Stream,C),C < 32,!,skipKIFChar(Stream),dw('[ctl]'),!.
peekKIFCharCode(Stream,C):-peek_byte(Stream,38),!,skipKIFChar(Stream),dw('[skipping]'),peekKIFCharCode(Stream,C),!.
peekKIFCharCode(Stream,C):-peek_byte(Stream,46),!,skipKIFChar(Stream),dw('[skip-dot]'),peekKIFCharCode(Stream,C),!.
peekKIFCharCode(Stream,C):-peek_byte(Stream,37),!,skipKIFChar(Stream),dw('[skipping]'),peekKIFCharCode(Stream,C),!.
peekKIFCharCode(Stream,C):-peek_byte(Stream,C),skipKIFChar(Stream),!. %,put(C),!.
peekKIFCharCode(Stream,C):-peek_byte(Stream,C),flush,dw('[peekKIFCharCode]'),sleep(2),!,peekKIFCharCode(Stream,C),!.

readKIFChars_next(C,C,Stream,Chars):-if_g(reading_in_string),readKIFChars_p0_priv(Stream,Chars),!.
readKIFChars_next(10,10,Stream,[]):-if_g(reading_in_comment),!.
readKIFChars_next(13,10,Stream,[]):-if_g(reading_in_comment),!.
readKIFChars_next(C,C,Stream,Chars):-if_g(reading_in_comment),readKIFChars_p0_priv(Stream,Chars),!.
readKIFChars_next(41,41,Stream,[]):-flag('bracket_depth',X,X),(X=0),!.
readKIFChars_next(C,Char,Stream,Chars):-once(kifAsciiRemap(C,Char)),!,readKIFChars_p0_priv(Stream,Chars),!.
readKIFChars_next(C,Char,Stream,Chars):-dw(errror).

set_g(F):-!,flag(F,_,2),!.
unset_g(F):-!,flag(F,_,1),!.
if_g(F):-!,flag(F,X,X),not(X=1),!.

%end_char(41,41)  :-   moo_console_bracket_depth(D),D<1,!. 

kifUpdateReadState('46'):-dw('[dotp]'),!.
kifUpdateReadState('32'):-!.
kifUpdateReadState(_):- if_g(reading_in_comment),dw('[;]'),!.
kifUpdateReadState('34'):-!,
		(if_g(reading_in_string) -> (dw('[strout]'),unset_g(reading_in_string));(set_g(reading_in_string),!,dw('[strin]'))),!.
kifUpdateReadState('46'):-if_g(reading_in_string),dw('='),!.
kifUpdateReadState(_):-if_g(reading_in_string),dw('='),!.
kifUpdateReadState('59'):- set_g(reading_in_comment),dw('[commentStart]'),!.

kifUpdateReadState('40'):-!,logOnFailure(flag('bracket_depth',N,N)),dw(n(N)),logOnFailure(flag('bracket_depth',N,N + 1)),logOnFailure((V is N +1)),logOnFailure(dw([brackin:V])),!.
kifUpdateReadState('41'):-!,flag('bracket_depth',N,N - 1),dw([brackout:N]),!.
kifUpdateReadState(_):-!. %dw('-'),!.

:-dynamic(bd/1).

%bdInc:-

dw(W):-flush_output,!. %write(W),flush. %,flush(user_error).

kifReadStatePopParens:-flag('bracket_depth',_,0),!,dw(newbd).

skipKIFChar(Stream):- at_end_of_stream(Stream),!.
skipKIFChar(Stream):- logOnFailure(get_char(Stream,_)),!.
/*
		stream_property(Stream,position('$stream_position'(PCharIndex, PLineNo, PLinePos))),
		NCharIndex is PCharIndex +1,
		seek(Stream,NCharIndex, bof, CharIndex),
		ignore(check_same(NCharIndex,CharIndex)).
*/

check_same(NCharIndex,CharIndex):-NCharIndex == CharIndex,!.
check_same(NCharIndex,CharIndex):-dw('!@#$%@#!@'),dw((NCharIndex,CharIndex)).


getSurfaceFromChars_d(Chars,WFFOut,VARSOut):- 
    retractall(var_counter(_)),retractall(numbered_var(_,_,_)),asserta(var_counter(0)), 
               (getKIFTokens(Chars,Tokens) -> true ; (sendNote(user,kifParser,'Syntax Error (or I need more work)',Chars),sleep(2),fail)),
               logOnFailure(clean_sexpression(Tokens,WFFClean)),
               logOnFailure(phrase(expr(WFF),WFFClean)),
               collect_temp_vars(VARS),
              !, ( 
                     (VARS=[],VARSOut=_,WFFOut=WFF)
               ;
                     (
                     unnumbervars(VARS,LIST),
                     kifVarNums(LIST,WFF,WFFOut,VARSOut2) ,
                     list_to_set(VARSOut2,VARSOut1),
                     open_list(VARSOut1,VARSOut)
                     ) 
               ).

            




readKIFChars_p0(Stream,[]):-at_end_of_stream(Stream),!.
readKIFChars_p0(Stream,[Char|Chars]):-
        get_code(Stream,C),!,
	kifReadStateChange(C),!,readKIFChars_p1(C,Char,Stream,Chars),!.
	
readKIFChars_p1(C,Char,Stream,[]):-isKIFTerminationStateChar(C,Char),!.
readKIFChars_p1(C,Char,Stream,Chars):-once(kifAsciiRemap(C,Char)),!,readKIFChars_p0(Stream,Chars),!.



isKIFTerminationStateChar(10,32)  :-reading_in_comment,!.
isKIFTerminationStateChar(13,32)  :-reading_in_comment,!.
isKIFTerminationStateChar(41,41)   :-  flag('bracket_depth',X,X),!,(X=0),!.
%isKIFTerminationStateChar(41,41)  :-   moo_console_bracket_depth(D),D<1,!. 


kifReadStateChange(_):- reading_in_comment,!.
kifReadStateChange(34):-retract(reading_in_string),!.
kifReadStateChange(34):-assert(reading_in_string),!.
kifReadStateChange(_):-reading_in_string,!.
kifReadStateChange(59):- assert(reading_in_comment),!.

kifReadStateChange(40):-!,flag('bracket_depth',N,N + 1).
kifReadStateChange(41):-!,flag('bracket_depth',N,N - 1).
kifReadStateChange(_).

%kifAsciiRemap(X,Y):-(catch(kifAsciiRemap0(X,Y),_,fail)),!.

kifAsciiRemap(X,X).

kifAsciiRemap(N,32):-not(number(N)).
kifAsciiRemap(X,32):-X<32,!.
kifAsciiRemap(X,32):-X>128,!.
kifAsciiRemap(X,X):-!.


isCodesWhite([]).
isCodesWhite([T|W]):-member(T,[32,10,13]),isCodesWhite(W).


% :-include('moo_header.pl').

% TODO Need support for
/*
Predicate AFTER

% 3037 (pnx_nf (FORWARD (arg1Isa hasMembers Organization)) GlobalContext T-3015) 
surface(DynStat,'clause-form'(arg1Isa(hasMembers,'Organization')),'BaseIContext','GlobalContext','T-3015',_h75135). 
clf(arg1Isa(hasMembers,'Organization'),true,'BaseIContext','GlobalContext','T-3015',3110).

)
% ===================================================================
% EXPORTS
% ===================================================================
 */
 
ssleep(_).       
                  
source_from_stream(Stream,[],surf,Vars):-at_end_of_stream(Stream),!.
source_from_stream(Stream,Trimed,Surface,Vars):-
		logOnFailure(once(readKIF_priv(Stream,RRAW))), %writeFmt('~s\n',[RRAW]),
		once(after_readKIF(Stream,RRAW,Trimed,Surface,Vars)),!.
source_from_stream(Stream,Trimed,Surface,Vars):-line_count(Stream,Line),writeFmt(user_error,'\nLine ~w  Unreadable KIF (source_from_stream) \n',[Line]),ssleep(2),!.

after_readKIF(Stream,RRAW,L_trimmed,Surface,Vars):-
			logOnFailure(getCleanCharsWhitespaceProper(RRAW,Trimed)),
			(once(ltrim(Trimed,L_trimmed))),
			source_from_clean_chars(Stream,L_trimmed,Surface,Vars).

after_readKIF(Stream,RRAW,Trimed,surf,Vars):- line_count(Stream,Line),writeFmt('\nLine ~w  Unreadable KIF: ~s (after_readKIF) \n',[Trimed,RRAW]),ssleep(2),!.

source_from_chars(RRAW,Surface,Vars):-
			source_from_chars(user_input,RRAW,Surface,Vars).

source_from_chars(Stream,RRAW,Surface,Vars):-
			logOnFailure(once(getCleanCharsWhitespaceProper(RRAW,Trimed))),
			logOnFailure(once(ltrim(Trimed,L_trimmed))),
			source_from_clean_chars(Stream,L_trimmed,Surface,Vars).
       
source_from_clean_chars(Stream,"var in stream",surf,Vars):-!,line_count(Stream,Line),writeFmt('\nLine ~w  Var in Stream KIF " \n',[Line]),ssleep(2),!.
source_from_clean_chars(Stream,[40|REST],Surface,Vars):-
				once(getSurfaceFromChars([40|REST],KIFSTERM,Vars)),
				once(source_from_sterm(Stream,KIFSTERM,Surface,Vars)),!.

source_from_clean_chars(Stream,[59|REST],file_comment(Atom),Vars):-!,string_to_atom([59|REST],Atom).% ignore(catch(fmtString(CMT,'~s',[59|REST]),_,fmtString(CMT,'~w',[59|REST]))).

source_from_clean_chars(Stream,[],surf,Vars).
source_from_clean_chars(Stream,[10],surf,Vars).
source_from_clean_chars(Stream,[13],surf,Vars).
source_from_clean_chars(Stream,Trimed,file_comment(nil),Vars):-!,line_count(Stream,Line),ignore(catch(writeFmt('\nLine ~w  Unreadable KIF "~s"\n',[Line,Trimed]),_,true)),ssleep(2),!.


source_from_sterm(Stream,KIFSTERM,Surface,Vars):-
			getMooTermFromSurface(KIFSTERM,Surface).

source_from_sterm(Stream,KIFSTERM,Surface,Vars):-(line_count(Stream,Line),writeFmt('\nLine ~w  Uninterpretable "~q" (~q)\n',[Line,KIFSTERM,kif])),ssleep(2).

/*

Purpose:                                                         
  
Transliterator to get KIF-like KR turned into a more expressive ground form sometimes using only syntax rules

Used by moo_server

% These predicates are used by moo_useragent.P and moo_operation.P

:-export 
      pterm_to_sterm/2, 
      sterm_to_pterm/2,
      conv_to_sterm/3,
      conv_to_pterm/3,
      conv_full_trans_request/3,
      conv_full_trans_generic/3,
      conv_full_trans_assert/3,
      getSurfaceFromChars/3.

  In XSB modules cannot use DCGs
*/

                           
% ===================================================================
% EXPORTS
% ===================================================================
                         
/*

:-export readKIF/1.
:-export readKIF/2.

:-export conv_readS/3.
:-export conv_readP/3.
:-export conv_readS/4.
:-export conv_readP/4.
:-export e_o_f/1.
:-export conv_file_line_format/6.

  */                         
                           
% ===================================================================
% IMPORTS
% ===================================================================

                                                         
:-assert(re_entry(conv_kr_rule_assert)).

kif_to_xml(KIF,ML):-
         tell_retract_parse_chars(KIF,X,V),
         toMarkUp(leml,X,V,ML).


% =====================================================================================
%  tell_retract_parse_chars(Chars,FORM,Vars) and  ask_parse_chars(Chars,FORM,Vars)
%  Both Return FORM='nil' if not well formed
% =====================================================================================

tell_retract_parse_chars(Chars,FORM,Vars):-
         logOnFailure(getCleanCharsWhitespaceProper(Chars,Show)),!,
         once(getSurfaceFromChars(Show,STERM,Vars)),!,
         getMooTermFromSurface(STERM,NEWFORM),!,  
              once(( 
                    NEWFORM=browser_only(browser_only(comment(end_of_file))) -> 
                           ((
                             catch(fmtString(What,'~s',[Show]),_,What='Unreadable'),!,
                             sendNote(user,kifParser,'Assertion/Retraction Syntax error: Unmatched parentheses',['"',What,'"',nl,helplink('Syntactical Well Formedness','syntax.html')]),
                             FORM=nil 
                             ))
                                 ;
                           (!,FORM=NEWFORM)
                     )).


ask_parse_chars(Chars,FORM,Vars):-
         logOnFailure(getCleanCharsWhitespaceProper(Chars,Show)),!,
         once(getSurfaceFromChars(Show,STERM,Vars)),!,
         getMooTermFromSurface(STERM,NEWFORM),!,
              once(( 
                    NEWFORM=browser_only(browser_only(comment(end_of_file))) -> 
                           ((
                             catch(fmtString(What,'~s',[Show]),_,What='Unreadable'),!,
                             sendNote(user,kifParser,'Request Syntax error: Unmatched parentheses',['"',What,'"',nl,helplink('Syntactical Well Formedness','syntax.html')]),
                             FORM=nil 
                             ))
                                 ;
                           (!,FORM=NEWFORM)
                     )).


/*===================================================================
Convert Prolog Term to S-Expression

Recursively Applies the Univ Op to create an easier to compile prolog writeFmt
                                                 
Examples:

| ?- pterm_to_sterm((G(X,Y):-A(X,Y)),Sterm).
Sterm = [:-,[_h76,_h90,_h104],[_h122,_h90,_h104]]

| ?- pterm_to_sterm(t,Sterm).
Sterm = [t]

| ?- pterm_to_sterm(t(a),Sterm).
Sterm = [t,[a]]

| ?- pterm_to_sterm(and(a,b),Sterm).
Sterm = [and,[a],[b]]

====================================================================*/
%pterm_to_sterm(X,X):-!,writeq(pterm_to_sterm(X,X)).


pterm_to_sterm(VAR,VAR):-isSlot(VAR),!.
pterm_to_sterm([],['AssignmentFn','Set',[]]):-!.
pterm_to_sterm(ATOM,[ATOM]):-atomic(ATOM),!.
pterm_to_sterm(PTERM,STERM):-compound(PTERM),
            PTERM=..[holds,P|PARGS],         !,
            pterm_to_sterm_list(PARGS,SARGS),
            STERM=[P|SARGS].
pterm_to_sterm(PTERM,STERM):-compound(PTERM),!,
            PTERM=..[P|PARGS],
            pterm_to_sterm_list(PARGS,SARGS),
            STERM=[P|SARGS].

pterm_to_sterm_list([],[]):-!.
pterm_to_sterm_list([P|PTERM],[S|STERM]):-!,
              pterm_to_sterm(P,S),
              pterm_to_sterm_list(PTERM,STERM).

/*===================================================================
Convert Prolog Term to S-Expression

Recursively Applies the Univ Op to create an easier to compile prolog writeFmt
                                                 
Examples:

| ?- pterm_to_sterm_native((G(X,Y):-A(X,Y)),Sterm_native).
Sterm_native = [:-,[holds,_h76,_h90,_h104],[holds,_h122,_h90,_h104]]

| ?- pterm_to_sterm_native(t,Sterm_native).
Sterm_native = [t]

| ?- pterm_to_sterm_native(t(a),Sterm_native).
Sterm_native = [t,[a]]

| ?- pterm_to_sterm_native(and(a,b),Sterm_native).
Sterm_native = [and,[a],[b]]

====================================================================*/
%pterm_to_sterm_native(X,X):-!,writeq(pterm_to_sterm_native(X,X)).


pterm_to_sterm_native(VAR,VAR):-isSlot(VAR),!.
pterm_to_sterm_native([],['AssignmentFn','Set',[]]):-!.
pterm_to_sterm_native(ATOM,[ATOM]):-atomic(ATOM),!.
pterm_to_sterm_native(PTERM,STERM_NATIVE):-compound(PTERM),!,
            PTERM=..[P|PARGS],
            pterm_to_sterm_native_list(PARGS,SARGS),
            STERM_NATIVE=[P|SARGS].

pterm_to_sterm_native_list([],[]):-!.
pterm_to_sterm_native_list([P|PTERM],[S|STERM_NATIVE]):-!,
              pterm_to_sterm_native(P,S),
              pterm_to_sterm_native_list(PTERM,STERM_NATIVE).

/*===================================================================
Convert S-Expression originating from user to a Prolog Clause representing the surface level

Recursively creates a Prolog term based on the S-Expression to be done after compiler
                                                 
Examples:

| ?- sterm_to_pterm([a,b],Pterm).
Pterm = a(b)

| ?- sterm_to_pterm([a,[b]],Pterm).    %Note:  This is a special Case
Pterm = a(b)

| ?- sterm_to_pterm([holds,X,Y,Z],Pterm).    %This allows Hilog terms to be Converted
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm([X,Y,Z],Pterm).   %But still works in normal places
Pterm = _h76(_h90,_h104)                    

| ?- sterm_to_pterm(['AssignmentFn',X,[Y,Z]],Pterm).                                
Pterm = 'AssignmentFn'(_h84,[_h102,_h116])
====================================================================*/

sterm_to_pterm(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm([VAR],VAR):-isSlot(VAR),!.
sterm_to_pterm([X],Y):-!,nonvar(X),sterm_to_pterm(X,Y).

sterm_to_pterm([S|TERM],PTERM):-isSlot(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-number(S),!,
            sterm_to_pterm_list([S|TERM],PTERM).            
	    
sterm_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].

sterm_to_pterm([S|TERM],PTERM):-!,  atomic(S),
            sterm_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

sterm_to_pterm(VAR,VAR):-!.

sterm_to_pterm_list(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_list([],[]):-!.
sterm_to_pterm_list([S|STERM],[P|PTERM]):-!,
              sterm_to_pterm(S,P),
              sterm_to_pterm_list(STERM,PTERM).
sterm_to_pterm_list(VAR,[VAR]).

/*===================================================================
Convert S-Expression originating from user to a Prolog Clause representing the surface level

Recursively creates a Prolog term based on the S-Expression to be done after compiler
                                                 
Examples:

| ?- sterm_to_pterm_native([a,b],Pterm_native).
Pterm_native = a(b)

| ?- sterm_to_pterm_native([a,[b]],Pterm_native).    %Note:  This is a special Case
Pterm_native = a(b)

| ?- sterm_to_pterm_native([holds,X,Y,Z],Pterm_native).    %This allows Hilog terms to be Converted
Pterm_native = _h76(_h90,_h104)                    

| ?- sterm_to_pterm_native([X,Y,Z],Pterm_native).   %But still works in normal places
Pterm_native = _h76(_h90,_h104)                    

| ?- sterm_to_pterm_native(['AssignmentFn',X,[Y,Z]],Pterm_native).                                
Pterm_native = 'AssignmentFn'(_h84,[_h102,_h116])
====================================================================*/

sterm_to_pterm_native(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_native([VAR],VAR):-isSlot(VAR),!.
sterm_to_pterm_native([X],Y):-!,nonvar(X),sterm_to_pterm_native(X,Y).
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-isSlot(S),
            sterm_to_pterm_native_list(TERM,PLIST),            
            PTERM_NATIVE=..[holds,S|PLIST].
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-number(S),!,
            sterm_to_pterm_native_list([S|TERM],PTERM_NATIVE).            
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-nonvar(S),atomic(S),!,
            sterm_to_pterm_native_list(TERM,PLIST),            
            PTERM_NATIVE=..[S|PLIST].
sterm_to_pterm_native([S|TERM],PTERM_NATIVE):-!,  atomic(S),
            sterm_to_pterm_native_list(TERM,PLIST),            
            PTERM_NATIVE=..[holds,S|PLIST].
sterm_to_pterm_native(VAR,VAR):-!.

sterm_to_pterm_native_list(VAR,VAR):-isSlot(VAR),!.
sterm_to_pterm_native_list([],[]):-!.
sterm_to_pterm_native_list([S|STERM],[P|PTERM_NATIVE]):-!,
              sterm_to_pterm_native(S,P),
              sterm_to_pterm_native_list(STERM,PTERM_NATIVE).
sterm_to_pterm_native_list(VAR,[VAR]).

% [and,A,B]                           lc(pos,and(A,B))                     A equal B
% [not,[and,A,B]]                   lc(neg,and(A,B))                  ~ A equal B
% [or,A,B]                             lc(pos,or(A,B))                        A v B
% ['relation-const',V,B]            lc(pos,pc(pos,'relation-const',[V,B]))          relation-const(V,B)
% [thereExists,V,['relation-const',V,B]]        lc(pos,exists(1,V,pc(pos,'relation-const',[V,B])))          ex V:  r(V,B)
% [forall,V,[not,['relation-const',V,B]]]          lc(pos,univ(forall,V,pc(neg,'relation-const',[V,B])))               ex V:  ~r(V,B)
% ['AssignmentFn',A,[B]]                         'AssignmentFn'(A,[B])
% Fido   ->                            'AssignmentFn'(_,['Fido'])
% [+,1,1] ->                          comp(+(1,1))
% [list,1,2] ->                        varparams([1,2])


% lc -> or clause
% lc -> and clause
% lc -> predicate constant clause
% lc -> exists clause
% lc -> univ clause
% lc -> => clause
% lc -> <=> clause
                                        
         
% ========================================================
%          Atom Transliteration
% ========================================================




% Prolog Declarations
'surface-instance'((':-'),'ImplicationConnective',_).
'surface-instance'((','),'ConjunctionalConnective',_).
'surface-instance'((';'),'DisjunctionalConnective',_).
'surface-instance'((':-'),'Connective',_).
'surface-instance'((','),'Connective',_).
'surface-instance'((';'),'Connective',_).
'surface-instance'(('=>'),'ImplicationConnective',_).
'surface-instance'(('and'),'ConjunctionalConnective',_).
'surface-instance'(('or'),'DisjunctionalConnective',_).
'surface-instance'(('=>'),'Connective',_).
'surface-instance'(('and'),'Connective',_).
'surface-instance'(('or'),'Connective',_).

% Brought in from moo_language.[KIF|P]
'surface-instance'(A,B,_):-'surface-instance'(A,B).
'surface-instance'(A,C,_):-'surface-instance'(A,B),'surface-subclass'(B,C).
'surface-instance'(A,D,_):-'surface-instance'(A,B),'surface-subclass'(B,C),'surface-subclass'(C,D).
'surface-instance'(A,E,_):-'surface-instance'(A,B),'surface-subclass'(B,C),'surface-subclass'(C,D),'surface-subclass'(D,E).


% Brought in from moo_language.[KIF|P]
'surface-instance'(Arity2Pred,'ArityTwoPredicate',_C):-'surface-multiple-arity'(Arity2Pred).
'surface-instance'(Arity1Pred,'ArityOnePredicate',_C):-'surface-single-arity'(Arity1Pred).
'surface-instance'(AE,'Quantifier',_):-'surface-quantifier'(AE).
'surface-instance'(findall,'Quantifier',_).


'surface-instance'(and,'ArityTwoPredicate',_C).
'surface-instance'(or,'ArityTwoPredicate',_C).
'surface-instance'('<=>','ArityTwoPredicate',_C).
'surface-instance'('=>','ArityTwoPredicate',_C).
         
% ========================================================
%           Generic Transliteration
% ========================================================

conv_kr_rule_generic(V,V):- isSlot(V),!.


conv_kr_rule_generic(IN,Out):- conv_pred(IN,Out),!.
conv_kr_rule_generic(G,G).

conv_kr_re_entry(IN,Out):-conv_pred(IN,Out),!.

% ========================================================
%           Common Transliteration  Expects S-Expression
% ========================================================

conv_pred(V,V):- isSlot(V),!.
conv_pred([],[]).
conv_pred([V],[V]):- isSlot(V),!.
conv_pred( Before, After) :- atom(Before),'surface-word'( Before, After),!.

% Variable in the 1st Position
conv_pred([Op|A],[Op|List]):-isSlot(Op),!,conv_pred_list(A,List).


conv_pred([V,A|R],New):- copy_term([V,A|R],Process),	
		       'surface-macro'(Process,_),
		       once((getPrologVars([V,A|R],BV,_,_), 
		       getPrologVars(Process,PV,_,_))),
		       length(PV,X),length(BV,X),!,
		       'surface-macro'([V,A|R],NewTerm),!,
		       conv_kr_re_entry(NewTerm,New).


% Arity2Predicates that have only More then 2 Arguments
conv_pred([Arity2Pred,A,B,C|M],List):-   
                              'surface-instance'(Arity2Pred,'ArityTwoPredicate',_C),!,
                                conv_functsymbol_two([Arity2Pred,A,B,C|M],MID),!,
                                conv_kr_re_entry(MID,List).

	conv_functsymbol_two([],[]).
	conv_functsymbol_two([Pred,A,B,C|More],List):-!,
		    conv_functsymbol_two([Pred,B,C|More],SEMORE),
		    conv_functsymbol_two([Pred,A,SEMORE],List).
	conv_functsymbol_two([_Pred,_A,_B],[_Pred,_A,_B]):-!.
	conv_functsymbol_two([_Pred,_A],_A):-!.


% Arity2Predicates that have only one Argument (Are squashed)
conv_pred([Arity2Pred,MID],List):-   
                              'surface-instance'(Arity2Pred,'ArityTwoPredicate',_C),!,
                                conv_kr_re_entry(MID,List).

% multiple arity not/not
conv_pred([Arity1Pred,A,B|More],List):-  
	    'surface-instance'(Arity1Pred,'ArityOnePredicate',_C),!,
            conv_kr_re_entry([Arity1Pred,B|More],BEMORE),
            conv_kr_re_entry([and,[Arity1Pred,A],BEMORE],List).

% Arity1Predicates that are logical connectives
conv_pred([Arity1Pred,A],[Arity1Pred,List]):- 'surface-instance'(Arity1Pred,'Connective',_C),!,
              conv_kr_re_entry(A,List).


% ========================================================
% Agregation Predicates
% ========================================================
%conv_kr_re_entry([Agregation,Entity,[=>,Ant,Con]],Formula):-nonvar(Agregation),member(Agregation,[forall,forall,for_all,forall]),conv_kr_re_entry([=>,[and,exists(Entity),Ant],Con],Formula).

% Single Entity Exists  %[exists,[list],tr]                                           
conv_pred([AE,[Entity,Collection],FormulaA],Result):- ('surface-instance'(AE,'ExistentualQuantifier',_)),
	conv_kr_re_entry(AE,AO),
            isSlot(Entity),nonvar(Collection),!,conv_kr_re_entry(FormulaA,FormulaAO),
            conv_kr_re_entry(['and',[instance,Entity,Collection],FormulaAO],FormulaB),
            conv_kr_re_entry([AO,Entity,FormulaB],Result).

conv_pred([AE,[Entity,Collection],FormulaA],Result):- ('surface-instance'(AE,'UniversalQuantifier',_)),
            isSlot(Entity),nonvar(Collection),!,conv_kr_re_entry(FormulaA,FormulaAO),
            conv_kr_re_entry(['=>',[instance,Entity,Collection],FormulaAO],Result).

conv_pred([AE,Entity,FormulaA],[AO,Entity,FormulaB]):- ('surface-instance'(AE,'Quantifier',_)),
	conv_kr_re_entry(AE,AO),
            isSlot(Entity),!,
            conv_kr_re_entry(FormulaA,FormulaB).

conv_pred([AE,[],FormulaA],FormulaB):- ('surface-instance'(AE,'Quantifier',_)),!,
            conv_kr_re_entry(FormulaA,FormulaB).

conv_pred([AE,[Struct|More],FormulaA],Result):- ('surface-instance'(AE,'Quantifier',_)),
            !,   conv_kr_re_entry(FormulaA,FormulaAO),  %%%% AO
	conv_kr_re_entry(AE,AO),
            conv_kr_re_entry([AO,Struct,FormulaAO],ResultFormulaA),
            conv_kr_re_entry([AO,More,ResultFormulaA],Result).

%conv_pred([Pred|ARGS],[browser_only,[Pred|ARGS]]):-'browser-only'(Pred),!.

conv_pred([Class,Pred], ['instance',Pred,Class]):-nonvar(Pred),'surface-class'(Class),!.               

conv_pred([A|T],[AO|TO]):-!,conv_pred_list([A|T],[AO|TO]).

conv_pred(A,A):-!.

conv_pred_list(Var,Var):-isSlot(Var),!.
conv_pred_list([],[]):-!.
conv_pred_list([H|T],[HH|TT]):-!,
         conv_kr_re_entry(H,HH),
         conv_pred_list(T,TT).


% ========================================================
% Mine Out Formulas Durring Transliteration
% ========================================================

reduce_arg_nth(_C,_,_,[],[]):-!.
reduce_arg_nth(_C,Pred,N,[ArgS|ArgSS],[ArgSO|ArgSOS]):-!,
            conv_kr_re_entry(ArgS,ArgSO),
            reduce_arg_nth(_C,Pred,NN,ArgSS,ArgSOS).

% Need to be moved to KIF File
kif_to_pterm_nv_fn([FN,ID,LITS],LITP):-nonvar(ID),ID='Set',kif_to_pterm_list(LITS,LITP),!.
kif_to_pterm_nv_fn([FN,ID,LITS],'AssignmentFn'(ID,LITP)):-kif_to_pterm_list(LITS,LITP),!.
kif_to_pterm_nv_fn([FN,ID|LITS],LITP):-nonvar(ID),ID='Set',kif_to_pterm_list(LITS,LITP),!.
kif_to_pterm_nv_fn([FN,ID|LITS],'AssignmentFn'(ID,LITP)):-kif_to_pterm_list(LITS,LITP),!.


kif_to_pterm(VAR,VAR):-isSlot(VAR),!.
kif_to_pterm([KIF],P):-!,kif_to_pterm(KIF,P).
kif_to_pterm('zzskFn'(X),'zzskFn'(X)):-!.
kif_to_pterm([AS,X,Y],'surface-macro'(X,Y)):-nonvar(AS),AS='surface-macro',!.
%kif_to_pterm([Fn, Fn, [X|LIST]],'AssignmentFn'(X,PLIST)):-nonvar(Fn),Fn='AssignmentFn',!,kif_to_pterm_list(LIST,PLIST).
%%kif_to_pterm([ID,FN|LITS],OUT):-nonvar(FN),FN='AssignmentFn',kif_to_pterm([FN,ID|LITS],OUT),!.
%kif_to_pterm([FN,ID|LITS],OUT):-nonvar(FN),FN='AssignmentFn',kif_to_pterm_nv_fn([FN,ID|LITS],OUT),!.
kif_to_pterm([X],Y):-!,nonvar(X),kif_to_pterm(X,Y).
kif_to_pterm(ATOM,ATOM):-atomic(ATOM),!.

kif_to_pterm([S|TERM],PTERM):-isSlot(S),
            kif_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds,S|PLIST].

kif_to_pterm([holds|TERM],PTERM):-!,
            kif_to_pterm_list(TERM,PLIST),            
            PTERM=..[holds|PLIST].
	    	    
kif_to_pterm([S|TERM],PLIST):-nonvar(S),number(S),!,
            kif_to_pterm_list([S|TERM],PLIST).    
	            
kif_to_pterm([S|TERM],PTERM):-nonvar(S),atomic(S),!,
            kif_to_pterm_list(TERM,PLIST),            
            PTERM=..[S|PLIST].
	    
kif_to_pterm(VAR,VAR):-!.

kif_to_pterm_list(VAR,VAR):-isSlot(VAR),!.
kif_to_pterm_list([],[]):-!.
kif_to_pterm_list([S|STERM],[P|PTERM]):-!,
              kif_to_pterm(S,P),
              kif_to_pterm_list(STERM,PTERM).
	      
kif_to_pterm_list(VAR,[VAR]).


'surface-domain'(salientAssertions,2,'Formula',_Cxt).
'surface-domain'(ist,2,'Formula',_Cxt).

'surface-domain'(P,1,'Formula',_Cxt):-nonvar(P),'surface-instance'(P,'Connective',_).
'surface-domain'(P,2,'Formula',_Cxt):-nonvar(P),'surface-instance'(P,'Connective',_).
'surface-domain'(P,N,T,_):-'domain'(P,N,T,_Cxt).
'surface-domain'(P,N,T,_):-'domain'(P,N,T2,_Cxt),'subclass'(T,T2,_Cxt).

:-dynamic('domain'/4).
:-dynamic('subclass'/3).




/*===================================================================
% getSurfaceFromChars/3 is does less consistantsy checking then conv_to_sterm

Always a S-Expression: 'WFFOut' placing variables in 'VARSOut'

|?-getSurfaceFromChars("(isa a b)",Clause,Vars).
Clause = [isa,a,b]
Vars = _h70

| ?- getSurfaceFromChars("(isa a (b))",Clause,Vars).
Clause = [isa,a,[b]]
Vars = _h70

|?-getSurfaceFromChars("(list a b )",Clause,Vars)
Clause = [list,a,b]
Vars = _h70

| ?- getSurfaceFromChars("(genlMt A ?B)",Clause,Vars).
Clause = [genlMt,'A',_h998]
Vars = [=('B',_h998)|_h1101]

| ?- getSurfaceFromChars("(goals Iran  (not   (exists   (?CITIZEN)   (and    (citizens Iran ?CITIZEN)    (relationExistsInstance maleficiary ViolentAction ?CITIZEN
)))))",Clause,Vars).

Clause = [goals,Iran,[not,[exists,[_h2866],[and,[citizens,Iran,_h2866],[relationExistsInstance,maleficiary,ViolentAction,_h2866]]]]]
Vars = [=(CITIZEN,_h2866)|_h3347]

====================================================================*/

getSurfaceFromChars([],[end_of_file],_):-!.

getSurfaceFromChars([CH|ARSIn],TERM,VARS):-!, 
         %getCleanCharsWhitespaceProper(CHARSIn,NoWhiteCHARS),!,  
         logOnFailure(ltrim([CH|ARSIn],CHARS)),!,
              CHARS=[FC|REST],!,
          (( 
            ([FC]=";",TERM=[comment,end_of_file], VARS= _ ) ;   %Comment Char found in Line
            (CHARS=[],TERM=nil,VARS=_,! 	  )    %String came empty
            ;
            (FC=40,getSurfaceFromChars_2(CHARS,TERM,VARS) ,! )    %Use vanila KIF parser
            ;
            ( TERM=[comment,end_of_file],VARS= _,! )     %All above methods of parsing failed.. Convert to comment
            )).
	    
getSurfaceFromChars(C,TERM,VARS):-string_to_list(C,List),!,getSurfaceFromChars(List,TERM,VARS),!.


getSurfaceFromChars_2(Chars,WFFOut,VARSOut):- 
    retractall(var_counter(_)),retractall(numbered_var(_,_,_)),asserta(var_counter(0)), 
               once(getKIFTokens(Chars,Tokens)), 
               once((clean_sexpression(Tokens,WFFClean))),
               phrase(moo(WFF),WFFClean),
               collect_temp_vars(VARS),
              !, ( 
                     (VARS=[],VARSOut=_,WFFOut=WFF)
               ;
                     (
                     unnumbervars(VARS,LIST),
                     kifVarNums(LIST,WFF,WFFOut,VARSOut2) ,
                     list_to_set(VARSOut2,VARSOut1),
                     open_list(VARSOut1,VARSOut)
                     ) 
               ).

    

/*===================================================================
% clean_sexpression(Tokens,CleanTokens)

Removes out STANDARD tokens

====================================================================*/

clean_sexpression([],[]).
clean_sexpression(['#$'|WFF],WFFClean):-clean_sexpression(WFF,WFFClean).
clean_sexpression(['#'|WFF],WFFClean):-clean_sexpression(WFF,WFFClean).
clean_sexpression(['$'|WFF],WFFClean):-clean_sexpression(WFF,WFFClean).
clean_sexpression([E|WFF],[E|WFFClean]):-clean_sexpression(WFF,WFFClean).


%isCharCodelist([]):-!.
%isCharCodelist([H|T]):-!,integer(H),isCharCodelist(T).

/*===================================================================
% S-Expression Version of ISO-Prolog chars_to_tem/3
====================================================================*/
chars_to_term_s(CHARS,TERM,VARS):-
             once(chars_to_term(CHARS,PTERM,VARS)),
             once(pterm_to_sterm(PTERM,TERM)).


/*===================================================================
% Safe Entry Call Into ISO-Prolog tokenize_chars/2
====================================================================*/

getKIFTokens(X,Z):-is_list(X),!,  tokenize_chars(X,Y),convert_the_atoms(Y,Z).

convert_the_atoms([],[]):-!.
convert_the_atoms([H|T],[HH|TT]):-!,  
                convert_the_atom(H,HH),
                convert_the_atoms(T,TT).

%convert_the_atom(H,HH):-atom_codes(H,[34|Rest]),reverse(Rest,[_|AtomCharsR]),reverse(AtomCharsR,AtomChars),atom_codes(HH,AtomChars).
%convert_the_atom(H,HH):-atom_codes(H,[39|Rest]),reverse(Rest,[_|AtomCharsR]),reverse(AtomCharsR,AtomChars),atom_codes(HH,AtomChars).
convert_the_atom(H,H):-!.


getKIFTokens(X,[X]). 

/*===================================================================
% Removes Leading whitespaces and not ANSI charset
====================================================================*/

ltrim([],[]):-!.
ltrim([P|X],Y):-P<33,ltrim(X,Y),!.
ltrim([P|X],Y):-P>128,ltrim(X,Y),!.
ltrim(X,X):-!.

/*===================================================================
%   SUO-KIF String to SXpression
% Converts up to 6 SUO-KIF Flags into set(Name,Val) pairs
====================================================================*/

suokif((XSB_Prolog))--> ['(',':','SUOKIF'],moo(XSB_Prolog),[')'].
suokif((XSB_Prolog))--> ['('],kif_flag(_),[':','SUOKIF'],moo(XSB_Prolog),[')'].
suokif((XSB_Prolog))--> ['('],kif_flag(_),kif_flag(_),[':','SUOKIF'],moo(XSB_Prolog),[')'].
suokif((XSB_Prolog))--> ['('],kif_flag(_),kif_flag(_),kif_flag(_),[':','SUOKIF'],moo(XSB_Prolog),[')'].
suokif((XSB_Prolog))--> ['('],kif_flag(_),kif_flag(_),kif_flag(_),kif_flag(_),[':','SUOKIF'],moo(XSB_Prolog),[')'].
suokif((XSB_Prolog))--> ['('],kif_flag(_),kif_flag(_),kif_flag(_),kif_flag(_),kif_flag(_),[':','SUOKIF'],moo(XSB_Prolog),[')'].
suokif((XSB_Prolog))--> ['('],kif_flag(_),kif_flag(_),kif_flag(_),kif_flag(_),kif_flag(_),kif_flag(_),[':','SUOKIF'],moo(XSB_Prolog),[')'].
  
suokif(XSB_Prolog)--> moo(XSB_Prolog).

flag_list((A,B)) --> kif_flag(A),flag_list(B).
flag_list(A) --> kif_flag(A).
flag_list(true) --> [].

kif_flag('set'(A,V)) -->  [(':'),A,V], { atomical(V) }.
kif_flag('set'(A,true)) -->  [(':'),A], { atomical(A) }.

/*===================================================================
%   Moo-KIF String to DCG Converter
% Converts up to 13 forms
%     13 Terms long
%  
% =169 Parens Pairs at the First 2 levels  
% 
====================================================================*/


moo([A]) --> expr(A).
moo([and,A|L]) --> expr(A) , moo(L).

   %%expr(RF) --> reifiableFN(RF),!.
expr([]) -->  ['(',')'],!.
expr([Head]) -->  ['('],opr(Head),[')'],!.
expr([Head|LIST]) -->  ['('],opr(Head),many_slots(LIST),[')'].

many_slots([A]) --> slot(A).
many_slots([A|L]) --> slot(A) , many_slots(L).

opr(Head) --> simple(Head) .
opr(Head) --> expr(Head).

%slot(Name) --> simple(Name),['AssignmentFn'], { nonvar(Name), ! }.
slot(SKFName) --> ['SKF'],simple(Name), { nonvar(Name), ! , skf_name(Name,SKFName) }.
slot(WFF) -->  simple(WFF), { nonvar(WFF), ! }.
%slot(['AssignmentFn',Name,List]) -->  reifiableFN(['AssignmentFn',Name,List]).
slot(WFF) -->  expr(WFF), { nonvar(WFF), ! }.


expr(WFF) -->  variable(WFF), { nonvar(WFF) ,!}.
%expr(WFF) -->  reifiableFN(WFF), { nonvar(WFF),! }.   %slot(WFF) -->  literal_list(WFF), { nonvar(WFF) }.


variables_list([list,A]) --> qual_var(A).
variables_list([list,A]) -->  ['('],qual_var(A),[')'],!.
variables_list([list,A,B]) -->  ['('],qual_var(A),qual_var(B),[')'],! .
variables_list([list,A|QV]) -->  ['('],qual_var(A),many_qual_var(QV),[')'],!.
many_qual_var([A]) -->  qual_var(A).
many_qual_var([A|T]) -->  qual_var(A),many_qual_var(T).

% Var/Quality pairs that Sowa's ACE examples use

qual_var(VN) --> ['('],variable(VN),[')'].
qual_var(VN) --> variable(VN).
qual_var(VN) --> ['('],variable(VN),qual(_Quality),[')'].

qual(Q) --> constant(Q), { nonvar(Q) }. % , 'surface-instance'(_,Q,_) }.

number(Number) -->  [Number] , {  nonvar(Number), number(Number),! } .

quantity(Number) --> number(Number).

simple(WFF) -->  quantity(WFF), { nonvar(WFF), ! }.
simple(WFF) -->  variable(WFF), { nonvar(WFF), ! }.
simple(WFF) -->  constant(WFF), { nonvar(WFF), ! }.
%simple(['AssignmentFn',Name,[]]) --> ['SKF'],constant(Name).
%simple(['AssignmentFn',Name,[]]) --> ['SKF'],simple(Name),{ nonvar(Name) , nonvar(List), ! } .
%simple(['AssignmentFn',Name,[]]) --> ['AssignmentFn'],simple(Name), { nonvar(Name) , nonvar(List), ! } .

%reifiableFN(['AssignmentFn',SKFName,[]]) --> ['(','SKF'],simple(Name),[')'], { nonvar(Name) ,! , skf_name(Name,SKFName),sendNote('(skf)') } .
%reifiableFN(['AssignmentFn',SKFName,List]) --> ['(','SKF'],simple(Name),arbitrary(List),[')'], { nonvar(Name) , nonvar(List), ! , skf_name(Name,SKFName),sendNote('(skf)') } .
%reifiableFN(['AssignmentFn',Name,List]) --> ['(','AssignmentFn'],simple(Name),arbitrary(List),[')'], { nonvar(Name) , nonvar(List), ! } .
%%reifiableFN(['AssignmentFn',Name,_]) --> ['SKF'],simple(Name).
%reifiableFN(['AssignmentFn',Name,List]) --> ['('],simple(Name),arbitrary(List),[')'], { nonvar(Name) , nonvar(List),'surface-instance'(Name,'Function',_) ,! } .

skf_name(Num,SKFName):-!,number(Num), number_codes(Num,Codes),atom_codes(SKFName,[115,107|Codes]).

% Construct arbitrary list of args
          
arbitrary([]) -->  [].
arbitrary(VN)-->  ['?',A], { var_number(A,VN)   } . 
arbitrary([Head]) -->  slot(Head).
arbitrary([A|L]) --> slot(A) , many_slots(L).


variable(VN)-->  ['?',A], { var_number(A,VN)   } . 
variable(VN)-->  ['??'], { var_gen(A),var_number(A,VN)   } .     %Anonymous
variable(VN)-->  ['?'], { var_gen(A),var_number(A,VN)   } . 

% Makes up sequencial Variable names for anonymous kif getPrologVars
var_gen(Atom):-idGen(Number),number_codes(Number,Codes),atom_codes(Atom,[86,65,82|Codes]). % "VAR"

constant(Number) --> number(Number) .
   
constant(Unquoted) -->  [Unquoted] , {  nonvar(Unquoted), not((Unquoted='?';Unquoted='(';Unquoted=')')),! } .
     
var_number(A,'$VAR'(VN)):-numbered_var(A,'$VAR'(VN),_),!.
var_number(A,'$VAR'(VN)):-get_next_num(VN),assert(numbered_var(A,'$VAR'(VN),_)),!.

:-dynamic(numbered_var/3).

:-assert(var_counter(0)).

% This creates ISO Prolog getPrologVars w/in a KIF/STANDARD expression to be reconstrated as after parsing is complete 

get_next_num(VN):-!,retract(var_counter(VN)),NVN is VN +1,asserta(var_counter(NVN)).

kifVarNums(LIST,'$VAR'(NUM),VAR,[=(SYM,VAR)]):-numbered_var(SYM,'$VAR'(NUM),_VAR),
               member(=(SYM,VAR),LIST).

kifVarNums(_,Atom,Atom,[]):-atomic(Atom).
kifVarNums(LIST,Term,NewTerm,VARLIST):-Term=..[F|ARGS],kifVarNums_list(LIST,ARGS,VARARGS,VARLIST),NewTerm=..[F|VARARGS].

kifVarNums_list(_LIST,[],[],[]).
kifVarNums_list(LIST,[A|RGS],[V|ARARGS],VARLIST):-
            kifVarNums(LIST,A,V,VARS1),
            kifVarNums_list(LIST,RGS,ARARGS,VARS2),
            append(VARS1,VARS2,VARLIST).



unnumbervars_nil(X,Y):-!,unnumbervars(X,Y).

collect_temp_vars(VARS):-!,(setof(=(Name,Number),numbered_var(Name,Number,_),VARS);VARS=[]).

%================================================================
% ISO-Prolog STRING TOKENIZATION                            
%================================================================
:-assert(show_this_hide(tokenize,2)).

%tokenize_chars(M,['(',surf,')']):-nonvar(M),member(34,M),!.
tokenize_chars(X,Y):-once( tokenize3(X,Y) ).

tokenize3([],[]).
tokenize3([32|T],O):-!,tokenize3(T,O),!.
tokenize3(CharList,[Token|TList])  :- 
  append(_,[C|List],CharList), C \= 32,!,
  get_token([C|List],Token,Rest),!,
  tokenize3(Rest,TList),!.

get_token(List,Token,Rest)  :- 
  get_chars_type(List,Lchars,Rest,Type),!,
  type_codes(Type,Lchars,Token),!.

type_codes(num,CODES,Num):-catch(number_codes(Num,CODES),_,fail),!.
type_codes(_,[34|Lchars],string(S)):-!,atom_codes(S,[34|Lchars]).
type_codes(_,Lchars,Token):-!,atom_codes(Token,Lchars).

get_chars_type(L,S,L1,sep)  :-  separator(L,S,L1),!.
get_chars_type([C|L],[C|Lc],L1,S)  :- 
  check_start(S,C),
  get_word_chars(S,L,Lc,L1).

get_word_chars(S,L,Lc,L1)  :- 
  check_end(S,L,Lc,L1).
get_word_chars(S,[C|L],[C|Lc],L1)  :- 
  legal_char(S,C),
  get_word_chars(S,L,Lc,L1).

legal_char(num,C)    :-  digit(C).
legal_char(quote,C)  :-  not(bracket(_,C,_)).
legal_char(symb,C)   :-  valid_char(C).

check_start(Name,S):-bracket(Name,S,_E).
check_start(num, C)   :-  start_digit(C).
check_start(symb,C)   :- valid_char(C). %, 'not'(digit(C)).

check_end(_,[],[],[])  :-  !.
check_end(num, [C|L],[],[C|L])  :-  'not'(digit(C)),!.
check_end(Name,[E|L],[E],L)  :-  bracket(Name,S,E),!.
%check_end(symb,[C1,C2|L],[],[C1,C2|L])  :-  member([C1,C2],["Fn"]),!.
check_end(symb,[C|L],[],[C|L])  :-  'not'(valid_char(C)).

separator([C,D,E,F|L],[C,D,E],L)  :-member([C,D,E,F],["SKF-"]),!.
separator([C,D,E|L],[C,D,E],L)  :-member([C,D,E],["<=>","=:=","=\=","\==","@=<","@>=","=..","-->","SKF"]),!.
separator([C,D|L],[C,D],L)  :-member([C,D],["=>",":-","\+","->","\=","==","@<","@>","=<",">=","#$","//","??"]),!. %,"Fn"
separator([C|L],[C],L)  :- member(C,"*,():[];= < >^{}?%$#/"),!.

valid_char(C)  :-  letter(C); digit(C); C = 95 ; C=45 ; C=39.
letter(C)  :-   C=45 ; (97 =< C, C =< 122) ; (65 =< C, C =< 90) ; C = 95 .
start_digit(C)   :- member(C,"-01234567890").
digit(C)   :- member(C,"-.01234567890+eE").

%get_word([C|T],C,T)  :-  member(C,":,.?&%"),!. % ( : , . ?)
get_word([C|T],[C],T)  :- member(C,"=&"),!. % (=)
get_word([C,C1|T],[C,C1],T)  :- member([C,C1],["??"]),!. %"Fn",
get_word([C|T],[C|W],T2)  :-  bracket(_,C,C1),!,get_chars(0,C1,T,W,T2).
get_word([C|T],[C|W],T2)  :-  valid_start(C),!, get_chars(1,32,T,W,T2).

get_chars(K,C1,[C|T],[C|W],T2)  :-  valid_char(K,C,C1),!,get_chars(K,C1,T,W,T2).
get_chars(0,C,[C|T],[],T)  :- bracket(_,C,_), !.
get_chars(0,C,[C|T],[C],T)  :-  (C = 41; C = 93),!. % ) or ]
get_chars(1,_C1,[C|T],[],[C|T])  :-  member(C, [10,13|"=:,?"]).
%get_chars(2,_C1,[C,C2|T],[],[C,C2|T])  :-  member([C,C2], ["Fn"]).

valid_start(C)  :-  valid(C). %; C = 37.  % (%)
valid_char(K,C,C1)  :-  K = 0,!, C \= C1; K = 1, valid(C).

%bracket(quote,39,39).  % single quotes
bracket(quote,34,34).  % double quotes
%bracket(list,91,93).  % square brackets []
%bracket(quote,37,37).  % Literal Percent %%
%bracket(quote,35,35).  % Literal Percent ##

quote_found(0,B,B)  :-  member(B,[34]),!.
quote_found(Q,Q,0).

var_found(0,B,C)  :-  'not'(valid(B)),var_start(C).

var_start(C)  :-  (65 =< C,C =< 90);C = 95;C = 39.
valid(C)  :-   (65 =< C, C =< 90);    % A - Z
             (97 =< C, C =< 122);   % a - z
             (48 =< C, C =< 57);    % 0 - 9
             C = 95; C = 39;C = 45.  % underscore; hyphen


:-assert(show_this_hide(getCleanCharsWhitespaceProper,2)).






ltrim([],[]):-!.
ltrim([32,32,32,32,32,32,32|String],Out) :-!, ltrim(String,Out),!.
ltrim([32,32,32,32,32|String],Out) :- !,ltrim(String,Out),!.
ltrim([32,32,32|String],Out) :-!, ltrim(String,Out),!.
ltrim([32,32|String],Out) :- !,ltrim(String,Out),!.
ltrim([32|String],Out) :- !,ltrim(String,Out),!.
ltrim(X,X):-!.



%:-discontiguous(conv_pred/3).
%:-discontiguous(conv_pred/3).


% ====================================================================
% conv_readS/3-4 and conv_readP/3-4 
% ====================================================================

conv_readP(RAW,OUTP,VARS):-
            conv_readS(RAW,NEWTERM,VARS),
            getMooTermFromSurface(NEWTERM,OUTP).

conv_readP(Stream,RAW,OUTP,VARS):-
            conv_readS(Stream,RAW,NEWTERM,VARS),
            getMooTermFromSurface(NEWTERM,OUTP).

chars_to_pterm(Chars,PTerm,Vars):-
         once(getSurfaceFromChars(Chars,STERM,Vars)),!,
         getMooTermFromSurface(STERM,PTerm),!.


getMooTermFromSurface([end_of_file],end_of_file):-!.
getMooTermFromSurface(NEWTERM,OUTP):-
               conv_kr_rule_generic(NEWTERM,NEWTERMATOMS),
	       conv_kr_rule_generic(NEWTERMATOMS,OUT),
               kif_to_pterm(OUT,OUTP).

conv_readS(RAW,NEWTERM,VARS):-!,
                once(readKIF(RRAW)),
               once(getSurfaceFromChars(RRAW,RTERM,RVARS)),
					 once((
                 (RTERM=nil,!,conv_readS(RAW,NEWTERM,VARS),!)
                 ;(once(getCleanCharsWhitespaceProper(RRAW,RAW)),NEWTERM=RTERM,VARS=RVARS)
                 )).

conv_readS(Stream,RAW,NEWTERM,VARS):-!,
                     once(readKIF(Stream,RRAW)),
                     once(getSurfaceFromChars(RRAW,RTERM,RVARS)),
					 once((
                 (RTERM=nil,!,conv_readS(Stream,RAW,NEWTERM,VARS),!)
                 ;(once(getCleanCharsWhitespaceProper(RRAW,RAW)),NEWTERM=RTERM,VARS=RVARS)
                 )).


% ====================================================================
% Moo File IO
% ====================================================================
      
      

:-dynamic(moo_B_seeing/3).
:-dynamic(moo_BInserting/3).
:-asserta((moo_B_seeing(userin,userin,1))).
:-asserta((moo_BInserting(userin,userin,2))).
/*
moo_B_seen:-moo_B_seeing_console,!.
moo_B_seen:-retract(moo_B_seeing(FileName,LocalFile,_IOPort)),!,file_close(_IOPort).
*/
moo_B_told:-moo_BInserting_console,!.
moo_B_told:-retract(moo_BInserting(FileName,LocalFile,_IOPort)),!,file_close(_IOPort).

/*
moo_B_see(userin):-!.
moo_B_see(FileName):-real_kif_file_name(FileName,LocalFile),!,moo_file_open(LocalFile,'r',_IOPort),asserta(moo_B_seeing(FileName,LocalFile,_IOPort)).
*/

moo_BInsert(userin):-!.
moo_BInsert(FileName):-real_kif_file_name(FileName,LocalFile),!,moo_file_open(LocalFile,'w',_IOPort),asserta(moo_BInserting(FileName,LocalFile,_IOPort)).

moo_B_get0(Char):-!,get(Char).
moo_B_get0(Char):-moo_B_seeing(FileName,LocalFile,_IOPort),!,file_get0(_IOPort,Char).
moo_B_get0(Stream,OChar):-!,
            catch(file_get0(Stream,OChar),_,OChar=end_of_file).

moo_B_get(Char):-moo_B_seeing_console,!,get(Char).
moo_B_get(TERM):-moo_B_seeing(_FileName,_LocalFile,IOPort),!,file_get(IOPort,TERM,_).

moo_B_read(TERM):-moo_B_seeing_console,!,read(TERM).
moo_B_read(TERM):-moo_B_seeing(_FileName,_LocalFile,IOPort),!,file_read(IOPort,TERM,_).

moo_B_put(Char):-moo_BInserting_console,!,put(Char).
moo_B_put(Char):-moo_BInserting(FileName,LocalFile,_IOPort),!,put(_IOPort,Char).


moo_B_seeing_console:-moo_B_seeing(FileName,LocalFile,_IOPort),!,LocalFile=userin.
moo_BInserting_console:-moo_BInserting(FileName,LocalFile,_IOPort),!,LocalFile=userin.


moo_file_open(_LocalFile,Mode,_IOPort):-file_open(_LocalFile,Mode,_IOPort),once((valid_handle(_IOPort);((writeIfOption(cb_error,['File Not Found',_LocalFile],_X)),!,abort))).

% file_get0(IOPort,Char)  See Platform Specifics

valid_handle('$stream'(_)):-!.
valid_handle(IOPort):- IOPort > 3,!.




% ===================================================================
% File: moo_sentence.P
% Maintainer: Douglas Miles (dmiles@users.sourceforge.net) 
%
% Two Principal predicates defined: 
%
%    getAssertionClauses0/3 Converts a KIF Surface Form to Rule Form
%    getRequestClauses/3 Converts a KIF Surface Request to Request Macro in Heuristic Language
%
%  With 
%
%     Connectives <=> (bi-implication),impiles,and,or (logical version - i.g. as pure disjuction)
%     Quantifiers: forall, exists, exists (logical version - i.g. as per sentence)
%     Identity: equal (As in the equal Object), equal (As in the deisNotInClauseg an equivent within a certain domain)
%     Higher Order Predicates: 
%               Temporal:  after (preconditional) , before (causality)
%               FOL: not (Refuted)
%               Model: not (Unknown), known (In the Context), possible (Not refuted) 
%     Type Predicates:
%               domainV, domain-check
%     
% http://www.enm.bris.ac.uk/research/aigroup/enjl/logic/sld002.htm
% http://www.enm.bris.ac.uk/ai/enjl/logic1.pdf
% http://www.dyade.fr/fr/actions/vip/jgl/SPP/dowek.ps 
% http://logic.stanford.edu/~cs157/lectures/lecture04/sld004.htm
% ===================================================================
%:-module(moo_sentence,[getAssertionClauses/5]).

% :-include('moo_header.pl').

/*----------------------------------------------------------------------

    This module has three entry points:
	clausal_form(Formula, Clauses)
	clausal_form_of_negation(Formula, Clauses)
	units_separated(Clauses, PosUnits, NegUnits, NonUnits)

    The Formula is an <expr>, where
	<expr> ::= all(<variable>, <expr>)
		|  exists(<variable>, <expr>)
		|  <expr> => <expr>
		|  <expr> <=> <expr>
		|  if(<expr>,<expr>,<expr>)
		|  <expr> and <expr>
		|  <expr> or <expr>
		|  ~ <expr>
		|  <atom>

	<atom> ::= <predicate>(<term>,...,<term>)

	<term> ::= <variable>
		|  <constant>
		|  <functor>(<term>,...,<term>)

    The Clauses are a sentence, where
	<sentence> ::= []			(true)
		|  <clause> . <sentence>	(and)

	<clause> ::= clause(<atoms>, <atoms>)
	<atoms> ::= [] | <atom> . <atoms>

    Note that this representation of a clause is not quite the
    usual one.  clause([a,b,c], [d,e,f]) represents
	a v b v c <- d & e & f
    or, if you don'writeTranslation like "Kowalski form",
	a v b v c v ~d v ~e v ~f

    The reason for the two entry points is that the formula may
    contain free variables, these are to be understood as being
    universally quantified, and the negation of the universal
    closure of a formula is not at all the same thing as the
    universal closure of the negation!

    units_separated takes a list of clauses such as the other two predicates
    might produce, and separates them into a list of positive unit clauses
    (represented just by <atom>s), a list of negative unit clauses (also
    represented by their single <atom>s), and a list of non-unit clauses.
    Some theorem provers might find this separation advantageous, but it is
    not buillt into clausal_form becauses exists provers would not benefit.

----------------------------------------------------------------------*/
:- op(700, xfx, [contains,literally_contains,does_not_literally_contain]).

% ======================================================================
% EXPORTS
%
% getAssertionClauses0/3
% getRequestClauses/3
% ======================================================================

/*
ttsurf:-tsurf((=>(instance(A, 'Transaction'), 
	exists(B, exists(C, exists(D, exists(E, exists(F, exists(G, 
		and(instance(E, 'Giving'), and(instance(D, 'Giving'), and(subProcess(E, A), and(subProcess(D, A), and(agent(E, G), and(agent(D, F), and(patient(E, C), 
			and(patient(D, B), and(destination(E, F), and(destination(D, G), 
				and(not(equal(G, F)), not(equal(C, B))))))))))))))))))))),
		  ['TRANS'=A, 'AGENT1'=G, 'AGENT2'=F, 'GIVE1'=E, 'GIVE2'=D, 'OBJ1'=C, 'OBJ2'=B]).
*/

% ======================================================================
% IMPORTS
%
% moo_utility.P (only common predicates like getPrologVars/4)
% ======================================================================
% ======================================================================
% Converts a KIF Surface Assertion to Entailment Tests
% getAssertionClauses(-Context,-Ctx,-Prop,+NConjAssertsClauses,+KRVars,-AllFlagsO)
% ======================================================================

getAssertionClauses(Context,Prop,NConjAssertsClauses,KRVars,AllFlags):- 
	logOnFailure(canonicalizeProposition(Context,Prop,CNF,DNF,ConjAssertsClauses,KRVars,AllFlags)),
	debugOnFailure(putFeaturesInFormula(assertion,KRVars,ConjAssertsClauses,AllFlags,NConjAssertsClauses)),!.
	
% ======================================================================
% Converts a KIF Surface Request to Entailment Tests
% getRequestClauses(-Context,-Ctx,-Prop,+NConjAssertsClauses,+KRVars,-AllFlagsO)
% ======================================================================

/*
getRequestClauses(Context,Surface,surface,[],[] ):-
	once(getConstants(atomic,Surface,Cs,_,_)),
	intersection(Cs,[(<=>),(exists),(and),(or),(equal),(entails),(forall),(=>),(not),(possible),(known)],([])),
	!.
*/

getRequestClauses(Context,Prop,NConjAssertsClauses,KRVars,AllFlags):- 
	canonicalizeProposition(Context,Prop,CNF,DNF,ConjAssertsClauses,KRVars,AllFlags),
	logOnFailure(putFeaturesInFormula(request,KRVars,ConjAssertsClauses,AllFlags,NConjAssertsClauses)),!.
	

% ======================================================================
% canonicalizeProposition(+Context,+Ctx,+Prop,-ConjAssertsClauses,+KRVars,-AllFlags)
% ======================================================================
canonicalizeProposition(Context,Prop,CNF,DNF,ConjAssertsClauses,KRVars,AllFlags):- 
	close_list(KRVars),!,                  
	%writeObject(Prop,KRVars),
	numbervars((Prop,KRVars,Context,Ctx)),
	logOnFailure(getModeledPredicates(Prop,FmlInOpen)),!,
	%writeObject('<hr>getModeledPredicates: \n',KRVars),
	%writeObject(FmlInOpen,KRVars),
        getClosedVersionWFF(forall,FmlInOpen,Axiom),!,
	%logOnFailure(getFunctionalForm(Axiom,FunctionFlags,NewVarsForFunctions,NoFunctions)),!,
	%writeObject('<hr>FunctionFlags: \n',KRVars),!,
	%getPrologVars(NoFunctions,FFV,_,_),
	%logOnFailure(getFlagsValidToVars(FFV,FunctionFlags,FFC)),!,
	%ignore(writeObject(ff(FFC),KRVars)),!,
	%writeObject('<hr>NoFunctions: \n',KRVars),
	%writeObject(NoFunctions,KRVars),
	logOnFailure(
	getNegationForm(toplevel,0,Context,KRVars,Flags,Axiom,_,NNF,_)),!,
	%logOnFailure(getDisjForm(NNF,DNF)),!,
	logOnFailure(getConjForm(NNF,CNF)),!,
	%write_cnf_lit(CNF,KRVars),!,
	%writeq_conj(DNF),nl,nl,
	%writeObject('<hr>Conjuntive Form: \n',KRVars),!,
	%writeObject(CNF,KRVars),!,
	logOnFailure(toClauseFormOptimal(CNF,ConjAssertsClauses)),!,
	getPrologVars(ConjAssertsClauses:NewVarsForFunctions,FVars,_,_),
	logOnFailure(getFlagsValidToVars(FVars,Flags,AllFlags)),!.

       
putFeaturesInFormula(AssertRequest,KRVars,entails(true,true),AllFlags,true):-!.

putFeaturesInFormula(AssertRequest,KRVars,and(A,B),AllFlags,and(AA,BB)):-!,
	putFeaturesInFormula(AssertRequest,KRVars,A,AllFlags,AA),
	putFeaturesInFormula(AssertRequest,KRVars,B,AllFlags,BB).

putFeaturesInFormula(AssertRequest,KRVars,entails(Ante,Cons),AllFlags,AExplaination):-
	getPrologVars(Cons:Ante,Together,_,_),
	getPrologVars(Cons,ConVars,_,_),
	add_ante(AllFlags,Together,Ante,NewAnte),
	add_skolems_to_body(AllFlags,NewAnte,Cons,ConVars,NewestAnte),
	cleanExplaination(Cons,NewestAnte,AExplaination),!.

%skolemIfRequired(AllFlags,NewAnte,KRVars,Cons,AllFlags,NewCons),
	
	
cleanExplaination(NewCons,true,NewCons).
cleanExplaination(NewCons,NewAnte,entails(NewAnte,NewCons)).

putFeaturesInFormula(AssertRequest,KRVars,Cons,AllFlags,NewCons):-!,
	putFeaturesInFormula(AssertRequest,KRVars,entails(true,Cons),AllFlags,NewCons).
	
% =============================================================



% =============================================================
	
ifThenElse(I,T,_):- I,!,T,!.
ifThenElse(_,_,E):- E,!.
  
% =============================================================

ground_unused_vars([],KRVars,SKG,SKG):-!.
ground_unused_vars([V1|Ante],KRVars,SK,SKG):-!,
	toMarkUp(kif,V1,KRVars,VN),
	subst(SK,V1,VN,SKGM),
	ground_unused_vars(Ante,KRVars,SKGM,SKG).
	
add_ante([],Together,NewAnte,NewAnte):-!.
add_ante([F|Flags],Together,Ante,NewAnte):-!,
	do_flag(F,Together,Ante,AnteMid),
	add_ante(Flags,Together,AnteMid,NewAnte).
	
do_flag(post(Var,Call),Together,Ante,AnteMid):-
	getPrologVars(Call,CV,_,_),
	member(Var,Together),
	intersection(CV,Together,[_|_]),!,
	conjoin_kr(Ante,Call,AnteMid).
do_flag(pre(Var,Call),Together,Ante,AnteMid):-
	getPrologVars(Call,CV,_,_),
	member(Var,Together),
	intersection(CV,Together,[_|_]),!,
	conjoin_kr(Call,Ante,AnteMid).
do_flag(_,Together,AnteMid,AnteMid):-!.


add_skolems_to_body([],Ante,Cons,ConVars,Ante):-!.

add_skolems_to_body([replaceConsVar(Var,'$existential'(VarName,not(Formula)))|Flags],Ante,Cons,ConVars,NewAnte):-!,
	ifThenElse( 
		(functor(Cons,not,_),member(Var,ConVars)),
		conjoin_kr(Ante,'$existential'(Var,VarName,not(Formula)),NewAnteM),
		Ante=NewAnteM),
	getPrologVars(NewAnteM:Cons,NewConstVars,_,_),
	add_skolems_to_body(Flags,NewAnteM,Cons,NewConstVars,NewAnte).

add_skolems_to_body([replaceConsVar(Var,'$existential'(VarName,Formula))|Flags],Ante,Cons,ConVars,NewAnte):-!,
	ifThenElse( 
		(not(functor(Cons,not,_)),member(Var,ConVars)),
		conjoin_kr(Ante,'$existential'(Var,VarName,Formula),NewAnteM),
		Ante=NewAnteM),
	getPrologVars(NewAnteM:Cons,NewConstVars,_,_),
	add_skolems_to_body(Flags,NewAnteM,Cons,NewConstVars,NewAnte).
	
add_skolems_to_body([_|Flags],Ante,Cons,ConVars,NewAnte):-!,
	add_skolems_to_body(Flags,Ante,Cons,ConVars,NewAnte).

skolemizeCons(AnteVars,KRVars,Cons,AllFlags,NewCons):-
	skolemIfRequired(AllFlags,AnteVars,KRVars,Cons,AllFlags,NewCons),!.


/*
% error:  'Predicate Failed' skolemizeCons(
	[V16], 
	['TRANS'=V16, 'AGENT1'=B17, 'AGENT2'=A17, 'GIVE1'=Z16, 'GIVE2'=Y16, 'OBJ1'=X16, 'OBJ2'=W16], 
	patient(Y16, W16), 
	[domainV(B17, [agent:2, destination:2]), domainV(A17, [agent:2, destination:2]), domainV(Z16, ['$instanceof':'Giving', agent:1, destination:1, patient:1, subProcess:1]), domainV(Y16, ['$instanceof':'Giving', agent:1, destination:1, patient:1, subProcess:1]), domainV(X16, [patient:2]), domainV(W16, [patient:2]), domainV(V16, [subProcess:2]), 
	replaceConsVar(W16, '$existential'("?OBJ2", exists(X16, exists(Y16, exists(Z16, exists(A17, exists(B17, instance(Z16, 'Giving')and instance(Y16, 'Giving')and subProcess(Z16, V16)and subProcess(Y16, V16)and agent(Z16, B17)and agent(Y16, A17)and patient(Z16, X16)and patient(Y16, "?OBJ2")and destination(Z16, A17)and destination(Y16, B17)and not equal(B17, A17)and not equal(X16, "?OBJ2")))))))), 
	replaceConsVar(X16, '$existential'("?OBJ1", exists(Y16, exists(Z16, exists(A17, exists(B17, instance(Z16, 'Giving')and instance(Y16, 'Giving')and subProcess(Z16, V16)and subProcess(Y16, V16)and agent(Z16, B17)and agent(Y16, A17)and patient(Z16, "?OBJ1")and patient(Y16, W16)and destination(Z16, A17)and destination(Y16, B17)and not equal(B17, A17)and not equal("?OBJ1", W16))))))), 
	replaceConsVar(Y16, '$existential'("?GIVE2", exists(Z16, exists(A17, exists(B17, instance(Z16, 'Giving')and instance("?GIVE2", 'Giving')and subProcess(Z16, V16)and subProcess("?GIVE2", V16)and agent(Z16, B17)and agent("?GIVE2", A17)and patient(Z16, X16)and patient("?GIVE2", W16)and destination(Z16, A17)and destination("?GIVE2", B17)and not equal(B17, A17)and not equal(X16, W16)))))), 
	replaceConsVar(Z16, '$existential'("?GIVE1", exists(A17, exists(B17, instance("?GIVE1", 'Giving')and instance(Y16, 'Giving')and subProcess("?GIVE1", V16)and subProcess(Y16, V16)and agent("?GIVE1", B17)and agent(Y16, A17)and patient("?GIVE1", X16)and patient(Y16, W16)and destination("?GIVE1", A17)and destination(Y16, B17)and not equal(B17, A17)and not equal(X16, W16))))),
	replaceConsVar(A17, '$existential'("?AGENT2", exists(B17, instance(Z16, 'Giving')and instance(Y16, 'Giving')and subProcess(Z16, V16)and subProcess(Y16, V16)and agent(Z16, B17)and agent(Y16, "?AGENT2")and patient(Z16, X16)and patient(Y16, W16)and destination(Z16, "?AGENT2")and destination(Y16, B17)and not equal(B17, "?AGENT2")and not equal(X16, W16)))), 
	replaceConsVar(B17, '$existential'("?AGENT1", instance(Z16, 'Giving')and instance(Y16, 'Giving')and subProcess(Z16, V16)and subProcess(Y16, V16)and agent(Z16, "?AGENT1")and agent(Y16, A17)and patient(Z16, X16)and patient(Y16, W16)and destination(Z16, A17)and destination(Y16, "?AGENT1")and not equal("?AGENT1", A17)and not equal(X16, W16)))],
	 _G50398)

*/
skolemIfRequired(AllFlags,AnteVars,KRVars,Cons,[],Cons).
/*
    
skolemIfRequired(AllFlags,AnteVars,KRVars,,NewCons):-
			getPrologVars(Cons,ConsVars,_,_),
			subtract(AnteVars,ConsVars,UnusedVars),       
			logOnFailure(ground_unused_vars(UnusedVars,KRVars,'$existential'(VarName,not(Formula)),Grounded),
			logOnFailure(putDomainInSkolem(Var,AllFlags,Grounded,SKGD)),
			subst(not(Cons),Var,SKGD,NConsM),!,
			skolemIfRequired(AllFlags,Ante,KRVars,NConsM,Flags,NewCons).
    			
skolemIfRequired(AllFlags,Ante,KRVars,Cons,[replaceConsVar(Var,'$existential'(VarName,Formula))|Flags],NewCons):-
				not(Cons=not(_)),
				not(Formula=not(_)),
				not((occurs_term(Var,Ante),occurs_term(Var,Cons))),
				,
				getPrologVars(Cons,ConsVars,_,_),
				subtract(AnteVars,ConsVars,UnusedVars),       
				logOnFailure(ground_unused_vars(UnusedVars,KRVars,'$existential'(VarName,Formula),Grounded)),
				logOnFailure(putDomainInSkolem(Var,AllFlags,Grounded,SKGD)),
				subst(Cons,Var,SKGD,NConsM),!,
				skolemIfRequired(AllFlags,Ante,KRVars,NConsM,Flags,NewCons).

skolemIfRequired(AllFlags,Ante,KRVars,not(Cons),[replaceConsVar(Var,functional(VarName,not(Formula)))|Flags],NewCons):-
				getPrologVars(Cons,ConsVars,_,_),
				subtract(AnteVars,ConsVars,UnusedVars),       
				logOnFailure(ground_unused_vars(UnusedVars,KRVars,functional(VarName,not(Formula)),Grounded)),
				logOnFailure(putDomainInSkolem(Var,AllFlags,Grounded,SKGD)),
				subst(not(Cons),Var,SKGD,NConsM),!,
				skolemIfRequired(AllFlags,Ante,KRVars,NConsM,Flags,NewCons).
     			
*/
skolemIfRequired(AllFlags,AnteVars,KRVars,Cons,[replaceConsVar(Var,functional(VarName,Formula))|Flags],NewCons):-
				not(Cons=not(_)),
				not(Formula=not(_)),
				getPrologVars(Cons,ConsVars,_,_),
				subtract(AnteVars,ConsVars,UnusedVars),       
				logOnFailure(ground_unused_vars(UnusedVars,KRVars,functional(VarName,Formula),Grounded)),
				logOnFailure(putDomainInSkolem(Var,AllFlags,Grounded,SKGD)),
				subst(Cons,Var,SKGD,NConsM),!,
				skolemIfRequired(AllFlags,Ante,KRVars,NConsM,Flags,NewCons).
								
skolemIfRequired(AllFlags,AnteVars,KRVars,Cons,[_|Flags],NewCons):-!,
	skolemIfRequired(AllFlags,AnteVars,KRVars,Cons,Flags,NewCons).

skolemizeVars(RFlags,KRVars,Term,Skolemized):-
	skolemIfRequired(RFlags,[],KRVars,Term,RFlags,Skolemized),!.

% Normal 
putDomainInSkolem(Var,AllFlags,'$existential'(VarName,Term),'$existential'(VarName,Domains,Term)):-
	member(domainV(Var,Domains),AllFlags),!.

/*% Normal 
putDomainInSkolem(Var,AllFlags,functional(VarName,Term),functional(VarName,Domains,Term)):-
	member(domainV(Var,Domains),AllFlags),!.
*/

% Overloaded
putDomainInSkolem(Var,AllFlags,SK,SK):-!. 

    
getFlagsValidToVars([],Same,Same):-!.
getFlagsValidToVars([V|Rest],FlagsIn,FlagsOut):-
	putDomainsTogether(V,FlagsIn,FlagsMid),!,
	getFlagsValidToVars(Rest,FlagsMid,FlagsOutM),!,
	fdelete(FlagsOutM,dom,FlagsOut).
putDomainsTogether(V,[],[]):-!.


putDomainsTogether(V,Flags,[domainV(V,FUnivListO)|Flags]):-
	findall(Univ,(member(dom(VV,Univ),Flags),V==VV),UnivList),
	flatten(UnivList,FUnivListU),
	sort(FUnivListU,FUnivList),
	subtract(FUnivList,[':'(instance,1),':'(request,_),':'(equal,_)],FUnivListO),!.

%%% Negation Normal Form
% -----------------------------------------------------------------
%  getNegationForm(Axiom,Caller,ArgN,Context,KRVars,PreQ,PreQ,+Fml,+UFreeV,-NNF,-Paths)
%
% Fml,NNF:    See above.
% UFreeV:      List of free variables in Fml.
% Paths:      Number of disjunctive paths in Fml.

% Variable as Formula collect its caller
getNegationForm(Caller,ArgN,Context,KRVars,[dom(Var,[':'(Caller,ArgN)]) ],Var,UFreeV,Var,1):- isSlot(Var),!.

% Special case for Instance
getNegationForm(Caller,ArgN,Context,KRVars,[dom(A,[':'('$instanceof',Class)])],
   instance(A,Class),UFreeV,instance(A,Class),1):-
	isSlot(A),atom(Class),!.

/*
% Special case for Instance
getNegationForm(Caller,ArgN,Context,KRVars,[dom(A,['$instanceof':Class])|PreQ],or(not(instance(A,Class)),Fml),UFreeV,Out,N):-
	not(Fml = exists(_,_)),
	isSlot(A),atom(Class),!,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,Fml,UFreeV,Out,N),!.
*/


% Atom as Formula (do nothing)     				    
getNegationForm(Caller,ArgN,Context,KRVars,[],Term,UFreeV,Term,1):- \+ (compound(Term)),!.

% Special case for string
getNegationForm(Caller,ArgN,Context,KRVars,[],string(A),UFreeV,string(A),1):-!.


% Special cases for Equals
getNegationForm(Caller,ArgN,Context,KRVars,[],equal(A,B),UFreeV,equal(A,B),1):-isSlot(B),isSlot(A),!.

getNegationForm(Caller,ArgN,Context,KRVars,PreQ,equal(A,Fml),UFreeV,Out,N):-isSlot(A),!,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,equal(Fml,A),UFreeV,Out,N),!.
	
       						       
/*
getNegationForm(Caller,ArgN,Context,KRVars,[dom(X,[F1:Range1,F2:Range2])|PreQ],equal(Fml1,Fml2),UFreeV,Result,2):-
	Fml1=..[holds,F1|Args1],hlPredicateAttribute(F1,'Function'),
	Fml2=..[holds,F2|Args2],hlPredicateAttribute(F2,'Function'),!,
	length(Args1,R1),Range1 is R1 +1,
	length(Args2,R2),Range2 is R2 +1,
	getNegationForm_Args(Caller,ArgN,Args1,_,true,Context,KRVars,PreQ1,UFreeV,F1,1,Args1,ArgsO1),!,
	getNegationForm_Args(Caller,ArgN,Args2,_,true,Context,KRVars,PreQ2,UFreeV,F2,1,Args2,ArgsO2),!,
	idGen(G2),
	X='$VAR'(G2),!,
	FmlO1=..[holds,F1|ArgsO1,X],
	FmlO2=..[holds,F2|ArgsO2,X],
	Rs1 = not(FmlO1) or FmlO2,
	Rs2 = not(FmlO2) or FmlO1,
	Result = Rs1 and Rs2,!,
%	getConjForm(Result,CResult),
	append(PreQ1,PreQ2,PreQ),!.

%  Skolem Function as Formula (the PVersion leaves Skolem Intact)     				    
getNegationForm(PIN,PIN,formula,ArgN,Context,KRVars,[dom(Var,[Caller:ArgN],[])],Term,UFreeV,X,1):-
	Term=..[F|Args],  hlPredicateAttribute(F,'SkolemFunction'),!,
	last(X,Args),!.

% Skolem Function  (fix its args)
getNegationForm(Caller,ArgN,Context,KRVars,[dom(Var,[Caller:ArgN],[]),equalSK(Var,Result)|PreQ],Term,UFreeV,Var,1):-
	Term=..[F|Args],hlPredicateAttribute(F,'SkolemFunction'),!,
	idGen(N),
	Var='$VAR'(N),
	getNegationForm_Args(Caller,ArgN,true,Context,KRVars,PreQ,[Var|UFreeV],F,1,Args,ArgsO),
	PResult=..[F|PArgsO],!,
	Result=..[F|ArgsO],!.
*/	

getNegationForm(Caller,ArgN,Context,KRVars,PreQ,necessary(F),UFreeV,NECESSARY,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,F,UFreeV,NNF,Paths), 
	getConjForm(NNF,CNF), 
	necessaryRule(necessary CNF, NECESSARY),!.

getNegationForm(Caller,ArgN,Context,KRVars,PreQ,possible F,UFreeV,POSSIBLE,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,F,UFreeV,NNF,Paths),
	getDisjForm(NNF,DNF),
	possibleRule(possible DNF, POSSIBLE).


getNegationForm(Caller,ArgN,Context,KRVars,[forall(X)|PreQ],forall(X,Fml),UFreeV, NNF,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,Fml,UFreeV, NNF,Paths).

getNegationForm(Caller,ArgN,Context,KRVars,[replaceConsVar(X,'$existential'(Repl,SKF))|PreQ],exists(X,Fml),UFreeV, NNF,Paths) :- !,
	 toMarkUp(kif,X,KRVars,Repl),
	 subst( Fml, X, (Repl), SKF),!,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,Fml,UFreeV,NNF,Paths).	
	
/*
% Function  (fix its args)								 % Treats as universal and Existential
getNegationForm(Caller,ArgN,Context,KRVars,[post(Var,eval(Result,Var)),replaceConsVar(Var,Result),dom(Var,[F:Range,F:range,Caller:ArgN])|PreQ],Term,UFreeV,Var,1):-
	Term=..[F|Args],hlPredicateAttribute(F,'Function'),!,
	idGen(N),
	Var='$VAR'(N),
	PTerm=..[F|PArgs],!,
	length(Args,R),Range is R +1,
	getNegationForm_Args(Caller,ArgN,true,Context,KRVars,PreQ,UFreeV,F,1,Args,ArgsO),
	PResult=..[F|PArgsO],!,
	Result=..[F|ArgsO],!.
*/
	
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,A and B,UFreeV,NNF,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ1,A,UFreeV,NNF1,Paths1),
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ2,B,UFreeV,NNF2,Paths2),
	append(PreQ1,PreQ2,PreQ),
	Paths is Paths1 * Paths2,
	(Paths1 > Paths2 -> (NNF = (NNF2 and NNF1));
		            (NNF = (NNF1 and NNF2))),!.

getNegationForm(Caller,ArgN,Context,KRVars,PreQ,A or B,UFreeV,NNF,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ1,A,UFreeV,NNF1,Paths1),
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ2,B,UFreeV,NNF2,Paths2),
	append(PreQ1,PreQ2,PreQ),
	Paths is Paths1 + Paths2,
	(Paths1 > Paths2 -> (NNF = (NNF2 or NNF1));
		            (NNF = (NNF1 or NNF2))),!.

% Temporal Logic
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,not until(A,B),UFreeV,NNF,Paths) :-  
		getNegationForm(Caller,ArgN,Context,KRVars,PreQ1,not A,UFreeV,NNA,_), 
		getNegationForm(Caller,ArgN,Context,KRVars,PreQ2,not B,UFreeV,NNB,_), !,
		( Fml1 = (NNB or  until(NNB,NNA or NNB)) ),
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ3,Fml1,UFreeV,NNF,Paths),!,
	append(PreQ1,PreQ2,PreQ12),!,
	append(PreQ12,PreQ3,PreQ),!.
	
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,next F,UFreeV,NEXT,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,F,UFreeV,NNF,Paths), 
	nextRule(next NNF, NEXT),!.


getNegationForm(Caller,ArgN,Context,KRVars,PreQ,until(A,B),UFreeV,NNF,Paths) :- !,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ1,A,UFreeV,NNF1,Paths1),
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ2,B,UFreeV,NNF2,Paths2),
	append(PreQ1,PreQ2,PreQ),
	Paths is Paths1 + Paths2,
	NNF = until(NNF1, NNF2),
	!.



% NNF Continued
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,Fml,UFreeV,NNF,Paths) :-  
	(
		Fml =  not(not A)      ->  Fml1 = A;
		 Fml =  not(necessary F)   -> Fml1 = possible (not F);
		 Fml =  not(possible(not F))   -> Fml1 = necessary ( F);
		 Fml =  not(possible F)   -> Fml1 = necessary (not F);
		 Fml =  not(next F)   -> Fml1 = possible (not F);
		 Fml =  not forall(X,F)  -> Fml1 = exists(X,not(F));
		 Fml =  not exists(X,F)   -> Fml1 = forall(X,not(F));
		 Fml =  not(A or B)   -> Fml1 = not(A) and not(B);
		 Fml =  not(A and B)   -> Fml1 = not(A) or not(B);
		 Fml = (A => B)   -> Fml1 = not(A) or B;
		 Fml =  not((A => B))  -> Fml1 = A and not(B);
		 Fml = (A <=> B)  -> Fml1 = (A and B) or (not A and not(B));
		 Fml =  not((A <=> B)) -> Fml1 = (A and not(B)) or (not A and B)
	 ),!,getNegationForm(Caller,ArgN,Context,KRVars,PreQ,Fml1,UFreeV,NNF,Paths),!.



% Left over Terms
getNegationForm(Caller,ArgN,Context,KRVars,[dom(F,[holds:1])|PreQ],(Term),UVars,(Result),1):- 
	Term=..[holds,F|Args],isEntitySlot(F),!,
	getNegationForm_Args(F,1,true,Context,KRVars,PreQ,UVars,Args,ArgsO),!,
	Result=..[holds,F|ArgsO].
	
% Strip Not Holds and Loop over 
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,(Term),UVars,(Result),N):- 
	Term=..[holds,F|Args],
	NTerm=..[F|Args], 
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,NTerm,UVars,Result,N),!.
 


% Left over Terms
getNegationForm(Caller,ArgN,Context,KRVars,[dom(F,['AssignmentFn':1])|PreQ],(Term),UVars,(Result),1):- 
	Term=..['AssignmentFn',F|Args],isEntitySlot(F),!,
	getNegationForm_Args(F,1,true,Context,KRVars,PreQ,UVars,Args,ArgsO),!,
	Result=..['AssignmentFn',F|ArgsO].
	
% Strip Not Holds and Loop over 
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,(Term),UVars,(Result),N):- 
	Term=..['AssignmentFn',F|Args],
	NTerm=..[F|Args], 
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,NTerm,UVars,Result,N),!.
 



% Explore arguments
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,not(Term),UVars,not(Result),N):-
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ,(Term),UVars,(Result),N),!.

% Explore arguments
getNegationForm(Caller,ArgN,Context,KRVars,PreQ,(Term),UVars,(Result),1):-
	Term=..[F|Args],
	getNegationForm_Args(F,1,true,Context,KRVars,PreQ,UVars,Args,ArgsO),!,
	Result=..[F|ArgsO].
	
getNegationForm_Args(Caller,ArgN,Truth,Context,KRVars,[],UVars,[],[]):-!.

getNegationForm_Args(Caller,ArgN,Truth,Context,KRVars,PreQ,UVars,[Arg|ArgS],[ArgO|ArgSO]):-
	ArgNN is ArgN + 1,
	getNegationForm(Caller,ArgN,Context,KRVars,PreQ1,Arg,UVars,ArgO,Paths),
	getNegationForm_Args(Caller,ArgNN,Truth,Context,KRVars,PreQ2,UVars,ArgS,ArgSO),!,
	append(PreQ1,PreQ2,PreQ),!.


necessaryRule(Var,Var):-isEntitySlot(Var),!.
necessaryRule(necessary (A and B), (BA) and (BB)) :- !, necessaryRule(necessary A,BA), necessaryRule(necessary B,BB).
necessaryRule(NECESSARY, NECESSARY).
possibleRule(Var,Var):-isEntitySlot(Var),!.
possibleRule(possible (A or B), (DA) or (DB)) :- !, possibleRule(possible A,DA), possibleRule(possible B,DB).
possibleRule(POSSIBLE, POSSIBLE).
nextRule(Var,Var):-isEntitySlot(Var),!.
nextRule(next (A or B), (DA) or (DB)) :- !, nextRule(next A,DA), nextRule(next B,DB).
nextRule(next (A and B), (DA) and (DB)) :- !, nextRule(next A,DA), nextRule(next B,DB).
nextRule(NEXT, NEXT).

%%%  Conjunctive Normal Form (CNF) -- assumes Fml in NNF


%%%  Disjunctive Normal Form (DNF) -- assumes Fml in NNF

% Usage: getDisjForm( +NNF, ?DNF )

getDisjForm(Var,Var):-isEntitySlot(Var),!.
getDisjForm(P or Q, P1 or Q1):- !, getDisjForm(P, P1), getDisjForm(Q, Q1).
getDisjForm(P and Q,     DNF):- !, getDisjForm(P, P1), getDisjForm(Q, Q1), getDisjForm1(P1 and Q1, DNF).
getDisjForm(DNF,       DNF).

getDisjForm1(P and (Q or R), P1 or Q1):- !, getDisjForm1(P and Q, P1), getDisjForm1(P and R, Q1).
getDisjForm1((P or Q) and R, P1 or Q1):- !, getDisjForm1(P and R, P1), getDisjForm1(Q and R, Q1).
getDisjForm1(DNF,             DNF).

/*
skolemize(Fml,X,UFreeV,FmlSk,true):-
	copy_term((X,Fml,UFreeV),(Fml,Fml1,UFreeV)),
	copy_term((X,Fml1,UFreeV),(exists,FmlSk,UFreeV)),!.
*/     
			  
getSkolemGen(F,O):-
      getConstants(atomic,F,List,_,_),
      idGen(YY),Y is YY /\ 15,
      getSkolemGen_util_clean_list(List,Clean),
      listTrim(5,Clean,Trimmed),
      getSkolemGen_util(YY,Trimmed,Good),
      concat_atom(Good,Head),
      concat_atom([f,Head,Y,'SkFn'],O),!.   % Adds "'zzskFn'" to the next generated identity

listTrim(N,Clean,Clean):-!.

listTrim(N,Clean,Trimmed):-length(Clean,NN),NN<N.



getSkolemGen_util(Y,[],['m',Y]).
getSkolemGen_util(Y,This,This).

getSkolemGen_util_clean_list([],[]).
getSkolemGen_util_clean_list([H|T],Clean):-isTooGeneralForSkolem(H),!,
	getSkolemGen_util_clean_list(T,CleanS),list_to_set(CleanS,Clean).
getSkolemGen_util_clean_list([H|T],[HH|Clean]):-
	getAtomPropercase(H,HH),
	getSkolemGen_util_clean_list(T,Clean).
	
getAtomPropercase(H,H):-not(atom(H)).
getAtomPropercase(H,HH):-
		catch((atom_codes(H,[HC|T]),
		char_type(HC,to_lower(UC)),
		atom_codes(UC,[Code]),
		atom_codes(HH,[Code|T])),_,HH=H).

isTooGeneralForSkolem(X):-var(X).
isTooGeneralForSkolem(X):-number(X).
isTooGeneralForSkolem('$VAR').
isTooGeneralForSkolem('E').
isTooGeneralForSkolem('instance').
isTooGeneralForSkolem(',').
isTooGeneralForSkolem([]).
isTooGeneralForSkolem((.)).
isTooGeneralForSkolem(X):-hlPredicateAttribute(X,connective).
isTooGeneralForSkolem(X):-atom(X),atom_concat(_,'SkFn',X).


% ======================================================================
% Conjunctive normal form: getConjForm(A,A1) returns A1 in conjunctive normal form
% where A is an input formula in negation normal form. A1 is a logically equivalent 
% formula, which is a conjunction of disjunctions of atomic (negated or unnegated)
% subformulae of A.
% Usage: getConjForm( +NNF, ?CNF )
% Example:
%
% | ?- getConjForm(or(and(a(_h80),not(b(sk2(_h80)))),or(not(c(_h80)),d(sk2(_h80)))),Fml).
%
% Fml = and(or(a(_h96),or(not(c(_h96)),d(sk2(_h96)))),or(not(b(sk2(_h96))),or(not(c(_h96)),d(sk2(_h96)))))
%
% yes
% | ?-
% ======================================================================

%begin added to aaby
getConjForm(Var,Var) :- isEntitySlot(Var),!.
getConjForm(not(NP),PO):-not(isEntitySlot(NP)),NP=not(P),!,getConjForm(P,PO).
%end added to aaby

getConjForm(or(and(P,Q),and(R,S)), and(or(Q1,S1), and(or(Q1,R1),and(or(P1,R1),or(P1,S1))))):- 
        getConjForm(P,P1),getConjForm(Q,Q1),getConjForm(R,R1),getConjForm(S,S1).

getConjForm(P and Q, P1 and Q1):- !, getConjForm(P, P1), getConjForm(Q, Q1).
getConjForm(P or Q,     CNF):- !, getConjForm(P, P1), getConjForm(Q, Q1), getConjForm1(P1 or Q1, CNF).
getConjForm(CNF,       CNF).

getConjForm1(Var,Var) :- isEntitySlot(Var),!.
getConjForm1((P and Q) or R, P1 and Q1):- !, getConjForm1(P or R, P1), getConjForm1(Q or R, Q1).
getConjForm1(P or (Q and R), P1 and Q1):- !, getConjForm1(P or Q, P1), getConjForm1(P or R, Q1).
getConjForm1(CNF,             CNF).

% ======================================================================
%  Clausify (Clausification of CNF to KRClfog)
%  Assumes Fml in CNF (post NNF however) and that each quantified variable is unique
% Usage: toClauseFormOld(+Fml, ?Cs)
% Cs is a list of the form: 
% ======================================================================
toClauseFormOld(A,A):- isSlot(A),!.

toClauseFormOld(CNF, CLs) :- toClauseFormOld(CNF, CLs, [] ).

toClauseFormOld( (P and Q), C1, C2 ) :- !, 
	toClauseFormOld( P, C1, C3 ), 
	toClauseFormOld( Q, C3, C2 ).

toClauseFormOld( P, [cl(A,B)|Cs], Cs ) :-
	writeq_conj(P),
	getInClause( P, A, [], B, [] ), !.
toClauseFormOld( _, C, C ).


getInClause( (P or Q), A, A1, B, B1 ) :- !, 
	getInClause( P, A2, A1, B2, B1 ),
	getInClause( Q, A,  A2, B,  B2 ).

getInClause( not P, A,  A, B1, B ) :- !, isNotInClause( P, A ), putInClause( P, B, B1 ).
getInClause( P,  A1, A, B,  B ) :- !, isNotInClause( P, B ), putInClause( P, A, A1 ).

isNotInClause(X,[Y|_]) :- X==Y, !, fail.
isNotInClause(X, _ and Y) :- !,isNotInClause(X,Y).
isNotInClause(X,[_|Y]) :- !,isNotInClause(X,Y).
isNotInClause(_,[]).

putInClause(X,[],   [X]   ) :- !.
putInClause(X,[Y|L],[Y|L] ) :- X == Y,!.
putInClause(X,[Y|L],[Y|L1]) :- putInClause(X,L,L1).


% ======================================================================
%  Previous Clausify (Clausification of CNF to KRClfog)
%  Assumes Fml in CNF (post NNF however) and that each quantified variable is unique
% Usage: toClauseFormOld(+Fml, ?Cs)
% Cs is a list of the form: 
% ======================================================================

toClauseFormOptimal(KRLOG,Optimum):-
         toClauseFormAll(KRLOG,Clf),
	 getOptimalClauseEntailments(Clf,Optimum).


getOptimalClauseEntailments(Optimum,Optimum):-!.

getOptimalClauseEntailments(Clf,Optimum):-
	getGraphOfClause(Clf,Graph),
	optimizeGraph(Graph,Optimum).


getGraphOfClause(and(Clf1,Clf2),CLFList):-!,
	getGraphOfClause(Clf1,List1),
	getGraphOfClause(Clf2,List2),
	append(List1,List2,CLFList).
	
getGraphOfClause(entails(Ante,ConqQ),[[ConqQ]-AnteLS]):-!,
	conjunctsToList(Ante,AnteL),sort(AnteL,AnteLS).
getGraphOfClause(ConqQ,[ConqQ-[true]]).

optimizeGraph(Graph,Optimal):-
	mergeAnteceedants(Graph,Graph,Optimal).
	
mergeAnteceedants(Optimal,[],Optimal).
mergeAnteceedants([],Optimal,[]).
mergeAnteceedants(Pre,[[Cons]-Ante|More],Optimal):- %true,
	once((member(ConsqS-Before,Pre),
	copy_term_member(Cons,ConsqS,Original))),
	not(Before=Ante),
	length(Pre,BN),
	delete(Pre,ConsqS-Before,ClauseRemovedFirst),
	delete(ClauseRemovedFirst,[Cons]-Ante,ClauseRemoved),
	length(ClauseRemoved,AN),
	getSetPartion(Before,Ante,BeforeDisj,AnteDisj,Sameness),
	not(Sameness=[]),!,
	make_reduction_clause(Original,Cons,ReductionHead,Sameness,ReductionClause),
	mergeAnteceedants([
		ReductionClause,
		ConsqS-[ReductionHead|BeforeDisj],
		ConsqS-[ReductionHead|AnteDisj]
		|ClauseRemoved],More,Optimal),!.

mergeAnteceedants(Pre,[Cons-Ante|More],Optimal):-
	mergeAnteceedants(Pre,More,Optimal).

make_reduction_clause(Original,Cons,common(Original),Sameness,[common(Original)]-Sameness):-
			      Original==Cons.
	
make_reduction_clause(Original,Cons,common(Original,Cons),Sameness,[common(Original,Cons)]-Sameness).
	
spt1:-spt([],[]).
spt2:-spt([instance(X,'Class')],[instance(X,'Class')]).
spt3:-spt([instance(X,'Class')],[p1,instance(X,'Class'),p2]).
spt4:-spt([p2,instance(X,'Class')],[p1,instance(X,'Class'),p2]).
spt5:-spt([p2,instance(X,'Class')],[p1,instance(X,'Class')]).
spt6:-spt([p2,instance(X,'Class')],[p1,instance(X,Y)]).
spt7:-spt([p1,instance(X,'Class')],[p1,instance(X,Y)]).

spt(Set1,Set2):-
	getSetPartion_proc(Set1,Set2,NewSet1,NewSet2,Intersection),
	writeq_conj(getSetPartion_proc(Set1,Set2,NewSet1,NewSet2,Intersection)).

	
getSetPartion(Before,Ante,BeforeDisj,AnteDisj,Sameness):-
	getSetPartion_proc(Before,Ante,BeforeDisj,AnteDisj,Sameness),!.

	
getSetPartion_proc([],Set2,[],Set2,[]).
getSetPartion_proc(Set1,[],Set1,[],[]).
getSetPartion_proc([H|Rest],Clause,NewSet1,NewSet2,GeneralizedIntersection):-
	replace_in_clause(H,Clause,PutFront,NewClause,Generalized),!,
	getSetPartion_proc(Rest,NewClause,MidSet1,NewSet2,Intersection),
	append(PutFront,MidSet1,NewSet1),
	append(Generalized,Intersection,GeneralizedIntersection),!.
	
getSetPartion_proc([H|Rest],Set2,[H|O1],O2,Intersection):-!,
	getSetPartion_proc(Rest,Set2,O1,O2,Intersection).	

% replace_in_clause(H,Clause,PutFront,NewClause,Generalized)

replace_in_clause(T1,[],[T1],[],[]):-!.

replace_in_clause(T1,[T2|Clause],PutFront,NewClause,Generalized):-
	not(functor(T1,common,_)),
	not(functor(T2,common,_)),
	once((compareVariant(T1,T2,GT,Cost1,Cost2))),
		compare(Dif,Cost1,Cost2),
		apply_mgu(Dif,Cost1,Cost2,T1,T2,GT,PutFront,Clause,NewClause,Generalized),!.

replace_in_clause(T1,[T2|Clause],PutFront,[T2|NewClause],Generalized):-!,
	replace_in_clause(T1,Clause,PutFront,NewClause,Generalized).

	
apply_mgu(_,_,_,T1,T2,GT,Front,Clause,Clause,_Generalized):-var(GT),!,fail.
apply_mgu(=,0,0,T1,T2,GT,[],Clause,NewClause,[GT]):-T1==T2,!,delete(Clause,T2,NewClause).

apply_mgu(=,Cost1,Cost2,T1,T2,GT,[],Clause,NewClause,[table_for(T2,T1)]):-T1==GT,!,delete(Clause,T2,NewClause).
apply_mgu(<,Cost1,Cost2,T1,T2,GT,[/*wait(T1)*/],Clause,NewClause,[table_for(T2,T1)]):-T1==GT,!,delete(Clause,T2,NewClause).
apply_mgu(>,Cost1,Cost2,T1,T2,GT,[],Clause,NewClause,[wait(T2),T1]):-T1==GT,!,fail,delete(Clause,T2,NewClause).

apply_mgu(=,Cost1,Cost2,T1,T2,GT,[],Clause,NewClause,[table_for(T1,T2)]):-T2==GT,!,delete(Clause,T2,NewClause).
apply_mgu(>,Cost1,Cost2,T1,T2,GT,[],Clause,/*[wait(T2)|*/NewClause/*]*/,[table_for(T1,T2)]):-T2==GT,!,delete(Clause,T2,NewClause).
apply_mgu(<,Cost1,Cost2,T1,T2,GT,[],Clause,NewClause,[wait(T1),T2]):-T2==GT,!,fail,delete(Clause,T2,NewClause).


apply_mgu(>,Cost1,Cost2,T1,T2,GT,[wait(T1)],Clause,[save(T2)|NewClause],[table_for(T2,T1)]):-!,delete(Clause,T2,NewClause).
apply_mgu(<,Cost1,Cost2,T1,T2,GT,[save(T1)],Clause,[wait(T2)|NewClause],[table_for(T1,T2)]):-!,delete(Clause,T2,NewClause).

	
			
	
	

	
copy_term_member(Cons,ConsqS,Original):-
	copy_term(Cons,ConsCopy),!,
	member(Original,ConsqS),
	not(not(Original=ConsCopy)).	
	

compareVariant(T1,T2,M):-compareVariant(T1,T2,M,_,_).

compareVariant(T1,T2,M,Dif):-
	compareVariant(T1,T2,M,C1,C2),!,
	Dif is C1-C2.

compareVariant(T1,T2,T1,0,0):-T1==T2,!.
compareVariant(T1,T2,T1,0,0):-isSlot(T1),isSlot(T2),!.
compareVariant(T1,T2,T1,0,C):-isSlot(T1),!,isPriceOf(T2,C).
compareVariant(T1,T2,T2,C,0):-isSlot(T2),!,isPriceOf(T1,C).
compareVariant([],[],[]):-!.
compareVariant([],T2,_,0,N):-!,length(T2,N).
compareVariant(T1,[],_,N,0):-!,length(T1,N).
compareVariant([H1|T1],[H2|T2],[U1|U2],C1,C2):-!,
	compareVariant(H1,H2,U1,HC1,HC2),
	compareVariant(T1,T2,U2,TC1,TC2),!,
	C1 is HC1 + TC1,
	C2 is HC2 + TC2.
       
compareVariant(T1,T2,_,1,1):-atomic(T1),atomic(T2),!.

compareVariant(not(T1),not(T2),not(U),C1,C2):-
	once(compareVariant(T1,T2,U,C1,C2)),nonvar(U).

compareVariant(T1,T2,U,C1,C2):-
	T1=..[F|Args1],
	T2=..[F|Args2],
	not(F=not),
	length(Args1,N1),
        length(Args2,N2),
	min(N1,N2,N),
	length(ArgsT,N),
	compareVariant(Args1,Args2,ArgsT,C1,C2),!,
	((N1=:=N2,U=..[F|ArgsT]); U=_).
	
compareVariant(T1,T2,_,C1,C2):-!,isPriceOf(T1,C1),isPriceOf(T2,C2),!.

isPriceOf(T,-1):-not(not(T=[])),!.
isPriceOf('$VAR'(T),-1):-!.
isPriceOf(T,1):-atomic(T),!.
isPriceOf([H|T],C):-
	isPriceOf(H,HC),
	isPriceOf(T,TC),!,
	C is TC + HC.
isPriceOf(not(T),C):-!,isPriceOf(T,C).
isPriceOf(T,C):-
	T=..List,
	isPriceOf(List,C2),!,C is C2 +2.

	
        
toClauseFormAll(Disj,Disj):- isSlot(Disj),!.
toClauseFormAll((Disj1 and Disj2),Clf) :- !,
        toClauseFormAll(Disj1,Clf1),
        toClauseFormAll(Disj2,Clf2),
        conjoin_kr(Clf1,Clf2,Clf).
	
toClauseFormAll(Disj,Clf) :-
        getConsequentList(Disj,Cons), 
        toClauseForm_proc(Disj,Cons,Clf). %, write_clause_with_number(Clf,TN1).

getConsequentList(A,A) :-isSlot(A),!.

getConsequentList(Fml,Clf) :-
        Fml = entails(B,A) ->     % contrapositives not made if in Clause Form (i.g. built from "if")
                getConsequentList(A,Clf);
        Fml = (A and B) ->
                getConsequentList(A,Clf1),
                getConsequentList(B,Clf2),
                union(Clf1,Clf2,Clf);
        Fml = (A or B) ->
                getConsequentList(A,Clf1),
                getConsequentList(B,Clf2),
                union(Clf1,Clf2,Clf);
        %true ->
                Clf = [Fml].

toClauseForm_proc(Disj,[Con|RestCons],Clf) :-
        getAntecedantForConsequent(Con,Disj,Ante1),
        (Ante1 == false ->
                Clf = true;
		Ante=Ante1,
                toClauseForm_proc(Disj,RestCons,Clf1),
                conjoin_kr(entails(Ante,Con),Clf1,Clf)).
toClauseForm_proc(_,[],true).

	
getAntecedantForConsequent(Cons,Fml,Ante):-(isSlot(Cons);isSlot(Fml)),!,Ante=true.
getAntecedantForConsequent(Cons,Fml,Ante) :-
        Fml = entails(B,A) ->
                getAntecedantForConsequent(Cons,A,A1),
                conjoin_kr(A1,B,Ante);
        Fml = (A and B) ->
                getAntecedantForConsequent(Cons,A,A1),
                getAntecedantForConsequent(Cons,B,B1),
                disjoin_kr(A1,B1,Ante);
        Fml = (A or B) ->
                getAntecedantForConsequent(Cons,A,A1),
                getAntecedantForConsequent(Cons,B,B1),
                conjoin_kr(A1,B1,Ante);
        Fml == Cons ->
                Ante = true;
   getNegationForm_let(Fml,Cons) -> 
                Ante = false;
        %true ->
   getNegationForm_let(Fml,Ante).

conjoin_kr(A,B,C) :-
        A == true ->
                C = B;
        B == true ->
                C = A;
        A == false ->
                C = false;
        B == false ->
                C = false;
        %true ->
                C = (A and B).

disjoin_kr(A,B,C) :-
        A == true ->
                C = true;
        B == true ->
                C = true;
        A == false ->
                C = B;
        B == false ->
                C = A;
        %true ->
                C = (A or B).


getNegationForm_let(not(A),A). 
getNegationForm_let(A,not(A)). 
%getNegationForm_let(not(Fml),Ante):-getNegationForm_let(not(Fml),Ante).

% ======================================================================
% getClosedVersionWFF(FmlIn,FmlOut)
% This takes an open or closed Wff in PNF form and Produces a Closed version of the Wff treating unquantified varaibles as universal
%  ?- getClosedVersionWFF(forall,=>(p(X),and(q(X,Y),r(Y))),FmlOut).

% X = _G447
% Y = _G450
% OFmlOut = forall(_G447, forall(_G450, p(_G447)=> q(_G447, _G450)and r(_G450)))

%  ?- getClosedVersionWFF(exists,=>(p(X),and(q(X,Y),r(Y))),FmlOut).

% X = _G447
% Y = _G450
% OFmlOut = exists(_G447, exists(_G450, p(_G447)=> q(_G447, _G450)and r(_G450)))

% ======================================================================

%getClosedVersionWFF(_,Fml,Fml):-!. %Temp TODO Short 
%            isTheorem(Fml,UFreeV),!.

getClosedVersionWFF('?',Fml,Fml).
%getClosedVersionWFF(_,Fml,Fml):-ground(Fml),!.

getClosedVersionWFF(_,Fml,Fml):-isEntitySlot(Fml),!.

getClosedVersionWFF(With,Fml,FmlOut):-getPrologVars(Fml,FV,_,_),!,
        getClosedVersionWFF_util_closevars(With,Fml,FV,FmlOut).

getClosedVersionWFF_util_closevars(With,Fml,[],Fml):-!.
getClosedVersionWFF_util_closevars(With,Fml,[Var|Vs],FmlOut):-
            isQuantifiedVar(Var,Fml),!,
            getClosedVersionWFF_util_closevars(With,Fml,Vs,FmlOut).

getClosedVersionWFF_util_closevars(With,Fml,[Var|Vs],Out):-
	    getClosedVersionWFF_util_closevars(With,Fml,Vs,POut),!,
                        Out=..[With,Var,POut].


isQuantifiedVar(Var,Fml):-isEntitySlot(Fml),!.
isQuantifiedVar(Var,forall(Var2,Fml)):-Var==Var2,!.
isQuantifiedVar(Var,exists(Var2,Fml)):-Var==Var2,!.
isQuantifiedVar(Var,exists(Var2,Fml)):-Var==Var2,!.
isQuantifiedVar(Var,forall(_,Fml)):-!,isQuantifiedVar(Var,Fml).
isQuantifiedVar(Var,exists(_,Fml)):-!,isQuantifiedVar(Var,Fml).
isQuantifiedVar(Var,exists(_,Fml)):-!,isQuantifiedVar(Var,Fml).
isQuantifiedVar(Var,exists(_,Fml)):-!,isQuantifiedVar(Var,Fml).
isQuantifiedVar(Var,(Fml1 => Fml2)):-!,
	(isQuantifiedVar(Var,Fml1);
	isQuantifiedVar(Var,Fml2)).
isQuantifiedVar(Var,(Fml1 <=> Fml2)):-!,
       ( isQuantifiedVar(Var,Fml1);
	isQuantifiedVar(Var,Fml2)).
isQuantifiedVar(Var,and(Fml1,Fml2)):-!,
	(isQuantifiedVar(Var,Fml1);isQuantifiedVar(Var,Fml2)).
isQuantifiedVar(Var,or(Fml1,Fml2)):-!,
	(isQuantifiedVar(Var,Fml1);isQuantifiedVar(Var,Fml2)).





getOpenVariablesWFF(FmlInOpen,[],[]):-!.
getOpenVariablesWFF(FmlInOpen,V,[]):-var(V),!.
getOpenVariablesWFF(FmlInOpen,[K=Va|Rs],[K=Va|Vars]):-
		not(isVarClosedWFF(Va,FmlInOpen)),!,
		getOpenVariablesWFF(FmlInOpen,Rs,Vars),!.
getOpenVariablesWFF(FmlInOpen,[_|Rs],Vars):-	!,
		getOpenVariablesWFF(FmlInOpen,Rs,Vars),!.
		
isVarClosedWFF(Va,forall(VS,FmlInOpen)):-Va==VS,!.
isVarClosedWFF(Va,exists(VS,FmlInOpen)):-Va==VS,!.
isVarClosedWFF(Va,forall(_,FmlInOpen)):-!,isVarClosedWFF(Va,FmlInOpen).
isVarClosedWFF(Va,exists(_,FmlInOpen)):-!,isVarClosedWFF(Va,FmlInOpen).
isVarClosedWFF(Va,and(FmlIn,Open)):-!,
	isVarClosedWFF(Va,FmlIn);
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,or(FmlIn,Open)):-!,
	isVarClosedWFF(Va,FmlIn);
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,'=>'(FmlIn,Open)):-!,
	isVarClosedWFF(Va,FmlIn);
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,'<=>'(FmlIn,Open)):-!,
	isVarClosedWFF(Va,FmlIn);
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,xor(FmlIn,Open)):-!,
	isVarClosedWFF(Va,FmlIn);
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,entails(FmlIn,Open)):-!,
	isVarClosedWFF(Va,FmlIn);
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,known(Open)):-!,
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,possible(Open)):-!,
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,consistent(Open)):-!,
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,not(Open)):-!,
	isVarClosedWFF(Va,Open).
isVarClosedWFF(Va,neg(Open)):-!,
	isVarClosedWFF(Va,Open).
	
	
fflagsN(Rule,Flags,Functor,Repl,Found,NewFlags):-
	getPrologVars(Rule,RuleVars,_,_),!,
	fflags_varN(RuleVars,Flags,Functor,Repl,Found,NewFlags),!.

fflags1(Rule,Flags,Functor,Repl,Found,NewFlags):-
	getPrologVars(Rule,RuleVars,_,_),!,
	fflags_var1(RuleVars,Flags,Functor,Repl,Found,NewFlags),!.

fflags_var1(RuleVars,[],Functor,Repl,[],[]):-!.
fflags_var1(RuleVars,[Flag|FlagS],Functor,Repl,[NFlag|Found],NewFlags):-
	Flag=..[Functor,V|Args],identical_member(V,RuleVars),!,
	NFlag=..[Repl,V|Args],
	fflags_var1(RuleVars,FlagS,Functor,Repl,Found,NewFlags).
fflags_var1(RuleVars,[Flag|FlagS],Functor,Repl,Found,[Flag|NewFlags]):-
	fflags_var1(RuleVars,FlagS,Functor,Repl,Found,NewFlags).

fflags_varN(RuleVars,[],Functor,Repl,[],[]):-!.
fflags_varN(RuleVars,[Flag|FlagS],Functor,Repl,[NFlag|Found],NewFlags):-
	Flag=..[Functor,V|Args],
	getPrologVars(Flag,FV,_,_),intersection(RuleVars,FV,[_|_]),!,
	NFlag=..[Repl,V|Args],
	fflags_var1(RuleVars,FlagS,Functor,Repl,Found,NewFlags).
fflags_varN(RuleVars,[Flag|FlagS],Functor,Repl,Found,[Flag|NewFlags]):-
	fflags_varN(RuleVars,FlagS,Functor,Repl,Found,NewFlags).
	

/*
x(Y,a and b) -> x(Y,a) and x(Y,b)
x(Y,a or b) -> x(Y,a) or x(Y,b)
x(Y,a => b) -> x(Y,a) => x(Y,b)
x(Y,a <=> b) -> x(Y,a) <=> x(Y,b)
x(Y, not(a))  -> not(x(Y,a))
x(Y, exists(a)  -> not(x(Y,a))
*/

   /*
getModeledPredicates(A,A):-isLiteralTerm(A),!.


		
getModeledPredicates(F,Args,TermO):-
	getModeledPredicates_l([F],Args,TermO),!.

getModeledPredicates_l(FL,[],TermO):-!,
	TermO=.. FL.
getModeledPredicates_l(FL,[Arg|Rest],TermO):-isLiteralTerm(Arg),!,
	append(FL,[Arg],NFL),
	getModeledPredicates_l(NFL,Rest,TermO),!.
getModeledPredicates_l(FL,[exists(V,Arg)|Rest],exists(V,TermO)):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).
getModeledPredicates_l(FL,[forall(V,Arg)|Rest],forall(V,TermO)):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).
getModeledPredicates_l(FL,[not exists(V,Arg)|Rest],not(exists(V,TermO))):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).
getModeledPredicates_l(FL,[not forall(V,Arg)|Rest],not(forall(V,TermO))):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).
getModeledPredicates_l(FL,[Arg|Rest],TermO):-
	Arg =..[C,A,B],
	member(C,[and,or,'=>','<=>',entails]),!,
	append(FL,[A|Rest],AL),
	append(FL,[B|Rest],BL),
	TermA =.. AL,
	TermB =.. BL,
	TermM =..[C,TermA,TermB],
	 getModeledPredicates(TermM,TermO),!.
getModeledPredicates_l(FL,[not(=>(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[or(not(A),B)|Rest],TermO).
getModeledPredicates_l(FL,[not(<=>(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[(A and B) or (not A and not(B))|Rest],TermO).
getModeledPredicates_l(FL,[not(or(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[(not(A) and not(B))|Rest],TermO).
getModeledPredicates_l(FL,[not(and(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[(not(A) or not(B))|Rest],TermO).
getModeledPredicates_l(FL,[Arg|Rest],TermO):-!,
	getModeledPredicates(Arg,ArgO),
	append(FL,[ArgO],NFL),
	getModeledPredicates_l(NFL,Rest,TermO),!.


 			     */
			     

getModeledPredicates(A,A):-isLiteralTerm(A),!.

getModeledPredicates(string(A),string(A)):-!.

getModeledPredicates([Term|TermL],[TermO|TermLO]):-!,
	getModeledPredicates(Term,TermO),
	getModeledPredicates(TermL,TermLO).

getModeledPredicates(Term,OTerm):-
	Term=..[F|Args],
	getModeledPredicates(F,Args,OTerm),!.
	
getModeledPredicates(TermO,TermO):-!.

getModeledPredicates(F,[A,B],OTerm):-
	memberchk(F,[and,or,'<=>','=>',entails]),!,
	getModeledPredicates(A,AA),
	getModeledPredicates(B,BB),
	OTerm=..[F,AA,BB],!.

getModeledPredicates(holds,Args,OTerm):- 
	Args=[AF,F|Args],AF=='AssignmentFn',!,
	OTerm=..[holds,F|Args],!.	

getModeledPredicates(equal,[A,B],OTerm):-
	isSlot(A),isSlot(B),
	OTerm=..[equal,A,B],!.

getModeledPredicates(equal,[A,B],OTerm):-
	isSlot(A),not(isSlot(B)),!,
	getModeledPredicates(equal,[B,A],OTerm).

getModeledPredicates(equal,[A,B],OTerm):- 
	not(isSlot(A)),isSlot(B),
	A=..['AssignmentFn',F|Args],!,
	append([F|Args],[B],OL),
	OTerm=..[holds|OL],!.	

getModeledPredicates(equal,[A,B],OTerm):- 
	not(isSlot(A)),isSlot(B),
	A=..[F|Args],atom_concat(_,'Fn',F),!,
	append([F|Args],[B],OL),
	OTerm=..[holds|OL],!.	



getModeledPredicates(F,Args,OTerm):-
	memberchk(F,[string,'include-context',holds,equal]),!,
	OTerm=..[F|Args],!.

getModeledPredicates(F,[B],OTerm):-
	memberchk(F,[possible,known,absurd,not]),!,
	getModeledPredicates(B,BB),
	OTerm=..[F,BB],!.

getModeledPredicates(F,[A,B],OTerm):-
	memberchk(F,[forall,exists,exists,any]),!,
	getModeledPredicates(B,BB),
	OTerm=..[F,A,BB],!.

getModeledPredicates(not,[NV],BB):-
	nonvar(NV),NV=not(B),!,
	getModeledPredicates(B,BB).

getModeledPredicates(F,Args,TermO):-
	getModeledPredicates_l([F],Args,TermO),!.

getModeledPredicates_l(FL,[],TermO):-!,
	TermO=.. FL.

getModeledPredicates_l(FL,[Arg|Rest],TermO):-isLiteralTerm(Arg),!,
	append(FL,[Arg],NFL),
	getModeledPredicates_l(NFL,Rest,TermO),!.

getModeledPredicates_l(FL,[exists(V,Arg)|Rest],exists(V,TermO)):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).

getModeledPredicates_l(FL,[forall(V,Arg)|Rest],forall(V,TermO)):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).

getModeledPredicates_l(FL,[not exists(V,Arg)|Rest],not(exists(V,TermO))):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).

getModeledPredicates_l(FL,[not forall(V,Arg)|Rest],not(forall(V,TermO))):-!,
	getModeledPredicates_l(FL,[Arg|Rest],TermO).

getModeledPredicates_l(FL,[Arg|Rest],TermO):-
	Arg =..[C,A,B],
	member(C,[and,or,'=>','<=>',entails]),!,
	append(FL,[A|Rest],AL),
	append(FL,[B|Rest],BL),
	TermA =.. AL,
	TermB =.. BL,
	TermM =..[C,TermA,TermB],
	 getModeledPredicates(TermM,TermO),!.

getModeledPredicates_l(FL,[not(=>(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[or(not(A),B)|Rest],TermO).

getModeledPredicates_l(FL,[not(<=>(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[(A and B) or (not A and not(B))|Rest],TermO).

getModeledPredicates_l(FL,[not(or(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[(not(A) and not(B))|Rest],TermO).

getModeledPredicates_l(FL,[not(and(A,B))|Rest],TermO):-
	getModeledPredicates_l(FL,[(not(A) or not(B))|Rest],TermO).

getModeledPredicates_l(FL,[Arg|Rest],TermO):-!,
	getModeledPredicates(Arg,ArgO),
	append(FL,[ArgO],NFL),
	getModeledPredicates_l(NFL,Rest,TermO),!.


units_separated([], [], [], []).
units_separated([clause([],[Neg])|Clauses], PosL, [Neg|NegL], NonL) :- !,
	units_separated(Clauses, PosL, NegL, NonL).
units_separated([clause([Pos],[])|Clauses], [Pos|PosL], NegL, NonL) :- !,
	units_separated(Clauses, PosL, NegL, NonL).
units_separated([Clause|Clauses], PosL, NegL, [Clause|NonL]) :-
	units_separated(Clauses, PosL, NegL, NonL).


clausal_form(Formula, Clauses) :-
	pass_one(Formula, ClosedAndImplicationFree),
	pass_two(ClosedAndImplicationFree, Clauses).


clausal_form_of_negation(Formula, Clauses) :-
	pass_one(Formula, ClosedAndImplicationFree),
	pass_two(not  ClosedAndImplicationFree, Clauses).


/*----------------------------------------------------------------------

    The first pass over the formula does two things.
    1a. It locates the free variables of the formula.
    2.  It applies the rules
	    A => B	--> B v not A
	    A <=> B	--> (B v not A) /\ (A v not B)
	    if(A,B,C)	--> (B v not A) /\ (A v C)
	to eliminate implications.  Even in a non-clausal
	theorem prover this can be a good idea, eliminating
	<=> and if is essential if each subformula is to
	have a definite parity, and that in turn is vital
	if we are going to replace '$existential' quantifiers
	by Skolem functions.
    1b. It adds explicit quantifiers for the free variables.
    The predicate which does all this is pass_one/5:
	pass_one(+Formula,		% The original formula
		 -Translation,		% its implication-free equivalent
		 +Bound,		% The binding environment
		 +Free0,		% The variables known to be free
		 -Free)			% Free0 union Formula's free variables
    The binding environment just tells us which variables occur in quantifiers
    dominating this subformula, it doesn'writeTranslation matter yet whether they're
    universal or '$existential'.

    The translated formula is still an <expr>, although there are practical
    advantages to be gained by adopting a slightly different representation,
    but the neatness of being able to say that
	pass_one(F, G) --> pass_one(G, G)
    outweighs them.

----------------------------------------------------------------------*/

pass_one(Formula, ClosedAndImplicationFree) :-
	pass_one(Formula, ImplicationFree, [], [], FreeVariables),
	pass_one(FreeVariables, ImplicationFree, ClosedAndImplicationFree).


pass_one([], Formula, Formula).
pass_one([Var|Vars], Formula, all(Var,Closure)) :-
	pass_one(Vars, Formula, Closure).


pass_one(all(Var,B), all(Var,D), Bound, Free0, Free) :- !,
	pass_one(B, D, [Var|Bound], Free0, Free).
pass_one(exists(Var,B), exists(Var,D), Bound, Free0, Free) :- !,
	pass_one(B, D, [Var|Bound], Free0, Free).
pass_one(A and B, C and D, Bound, Free0, Free) :- !,
	pass_one(A, C, Bound, Free0, Free1),
	pass_one(B, D, Bound, Free1, Free).
pass_one(A or B, C or D, Bound, Free0, Free) :- !,
	pass_one(A, C, Bound, Free0, Free1),
	pass_one(B, D, Bound, Free1, Free).
pass_one(A => B, D or not C, Bound, Free0, Free) :- !,
	pass_one(A, C, Bound, Free0, Free1),
	pass_one(B, D, Bound, Free1, Free).
pass_one(A <=> B, (D or not C) and (C or not D), Bound, Free0, Free) :- !,
	pass_one(A, C, Bound, Free0, Free1),
	pass_one(B, D, Bound, Free1, Free).
pass_one(if(T,A,B), (C or not U) and (D or U), Bound, Free0, Free) :- !,
	pass_one(T, U, Bound, Free0, Free1),
	pass_one(A, C, Bound, Free1, Free2),
	pass_one(B, D, Bound, Free2, Free).
pass_one(not A, not C, Bound, Free0, Free) :- !,
	pass_one(A, C, Bound, Free0, Free).
pass_one(Atom, Atom, Bound, Free0, Free) :-
	%   An Atom is "anything else".  If Atoms were explicitly flagged,
	%   say by being written as +Atom, we wouldn'writeTranslation need those wretched
	%   cuts all over the place.  The same is true of pass_two.
	term_one(Atom, Bound, Free0, Free).


%   term_one/4 scans a term which occurs in a context where exists
%   variables are Bound by quantifiers and exists free variables (Free0)
%   have already been discovered.  Free is returned as the union of the
%   free variables in this term with Free0.  Note that though we call
%   does_not_literally_contain twice, it is doing two different things.
%   The first call determines that the variable is free.  The second
%   call is part of adding an element to a set, which could perhaps have
%   been a binary tree or exists other data structure.

term_one(Term, Bound, Free0, Free) :-
	nonvar(Term),
	functor(Term, _, Arity),
	!,
	term_one(Arity, Term, Bound, Free0, Free).
term_one(Var, Bound, Free0, [Var|Free0]) :-
	Bound does_not_literally_contain Var,
	Free0 does_not_literally_contain Var,
	!.
term_one(_, _, Free0, Free0).

term_one(0, _, _, Free0, Free0) :- !.
term_one(N, Term, Bound, Free0, Free) :-
	arg(N, Term, Arg),
	term_one(Arg, Bound, Free0, Free1),
	M is N-1, !,
	term_one(M, Term, Bound, Free1, Free).


/*----------------------------------------------------------------------

    pass_two does the following in one grand sweep:
    1.  The original formula might have used the same variable in any
	number of quantifiers.  In the output, each quantifier gets a
	different variable.
    2.  But existentally quantified variables are replaced by new Skolem
	functions, not by new variables.  As a result, we can simply drop
	all the quantifiers, every remaining variable is universally
	quantified.
    3.  The rules
	not  all(V, F)	--> exists(V, not F)
	not  exists(V, F)	--> all(V, not F)
	not  (A and B)	--> not A or not B
	not  (A or B)	--> not A and not B
	not  not  A		--> A
	are applied to move negations down in front of atoms.
    4.  The rules
	A or A		--> A
	A or not A		--> true
	A or true	--> true
	A or false	--> A
	(A or B) or C	--> A or (B or C)
	(A and B) or C	--> (A or C) and (B or C)
	A or (B and C)	--> (A or B) and (A or C)
	A and true	--> A
	A and false	--> false
	(A and B) and C	--> A and (B and C)
	are applied to the clauses which we build as we work our
	way back up the tree.  The rules
	A and A		--> A
	A and not A	--> false
	A and (not A or B)	--> A and B
	are NOT applied.  This is best done, if at all, after all the
	clauses have been generated.  The last two rules are special
	cases of resolution, so it is doubtful whether it is worth
	doing them at all.

    The main predicate is pass_two_pos/4:
	pass_two_pos(+Formula,		% The formula to translate
		     -Translation,	% its translation
		     +Univ,		% universal quantifiers in scope
		     +Rename)		% how to rename variables
    Rename is var | var(Old,New,Rename), where Old is a source variable,
    and New is either a new variable (for universal quantifiers) or a
    Skolem function applied to the preceding new variables (for '$existential'
    quantifiers).  Univ is those New elements of the Rename argument which
    are variables.  pass_two_neg produces the translation of its Formula's
    *negation*, this saves building the negation and then handling it.

----------------------------------------------------------------------*/

pass_two(ClosedAndImplicationFree, ClausalForm) :-
	pass_two_pos(ClosedAndImplicationFree, PreClausalForm, [], var),
	pass_two_pos(PreClausalForm, ClausalForm).


%   pass_two_pos/2 does two things.  First, if there was only one clause,
%   pass_two_pos/4 wouldn'writeTranslation have wrapped it up in a list.  This we do here.
%   Second, if one of the clauses is "false", we return that as the only
%   clause.  This would be the place to apply A & A --> A.

pass_two_pos(clause(P,N), [clause(P,N)]) :- !.
pass_two_pos(Sentence, [clause([],[])]) :-
	Sentence contains clause([],[]),
	!.
pass_two_pos(Sentence, Sentence).


pass_two_pos(all(Var,B), Translation, Univ, Rename) :- !,
	pass_two_pos(B, Translation, [New|Univ], var(Var,New,Rename)).
pass_two_pos(exists(Var,B), Translation, Univ, Rename) :- !,
	gensym('f-', SkolemFunction),
	SkolemTerm =.. [SkolemFunction|Univ],
	pass_two_pos(B, Translation, Univ, var(Var,SkolemTerm,Rename)).
pass_two_pos(A and B, Translation, Univ, Rename) :- !,
	pass_two_pos(A, C, Univ, Rename),
	pass_two_pos(B, D, Univ, Rename),
	sent_and(C, D, Translation).
pass_two_pos(A or B, Translation, Univ, Rename) :- !,
	pass_two_pos(A, C, Univ, Rename),
	pass_two_pos(B, D, Univ, Rename),
	sent_or(C, D, Translation).
pass_two_pos(not A, Translation, Univ, Rename) :- !,
	pass_two_neg(A, Translation, Univ, Rename).
pass_two_pos(true, [], _, _) :- !.
pass_two_pos(false, clause([],[]), _, _) :- !.
pass_two_pos(Atom, clause([Renamed],[]), _, Rename) :-
	%   An Atom is "anything else", hence the cuts above.
	term_two(Atom, Renamed, Rename).


pass_two_neg(all(Var,B), Translation, Univ, Rename) :- !,
	gensym('g-', SkolemFunction),
	SkolemTerm =.. [SkolemFunction|Univ],
	pass_two_neg(B, Translation, Univ, var(Var,SkolemTerm,Rename)).
pass_two_neg(exists(Var,B), Translation, Univ, Rename) :- !,
	pass_two_neg(B, Translation, [New|Univ], var(Var,New,Rename)).
pass_two_neg(A and B, Translation, Univ, Rename) :- !,
	pass_two_neg(A, C, Univ, Rename),
	pass_two_neg(B, D, Univ, Rename),
	sent_or(C, D, Translation).
pass_two_neg(A or B, Translation, Univ, Rename) :- !,
	pass_two_neg(A, C, Univ, Rename),
	pass_two_neg(B, D, Univ, Rename),
	sent_and(C, D, Translation).
pass_two_neg(not A, Translation, Univ, Rename) :- !,
	pass_two_pos(A, Translation, Univ, Rename).
pass_two_neg(true, clause([],[]), _, _) :- !.
pass_two_neg(false, [], _, _) :- !.
pass_two_neg(Atom, clause([],[Renamed]), _, Rename) :-
	%   An Atom is "anything else", hence the cuts above.
	term_two(Atom, Renamed, Rename).



term_two(OldTerm, NewTerm, Rename) :-
	nonvar(OldTerm),
	functor(OldTerm, FunctionSymbol, Arity),
	functor(NewTerm, FunctionSymbol, Arity),
	!,
	term_two(Arity, OldTerm, NewTerm, Rename).
term_two(OldVar, NewTerm, Rename) :-
	term_var(Rename, OldVar, NewTerm).


term_var(var(Old,New,_), Var, New) :-
	Old == Var,
	!.
term_var(var(_,_,Rest), Var, New) :-
	term_var(Rest, Var, New).


term_two(0, _, _, _) :- !.
term_two(N, OldTerm, NewTerm, Rename) :-
	arg(N, OldTerm, OldArg),
	term_two(OldArg, NewArg, Rename),
	arg(N, NewTerm, NewArg),
	M is N-1, !,
	term_two(M, OldTerm, NewTerm, Rename).


/*----------------------------------------------------------------------

	sent_and(S1, S2, "S1 and S2")
	sent_or(S1, S2, "S1 or S2")
    perform the indicated logical operations on clauses or sets of
    clauses (sentences), using a fair bit of propositional reasoning
    (hence our use of "literally" to avoid binding variables) to try
    to keep the results simple.  There are several rules concerning
    conjunction which are *not* applied, but even checking for
	A and A --> A
    would require us to recognise alphabetic variants of A rather
    than literal identity.  So far the naivety abount conjunction
    has not proved to be a practical problem.

----------------------------------------------------------------------*/

sent_or(clause(P1,_), clause(_,N2), []) :-
	P1 contains Atom,
	N2 literally_contains Atom,
	!.
sent_or(clause(_,N1), clause(P2,_), []) :-
	N1 contains Atom,
	P2 literally_contains Atom,
	!.
sent_or(clause(P1,N1), clause(P2,N2), clause(P3,N3)) :- !,
	ord_union(P1, P2, P3),
	ord_union(N1, N2, N3).
sent_or([], _, []) :- !.
sent_or(_, [], []) :- !.
sent_or([Clause|Clauses], Sentence, Answer) :- !,
	sent_or(Sentence, Clause, X),
	sent_or(Clauses, Sentence, Y),
	sent_and(X, Y, Answer).
sent_or(Sentence, [Clause|Clauses], Answer) :- !,
	sent_or(Sentence, Clause, X),
	sent_or(Clauses, Sentence, Y),
	sent_and(X, Y, Answer).


sent_and([], Sentence, Sentence) :- !.
sent_and(Sentence, [], Sentence) :- !.
sent_and([H1|T1], [H2|T2], [H1,H2|T3]) :- !,
	sent_and(T1, T2, T3).
sent_and([H1|T1], Clause, [Clause,H1|T1]) :- !.
sent_and(Clause, [H2|T2], [Clause,H2|T2]) :- !.
sent_and(Clause1, Clause2, [Clause1,Clause2]).


[Head|_] contains Head.
[_|Tail] contains Something :-
	Tail contains Something.


[Head|_] literally_contains Something :-
	Head == Something,
	!.
[_|Tail] literally_contains Something :-
	Tail literally_contains Something.


[] does_not_literally_contain Anything.
[Head|Tail] does_not_literally_contain Something :-
	Head \== Something,
	Tail does_not_literally_contain Something.


% ============================================
% Theorem Checker
% ============================================

% Free Formulas are never 
isTheorem(T,V):-(isTheoremTrue(T,V)).
isTheoremTrue(V,FreeV):-isSlot(V),!,fail.
isTheoremTrue(V,FreeV):-isReducedToTrue(V),!.

% Kalish and Monash (Declared Theorem 17)
isTheoremTrue(=>(PP,=>(not(P),Q)),FreeV):- ==(P,PP),!.

% Kalish and Monash (Declared Theorem 17)
isTheoremTrue(=>(PP,=>(not(P),Q)),FreeV):-deduceLogicallyEquiv(P,PP),!.

% 'Kalish & Montague, Theorem 23'
isTheoremTrue(=>(=>(=>(D,_),D1),D2) ,FreeV):-deduceLogicallyEquiv(D,D1),deduceLogicallyEquiv(D1,D2),!.

% 'Kalish & Montague, Theorem 18'
isTheoremTrue(=>(not(D),=>(D1,D2)),FreeV):-deduceLogicallyEquiv(D,D1),deduceLogicallyEquiv(D1,D2),!.


 
% 'Kalish & Montague, Theorem 2'
isTheoremTrue(=>(D,=>(F,D1)),FreeV):-deduceLogicallyEquiv(D,D1),!.


% 'Kalish & Montague, Theorem 21'
isTheoremTrue(=>(not(=>(D,F)),D1),FreeV):-deduceLogicallyEquiv(D,D1),!.

% 'Kalish & Montague, Theorem 22' (=> (not (=> (isa ?X Dog) (isa ?X Fish))) (not (isa ?X Fish))) ) 
isTheoremTrue(=>(not(=>(D,F)),not(F1)),FreeV):-deduceLogicallyEquiv(F,F1),!.

% 'Kalish & Montague, Theorem 241' 
% (forall ?X (=> (F ?X) (or(G ?X) (H ?X)) ) )  => isTheoremTrue(or(forall(X,=>(F,G)),exists(Y,and(F1,H))),FreeV):-deduceLogicallyEquiv(F,F1),deduceLogicallyEquiv(X,Y),!.        

% All X F exisits X F'Kalish & Montague, Theorem 22' (=> (not (=> (isa ?X Dog) (isa ?X Fish))) (not (isa ?X Fish))) ) 
isTheoremTrue(=>(F,exists(X,F1)),FreeV):-deduceLogicallyEquiv(F,F1),!.

% All X F exisits X F'Kalish & Montague, Theorem 22' (=> (not (=> (isa ?X Dog) (isa ?X Fish))) (not (isa ?X Fish))) ) 
isTheoremTrue(=>(forall(Y,F),exists(X,F1)),FreeV):-deduceLogicallyEquiv(F,F1),deduceLogicallyEquiv(X,Y),!.



%(forall ?X (exists ?Y (<=> (F3 ?X) (not (F3 ?Y))))) 


% Le Logica De Morgan 
isTheoremTrue(<=>(not(and(P1,PP1)),or(not(P2),not(PP2))),FreeV):-
         deduceLogicallyEquiv(P1,P2),
         deduceLogicallyEquiv(PP1,PP2),!.

% Le Logica De Morgan Reversed
isTheoremTrue(<=>(or(not(P2),not(PP2)),not(and(P1,PP1))),FreeV):-
         deduceLogicallyEquiv(P1,P2),
         deduceLogicallyEquiv(PP1,PP2),!.

% Kalish and Monash (Declared Theorem)
isTheoremTrue(P,FreeV):-
         km_check(P,FreeV),!.

% Tautology #1
isTheoremTrue(=>(P1,P2),FreeV):-
         deduceLogicallyEquiv(P1,P2),!.

isTheoremTrue(=>(P1,not(P2)),FreeV):-
         deduceLogicallyEquiv(P1,P2),!.

% Tautology #2
isTheoremTrue(<=>(A,B),FreeV):-
         deduceLogicallyEquiv(A,B),!.

% Reduces to True
isTheoremTrue(P,FreeV):-
         deduceLogicallyEquiv(P,true),!.

% Kalish and Monash (Declared Theorem)
isTheoremTrue(P,FreeV):-
         getLogicalReduction(P,Q),
         km_check(Q,FreeV),!.


% Antecedent is a Theorem
isTheoremTrue(=>(P1,_),FreeV):-
         isTheoremTrue(P1,FreeV),!.

isTheoremTrue(forall(_,P),FreeV):-!,
         isTheoremTrue(P,FreeV),!.

isTheoremTrue(exists(_,P),FreeV):- !,
         isTheoremTrue(P,FreeV),!.
isTheoremTrue(request(P),FreeV):- !,
         isTheoremTrue(P,FreeV),!.
isTheoremTrue(requestyn(P),FreeV):- !,
         isTheoremTrue(P,FreeV),!.

 

% ============================================
% Specific Checks for theorms from Ned to Add Kalish and Monash
% ============================================

km_check(V,FreeV):-isSlot(V),!,fail.

% P => (~P => Q)  % KM 17
km_check(=>(PP,=>(not(P),Q)),FreeV):-!,deduceLogicallyEquiv(P,PP).

% ~P v P
km_check(or(not(P),PP),FreeV):-!,deduceLogicallyEquiv(P,PP).

% P v ~P
km_check(or(PP,not(P)),FreeV):-!,deduceLogicallyEquiv(P,PP).

% ~P => P
km_check(=>(not(P),PP),FreeV):-deduceLogicallyEquiv(P,PP),!.

% P => ~P
km_check(=>(PP,not(P)),FreeV):-!,deduceLogicallyEquiv(P,PP).




% P v true
km_check(or(_,true),FreeV):-!.

% true v P
km_check(or(true,_),FreeV):-!.

% 'Kalish & Montague, Theorem 17'
km_check(=>(P,=>(not(PP),_)),FreeV):-true,deduceLogicallyEquiv(P,PP),!.

% ==========================================
% Not possible
% ==========================================
deduceGoal_sentence_op(possible,false,Depth,Table,possible(NewRequest),Agent,Context,Explaination):-!,
        once(request_compile(not(NewRequest),NewRequest,Context,UVars,Given)),!,
	functor(NewRequest,Predicate,_),
	deduceGoal(Predicate,true,Depth,Table,(NewRequest),Agent,Context,Explaination).

% ==========================================
% Is possible
% ==========================================
deduceGoal_sentence_op(possible,true,Depth,Table,possible(NewRequest),Agent,Context,Explaination):-!,
        once(request_compile(not(NewRequest),NewRequest,Context,UVars,Given)),!,
	functor(NewRequest,Predicate,_),
	(deduceGoal(Predicate,false,Depth,Table,(NewRequest),Agent,Context,Explaination),!,fail);Explaination=possible(NewRequest).

% ============================================================
% Forall True
% ============================================================
deduceGoal_sentence_op(forall,true,Depth,Table, forall(Var,UFormulaIN),Agent,Context,incode(not(exists(Var,not(UFormulaIN))),'AxFx -> ~Ex~Fx') * Explaination) :-! ,%true,
	deduceGoal(exists,false,Depth,Table, exists(Var,not(UFormulaIN)),Agent,Context,Explaination).

% ============================================================
% Forall False
% ============================================================
deduceGoal_sentence_op(forall,false,Depth,Table, forall(Var,UFormulaIN),Agent,Context,incode(exists(Var,not(UFormulaIN)),'~AxFx -> Ex~Fx') * Explaination) :-! ,%true,
	deduceGoal(exists,true,Depth,Table, exists(Var,not(UFormulaIN)),Agent,Context,Explaination).

% ============================================================
% Does Exists
% ============================================================
deduceGoal_sentence_op(exists,true,Depth,Table,exists(Var,UFormulaIN),Agent,Context,Explaination) :-!,
	writeDebug(subgoal(UFormulaIN,Agent,Context)),!,
        once(request_compile((UFormulaIN),NewRequest,Context,UVars,Given)),!,
	writeDebug(subgoal(NewRequest,Agent,Context)), 
	functor(NewRequest,Predicate,_),
        deduceGoal(Predicate,true,Depth,Table,NewRequest,Agent,Context,Explaination),nonvar(Var).

% ============================================================
% Not Exists
% ============================================================
deduceGoal_sentence_op(exists,false,Depth,Table,exists(Var,UFormulaIN),Agent,Context,Explaination) :-!,
	writeDebug(subgoal(not(UFormulaIN),Agent,Context)),!,
        once(request_compile(not(UFormulaIN),NewRequest,Context,UVars,Given)),!,
	writeDebug(subgoal(NewRequest,Agent,Context)), 
	functor(NewRequest,Predicate,_),
        deduceGoal(Predicate,true,Depth,Table,NewRequest,Agent,Context,Explaination).

% ============================================================
% Does Imply
% ============================================================
deduceGoal_sentence_op('=>',true,Depth,Table,'=>'(Ante,Cons),Agent,Context,  Explaination) :-!,
	prove_implication('=>',true,Depth,Table,'=>'(Ante,Cons),Agent,Context, Explaination).
	

prove_implication('=>',true,Depth,Table,'=>'(Ante,Cons),Agent,Context, incode(asserted(Agent,Ante),'Does Imply') * incode(Cons,'Therefore Proves ')) :-!,
	idGen(ToRetract),!,
	copy_term(Ante,Copy),
	logOnFailure(invokeInsert([trusted,canonicalize],fsck,Copy,Agent,ToRetract,Context,Vars,'HypotheticalRequest')),
	functor(Cons,Predicate,_),!,
	deduceGoal(Predicate,true,Depth,Table,Cons,Agent,Context,Explaination),
	destroyTN(Context,ToRetract,Agent).
	
/*
prove_implication('=>',true,Depth,Table,'=>'(Ante,Cons),Agent,Context, incode(NewRequest,'Does Imply') * Explaination) :-!,
	%numbervars(Ante,'hyp',0,_),!,
	getAssertionClauses_inf('=>'(Ante,Cons),NewRequest,KRVars,Flags),
	functor(NewRequest,Predicate,_),
	deduceGoal(Predicate,true,Depth,Table,NewRequest,Agent,Context,Explaination).
*/

% ============================================================
% Does not Imply
% ============================================================
deduceGoal_sentence_op('=>',false,Depth,Table,'=>'(Ante,Cons),Agent,Context, incode(NewRequest,'Does Not Imply') * Explaination) :-!,
	%numbervars(Ante,'hyp',0,_),!,
	getAssertionClauses_inf(not('=>'(Ante,Cons)),NewRequest,KRVars,Flags),
	functor(NewRequest,Predicate,_),
	deduceGoal(Predicate,true,Depth,Table,NewRequest,Agent,Context,Explaination).


getAssertionClauses_inf((not((equal(_,_)'=>'_))),Out,Vars,Flags):- !,fail.
getAssertionClauses_inf(not((_ '=>' not(equal(_,_)))),Out,Vars,Flags):- !,fail.
getAssertionClauses_inf(In,Out,Vars,Flags):- %true,
	getAssertionClauses(Context,In,Mid,Vars,Flags),
	compile_conditionals(Mid,Out),!.
	
% ============================================================
% Is equivalant
% ============================================================
deduceGoal_sentence_op('<=>',true,Depth,Table,'<=>'(Ante,Cons),Agent,Context,incode(NewRequest,'Is Equivalent') * Explaination) :-!,
	%numbervars(Ante,'hyp',0,_),!,
	getAssertionClauses_inf('<=>'(Ante,Cons),NewRequest,KRVars,Flags),
	functor(NewRequest,Predicate,_),
	deduceGoal(Predicate,true,Depth,Table,NewRequest,Agent,Context, Explaination).

% ============================================================
% Is not equivalant
% ============================================================
deduceGoal_sentence_op('<=>',false,Depth,Table,'<=>'(Ante,Cons),Agent,Context,incode(NewRequest,'Is Not Equivalent') * Explaination) :-!,
	%numbervars(Ante,'hyp',0,_),!,
	getAssertionClauses_inf(not('<=>'(Ante,Cons)),NewRequest,KRVars,Flags),
	functor(NewRequest,Predicate,_),
	deduceGoal(Predicate,true,Depth,Table,NewRequest,Agent,Context, Explaination).

% ==========================================================
% True/False Disjunct
% ==========================================================
deduceGoal_sentence_op(or,Logic,Depth,Table,or(A,B),Agent,Context,Explaination):- !,
	writeDebug(disjuncts),
	(
	functor(A,Predicate,_),
	deduceGoal(Predicate,Logic,Depth,Table,A,Agent,Context,Explaination)
	)
	;
	(
	functor(A,Predicate,_),
	deduceGoal(Predicate,Logic,Depth,Table,B,Agent,Context,Explaination)
	).
		
% ==========================================================
% True/False Conjunct
% ==========================================================
deduceGoal_sentence_op(_,Logic,Depth,Table,and(A,B),Agent,Context,ExplainationA * ExplainationB ):-!,
	deduceGoal(holds,Logic,Depth,Table,A,Agent1,Context,ExplainationA ),
	deduceGoal(holds,Logic,Depth,Table,B,Agent2,Context,ExplainationB ).

% ==========================================
% Equal/Evaluate
% ==========================================

% Shunt a wild equals
deduceGoal_sentence_op(equal,true,Depth,Table,equal(V2, V1),Agent,Context,P):-%true,
	var(V1),var(V2),!,V1=V2,!.
	
deduceGoal_sentence_op(equal,true,Depth,Table,equal(U,W),Agent,Context,P):-!,equal(U,W,P),!.  %defined in moo_equal.P
deduceGoal_sentence_op(equal,false,Depth,Table,equal(U,W),Agent,Context,P):-!,not_equal(U,W,P),!. %defined in moo_equal.P


%% :-include('moo_header.pl').

% =========================================================
% Logicaly Equivalent
% =========================================================

deduceLogicallyEquiv(P,PP):-P==PP,!.
deduceLogicallyEquiv(P,PP):-
         getLogicalReduction(P,PR),
         getLogicalReduction(PP,PPR),!,
         PR==PPR.

% =========================================================
% Logicaly Reduce
% =========================================================

%Vars are not Reduced
getLogicalReduction(A,A):-isSlot(A),!.

% Not Not A
getLogicalReduction(not(not(A)),R):-!,getLogicalReduction(A,R).

% True => True
%getLogicalReduction(T,true):-isReducedToTrue(T),!.

% False => False
%getLogicalReduction(T,false):-isReducedToFalse(T),!.

% ~True => False
getLogicalReduction(not(T),false):-isReducedToTrue(T),!.

% ~False => True
getLogicalReduction(not(F),true):-isReducedToTrue(T),!.

% Reserved Fmls
getLogicalReduction(FML,FML):-member(FML,['AssignmentFn'(_,_),'zzskFn'(_,_),'zzskFn'(_),'equal'(_,_),'u'(_,_,_)]),!.


% Quantifiers using True  => True
getLogicalReduction(forall(V,T),true):-isReducedToTrue(T),!.
getLogicalReduction(some(V,T),true):-isReducedToTrue(T),!.
getLogicalReduction(exists(V,T),true):-isReducedToTrue(T),!.

% True -> Fml  => True
getLogicalReduction(=>(T,A),R):-isReducedToTrue(T),!,getLogicalReduction(A,R).

% Quantifiers Fml  => Fml
getLogicalReduction(forall(V,A),forall(V,R)):-!,getLogicalReduction(A,R).
getLogicalReduction(exists(V,A),exists(V,R)):-!,getLogicalReduction(A,R).
getLogicalReduction(some(V,A),some(V,R)):-!,getLogicalReduction(A,R).

% True ^ True => True
getLogicalReduction(and(T1,T2),true):-isReducedToTrue(T1),isReducedToTrue(T2),!.

% True ^ Fml => Fml
getLogicalReduction(and(T,Fml),Fml):-isReducedToTrue(T),!.

% Fml ^ True => Fml
getLogicalReduction(and(Fml,T),Fml):-isReducedToTrue(T),!.

% Fml v True => True
getLogicalReduction(or(Fml,T),true):-isReducedToTrue(T),!.

% True v Fml => True
getLogicalReduction(or(Fml,T),true):-isReducedToTrue(T),!.

/*
% Fml <=> True => True
getLogicalReduction(<=>(Fml,T),true):-isReducedToTrue(T),!.

% True <=> Fml => True
getLogicalReduction(<=>(Fml,T),true):-isReducedToTrue(T),!.
*/

% Fml v Fml => Fml
getLogicalReduction(or(Fml1,Fml2),Fml1):-Fml1==Fml2,!.

% Fml ^ ~Fml => False
getLogicalReduction(and(Fml1,not(Fml2)),Fml1):-Fml1==Fml2,!.

% ~Fml ^ Fml => False
getLogicalReduction(and(not(Fml1),Fml2),Fml1):-Fml1==Fml2,!.

% False ^ False => False
getLogicalReduction(and(F1,F2),false):-isReducedToFalse(F1),isReducedToFalse(F2),!,!.

% False ^ Fml => False
getLogicalReduction(and(F,Fml),false):-isReducedToFalse(F),!.

% Fml ^ False => False
getLogicalReduction(and(Fml,F),false):-isReducedToFalse(F),!.

% Fml v False => Fml
getLogicalReduction(or(Fml,F),Fml):-isReducedToFalse(F),!.

% False v Fml => Fml
getLogicalReduction(or(Fml,F),Fml):-isReducedToFalse(F),!.


% Higher Level
getLogicalReduction(known(T)):-isReducedToTrue(T).
getLogicalReduction(consistent(T)):-isReducedToTrue(T).
getLogicalReduction(after(T)):-isReducedToTrue(T).
getLogicalReduction(before(T)):-isReducedToTrue(T).

% Do not reduce Lists
getLogicalReduction(LIST,LIST) :-is_list(LIST),!. %,getLogicalReduction_l(LIST,LISTO).

% Nothing to Do
getLogicalReduction(A,B):-!,unify_with_occurs_check(A,B).


isReducedToTrue(V):-isSlot(V),!,fail.
isReducedToTrue(true).
isReducedToTrue(T):-getLogicalReduction(T,true).

isReducedToFalse(V):-isSlot(V),!,fail.
isReducedToFalse(false).
isReducedToFalse(F):-getLogicalReduction(F,false).



getLogicalReduction_l(V,V):-var(V),!.
getLogicalReduction_l([],[]).
getLogicalReduction_l([H|T],[HO|TO]):-!,
         getLogicalReduction(H,HO),
         getLogicalReduction_l(T,TO).


-include('moo_header.pl').


/* 
Purpose of this file:

Before a Context is canonicalized we must be able to make simple belief on

(instance AnyTerm ?What)
(domain AnyTerm ?N ?What)
(range AnyTerm ?What)
(subclass AnyTerm ?What)
(valence AnyTerm ?What)

(instance ?What Class)
(instance ?What Relation)
(instance ?What Function)
(instance ?What Predicate)
(instance ?What Attribute)

And get back the 'Simplest' answer first


Also we should be able to in some situations:

(domainSubclass AnyTerm ?N ?What)
(rangeSubclass AnyTerm ?What)

*/

% :-include('moo_header.pl').
% ================================================
% Superfulous Entry
% ================================================




deduceSurfaceGuarded(Fact,Context,Explaination):-	  
	ground(Fact),!,
	deduceSurface_full(Fact,Context,Explaination).
	
deduceSurfaceGuarded(Fact,Context,Explaination):-	  
	not(ground(Fact)),!,
	deduceSurface(Fact,Context,Explaination).
	
getFactForTransitiveClosure(Context,Call,Explaination):-
	deduceSurface_easy(Call,Context,Explaination).

%:-index(deduceSurface_gaf(Fact,Context,Explaination)).
	
% ========================================================
% deduceSurface => deduceSurface_full
% ========================================================

% Non defined presently	except this redirection
deduceSurface_full(Fact,Context,Explaination):-
	deduceSurface(Fact,Context,Explaination).

/*
deduceSurface_full(instance,false,Context,holds(instance,E,C),P1 * P2 * crossref(instance,disjoint)):-
	     deduceSurface(instance(E,M),Context,P1),
	     deduceSurface_full(disjoint(M,C),Context,P2).

deduceSurface_full_reflexive(disjoint(M,C),Context,P2):-
		deduceSurface_full(disjoint(C,M),Context,P2).

deduceSurface_full_reflexive(disjoint(M,C),Context,P2):-
		deduceSurface_full(disjoint(M,C),Context,P2).

deduceSurface_full(PredR,false,Context,holds(instance,E,C),P1 * P2):-
	     deduceSurface(instance(E,M),P1),
	     deduceSurface_full(subclass,false,Context,holds(subclass,M,C),P2),M\=C.
*/	     

% ========================================================
% Easy Forwardchains
% ========================================================

deduceSurface_easy(Fact,Context,Explaination):-
	deduceSurface_gaf(Fact,Context,Explaination).
	


/*
deduceSurface_easy(instance(X,Class),Context,Explainations):-
	atom(Class),deduceSurface_dc_instance1(X,Class,Context,Explainations).
*/
deduceSurface_gaf_sym(Fact,Context,P1):-deduceSurface_gaf(Fact,Context,I).
deduceSurface_gaf_sym(Fact,Context,P1):-compound(Fact),
	Fact=..[F,A,B],
	Term=..[F,B,A],
	deduceSurface_gaf(Term,Context,I).

deduceSurface_gaf(Fact,Context,surf(Context,_Ctx,TN,0)):-
	mooCache(Fact,_,Flags,[],Context,_Ctx,TN,Maintainer,TMResult).
	

% ========================================================
% subclass/partition True
% ========================================================

deduceSurface_easy(subclass(A,B),Context,Explaination * incode(holds(subclass,A,B),crossref(Composition,subclass))):-
	member(Composition,[disjointDecomposition,exhaustiveDecomposition,partition]),
	deduceSurface_gaf(G,Context,Explaination),
	G=..[Composition,B|Children],
%	not(B='Entity'),
	member(A,Children),
%	not(A='Entity'),
	A\=B.
% ====================================================
% make_disjoint_classes(Context,Ctx)
% ===================================================

deduceSurface_easy(disjoint(A,B),Context,  Explaination * incode(holds(disjoint,A,B),Composition) ):-%true,
	member(Composition,[disjointDecomposition,exhaustiveDecomposition,partition]),
	deduceSurface_gaf(G,Context,Explaination),
	G=..[Composition,C|Children],
	%`not(C='Entity'),
	member(A,Children),
	member(B,Children),
	A\=B.


% ================================================
% Normal Forwardchains
% ================================================

deduceSurface(valence(Predicate,N),Context,Explaination):-!,
	deduceValence(Context,Predicate,N,Explaination),!.

deduceSurface(Fact,Context,Explaination):-
	deduceSurface_easy(Fact,Context,Explaination).

deduceSurface(instance(X,Class),Context,incode(instance(X,Class),'Found in Class Constants')):-
	Class='Class',!,
	getClassesListFromContext(Rs,Context,Ctx),
	member(X,Rs).		

deduceSurface(instance(X,Class),Context,incode(instance(X,Class),'Found in Predicate Constants')):-
	Class='Predicate',!,
	getPredicatesListFromContext(Rs,Context,Ctx),
	member(X,Rs).	
	
deduceSurface(instance(X,Class),Context,incode(instance(X,Class),'Found in Attribute Constants')):-
	Class='Attribute',!,
	getAttributeNamelistFromContext(Rs,Context,Ctx),
	member(X,Rs).	

deduceSurface(instance(X,Class),Context,incode(instance(X,Class),'Found in Relation Constants')):-
	Class='Relation',!,
	getRelationsListFromContext(Rs,Context,Ctx),
	member(X,Rs).		

deduceSurface(instance(X,Class),Context,incode(instance(X,Class),'Found in Function Constants')):-
	Class='Function',!,
	getFunctionListFromContext(Rs,Context,Ctx),
	member(X,Rs).		

deduceSurface(instance(E,C),Context,P1 * P2 *  Explaination):-
	deduceSurface_easy(instance(E,M),Context,P1),
	not((M=='Entity')),
	deduceSurface_full(subclass(M,C),Context,P2),
	(M\==C),
	Explaination=sfindi((holds(subclass,M, C)=>forall(E,( holds(instance,E, M)=>holds(instance,E, C))))).
	     	
% ========================================================
% subrelations
% ========================================================

deduceSurface(subrelation(S,C),Context,Explaination):-!,
	deduceTransitiveClosure_PartialOrderingRelation(Context,subrelation,S,C,Explaination),not((S=C)).
						 
% ========================================================
% instance true
% ========================================================

deduceSurface(subclass(S,C),Context,Explaination):-!,
	deduceTransitiveClosure_PartialOrderingRelation(Context,subclass,S,C,Explaination),not((S=C)).

deduceSurface(instance(R,C),Context, (P1*P2*P3)):-
	deduceSurface_easy(subrelation(R,P),Context,P1),R\=P,
	deduceSurface_easy(instance(C,'InheritableRelation'),Context, P2), 
	deduceSurface(instance(P,C),Context, P3).


:-retractall(mooCache(Context,_Ctx,completed_table(_))).


deduceSurface(disjoint(A,B), P1 * P2 * P3 ):-
	(nonvar(A);nonvar(B)),
	deduceSurface(holds(disjoint,SuperOfB,SuperOfA),P1),
	deduceTransitiveClosure_PartialOrderingRelation(Context,subclass,A,SuperOfA,P2),
	deduceTransitiveClosure_PartialOrderingRelation(Context,subclass,B,SuperOfB,P3),
	((A\=SuperOfA);(B\=SuperOfB)).
	%TODO((A=AA,B=BB);(B=AA,A=BB)).


deduceSurface(domain(disjointDecomposition,N,'Class'),Context, incode(domain(disjointDecomposition,N,'Class'))):-integer(N),!.
deduceSurface(domain(exhaustiveDecomposition,N,'Class'),Context, incode(domain(exhaustiveDecomposition,N,'Class'))):-integer(N),!.
deduceSurface(domain('AssignmentFn',1,'Function'),Context, incode(domain('AssignmentFn',1,'Function'))):-!.
deduceSurface(domain('AssignmentFn',N,'Entity'),Context, incode(domain(AssignmentFn,N,'Entity'))):-integer(N),N>1,!.
deduceSurface(domain('holds',1,'Relation'),Context, incode(domain('holds',N,'Relation'))):-!.
deduceSurface(domain('holds',N,'Entity'),Context, incode(domain('holds',N,'Entity'))):-integer(N),N>1,!.


deduceSurface(domain(R,N,S),Context,(P1 * P2 * Explaination)):-
	deduceSurface_full(subrelation(R,P),Context,P1),
	R\=P,
	deduceSurface_full(domain(P,N,S),Context, P2),
	Explaination=(holds(subrelation,R, P)and domain(P, N, S)and domain(R, N, S)=>holds(subclass,S, S)).

deduceSurface(domain(R,N,S),Context, P1 * Explaination):-
	nonvar(N),
	deduceSurface(valence(R,N),Context,P1),
	deduceSurface(range(R,S),Context, Explaination),!.

deduceSurface(domain(R,N,S),Context,P1 * Explaination):-
	nonvar(N),
	deduceSurface_full(subrelation(R,PredR),Context,P1),R\=P,
	deduceSurface(valence(P,N),Context,_),
	deduceSurface(range(P,S),Context, Explaination),!.
	

deduceSurface(domainSubclass(R,N,S),Context,(P1 * P2 * Explaination)):-
	deduceSurface_full(subrelation(R,P),Context,P1),
	R\=P,
	deduceSurface_full(domainSubclass(P,N,S),Context, P2),
	Explaination=(holds(subrelation,R, P)and domainSubclass(P, N, S)and domainSubclass(R, N, S)=>holds(subclass,S, S)).

deduceSurface(domainSubclass(R,N,S),Context, P1 * Explaination):-
	nonvar(N),
	deduceSurface(valence(R,N),Context,P1),
	deduceSurface(rangeSubclass(R,S),Context, Explaination),!.

deduceSurface(domainSubclass(R,N,S),Context,P1 * Explaination):-
	nonvar(N),
	deduceSurface_full(subrelation(R,PredR),Context,P1),R\=P,
	deduceSurface(valence(P,N),Context,_),
	deduceSurface(rangeSubclass(P,S),Context, Explaination),!.

deduceSurface(domain(R,N,'Class'),Context, Explaination):-
	nonvar(N),nonvar(R),
	deduceSurface(domainSubclass(R,N,S),Context, Explaination),!.

deduceSurface(range(R,'Class'),Context, Explaination):-
	nonvar(N),nonvar(R),
	deduceSurface(rangeSubclass(R,N,S),Context, Explaination),!.


% ==========================================================
% Instance Deduction (Specialization) via Domains
% ==========================================================
%domain(A, 2, B)=>forall(C, forall(D, holds(A, D, C)=>holds(instance,C, B)))

expireOptimizationsInContext(Context,Assertion):-
	%writeDebug(yellow,'erasing instancell'),
	retractall((mooCache(Context,_Ctx,deduceInstanceTable(Class,Set)))).

	
instance_all(Context,Predicate,Args):-
	deduceSurfaceDomainVector(N,Predicate,VectS,Context,Explainations),
	deducePossibleInstancesFromClasslist(Context,VectS,Args).

deducePossibleInstancesFromClasslist(Context,[],[]).
deducePossibleInstancesFromClasslist(Context,[Class|Classes],[Arg|ArgS]):-
	deduceInstanceTable(Context,Arg,Class,_),
	deducePossibleInstancesFromClasslist(Context,Classes,ArgS).
	


deduceInstanceTable(Context,Arg,'Entity',_):-
	writeDebug(red,deduceInstanceTable(Context,Arg,'Entity')),!,fail.

deduceInstanceTable(Context,Arg,'Class',incode(instance(Arg,'Class'),'Found in Class Constants')):-
	getClassesListFromContext(Rs,Context,Ctx),!,
	member(Arg,Rs).

deduceInstanceTable(Context,Arg,'Relation',incode(instance(Arg,'Relation'),'Found in Relation Constants')):-
	getRelationsListFromContext(Rs,Context,Ctx),!,
	member(Arg,Rs).

deduceInstanceTable(Context,Arg,'Predicate',incode(instance(Arg,'Predicate'),'Found in Predicate Constants')):-
	getPredicatesListFromContext(Rs,Context,Ctx),!,
	member(Arg,Rs).

deduceInstanceTable(Context,Arg,'Function',incode(instance(Arg,'Function'),'Found in Function Constants')):-
	getFunctionListFromContext(Rs,Context,Ctx),!,
	member(Arg,Rs).
	
deduceInstanceTable(Context,Arg,'Attribute',incode(instance(Arg,'Attribute'),'Found in Attribute Constants')):-
	getAttributeNamelistFromContext(Rs,Context,Ctx),!,
	member(Arg,Rs).
	

deduceInstanceTable(Context,Arg,Class,incode(instance(Arg,Class),'Found in Defined Constants')):-
	mooCache(Context,_Ctx,deduceInstanceTable(Class,Set)),
	%writeDebug(silver,extent(holds(instance,Class,Set))),
	!,
	member(Arg,Set).
	
deduceInstanceTable(Context,Arg,Class,incode(instance(Arg,Class),'Found in Defined Cached Constants')):-
	atom(Class),
	findall(A,
			deduceSurface(instance(Arg,Class),Context,Explaination),
		List),sort(List,Set),!,
	asserta(mooCache(Context,_Ctx,deduceInstanceTable(Class,Set))),
	writeDebug(green,made_extent(Context,deduceInstanceTable(Class,Set))),!,
	member(Arg,Set).
     


expireOptimizationsInContext(Context,Assertion):-
		writeDebug(yellow,'erasing deduceInstanceTable'),
		retractall((mooCache(Context,_Ctx,deduceInstanceTable(Class,Set)))).
	


getRelationsListFromContext:-retractall(mooCache(Context,_Ctx,relation_list(Rs))),!,getRelationsListFromContext(Rs,Context,Ctx),write(Rs).


getRelationsListFromContext(Rs,Context,Ctx):-
	mooCache(Context,_Ctx,relation_list(Rs)),!.
getRelationsListFromContext(Rs,Context,Ctx):-
	findall(X,
		(
			(
				(
					(
						deduceTransitiveClosure_PartialOrderingRelation(Context,subclass,M,'Relation',SCExplaination),
						deduceSurface_gaf(instance(X,M),Context,Explaination)
					);
					(
					deduceSurface_gaf(GAF,Context,_Explaination),
					((
					  GAF=subrelation(X,_);GAF=subrelation(_,X);
					  GAF=inverse(X,_);GAF=inverse(_,X);
					  GAF=range(X,_);GAF=domain(X,1,_);GAF=domainSubclass(X,_,_);GAF=rangeSubclass(X,_,_)
					  
					  ))
				)
			),
			atom(X)
		)),Relations),
	sort(Relations,Rs),
	asserta(mooCache(Context,_Ctx,relation_list(Rs))),!.

getAttributeNamelistFromContext(Rs,Context,Ctx):-
	mooCache(Context,_Ctx,attribute_list(Rs)),!.
getAttributeNamelistFromContext(Rs,Context,Ctx):-
	findall(X,
		(
			(
				(
					(
						deduceTransitiveClosure_PartialOrderingRelation(Context,subclass,M,'Attribute',SCExplaination),
						deduceSurface_gaf(instance(X,M),Context,Explaination)
					);
					(
					deduceSurface_gaf(GAF,Context,_Explaination),
					((GAF=subAttribute(X,_);
						GAF=subAttribute(_,X);
							GAF=successorAttribute(X,_);
								GAF=successorAttribute(_,X);
									GAF=contraryProperty(X,_);
									GAF=contraryProperty(_,X);
									GAF=attribute(X,_)))
				)                                   
			),
			atom(X)
		)),Attributes),
	sort(Attributes,Rs),
	asserta(mooCache(Context,_Ctx,attribute_list(Rs))),!.


getPredicatesListFromContext(Rs,Context,Ctx):-
	mooCache(Context,_Ctx,predicatesListFromContext(Rs)),!.
getPredicatesListFromContext(Rs,Context,Ctx):-
	getRelationsListFromContext(RR,Context,Ctx),!,
	findall(X,
		((
		member(X,RR),
		not(atom_concat(_,'Fn',X))
		)),Relations),
	sort(Relations,Rs),
	asserta(mooCache(Context,_Ctx,predicatesListFromContext(Rs))),!.

getFunctionListFromContext(Rs,Context,Ctx):-
	mooCache(Context,_Ctx,functionListFromContext(Rs)),!.
getFunctionListFromContext(Rs,Context,Ctx):-
	getRelationsListFromContext(RR,Context,Ctx),!,
	findall(X,
		((
		member(X,RR),
		atom_concat(_,'Fn',X)
		)),Relations),
	sort(Relations,Rs),
	asserta(mooCache(Context,_Ctx,functionListFromContext(Rs))),!.

getClassesListFromContext(Rs,Context,Ctx):-
	mooCache(Context,_Ctx,classListFromContext(Rs)),!.
getClassesListFromContext(Rs,Context,Ctx):-
	findall(X,
		((
					deduceSurface_gaf(GAF,Context,_Explaination),
					((GAF=subclass(_,X);GAF=subclass(X,_);GAF=disjoint(_,X);GAF=disjoint(X,_);GAF=instance(_,X);GAF=range(_,X);
						deduceSubclassBySurfacePartition(GAF,Classes)
					)),nonvar(X))),Classes),
	sort(Classes,Rs),
	asserta(mooCache(Context,_Ctx,classListFromContext(Rs))),!.
			
deduceSubclassBySurfacePartition(GAF,A):-
	GAF=..[Composition|Children],
	member(Composition,[disjointDecomposition,exhaustiveDecomposition,partition]),
	member(A,Children).
/*
deduceSurface_dc_instance(X,Class,Context,Explainations  * SCExplaination):-%var(X),var(Class),!,
	atom(Class),
	deduceSurface_dc_instance1(X,M,Context,Explainations),
        deduceTransitiveClosure_PartialOrderingRelation(Context,subclass,M,Class,SCExplaination).
*/
       /*
deduceSurface_dc_instance1(X,Class,Context,argOf(Predicate,N,X)):-%var(X),var(Class),!,
	deduceSurfaceDomainVector(_Arity,Predicate,VectS,Context,Explainations),
	not(atom_concat(_,'Fn',Predicate)),
	nth1(N,VectS,Class),
	deduceSurfaceEntityInRelationArg(N,Predicate,X,Context,ExplainationO).
	 */

% ==================================================
% deduceSurfaceEntityInRelationArg(N,Predicate,VectS,Context,ExplainationO)
%
% (un)precacheSurfaceEntityInRelationArg(Context,Ctx)
% ==================================================

deduceSurfaceEntityInRelationArg(N,Predicate,X,Context,ExplainationO):-
	precacheSurfaceEntityInRelationArg(Context,Ctx),!,
	mooCache(Context,_Ctx,arg_vector(Predicate,N,X,ExplainationO)).
	
precacheSurfaceEntityInRelationArg(Context,Ctx):-mooCache(Context,_Ctx,done(precacheSurfaceEntityInRelationArg)),!.

/*
precacheSurfaceEntityInRelationArg(Context,Ctx):-
	mooCache(Fact, surface, Context,  Explaination),
	precacheSurfaceEntityInRelationArg_util(Fact,Classification,Context,Explaination),fail.

precacheSurfaceEntityInRelationArg(Context,Ctx):-
	mooCache(Predicate,HLFact,HLConds,_,  Context,  Explaination),
	precacheSurfaceEntityInRelationArg_util(entails(HLFact,HLConds),Classification,Context,Explaination),fail.
*/
	
precacheSurfaceEntityInRelationArg(Context,Ctx):-assert(mooCache(Context,_Ctx,done(precacheSurfaceEntityInRelationArg))),!.
		
expireSurfaceEntityInRelationArg(Context,Ctx):-
	 retractall(mooCache(Context,_Ctx,arg_vector(Predicate,N,VectS,_))),
	  retractall(mooCache(Context,_Ctx,done(precacheSurfaceEntityInRelationArg))).

% ==================================================
% Memorize Constants
%		precacheSurfaceEntityInRelationArg_util(entails(HLFact,HLConds),Classification,Context,Explaination),
%		precacheSurfaceEntityInRelationArg_util(HLFact,Classification,Context,Explaination),
% ==================================================

precacheSurfaceEntityInRelationArg_util(A,Classification,Context,Explaination):-(isSlot(A);string(A);atom(A);number(A)),!.

precacheSurfaceEntityInRelationArg_util([H|T],Classification,Context,Explaination):-!,
	precacheSurfaceEntityInRelationArg_util(H,Classification,Context,Explaination),!,
	precacheSurfaceEntityInRelationArg_util(T,Classification,Context,Explaination).
precacheSurfaceEntityInRelationArg_util(Formula,Classification,Context,Explaination):-
		Formula=..[holds,P|Args],!,
		precacheSurfaceEntityInRelationArg_util_holdsN(P,1,Args,Classification,Context,Explaination).
precacheSurfaceEntityInRelationArg_util(skolem(_,_),Classification,Context,Explaination):-!.
precacheSurfaceEntityInRelationArg_util(Formula,Classification,Context,Explaination):-
		Formula=..[_|Args],!,
		precacheSurfaceEntityInRelationArg_util(Args,Classification,Context,Explaination).
	
precacheSurfaceEntityInRelationArg_nosaveRelation(precacheSurfaceEntityInRelationArg_nosaveRelation). %dummy 

precacheSurfaceEntityInRelationArg_util_holdsN(P,N,_,Classification,Context,Explaination):-precacheSurfaceEntityInRelationArg_nosaveRelation(P),!.
precacheSurfaceEntityInRelationArg_util_holdsN(P,N,[],Classification,Context,Explaination).
precacheSurfaceEntityInRelationArg_util_holdsN(P,N,[A|RGS],Classification,Context,Explaination):-
	precacheSurfaceEntityInRelationArg_argN(PredR,P,N,A,Classification,Context,Explaination),
	NN is N+1,
	precacheSurfaceEntityInRelationArg_util_holdsN(P,NN,RGS,Classification,Context,Explaination).
	

precacheSurfaceEntityInRelationArg_argN(PredR,P,N,A,Classification,Context,Explaination):-non_memerable(A),!.
precacheSurfaceEntityInRelationArg_argN(PredR,Predicate,N,VectS,Classification,Context,Explaination):-
	mooCache(Context,_Ctx,arg_vector(Predicate,N,VectS,_)),!.
precacheSurfaceEntityInRelationArg_argN(PredR,Predicate,N,VectS,Classification,Context,Explaination):-
	asserta(mooCache(Context,_Ctx,arg_vector(Predicate,N,VectS,Explaination))),!.

non_memerable(A):-isSlot(A).
%non_memerable(A):-number(A).
%non_memerable(A):-string(A).
%non_memerable(A):-not(atom(A)),!,fail.
%non_memerable(A):-atom_codes(A,[34|_]).

	

%reif(Var):-var(Var),!,fail.
%reif('Entity'):-!,fail.
reif('Formula'):-!,fail.
%reif(N):-number(N),!,fail.
reif(_):-!.

%extentable('Entity'):-!,fail.
%extentable('Entity'):-!,fail.
%extentable('Formula'):-!,fail.
%extentable('SymbolicString'):-!,fail.
%extentable(Var):-var(Var),!,fail.
%extentable(_):-!.



expireOptimizationsInContext(Context,Assertion):-
		writeDebug(silver,'destroy_valence_vectors/expireDomainsListForRelation(Context,Ctx)/expireSurfaceEntityInRelationArg(Context,Ctx)'),
		retractall(mooCache(Context,_Ctx,functionListFromContext(Rs))),
		retractall(mooCache(Context,_Ctx,relation_list(Rs))),
		retractall(mooCache(Context,_Ctx,predicatesListFromContext(Rs))),
		retractall(mooCache(Context,_Ctx,classListFromContext(Rs))),
		retractall(mooCache(Context,_Ctx,attribute_list(Rs))),
		expireSurfaceEntityInRelationArg(Context,Ctx),
		expireDomainsListForRelation(Context,Ctx),
		precacheSurfaceEntityInRelationArg(Context,Ctx).
		



% Get Domain (Will return all predicates and arity with explaination of how it was derived)

deduceSurfaceDomainVector(N,Predicate,VectS,Context,ExplainationO):-
	buildDomainsListForRelation(Context,Ctx),!,
	mooCache(Context,_Ctx,domain_vector(Predicate,N,VectS,ExplainationO)).
	
buildDomainsListForRelation(Context,Ctx):-mooCache(Context,_Ctx,done(buildDomainsListForRelation)),!.
buildDomainsListForRelation(Context,Ctx):- 
	once(getRelationsListFromContext(Rs,Context,Ctx)),
	member(Predicate,Rs),  %true, 	
	once(deduceValence(Context,Predicate,N,_Explaination)),
	once(deduceHoldsNDomVect(N,Predicate,VectS,Context,Ctx)),
	%writeDebug(green,domain_vector(Predicate,N,VectS)),
	asserta_if_new(mooCache(Context,_Ctx,domain_vector(Predicate,N,VectS,cached))),fail.
buildDomainsListForRelation(Context,Ctx):-assert(mooCache(Context,_Ctx,done(buildDomainsListForRelation))),!.
		
expireDomainsListForRelation(Context,Ctx):-
	 retractall(mooCache(Context,_Ctx,domain_vector(Predicate,N,VectS,cached))),
	  retractall(mooCache(Context,_Ctx,done(buildDomainsListForRelation))).


% assert cache/2 
deduceSurface_domain(Predicate,N,Class,Context,Ctx):-
	atom(Predicate),
	deduceSurface(domain(Predicate,N,Class),Context,Explaination2).

:-index(deduceHoldsNDomVect(1,0,1,0,0)).


deduceHoldsNDomVect(2,Predicate,[Class1,Class2],Context,Ctx):-!,
	deduceSurface_domain(Predicate,1,Class1,Context,Ctx),!,
	deduceSurface_domain(Predicate,2,Class2,Context,Ctx),!.

deduceHoldsNDomVect(3,Predicate,[Class1,Class2,Class3],Context,Ctx):-!,
	deduceSurface_domain(Predicate,1,Class1,Context,Ctx),!,
	deduceSurface_domain(Predicate,2,Class2,Context,Ctx),!,
	deduceSurface_domain(Predicate,3,Class3,Context,Ctx),!.

deduceHoldsNDomVect(1,Predicate,[Class1],Context,Ctx):-!,
	deduceSurface_domain(Predicate,1,Class1,Context,Ctx),!.

deduceHoldsNDomVect(4,Predicate,[Class1,Class2,Class3,Class4],Context,Ctx):-!,
	deduceSurface_domain(Predicate,1,Class1,Context,Ctx),!,
	deduceSurface_domain(Predicate,2,Class2,Context,Ctx),!,
	deduceSurface_domain(Predicate,3,Class3,Context,Ctx),!,
	deduceSurface_domain(Predicate,4,Class4,Context,Ctx),!.

deduceHoldsNDomVect(5,Predicate,[Class1,Class2,Class3,Class4,Class5],Context,Ctx):-!,
	deduceSurface_domain(Predicate,1,Class1,Context,Ctx),!,
	deduceSurface_domain(Predicate,2,Class2,Context,Ctx),!,
	deduceSurface_domain(Predicate,3,Class3,Context,Ctx),!,
	deduceSurface_domain(Predicate,4,Class4,Context,Ctx),!,
	deduceSurface_domain(Predicate,5,Class5,Context,Ctx),!.

 

isPropositional(A):-isSlot(A),!.
isPropositional(not(A)):-!,isPropositional(A).
isPropositional(forall(_,A)):-!,isPropositional(A).
isPropositional(exists(_,A)):-!,isPropositional(A).
isPropositional(poss(A)):-!,isPropositional(A).
isPropositional(nec(A)):-!,isPropositional(A).
isPropositional(<=>(A,B)):-!,isPropositional(A),isPropositional(B).
isPropositional(=>(A,B)):-!,isPropositional(A),isPropositional(B).
isPropositional(or(A,B)):-!,isPropositional(A),isPropositional(B).
isPropositional(and(A,B)):-!,isPropositional(A),isPropositional(B).
isPropositional(A):-A=..[P|_],is_instance_of(P,C),is_subclass_of(C,'Predicate').



% ==========================================================
% True/False Instance (Specialization)  based on Asserted Rule
% ==========================================================

prove_goal_instance(Logic,Depth,Table,Entity,EClass,Agent,Context,P ):-!,
	Depth2 is Depth -1,!,
	writeDebug('?'(Logic,Entity,EClass)),   
	(((proveInstance(Logic,Depth2,Table,Entity,EClass,Agent,Context,P),
	nonvar(Entity),nonvar(EClass), 
	writeDebug('+i'(Logic,Entity,EClass))));(!,writeDebug('-i'(Logic,Entity,EClass)),!,fail)).


% ==========================================================
% Instance Deduction (Specializations based only on Structure of Fact)
% ==========================================================


%proveInstance(true,Depth,Table,X,Class,Agent,Context,incode(instance(X,Classes),'Cached')):-
%	atom(X),r_flags(X,Classes),!,member(Class,Classes).

%proveInstance(Logic,Depth,Table,X,Class,Agent,Context,Explaination):-
%	deduceSurfaceGuarded(instance,Logic,instance(X,Class),Agent,Context,Explaination).

proveInstance(Logic,Depth,Table,X,Class,Agent,Context,Explaination):-var(X),!,fail.

proveInstance(Logic,Depth,Table,X,Class,Agent,Context,Explaination):-
	memberchk(defering_to_gafs(Logic,_),Table),!,fail.
	
proveInstance(Logic,Depth,Table,X,Class,Agent,Context, Explaination2 * Explaination):- %true,
	compound(X),X=..[P|List],!,
	proveInstance_compound(Logic,Depth,Table,P,List,X,Class,Agent,Context,Explaination).
	
proveInstance(false,Depth,Table,'Formula',Type,Agent,Context,incode(not 'Formula')).

proveInstance(Logic,Depth,Table,Number,Type,Agent,Context,Explaination):-
	number(Number),!,
	proveInstance_number(Logic,Depth,Table,Number,Type,Agent,Context,Explaination).

/*
proveInstance(Logic,Depth,Table,Arg1,Arg2,Agent,Context,Explaination * Explaination2):-  !,
	not(member('some_instance'(Arg1),Table)),
	client_rulebase_spec(instance,Logic,instance(Arg1,Arg2), Agent,Context, Conditions, Explaination, F,Type),
	atom(Arg2),
	confirm_rule(instance,Logic,instance(Arg1,Arg2), Agent,Context, Conditions, Explaination, F,Type,Depth,Table,NewTable,NewConds),
	deduceGoal(holds,true,Depth,['Atom_instance'(Arg1),instance(Arg1,Arg2)|NewTable],NewConds,Agent,Context,Explaination2),
	confirm_ground(Conditions).
*/	

proveInstance_number(true,Depth,Table,Number,'RealNumber',Agent,Context,incode(instance(Number,'RealNumber'))).
proveInstance_number(Logic,Depth,Table,Number,Integer,Agent,Context,Explaination):-
	integer(Number),!,
	proveInstance_integer(Logic,Depth,Table,Number,Integer,Agent,Context,Explaination).

proveInstance_number(false,Depth,Table,Number,'Integer',Agent,Context,incode(not(instance(Number,'Integer')))).
	
proveInstance_integer(true,Depth,Table,Number,'Integer',Agent,Context,incode(instance(Number,'Integer'))).
proveInstance_integer(true,Depth,Table,Number,'PositiveInteger',Agent,Context,incode(instance(Number,'PositiveInteger'))):-Number>0.
proveInstance_integer(true,Depth,Table,Number,'NegativeInteger',Agent,Context,incode(instance(Number,'NegativeInteger'))):-Number<0.
proveInstance_integer(false,Depth,Table,Number,'PositiveInteger',Agent,Context,incode(instance(Number,'PositiveInteger'))):-Number<0.
proveInstance_integer(false,Depth,Table,Number,'NegativeInteger',Agent,Context,incode(instance(Number,'NegativeInteger'))):-Number>0.

proveInstance_compound(Logic,Depth,Table,'zzskFn',List,X,C,Agent,Context,Explaination):-!,
	proveInstance_skolem(Logic,Depth,Table,'zzskFn',List,X,C,Agent,Context,Explaination).


% Formula was a skolem
proveInstance_skolem(true,Depth,Table,'zzskFn',List,X,C,Agent,Context,Explaination * Explaination2):- C=='Entiry',!,
	ground(X).
/*

proveInstance_skolem(Logic,Depth,Table,'zzskFn',List,X,C,Agent,Context,Explaination * Explaination2):-
	not_in(instance(X,C),Table),
	client_rulebase(instance,true_'$existential's, instance(X,C),Agent,Context,ConditionsE,Explaination,Type),
	ground(ConditionsE),
	not(proveInstance_skolem_dis(ConditionsE)),
	writeDebug(green,'<='('E_instance'(X,C),ConditionsE)),
	deduce_backchain(true,Depth,[instance(X,C)|Table],ConditionsE,Agent,Context,Explaination2),!.
*/		

proveInstance_skolem_dis(not(A)):-!,
	proveInstance_skolem_dis(A).
proveInstance_skolem_dis(instance(_,C)):-not(atom(C)).
proveInstance_skolem_dis(ConditionsE):-functor(ConditionsE,F,N),proveInstance_skolem_dis(F,N).
proveInstance_skolem_dis(and,N).
proveInstance_skolem_dis(_,N):-N>4.
proveInstance_skolem_dis(ON,N):-atom_concat(_,'On',ON).

 
% Formula is a Function with Range
proveInstance_compound(true,Depth,Table,P,List,X,Class,Agent,Context,Explaination * Explaination2 * incode(instance(X,Class),'Structural Instances')):-
	deduceSurface(instance,true,Context,instance(P,'Function'),Explaination),
	deduceSurfaceGuarded(P,true,range( P ,Class),Agent,Context,Explaination2).

% Formula is a Function of not Range
proveInstance_compound(false,Depth,Table,P,List,X,Class,Agent,Context,Explaination * incode(not(range(P,Class))) * incode(instance(X,Class),'Structural Instances')):-
	deduceSurface(instance,true,Context,instance(P,'Function'),Explaination),
	not(deduceSurfaceGuarded(Predicate,true,Table,range(P,Class),Agent,Context,Explaination2)).

% Formual is a Proposition if it is headed be a Relation
proveInstance_compound(true,Depth,Table,P,List,X,'Proposition',Agent,Context,Explaination * incode(instance(X,'Proposition'),'Structural Instances') ):-
	deduceSurface(instance,true,Context,instance(P,'Relation'),Explaination).

% Formula is a Not Proposition if it is headed be a Relation
proveInstance_compound(false,Depth,Table,P,List,X,'Proposition',Agent,Context,(incode(not(instance(X,'Proposition'),'Structural Instances')* Explaination))):-
	deduceSurface(instance,true,Context,instance(P,'Relation'),Explaination).

% Formula is Formula
proveInstance_compound(true,Depth,Table,P,List,X,'Formula',Agent,Context,incode(instance(X,'Formula'),'Structural Instances')).

% Bachain on Formula
/*
proveInstance_compound(true,Depth,Table,P,List,X,C,Agent,Context,Explaination):-
		ground((X,C)),
		client_rulebase(instance,true, instance(X,C),Agent,Context,ConditionsE,_), requistionable(ConditionsE,Type),
		Depth2 is Depth-1,
		deduce_backchain(true,Depth2,[instance(X,C)|Table],ConditionsE,Agent,Context,Explaination). %TODO only one Antecedant Possble
*/



% =====================================================
% index/dynamic All exported predicates
% =====================================================

:-dynamic('PrologMOO_valence2'/6).
:-dynamic(forwardchain_PrologMOO_valence2/6).
:-dynamic(backchain_PrologMOO_valence2/6).

deduceValence(Context,not,1,inlinecode(valence(not,1))):-!.

deduceValence(Context,X,2,inlinecode(valence(X,2))):-
	deduceSurfaceGuarded(instance(X,'SententialOperator'),Context,Explaination),!.

deduceValence(Context,R,N,Explaination):-
	deduceValence_util(Context,R,N,Explaination),!.

% Valence #2
deduceValence(Context,X,N,Explaination * Explaination3 * inlinecode(valence,N)):-
	deduceTransitiveClosure_PartialOrderingRelation(Context,subrelation,X,Super,Explaination3),
	X\=Super,
	deduceValence_util(Context,Super,N,Explaination),!.

deduceValence(Context,X,N,Explaination * Explaination3 * inlinecode(valence,N)):-
	deduceSurface_gaf_sym(disjointRelation(X,Super),Context,Explaination3),
	X\=Super,
	deduceValence_util(Context,Super,N,Explaination),!.
	


	

% ==================================================================================
% Entry Points for singleValued   valence/2
% ==================================================================================
% Valence #1
deduceNegValence(Context,X,YY,Explaination * inlinecode(valence,1)):-
	isValenceInt(YY),
	deduceValence_util(Context,X,Y,Explaination),!,Y=YY.
	
% Valence #10
deduceNegValence(Context,X,YY,Explaination * inlinecode(valence,10)):-
	deduceValence_util(Context,X,Y,Explaination),isValenceInt(YY),Y\=YY,!.

	
% Valence Asserted
deduceValence_util(Context,X,Y,Explaination):-
	mooCache(valence(X,Y), _,_,_,Context,_,_,Explaination),!.
					    
% Valence #6
deduceValence_util(Context,X,2,Explaination * inlinecode(valence,6)):-
	deduceSurfaceGuarded(instance(X,'BinaryPredicate'),Context,Explaination),!.

% Valence #7
deduceValence_util(Context,X,3,Explaination * inlinecode(valence,7)):-
	deduceSurfaceGuarded(instance(X,'TernaryPredicate'),Context,Explaination),!.

% Valence #8
deduceValence_util(Context,X,4,Explaination * inlinecode(valence,8)):-
	deduceSurfaceGuarded(instance(X,'QuaternaryPredicate'),Context,Explaination),!.
	
% Valence #3
deduceValence_util(Context,X,2,Explaination * inlinecode(valence,3)):-
	deduceSurfaceGuarded(instance(X,'UnaryFunction'),Context,Explaination),!.

% Valence #4
deduceValence_util(Context,X,3,Explaination * inlinecode(valence,4)):-
	deduceSurfaceGuarded(instance(X,'BinaryFunction'),Context,Explaination),!.

% Valence #5
deduceValence_util(Context,X,4,Explaination * inlinecode(valence,5)):-
	deduceSurfaceGuarded(instance(X,'TernaryFunction'),Context,Explaination),!.


	


% Utility Predicates

isValenceInt(1).
isValenceInt(2).
isValenceInt(3).
isValenceInt(4).
isValenceInt(5).

	
% ================================================================================================================
% Rules for valence/2
% ================================================================================================================


/* 


Rule # 1 for valence   
  
Forms:
 1. "(=> 
         (instance ?REL VariableArityRelation) 
         (not 
            (exists (?INT) 
               (valence ?REL ?INT))))"
1a. (entails 
         (instance ?REL VariableArityRelation) 
         (not 
            (valence ?REL ?INT)))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 1, ['REL'=A, 'INT'=B|C]), via(entails(holds(instance, A, 'VariableArityRelation'), not holds(valence, A, B)), ['REL'=A, 'INT'=B|C])*surf('PrologMOO', 1628)).

/*
'PrologMOO_~valence'( A, B, 'BASE ONTOLOGY', E, E*D*incode('PrologMOO_valence2', 1, ['REL'=A, 'INT'=B|C])) :- 
	forwardchain_instance(true, holds(instance, A, 'VariableArityRelation'), 'BASE ONTOLOGY', D)
*/


/* 


Rule # 2 for valence   
  
Forms:
 2. "(=> 
         (instance ?REL QuintaryPredicate) 
         (valence ?REL 5))"
2a. (entails 
         (instance ?REL QuintaryPredicate) 
         (valence ?REL 5))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 2, ['REL'=A|B]), via(entails(holds(instance, A, 'QuintaryPredicate'), holds(valence, A, 5)), ['REL'=A|B])*surf('PrologMOO', 1622)).

/*
deduceValence_util(Context, A, 5, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 2, ['REL'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'QuintaryPredicate'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 3 for valence   
  
Forms:
 3. "(=> 
         (instance ?REL QuaternaryPredicate) 
         (valence ?REL 4))"
3a. (entails 
         (instance ?REL QuaternaryPredicate) 
         (valence ?REL 4))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 3, ['REL'=A|B]), via(entails(holds(instance, A, 'QuaternaryPredicate'), holds(valence, A, 4)), ['REL'=A|B])*surf('PrologMOO', 1614)).

/*
deduceValence_util(Context, A, 4, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 3, ['REL'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'QuaternaryPredicate'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 4 for valence   
  
Forms:
 4. "(=> 
         (instance ?REL TernaryPredicate) 
         (valence ?REL 3))"
4a. (entails 
         (instance ?REL TernaryPredicate) 
         (valence ?REL 3))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 4, ['REL'=A|B]), via(entails(holds(instance, A, 'TernaryPredicate'), holds(valence, A, 3)), ['REL'=A|B])*surf('PrologMOO', 1606)).

/*
deduceValence_util(Context, A, 3, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 4, ['REL'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'TernaryPredicate'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 5 for valence   
  
Forms:
 5. "(=> 
         (instance ?REL BinaryPredicate) 
         (valence ?REL 2))"
5a. (entails 
         (instance ?REL BinaryPredicate) 
         (valence ?REL 2))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 5, ['REL'=A|B]), via(entails(holds(instance, A, 'BinaryPredicate'), holds(valence, A, 2)), ['REL'=A|B])*surf('PrologMOO', 1598)).

/*
deduceValence_util(Context, A, 2, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 5, ['REL'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'BinaryPredicate'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 6 for valence   
  
Forms:
 6. "(=> 
         (instance ?FUNCTION TernaryFunction) 
         (valence ?FUNCTION 3))"
6a. (entails 
         (instance ?FUNCTION TernaryFunction) 
         (valence ?FUNCTION 3))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 6, ['FUNCTION'=A|B]), via(entails(holds(instance, A, 'TernaryFunction'), holds(valence, A, 3)), ['FUNCTION'=A|B])*surf('PrologMOO', 1580)).

/*
deduceValence_util(Context, A, 3, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 6, ['FUNCTION'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'TernaryFunction'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 7 for valence   
  
Forms:
 7. "(=> 
         (instance ?FUNCTION BinaryFunction) 
         (valence ?FUNCTION 2))"
7a. (entails 
         (instance ?FUNCTION BinaryFunction) 
         (valence ?FUNCTION 2))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 7, ['FUNCTION'=A|B]), via(entails(holds(instance, A, 'BinaryFunction'), holds(valence, A, 2)), ['FUNCTION'=A|B])*surf('PrologMOO', 1558)).

/*
deduceValence_util(Context, A, 2, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 7, ['FUNCTION'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'BinaryFunction'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 8 for valence   
  
Forms:
 8. "(=> 
         (instance ?FUNCTION UnaryFunction) 
         (valence ?FUNCTION 1))"
8a. (entails 
         (instance ?FUNCTION UnaryFunction) 
         (valence ?FUNCTION 1))


Flags: r1([2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 8, ['FUNCTION'=A|B]), via(entails(holds(instance, A, 'UnaryFunction'), holds(valence, A, 1)), ['FUNCTION'=A|B])*surf('PrologMOO', 1536)).

/*
deduceValence_util(Context, A, 1, 'BASE ONTOLOGY', D, D*C*incode('PrologMOO_valence2', 8, ['FUNCTION'=A|B])) :- 
	forwardchain_instance(true, holds(instance, A, 'UnaryFunction'), 'BASE ONTOLOGY', C)
*/


/* 


Rule # 9 for valence   
  
Forms:
 9. "(=> 
         (subrelation ?PRED1 ?PRED2) 
         (exists (?NUMBER) 
            (and 
               (valence ?PRED1 ?NUMBER) 
               (valence ?PRED2 ?NUMBER))))"
9a. (entails 
         (subrelation ?PRED1 ?PRED2) 
         (valence ?PRED2 
            (Valence8SkFn ?PRED2 ?PRED1)))


Flags: r1([zzskFn(Valence8SkFn), 2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 9, ['PRED1'=A, 'PRED2'=B, 'NUMBER'=C|D]), via(entails(holds(subrelation, A, B), holds(valence, B, zzskFn('Valence8SkFn', [B, A]))), ['PRED1'=A, 'PRED2'=B, 'NUMBER'=C|D])*surf('PrologMOO', 183)).

/*
deduceValence_util(Context, B, zzskFn('Valence8SkFn', [B, A]), 'STRUCTURAL ONTOLOGY', E, F*E*incode('PrologMOO_valence2', 9, ['PRED1'=A, 'PRED2'=B, 'NUMBER'=C|D])) :- 
	forwardchain(true, holds(subrelation, A, B), 'STRUCTURAL ONTOLOGY', E)
*/


/* 


Rule # 10 for valence   
  
Forms:
 10. "(=> 
         (subrelation ?PRED1 ?PRED2) 
         (exists (?NUMBER) 
            (and 
               (valence ?PRED1 ?NUMBER) 
               (valence ?PRED2 ?NUMBER))))"
10a. (entails 
         (subrelation ?PRED1 ?PRED2) 
         (valence ?PRED1 
            (Valence8SkFn ?PRED2 ?PRED1)))


Flags: r1([zzskFn(Valence8SkFn), 2nd(holds)])

*/

explaination_line(incode('PrologMOO_valence2', 10, ['PRED1'=A, 'PRED2'=B, 'NUMBER'=C|D]), via(entails(holds(subrelation, A, B), holds(valence, A, zzskFn('Valence8SkFn', [B, A]))), ['PRED1'=A, 'PRED2'=B, 'NUMBER'=C|D])*surf('PrologMOO', 183)).

/*
deduceValence_util(Context, A, zzskFn('Valence8SkFn', [B, A]), 'STRUCTURAL ONTOLOGY', E, F*E*incode('PrologMOO_valence2', 10, ['PRED1'=A, 'PRED2'=B, 'NUMBER'=C|D])) :- 
	forwardchain(true, holds(subrelation, A, B), 'STRUCTURAL ONTOLOGY', E)
*/


/* 
   Douglas Miles 
   This version handles request answering with integrity constraints.
*/

		  
%:-module(moo_slg_tabling,[]).

% :-include('moo_header.pl').

:- style_check(-singleton).
:- style_check(-discontiguous).
:- style_check(-atom).
:- style_check(-string).


:- op(1200,fx,  ::-).         /* operator for integrity constraints */

:- op(1200,xfx,<--).
%:- op(1150,fx,[(tabled),(prolog),(default)]).
:- op(900,xfx,<-).

:- dynamic slg_expanding/0.
:- dynamic wfs_trace/0.

:-dynamic('slg$default'/1).
:-dynamic('slg$prolog'/1).
:-dynamic('slg$tabled'/2).
:-dynamic('slg$tab'/2).
:-dynamic('inconsistent'/0).
:-dynamic('slg$inconsistent'/1).
:-dynamic((~)/1).
:-dynamic(('slg$~')/2).

:-multifile('slg$default'/1).
:-multifile('slg$prolog'/1).
:-multifile('slg$tabled'/2).
:-multifile('slg$tab'/2).
:-multifile('inconsistent'/0).
:-multifile('slg$inconsistent'/1).
:-multifile((~)/1).
:-multifile(('slg$~')/2).

:- dynamic 'sLGx$prolog'/1, 'sLGx$tab'/2.
:- dynamic sLGx_xexpanxdxing/0.
:- dynamic wfsx_trace/0.
:- op(1200,xfx,'<x--').
%:- op(1150,fx,[(xtabled),(prolog),(xdefault)]).
:- op(900,xfx,'<x-').

addDeclTabled(P,A):-(isDeclTabled(P,A);assert('slg$tab'(P,A))),!. 
remDeclTable(P,A):-retractall('slg$tab'(P,A)).

isDeclTabled(G):-functor(G,P,A),!,isDeclTabled(P,A).

isDeclTabled(P,A):-'slg$tab'(P,A);mooCache(_,type(tabled),(P/A)).
isDeclTabled(member,2):-!.
isDeclTabled(/*neg*/ \+,1):-!,fail.
isDeclTabled(P,A):-isAlwaysProlog(P/A),!,fail.
isDeclTabled(surf,4):-!,fail.
isDeclTabled(A,_):-nonvar(A),!.


addHasTable(P,A):-('slg$tabled'(P,A);assert('slg$tabled'(P,A))),!.
remHasTable(P,A):-retractall('slg$tabled'(P,A)).
isHasTable(P,A):-'slg$tabled'(P,A).  % Not used
failedHasTable(P,A):-not('slg$tabled'(P,A)).

:- addHasTable(inconsistent,0).

remDefaultDecl:-retractallLogged('slg$default'(_)).
setDefaultDecl(D):-assertLogged('slg$default'(D)).

getDefaultDecl(Default):-'slg$default'(Default),!.
getDefaultDecl(prolog).

isDeclProlog(Pred/A):-'slg$prolog'(Pred/A).      
isDeclProlog(surf/4):-!.
isDeclProlog(member/2):-!,fail.


addDeclProlog(Pred):-(isDeclProlog(Pred) ; assert('slg$prolog'(Pred))),!.

add_slg_functor(P,NewP):-atom_concat('slg$',P,NewP).

/*
% Must allow failures?
new_slg_head(Head,Body,NewHead) :-var(Head),!,
	NewHead=..[NF|NArgs],
	append(Args,[Body],NArgs),
	add_slg_functor(F,NF),
	Head=..[F|Args],
	ensure_slghead(Head,NewHead).

new_slg_head(Head,Body,NewHead) :-
	Head=..[F|Args],
	add_slg_functor(F,NF),
	append(Args,[Body],NArgs),
	NewHead=..[NF|NArgs],
	ensure_slghead(Head,NewHead).
	
ensure_slghead(Head,SLGHead):-
	predicate_property(SLGHead,number_of_clauses(H)),
	((H < 1) -> writeDebug(no_clauses_for : Head) ; true),!.
ensure_slghead(Head,SLGHead):-
	dynamic(SLGHead),
	functor(Head,F,A),
	addHasTable(F,A),
	writeDebug(faking_slg : Head),!.
*/

stableGround(G):-%
		(stableGroundTrace(G)).
stableGroundTrace(G):- (ground(G),!) ; (var(G),!,fail).
stableGroundTrace(v(_,G,_)):-!,nonvar(G).
stableGroundTrace(\+ (G)):-!,stableGroundTrace(G).
stableGroundTrace('$existential'(_,_,_)):-!.
stableGroundTrace('$existential'(_,_)):-!.
stableGroundTrace(G):-G=..[F|Args],!,stableGroundTraceA(Args).
stableGroundTraceA([G]):-!,
	stableGroundTrace(G).
stableGroundTraceA([H|T]):-
	stableGroundTrace(H),!,
	stableGroundTraceA(T).



isAlwaysProlog(true):-!.
isAlwaysProlog(/*neg*/ \+(_)):-!. %,fail.
isAlwaysProlog(surf(_,_,_,_)).
isAlwaysProlog(tnot(_)).
isAlwaysProlog(\+ _):-!.
isAlwaysProlog(P/A):-ground(P/A),functor(G,P,A),!,isAlwaysProlog(G).
isAlwaysProlog(Nlit):-nonvar(Nlit),
	(slg_built_in(Nlit);
	(predicate_property(Nlit,PP),(PP=built_in;PP=imported_from(_)))),!.


surf(Context,TN,CID,[]):-!.
surf(Context,TN,CID,Vars):-
	writeq(surf(Context,TN,CID,Vars)),nl.
	

/* isPrologCurrently(Call) :  Call is a Prolog subgoal */
isPrologCurrently(Call) :-!, fail, %TODO
	 not(number(Call)),
	functor(Call,P,A),
         failedHasTable(P,A). % Therefore prologCall its prolog entry point

/*
prologCall(G):-
	once( (G = (\+ Call )) -> Log=false(_) ; (Call=G,Log=true(_))),
	Call=..[F|Args],
	atom_concat('slg$',F,F),
	append(Args,[Body],Args),
	Call=..[F|Args],!,
	prologCall(Log,Call,F,Args,Body).
*/
	


prologCall(Call):-
	xhandle(prologCall,Call).

%xprologCall(Call):-dynamic(Call),catch(Call,E,xhandle(E,Call)).
xprologCall(Call):-prologCall(Call).

xhandle(E,Call):-format('xhandle: ~n~q.~nxhandle:',[E:Call]),true,fail.

xprologSLGCall(Call,Body):-
	prologSLGCall(Call,Body).

prologSLGCall( or(G1,G2),Body):-nonvar(G1),!,
	prologSLGCall( G1,Body);
	prologSLGCall( G2,Body).

prologSLGCall(holds(P,A,B),Body):-atom(P),
	Call=..[P,A,B],	  !,not(atom_concat(_,'Fn',P)),
	prologSLGCall(Call,Body).
prologSLGCall(holds(P,A,B,C),Body):-atom(P),
	Call=..[P,A,B,C],	  !,not(atom_concat(_,'Fn',P)),
	prologSLGCall(Call,Body).
	
	
prologSLGCall(not Call,Body):-nonvar(Call),!,
	Call=..[F|Args],!,
	prologCall(false(_),Call,F,Args,Body).

prologSLGCall(/*neg*/ \+ Call,Body):-nonvar(Call),!,
	Call=..[F|Args],!,
	prologCall(false(_),Call,F,Args,Body).

prologSLGCall( Call,Body):-
	Call=..[F|Args],!,
	prologCall(true(_),Call,F,Args,Body).



resetTableFlags:-(resetTableFlags2).
		
resetTableFlags2:-
	current_flag(X),
	(compound(X) ;(atomic(X),not(atom_concat('$',_,X)))),flag(X,_,0),fail.
resetTableFlags2:-
	current_key(X),
		(compound(X) ;(atomic(X),not(atom_concat('$',_,X)))),recorded(X,_,Y),erase(Y),fail.
resetTableFlags2:-!.
	

mslg(Goal):-
	resetTableFlags,
	prolog_statistics(cputime,S),
	findall(Goal,
		slg(Goal),L),
	prolog_statistics(cputime,E),
	writeq_conj(L),
	length(L,N),
	T is  E - S,
	format('found ~w answers in ~q secs.~n',[N,T]),!.

xmslg(Goal):-
	resetTableFlags,
	prolog_statistics(cputime,S),
	findall(Goal,
		sLGx(Goal),L),
	prolog_statistics(cputime,E),
	writeq_conj(L),
	length(L,N),
	T is  E - S,
	format('found ~w answers in ~q secs.~n',[N,T]),!.
	
	
call_one([B|L]):-prologSLGCall(B,[]),!.
call_one([B|L]):-call_one(L).


prologCall(true(_),Call,F,Args,[]):-
	mooCache(Call, true, Context, Ctx,Explaination),stableGroundTraceA(Args),writeq('+').
prologCall(false(_),Call,F,Args,[]):-
	mooCache(Call, false, Context, Ctx,Explaination),stableGroundTraceA(Args),writeq('-').

prologCall(true(_),instance(v(H,X,List),v('Asbtract',Class,['Class'|_])),F,Args,[]):-!,
	nonvar(X),nonvar(List),
		true,close_list(List),!,
		member(Class,List).

%prologCall(_,Call,F,Args,Body):-member(F,[domain]),!.
prologCall(_,Call,F,Args,Body):-
	(
	%member(F,[disjointDecomposition,domain,subrelation,subclass]);
	%member(Call,[instance(v(_,*,_),_)]);
	(Args=[v(_,A,_),v(_,B,_)|_],((atom(A),atom_concat(_,'Fn',A);(atom(B),atom_concat(_,'Fn',B)))))
	),!,fail.
		
prologCall(true(_),Call,F,Args,Body):-
	once((format('needs: '),writeArgLit(Call))),
	copy_term(Call,Copy),
	mooCache(Copy, Body,/*true(_)*/ _, Context, Ctx,surf(Context,TN,CLID,Vars)),
		not(recorded(TN,Call)),
		(recorda(TN,Call)),
		Call=Copy,
	once((format('found: ~q ~n',[[TN,CLID,Vars]]),writeArgLit(Call),writeArgLitL(Body))).

%		not(not(call_one(Body))),
		%term_to_atom(Vars,Atom),
				/*
prologCall(false(_),Call,F,Args,Body):-
		mooCache(Call, Body,false(_),Context, Ctx,surf(Context,TN,CLID,Vars)),
		call_one(Args),
		stableGroundTraceA(Args) -> true ;
		((
		term_to_atom(Vars,Atom),
		flag(Atom,X,X+1),
		X<3,
		stableGroundTraceA(Body) 
		)),
		format('~q.~n',[true:X:surf(Context,TN,CLID,Vars)]).
				  */
	

/*
prologCall(false(_),Call,F,Args,Body):-mooCache(Call, Body,false(_),Context, Ctx,Explaination),
		stableGroundTraceA(Args),
		stableGroundTraceA(Body),
		format('~q.~n',[false:Explaination]).

*/


'sLGx$prolog'(X):-isDeclProlog(X).
'sLGx$tablexd'(X,Y):-addHasTable(X,Y).
'sLGx$xdefault'(X):-getDefaultDecl(X).
'sLGx$tab'(X,Y):-isDeclTabled(X,Y).
/* xisCurrentlyProlog(Callx): Callx is a Prolog subgoal */

xisCurrentlyProlog(Callx) :-
        functor(Callx,P,A),
        \+ 'sLGx$tablexd'(P,A).

writeArgLitL([H]):-!,write('\t\t'),writeArgLit(H).
writeArgLitL([H|T]):-!,
	write('\t\t'),writeArgLit(H),
	writeArgLitL(T).
	

writeArgLit(Call):-
	Call=..[F|Args],
	remove_v_argsW(Args,ArgsO),
	R=..[F|ArgsO],
	writeq(R),nl,!.
	
remove_v_argsW([],[]).
remove_v_argsW([H|T],[HO|TO]):-
	remove_v_argW(H,HO),
	remove_v_argsW(T,TO).

remove_v_argW(v(_,H,_),H):-var(H).
remove_v_argW(v(_,H,_),HO):-!,remove_v_argW(H,HO).
remove_v_argW('$existential'(HO,_),HO).
remove_v_argW('$existential'(HO,_,_),HO).
remove_v_argW('$existential'(HO,_,_,_),HO).
remove_v_argW(HO,HO).
	

/* SLG tracing : 
   xtrace :  turns SLG true on, which prints out tables at various 
           points
   xnotrace :  turns off SLG true
*/
xtrace :-( wfs_trace -> true ; assertLogged(wfs_trace)).
xnotrace :- retractallLogged(wfs_trace).



slg_built_in(slg(_)).
slg_built_in(_<-_).
slg_built_in(slgall(_,_)).
slg_built_in(slgall(_,_,_,_)).
slg_built_in(emptytable(_)).
slg_built_in(st(_,_)).
slg_built_in(stnot(_,_)).
slg_built_in(stall(_,_,_)).
slg_built_in(stall(_,_,_,_,_)).
slg_built_in(stselect(_,_,_,_)).
slg_built_in(stselect(_,_,_,_,_,_)).
slg_built_in(xtrace).
slg_built_in(xnotrace).
slg_built_in(surf(_,_,_,_)).


/* ----------------- end of slg_load routines --------------------------- */


wfs_error(Msg,Term) :-
	write('Error :  '), write(Msg), write(Term), nl, fail.

/* slg(Call) : 
   It returns all true answers of Call under the well-founded semantics
   one by one.
*/
slg(Call) :-
	Call<-[].
	

/* Call<-Cons : 
   It returns all true or undefined answers of Call one by one. In
   case of a true answer, Cons = []. For an undefined answer,
   Cons is a list of delayed literals.
*/
Call<-Cons :-
        ( isPrologCurrently(Call) ->
          prologCall(Call),
          Cons = []
        ; wfs_all(Call,Anss),
          member_anss(d(Call,Cons),Anss)
        ).

/* emptytable(EmptTab) :  creates an initial empty table.
*/
emptytable(0 : []).

/* slgall(Call,Anss) : 
   slgall(Call,Anss,N0-Tab0,N-Tab) : 
   If Call is a prolog prologCall, findall is used, : Tab = Tab0;
   If Call is an atom of a tabled predicate, SLG evaluation
   is carried out.
*/
slgall(Call,Anss) :-
	slgall(Call,Anss,0 : [],_).
slgall(Call,Anss,N0 : Tab0,N : Tab) :-
        ( isPrologCurrently(Call) ->
          findall(Call,Call,Anss),
	  N = N0, Tab = Tab0
        ; wfs_all(Call,Answers,Tab0,Tab,N0,N),
          ansstree_to_list(Answers,Anss,[])
        ).

/* st(Call,PSM) : 
   stnot(Call,PSM) : 
   It finds a stable model in which Call must be true (false).
   Call must be stableGround.
*/
st(Call,PSM) :-
	( stableGround(Call) ->
	  stselect(Call,[Call],_,PSM)
        ; wfs_error('Error :  nonstableGround atom in st/2 :  ', Call)
        ).
	
stnot(Call,PSM) :-
	( stableGround(Call) ->
	  stselect(Call,[ /*neg*/ \+ Call],_,PSM)
        ; wfs_error('Error :  nonstableGround atom in stnot/2 :  ', Call)
        ).

tnot(Call):-
	stnot(Call,PSM).	


/* stall(Call,Anss,PSM) : 
   stall(Call,Anss,PSM,Tab0,Tab) : 
   It computes a partial stable model PSM : collects all
   answers of Call in that model.
*/
stall(Call,Anss,PSM) :-
	stselect(Call,[],Anss,PSM).
	
stall(Call,Anss,PSM,NTab0,NTab) :-
	stselect(Call,[],Anss,PSM,NTab0,NTab).

/* stselect(Call,PSM0,Anss,PSM) : 
   stselect(Call,PSM0,Anss,PSM,N0 : Tab0,N : Tab) : 
   It computes a partial stable model PSM in which all stableGround
   literals in PSM0 are true, : returns all answers of Call
   in the partial stable model.
*/
stselect(Call,PSM0,Anss,PSM) :-
	stselect(Call,PSM0,Anss,PSM,0 : [],_).

stselect(Call,PSM0,Anss,PSM,N0 : Tab0,N : Tab) :-
	( isPrologCurrently(Call) ->
	  findall(Call,Call,Anss),
	  PSM = [], Tab = Tab0, N = N0
        ; wfs_all(Call,Anss0,Tab0,Tab1,N0,N1,Delay),
	  ( Delay == 0 ->
	    Plits1 = [], Nlits1 = [], Nseq1 = [] 
	  ; relevant(Anss0,Tab1,[],Plits1,[],Nlits1,[],Nseq1)
          ),
	  PSM1 = [ /*neg*/ \+ inconsistent|PSM0],
	  relevant_psm(PSM1,PSM2,[],Tab1,Tab2,N1,N,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq),
          one_psm(PSM2,Tab2,Tab3,Plits,Nseq),
	  construct_psm(Plits,Nlits,Tab3,Tab,PSM,[]),
	  ( Delay == 0 ->
	    ansstree_to_list(Anss0,Anss,[])
	  ; findall(Call,member(Call,PSM),Anss)
          )
        ).
/*
        ; wfs_all(inconsistent,IAnss,Tab0,Tab1,N0,N1,IDelay),
	  ( succeeded(IAnss) ->
	    write('*** Constraints violated in the WFS of the program!'), 
	    nl, fail
	  ; wfs_all(Call,Anss0,Tab1,Tab2,N1,N2,Delay),
	    ( IDelay == 0, Delay == 0 ->
	      ansstree_to_list(Anss0,Anss,[]),
	      PSM = [], Tab = Tab2, N = N2
	    ; relevant(Anss0,Tab2,[],Plits1,[],Nlits1,[],Nseq1),
	      relevant_psm(PSM0,Tab2,Tab3,N2,N,Plits1,Plits2,Nlits1,Nlits2,Nseq1,Nseq2),
	      ( failed(IAnss) ->
		PSM1 = PSM0, Plits = Plits2, Nlits = Nlits2, Nseq = Nseq2
	      ; relevant(IAnss,Tab1,Plits2,Plits,Nlits2,Nlits,Nseq2,Nseq),
	        PSM1 = [ /*neg*/ \+ inconsistent|PSM0]
	      ),
	      one_psm(PSM1,Tab3,Tab4,Plits,Nseq),
	      construct_psm(Plits,Nlits,Tab4,Tab,PSM,[]),
	      findall(Call,member(Call,PSM),Anss)
	    )
          )
        ).
*/

relevant_psm([],PSM,PSM,Tab,Tab,N,N,Plits,Plits,Nlits,Nlits,Nseq,Nseq).

relevant_psm([A|PSM0],PSM1,PSM,Tab0,Tab,N0,N,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	( A = ( /*neg*/ \+ G) -> true; A = G ),
  
        ( 
	
  %isPrologCurrently(G) ->
   %       wfs_error('Error :  Prolog predicate in stselect :  ', A)
	%; 
	stableGround(G) ->
	  wfs_all(G,Anss,Tab0,Tab1,N0,N1,Delay),
	  ( failed(Anss), A=G ->
	    fail
	  ; succeeded(Anss), A = ( /*neg*/ \+ G) ->
	    fail
	  ; Delay == 0 ->
	    relevant_psm(PSM0,PSM1,PSM,Tab1,Tab,N1,N,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq)
	  ; relevant(Anss,Tab1,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	    PSM1 = [A|PSM2],
	    relevant_psm(PSM0,PSM2,PSM,Tab1,Tab,N1,N,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq)
	  )
        ; wfs_error('Error :  non-stableGround literal in stselect :  ', A)
	).

/* stintall(Call,Anss) : 
   computes the set of answers of Call that are true in all two-valued
   partial stable models of the portion of a program that is relevant
   to Call, in which all integrity constraints are satisfied.
*/
stintall(Call,Anss) :-
	( isPrologCurrently(Call) ->
	  findall(Call,Call,Anss)
        ; wfs_all(inconsistent,IAnss,[],Tab1,0,N1,IDelay),
	  ( succeeded(IAnss) ->
	    write('*** Constraints violated in the WFS of the program!'), 
	    nl, fail
	  ; wfs_all(Call,Anss0,Tab1,Tab2,N1,_N2,Delay),
	    ( IDelay == 0, Delay == 0 ->
	      ansstree_to_list(Anss0,Anss,[])
	    ; extract_wfs(Anss0,Tab2,Hlist,[],Anss,Anss1,[],Plits1,[],Nlits1,[],Nseq1),
	      ( failed(IAnss) ->
		Tab3 = Tab2, Plits = Plits1, Nlits = Nlits1, Nseq = Nseq1
	      ; relevant(IAnss,Tab2,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq),
	        assume_one(inconsistent,false,Tab2,Tab3,Plits)
	      ),
	      ( one_psm(Tab3,Tab4,Plits,Nseq),
	        construct_psm(Plits,Nlits,Tab4,_Tab,_PSM,[]) ->
		stableGround(Call,Ggoal),
		check_each_ans(Hlist,Ggoal,Tab3,Anss1,[])
	      ; fail % no model exists
	      )
	    )
          )
        ).

extract_wfs(Tree,Tab,Hlist0,Hlist,Anss0,Anss,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	( Tree = [] ->
	  Hlist0 = Hlist, Anss0 = Anss, Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
        ; Tree = l(GH,Lanss) ->
	  ( Lanss = [] ->
	    Hlist0 = Hlist, Anss0 = Anss, Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
	  ; Lanss = [d(H,[])] ->
	    Hlist0 = Hlist, Anss0 = [H|Anss], Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
	  ; Lanss = [d(H,_)|_], 
	    Hlist0 = [Tree|Hlist], Anss0 = Anss, 
            ( addkey(Plits0,GH,v(_Val,_Con,H),Plits1) ->
              relevant_lanss(Lanss,Tab,Plits1,Plits,Nlits0,Nlits,Nseq0,Nseq)
            ; Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
            )
	  )
        ; Tree = n2(T1,_,T2) ->
	  extract_wfs(T1,Tab,Hlist0,Hlist1,Anss0,Anss1,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	  extract_wfs(T2,Tab,Hlist1,Hlist,Anss1,Anss,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq)
        ; Tree = n3(T1,_,T2,_,T3) ->
	  extract_wfs(T1,Tab,Hlist0,Hlist1,Anss0,Anss1,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	  extract_wfs(T2,Tab,Hlist1,Hlist2,Anss1,Anss2,Plits1,Plits2,Nlits1,Nlits2,Nseq1,Nseq2),
	  extract_wfs(T3,Tab,Hlist2,Hlist,Anss2,Anss,Plits2,Plits,Nlits2,Nlits,Nseq2,Nseq)
        ).

check_each_ans([],_Ggoal,_Tab,Anss,Anss).
check_each_ans([l(GH,Lanss)|Hlist],Ggoal,Tab,Anss0,Anss) :-
        ( not(not(canbe_false(GH,Ggoal,Lanss,Tab))) ->
	  Anss0 = Anss1
        ; Lanss = [d(H,_)|_], 
	  Anss0 = [H|Anss1]
        ),
	check_each_ans(Hlist,Ggoal,Tab,Anss1,Anss).

canbe_false(GH,Ggoal,Lanss,Tab0) :-
	relevant_anshead(GH,Lanss,_Val,Tab0,[],Plits,[],Nlits,[],Nseq),
	assume_one((Ggoal-GH),false,Tab0,Tab1,Plits),
	one_psm(Tab1,Tab2,Plits,Nseq),
	construct_psm(Plits,Nlits,Tab2,_Tab,_PSM,[]).

logComplement(true,false).
logComplement(false,true).

/* relevant(Anss,Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) : 
   Plits0/Plists is the accumulator for (the head atoms 
   of) all answers in Tab that are relevant to Ggoal, 
   where Anss is the set of answers for Ggoal; : 
   Nlits0/Nlists is the accumulator for stableGround calls
   whose negation has been delayed.
*/
relevant([],_Tab,Plits,Plits,Nlits,Nlits,Nseq,Nseq).
relevant(l(GH,Lanss),Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	( find(Plits0,GH,_) ->
	  Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
        ; relevant_anshead(GH,Lanss,_Val,Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq)
        ).
relevant(n2(T1,_,T2),Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	relevant(T1,Tab,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	relevant(T2,Tab,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq).
relevant(n3(T1,_,T2,_,T3),Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	relevant(T1,Tab,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	relevant(T2,Tab,Plits1,Plits2,Nlits1,Nlits2,Nseq1,Nseq2),
	relevant(T3,Tab,Plits2,Plits,Nlits2,Nlits,Nseq2,Nseq).

relevant_anshead(GH,Lanss,Val,Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	addkey(Plits0,GH,v(Val,Con,H),Plits1),
	( Lanss == [] -> 
	  Val = false, Con = true,
	  Plits = Plits1, Nlits = Nlits0, Nseq = Nseq0
        ; Lanss = [d(H,[])] -> 
	  Val = true, Con = true,
	  Plits = Plits1, Nlits = Nlits0, Nseq = Nseq0
	; Lanss = [d(H,_)|_],
	  relevant_lanss(Lanss,Tab,Plits1,Plits,Nlits0,Nlits,Nseq0,Nseq)
        ).

relevant_lanss([],_Tab,Plits,Plits,Nlits,Nlits,Nseq,Nseq).
relevant_lanss([d(_,D)|Lanss],Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	relevant_list(D,Tab,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	relevant_lanss(Lanss,Tab,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq).

relevant_list([],_Tab,Plits,Plits,Nlits,Nlits,Nseq,Nseq).
relevant_list(all(D),_Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	( D = [] ->
	  Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
        ; wfs_error('Error :  universal disjunction in relevant_list :  ',
	            all(D))
	).
relevant_list([Lit|D],Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	relevant_lit(Lit,Tab,Plits0,Plits1,Nlits0,Nlits1,Nseq0,Nseq1),
	relevant_list(D,Tab,Plits1,Plits,Nlits1,Nlits,Nseq1,Nseq).

relevant_lit(( /*neg*/ \+ A),Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	( find(Nlits0,A,_) ->
	  Plits = Plits0, Nlits0 = Nlits, Nseq = Nseq0
        ; addkey(Nlits0,A,Val,Nlits1),
	  Nseq1 = [(A,Val)|Nseq0],
          relevant_pos_lit(A,A,Val,Tab,Plits0,Plits,Nlits1,Nlits,Nseq1,Nseq)
        ).
relevant_lit((Ggoal - GH),Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	relevant_pos_lit(Ggoal,GH,_,Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq).

relevant_pos_lit(Ggoal,GH,Val,Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq) :-
	( find(Plits0,GH,v(Val0,_,_)) ->
	  Val0 = Val, Plits = Plits0, Nlits = Nlits0, Nseq = Nseq0
        ; find(Tab,Ggoal,Ent),
	  ent_to_anss(Ent,Anss),
	  find(Anss,GH,Lanss),
	  relevant_anshead(GH,Lanss,Val,Tab,Plits0,Plits,Nlits0,Nlits,Nseq0,Nseq)
        ).

one_psm(Tab0,Tab,Plits,Nseq) :-
	one_psm([],Tab0,Tab,Plits,Nseq).

one_psm(PSM0,Tab0,Tab,Plits,Nseq) :-
	assume_list(PSM0,true,Tab0,Tab1,Plits),
	st_enum(Nseq,Plits,Tab1,Tab).

assume_list([],_Val,Tab,Tab,_Plits).
assume_list([Lit|Lits],Val,Tab0,Tab,Plits) :-
	assume_one(Lit,Val,Tab0,Tab1,Plits),
	assume_list(Lits,Val,Tab1,Tab,Plits).

stableVar(v(_,V,_)):-!,nonvar(V).
stableVar(V):-nonvar(V).
	
assume_one(Lit,Val,Tab0,Tab,Plits) :-
	assume_one_val(Lit,Val,Ggoal,GH,AVal),
	find(Plits,GH,v(Val0,_Con,_)),
	( stableVar(Val0) ->
	  Val0 = AVal, Tab = Tab0
        ; Val0 = AVal,
	  propagate_forward(Ggoal,GH,AVal,Tab0,Tab1,Plits),
	  propagate_backward(Ggoal,GH,AVal,Tab1,Tab,Plits)
        ).

assume_one_val(Lit,Val,Ggoal,GH,AVal) :-
	( Lit = ( /*neg*/ \+ A) ->
	  Ggoal = A, GH = A, 
	  logComplement(Val,AVal)
        ; Lit = (Ggoal - GH) ->
	  AVal = Val
        ; Ggoal = Lit, GH = Lit, 
	  AVal = Val
        ).

/* propagate_forward(Ggoal,GH,Val,Tab0,Tab,Plits) : 
   G has been assumed to be Val, : this 
   information is propagated using simplification or 
   forward chaining links as much as possible.
*/
propagate_forward(Ggoal,GH,Val,Tab0,Tab,Plits) :-
	updatevs(Tab0,Ggoal,Ent0,Ent,Tab1),
	Ent0 = e(Nodes,ANegs,Anss,Delay,Comp,Gdfn,Slist0),
	Ent = e(Nodes,ANegs,Anss,Delay,Comp,Gdfn,Slist),
	extract_known_by_abd(Slist0,GH,Val,Slist,Klist),
	simplify(Klist,Tab1,Tab,Plits).

/* The forward chaining is such that negative literals can fail 
   or succeed by assumption, : positive literals can fail 
   by assumption, but cannot succeed by assumption.
   This avoids the construction of supported models that are 
   not stable.

   Klist is organized in such a way that self-looping links : 
   links with negative literals are put before others. The heuristics
   is that the simplification of such links may lead to 
   contradiction sooner if there is no stable model.
*/
extract_known_by_abd(Slist0,GH,Val,Slist,Klist) :-
	known_by_abd(Slist0,GH,Val,Slist,[],Klist,Ks,Ks,Kn,Kn,[]).

known_by_abd([],_GH,_Val,Slist,Slist,Ks,Ks,Kn,Kn,Kr,Kr).
known_by_abd([Link|Links],GH,Val,Slist0,Slist,Ks0,Ks,Kn0,Kn,Kr0,Kr) :-
	( Link = (GHead  :  ( /*neg*/ \+  GH)) ->
	  logComplement(Val,NVal),
	  Slist0 = Slist1, 
	  ( GHead = (GH-GH) -> % looping links
	    Ks0 = [NVal-Link|Ks1], Kn0 = Kn1, Kr0 = Kr1
	  ; Ks0 = Ks1, Kn0 = [NVal-Link|Kn1], Kr0 = Kr1
          )
        ; Val = false, Link = (GHead  :  _-GH) ->
	  Slist0 = Slist1,
	  ( GHead = (GH-GH) ->
	    Ks0 = [false-Link|Ks1], Kn0 = Kn1, Kr0 = Kr1
	  ; Ks0 = Ks1, Kn0 = Kn1, Kr0 = [false-Link|Kr1]
          )
	; Slist0 = [Link|Slist1], Ks0 = Ks1, Kn0 = Kn1, Kr0 = Kr1
        ),
	known_by_abd(Links,GH,Val,Slist1,Slist,Ks1,Ks,Kn1,Kn,Kr1,Kr).

/* propagate_backward(Ggoal,GH,Val,Tab0,Tab,Plits) : 
   It propagates the Val of GH backward through answers
   if possible. If GH is assumed to be true, : GH has only one
   answer clause, then all literals in the body of the answer
   clause must be true. If GH is assumed to be false, then all
   literals in answer clauses of GH that have a single literal
   are assumed to be false too. Otherwise, it is no-op.
*/

/*
% aggresive back propagation
propagate_backward(Ggoal,GH,Val,Tab0,Tab,Plits) :-
	find(Tab0,Ggoal,Ent),
	ent_to_anss(Ent,Anss),
	find(Anss,GH,Lanss),
	( Val == true ->
	  member(d(_,Ds),Lanss),
	  assume_list(Ds,true,Tab0,Tab,Plits)
        ; Val == false ->
	  assume_lanss_false(Lanss,Tab0,Tab,Plits)
        ).

assume_lanss_false([],Tab,Tab,_Plits).
assume_lanss_false([d(_,Ds)|Lanss],Tab0,Tab,Plits) :-
	member(Lit,Ds),
	assume_one(Lit,false,Tab0,Tab1,Plits),
	assume_lanss_false(Lanss,Tab1,Tab,Plits).
*/

% limited back propagation
propagate_backward(Ggoal,GH,Val,Tab0,Tab,Plits) :-
	find(Tab0,Ggoal,Ent),
	ent_to_anss(Ent,Anss),
	find(Anss,GH,Lanss),
	( Val == true, Lanss = [d(_,Ds)] ->
	  assume_list(Ds,true,Tab0,Tab,Plits)
        ; Val == false, findall(Lit,member(d(_,[Lit]),Lanss),Ds) ->
	  assume_list(Ds,false,Tab0,Tab,Plits)
        ; Tab = Tab0
        ).
	


/* st_enum(Nseq,Plits,Tab0,Tab) : 
   Nlits is a list where each node consists of a key 
   that is a stableGround atom whose negation is a delayed literal,
   : a value (not necessarily bound). st_enum traverses
   Nseq, : makes sure that every stableGround atom is 
   assigned some value.
*/
st_enum([],_Plits,Tab,Tab).
st_enum([(A,Val)|Nseq],Plits,Tab0,Tab) :-
	( stableVar(Val) -> % already has a value
	  Tab2 = Tab0
        ; ( Val = true; Val = false ),
	  wfs_trace(writeDebug('Choice point :  ' : A=Val)),
	  propagate_forward(A,A,Val,Tab0,Tab1,Plits),
	  propagate_backward(A,A,Val,Tab1,Tab2,Plits),
	  wfs_trace((
	    show_tree('Table after propagate_forward :  ', Tab1),
	    show_tree('Table after propagate_backward :  ', Tab2),
	    show_tree('Plits after propagation :  ',Plits)
          ))
        ),
	st_enum(Nseq,Plits,Tab2,Tab).

/* construct_psm(Plits,Nlits,Tab0,Tab,PSM0,PSM) : 
   A proposition may be assumed to be true, but no true answer
   is derived at the end, which is inconsistency.

   Also at the end of a fixpoint computation, a subgoal may
   have only delayed answers with positive literals. These
   have to be deleted in order for Tab0/Tab to be used
   correctly later.
*/
construct_psm([],_Nlits,Tab,Tab,PSM,PSM).
construct_psm(l(_,v(Val,Con,H)),Nlits,Tab0,Tab,PSM0,PSM) :-
	( Con == true -> % confirmed with the table
	  ( Val == true ->
	    PSM0 = [H|PSM], Tab = Tab0
	  ; Val == false, stableGround(H) ->
	    ( find(Nlits,H,Val) ->
	      PSM0 = [ /*neg*/ \+ H|PSM], Tab = Tab0
	    ; PSM0 = PSM, Tab = Tab0
	    )
	  ; PSM0 = PSM, Tab = Tab0
          )
        ; Val == true -> % assumption of true not confirmed
          fail
        ; Val = false -> % unconfirmed false
	  Tab = Tab0,    % this table needs to be updated to delete delayed answers
	  ( stableGround(H), find(Nlits,H,Val) ->
	    PSM0 = [ /*neg*/ \+ H|PSM]
	  ; PSM0 = PSM
          )
        ).
construct_psm(n2(T1,_,T2),Nlits,Tab0,Tab,PSM0,PSM) :-
	construct_psm(T1,Nlits,Tab0,Tab1,PSM0,PSM1),
	construct_psm(T2,Nlits,Tab1,Tab,PSM1,PSM).
construct_psm(n3(T1,_,T2,_,T3),Nlits,Tab0,Tab,PSM0,PSM) :-
	construct_psm(T1,Nlits,Tab0,Tab1,PSM0,PSM1),
	construct_psm(T2,Nlits,Tab1,Tab2,PSM1,PSM2),
	construct_psm(T3,Nlits,Tab2,Tab,PSM2,PSM).

/* top-level calls for request answering under the 
   well-founded semantics
*/
wfs_all(Call,Anss) :-
    wfs_all(Call,Anss,[],_Tab,0,_N,_Delay).

wfs_all(Call,Anss,Tab0,Tab,N0,N) :-
    wfs_all(Call,Anss,Tab0,Tab,N0,N,_Delay).

wfs_all(Call,Anss,Tab,Delay) :-
    wfs_all(Call,Anss,[],Tab,0,_N,Delay).

wfs_all(Call,Anss,Tab0,Tab,N0,N,Delay) :-
    stableGround(Call,Ggoal),
    ( find(Tab0,Ggoal,Ent) ->
      ent_to_anss(Ent,Anss),
      ent_to_delay(Ent,Delay),
      Tab = Tab0, N = N0
    ; new_init_call(Ggoal,Ent0,[],S1,1,Dfn1),
      add_tab_ent(Ggoal,Ent0,Tab0,Tab1),
      oldt(Call,Ggoal,Tab1,Tab,S1,_S,Dfn1,_Dfn,maxint-maxint,_Dep,N0 : [],N : _TP),
      find(Tab,Ggoal,Ent),
      ent_to_anss(Ent,Anss),
      ent_to_delay(Ent,Delay)
    ).

/* oldt(Call,Ggoal,Tab0,Tab,Stack0,Stack,DFN0,DFN,Dep0,Dep,TP0,TP)
   explores the initial set of edges, i.e., all the 
   program clauses for Call. Ggoal is of the form 
   Gcall-Gdfn, where Gcall is numbervar of Call : Gdfn
   is the depth-first number of Gcall. Tab0/Tab,Stack0/Stack,
   DFN0/DFN, : Dep0/Dep are accumulators for the table, 
   the stack of subgoals, the DFN counter, : the dependencies.
   TP0/TP is the accumulator for newly created clauses during
   the processing of general clauss with universal disjunctions
   in the body. These clauses are created in order to guarantee
   polynomial data complexity in processing clauses with
   universal disjuntions in the body of a clause. The newly 
   created propositions are represented by numbers.
*/

% :- assertLogged('slg$tabled'(_,_)).

oldt(Call,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-%true,
    ( number(Call) ->
      TP0 = (_  :  Tcl),
      find(Tcl,Call,Clause),
      edge_oldt(Clause,Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1)
    ; % findall(rule(d(Call,[]),Body),rule(Call,Body),Frames),
	findall(rule(d(Call,[]),Body),( prologSLGCall(Call,Body)  /*new_slg_head(Call,Body,NewHead), prologSLGCall(NewHead) */ ),Frames),
	map_oldt(Frames,Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1)
    ),
    comp_tab_ent(Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

map_oldt([],_Ggoal,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_oldt([Clause|Frames],Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-%true,
  edge_oldt(Clause,Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
  map_oldt(Frames,Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* edge_oldt(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
   Clause may be one of the following forms : 
          rule(d(H,Dlist),Blist)
          rule(d(H,all(Dlist)),all(Blist))
   where the second form is for general clauses with a universal
   disjunction of literals in the body. Dlist is a list of delayed 
   literals, : Blist is the list of literals to be solved.
   Clause represents a directed edge from Ggoal to the left most 
   subgoal in Blist.
*/
edge_oldt(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = rule(Ans,B),
    ( B == [] ->
      ans_edge(Ans,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ; B = [Lit|_] ->
      ( Lit = ( /*neg*/ \+ N) ->
        neg_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ; pos_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      )
    ; B = all(Bl) ->
      ( Bl == [] ->
        ans_edge(Ans,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ; Bl = [Lit|_],
        ( Lit = ( /*neg*/ \+ N) ->
          aneg_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        ; apos_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        )
      )
    ).

ans_edge(Ans,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( add_ans(Tab0,Ggoal,Ans,Nodes,Mode,Tab1) -> 
      ( Mode = new_head -> 
        returned_ans(Ans,Ggoal,RAns),
        map_nodes(Nodes,RAns,Tab1,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ; Mode = no_new_head ->
        Tab = Tab1, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
      )
    ; Tab = Tab0, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
    ).

neg_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = rule(_R,[ /*neg*/ (\+ N)|_L]),
    ( stableGround(N) -> true
    ; /*wfs_trace*/
    ((write('Flounder :  '), write(R -> [/*neg*/ \+ N|_L]), nl , 
	nonvar(N),
	not(recorded(N,N)) ->
		(copy_term(N,NC),
		numbervars(NC),
		recorda(N,NC)) ; fail ))
	),
    Node = (Ggoal : Clause),
    Ngoal = N,                 % N is already stableGround
    (	       /*
      isPrologCurrently(N) ->           % if N is a Prolog predicate
      ( 
      prologCall(N) ->             %    then just prologCall
        Tab = Tab0, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
      ; 
	apply_subst(Node,d( /*neg*/ \+  N,[]),Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ); */
      
      ( find(Tab0,Ngoal,Nent) ->
        Tab2 = Tab0, S2 = S0, Dfn2 = Dfn0, Dep1 = Dep0, TP1 = TP0
      ; new_init_call(Ngoal,Ent,S0,S1,Dfn0,Dfn1),
	add_tab_ent(Ngoal,Ent,Tab0,Tab1),
	oldt(N,Ngoal,Tab1,Tab2,S1,S2,Dfn1,Dfn2,maxint-maxint,Ndep,TP0,TP1),
	compute_mins(Dep0,Ndep,pos,Dep1),
        find(Tab2,Ngoal,Nent)
      ),
      ent_to_comp(Nent,Ncomp),
      ent_to_anss(Nent,Nanss),
      ( succeeded(Nanss) ->
	Tab = Tab2, S = S2, Dfn = Dfn2, Dep = Dep1, TP = TP1
      ; failed(Nanss), Ncomp == true ->
        apply_subst(Node,d( /*neg*/ \+ N,[]),Tab2,Tab,S2,S,Dfn2,Dfn,Dep1,Dep,TP1,TP)
      ; apply_subst(Node,d( /*neg*/ \+ N,[ /*neg*/ \+ N]),Tab2,Tab,S2,S,Dfn2,Dfn,Dep1,Dep,TP1,TP)
      )
    ).

pos_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = rule(_H, [N| _B]),
    Node = (Ggoal : Clause),
    stableGround(N,Ngoal),
    ( isPrologCurrently(N) ->
      findall(d(N,[]),prologCall(N),Nanss),
      map_anss_list(Nanss,Node,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ; ( find(Tab0,Ngoal,Nent) ->
        ent_to_comp(Nent,Ncomp),
        ent_to_anss(Nent,Nanss),
        ( Ncomp \== true ->
          update_lookup_mins(Ggoal,Node,Ngoal,pos,Tab0,Tab1,Dep0,Dep1),
          map_anss(Nanss,Node,Ngoal,Tab1,Tab,S0,S,Dfn0,Dfn,Dep1,Dep,TP0,TP)
        ; % N is completed. 
          map_anss(Nanss,Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        )
      ; % otherwise N is new
        new_pos_call(Ngoal,Node,Ent,S0,S1,Dfn0,Dfn1),
        add_tab_ent(Ngoal,Ent,Tab0,Tab1),
        oldt(N,Ngoal,Tab1,Tab2,S1,S,Dfn1,Dfn,maxint-maxint,Ndep,TP0,TP),
        update_solution_mins(Ggoal,Ngoal,pos,Tab2,Tab,Ndep,Dep0,Dep)
      )
    ).

aneg_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = rule(H,all([ /*neg*/ \+ N|Bs])),
    Node = (Ggoal : Clause),
    stableGround(N,Ngoal),
    ( isPrologCurrently(N) ->
      extract_prolog(Bs,N,PN,RestBs),
      findall(d(PN,[]),prologCall(PN),Nanss),
      NewNode = (Ggoal : rule(H,all([ /*neg*/ \+ PN|RestBs]))),
      return_to_disj_list(Nanss,NewNode,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ; stableGround(N) ->
      neg_edge(rule(H,[ /*neg*/ \+ N]),Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
      ( Bs == [] ->
        Tab = Tab1, S = S1, Dfn = Dfn1, Dep = Dep1, TP = TP1
      ; edge_oldt(rule(H,all(Bs)),Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP)
      )
    ; ( find(Tab0,Ngoal,Nent) ->
        ent_to_comp(Nent,Ncomp),
        ent_to_anss(Nent,Nanss),
        ( Ncomp \== true ->
          update_lookup_mins(Ggoal,Node,Ngoal,aneg,Tab0,Tab,Dep0,Dep),
          S = S0, Dfn = Dfn0, TP = TP0
        ; % N is completed. 
          return_to_disj(Nanss,Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        )
      ; % otherwise N is new
        new_aneg_call(Ngoal,Node,Ent,S0,S1,Dfn0,Dfn1),
        add_tab_ent(Ngoal,Ent,Tab0,Tab1),
        oldt(N,Ngoal,Tab1,Tab2,S1,S,Dfn1,Dfn,maxint-maxint,Ndep,TP0,TP),
        update_solution_mins(Ggoal,Ngoal,pos,Tab2,Tab,Ndep,Dep0,Dep)
      )
    ).

apos_edge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = rule(d(H,D),all([N|B])),
    ( stableGround(N) -> true
    ; write('Flounder in a universal disjunction :  '), 
      write(N), 
      nl, 
      fail
    ),
    pos_edge(rule(d(H,[]),[N]),Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    edge_oldt(rule(d(H,D),all(B)),Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

extract_prolog([],PN,PN,[]).
extract_prolog([Lit|Bs],PN0,PN,RestBs) :-
	( Lit = ( /*neg*/ \+ N) ->
	  CN = N
        ; Lit = N, CN = ( /*neg*/ \+ N)
        ),
	( isPrologCurrently(N) ->
	  extract_prolog(Bs,(PN0,CN),PN,RestBs)
        ; PN = PN0, RestBs = [Lit|Bs]
        ).

apply_subst(Ggoal : Cl,d(An,Vr),Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    copy_term(Cl,rule(d(Ac,Vc),Body)),
    ( Body = [Call|NBody] ->
      Call = An,
      append(Vr,Vc,Vn)
    ; Body = all([Call|Calls]),
      % Call = An,              % An is the numbervar-ed version of Call.
      ( Vc == [] ->
        Vn = all(Vr)
      ; Vc = all(Vc0),
        append(Vr,Vc0,Vn0),
        Vn = all(Vn0)
      ),
      NBody = all(Calls)
    ),
    edge_oldt(rule(d(Ac,Vn),NBody),Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP).

/* map_nodes(Nodes,Ans,....) : 
   return Ans to each of the waiting nodes in Nodes, where a node
   is of the form Ggoal : Clause.
*/  
map_nodes([],_Ans,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_nodes([Node|Nodes],Ans,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    apply_subst(Node,Ans,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_nodes(Nodes,Ans,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

map_anss([],_Node,_Ngoal,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_anss(l(_GH,Lanss),Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( Lanss == [] ->
      Tab = Tab0, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
    ; Lanss = [Ans|_],
      returned_ans(Ans,Ngoal,RAns),
      apply_subst(Node,RAns,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ).
map_anss(n2(T1,_,T2),Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_anss(T1,Node,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_anss(T2,Node,Ngoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).
map_anss(n3(T1,_,T2,_,T3),Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_anss(T1,Node,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_anss(T2,Node,Ngoal,Tab1,Tab2,S1,S2,Dfn1,Dfn2,Dep1,Dep2,TP1,TP2),
    map_anss(T3,Node,Ngoal,Tab2,Tab,S2,S,Dfn2,Dfn,Dep2,Dep,TP2,TP).

map_anss_list([],_Node,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_anss_list([Ans|Lanss],Node,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    apply_subst(Node,Ans,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_anss_list(Lanss,Node,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* return_to_disj(Nanss,Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
   Nanss :  an answer table for Ngoal
   Node :  is of the form (Ggoal : Clause), where Clause is of the form
         rule(d(H,D),all([ /*neg*/ \+ N|B]))
   It carries out resolution of each answer with Clause, : constructs
   a new clause rule(Head,NBody), where the body is basically a 
   conjunction of all the resolvents. If a resolvent is a disjunction
   or a non-stableGround literal, a new proposition is created (which is 
   actually represented by a number), which has a clause whose body
   is the resolvent.
*/
return_to_disj(Nanss,Node,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Node = (Ggoal  :  Clause),
    Clause = rule(Head,all(Body)),
    TP0 = (N0  :  Tcl0),
    negative_return_all(Nanss,Body,Ngoal,NBody,[],N0,N,Tcl0,Tcl),
    TP1 = (N  :  Tcl),
    edge_oldt(rule(Head,NBody),Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP1,TP).

negative_return_all([],_Body,_Ngoal,NBody,NBody,N,N,Tcl,Tcl).
negative_return_all(l(_GH,Lanss),Body,Ngoal,NBody0,NBody,N0,N,Tcl0,Tcl) :-
    ( Lanss == [] ->
      NBody0 = NBody, N = N0, Tcl = Tcl0
    ; Lanss = [Ans|_],
      negative_return_one(Ans,Body,Ngoal,NBody0,NBody,N0,N,Tcl0,Tcl)
    ).
negative_return_all(n2(T1,_,T2),Body,Ngoal,NBody0,NBody,N0,N,Tcl0,Tcl) :-
    negative_return_all(T1,Body,Ngoal,NBody0,NBody1,N0,N1,Tcl0,Tcl1),
    negative_return_all(T2,Body,Ngoal,NBody1,NBody,N1,N,Tcl1,Tcl).
negative_return_all(n3(T1,_,T2,_,T3),Body,Ngoal,NBody0,NBody,N0,N,Tcl0,Tcl) :-
    negative_return_all(T1,Body,Ngoal,NBody0,NBody1,N0,N1,Tcl0,Tcl1),
    negative_return_all(T2,Body,Ngoal,NBody1,NBody2,N1,N2,Tcl1,Tcl2),
    negative_return_all(T3,Body,Ngoal,NBody2,NBody,N2,N,Tcl2,Tcl).

negative_return_one(d(H,Tv),Body,Ngoal,NBody0,NBody,N0,N,Tcl0,Tcl) :-
    copy_term(Body,[ /*neg*/ \+ Call|Bs]),
    H = Call,
    ( Tv == [] ->                    % no delay
      ( (Bs = [Lit], stableGround(Lit)) -> % resovlent is a stableGround literal
        NBody0 = [Lit|NBody],
        N = N0, Tcl = Tcl0
      ; Lit = N0,                    % otherwise, replace it with a number
        N is N0+1,
        NBody0 = [Lit|NBody],
        Clause = rule(d(Lit,[]),all(Bs)),
        add_tab_ent(Lit,Clause,Tcl0,Tcl)
      )
    ; ( stableGround(H) ->                 % if there is delay, always replace with number
	NewTv = [ /*neg*/ \+ H]
      ; stableGround(H,GH),
	NewTv = [Ngoal - ( /*neg*/ \+ GH)]
      ),
      Lit = N0,
      N is N0+1,
      NBody0 = [Lit|NBody],
      Clause = rule(d(Lit,all(NewTv)),all(Bs)),
      add_tab_ent(Lit,Clause,Tcl0,Tcl)
    ).

return_to_disj_list(Lanss,Node,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Node = (Ggoal  :  Clause),
    Clause = rule(Head,all(Body)),
    TP0 = (N0  :  Tcl0),
    negative_return_list(Lanss,Body,NBody,[],N0,N,Tcl0,Tcl),
    TP1 = (N  :  Tcl),
    edge_oldt(rule(Head,NBody),Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP1,TP).

negative_return_list([],_Body,NBody,NBody,N,N,Tcl,Tcl).
negative_return_list([d(H,[])|Lanss],Body,NBody0,NBody,N0,N,Tcl0,Tcl) :-
    copy_term(Body,[ /*neg*/ \+ Call|Bs]),
    H = Call,
    ( Bs = [Lit], stableGround(Lit) ->
      NBody0 = [Lit|NBody1],
      N1 = N0, Tcl1 = Tcl0
    ; Lit = N0,
      N1 is N0+1,
      NBody0 = [Lit|NBody1],
      Clause = rule(d(Lit,[]),all(Bs)),
      add_tab_ent(Lit,Clause,Tcl0,Tcl1)
    ),
    negative_return_list(Lanss,Body,NBody1,NBody,N1,N,Tcl1,Tcl).

/* comp_tab_ent(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
   check if Ggoal : subgoals on top of it on the stack are
   completely evaluated.
*/
comp_tab_ent(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( Dep0 == maxint-maxint ->
      process_pos_scc(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP)
    ; update_mins(Ggoal,Dep0,pos,Tab0,Tab1,Gdfn,Gdep),
      Gdep = Gpmin-Gnmin,
      ( Gdfn @=< Gpmin, Gnmin == maxint ->
        process_pos_scc(Ggoal,Tab1,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP)
      ; Gdfn @=< Gpmin, Gdfn @=< Gnmin ->
        process_neg_scc(Ggoal,Tab1,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP)
      ; Tab = Tab1, S0 = S, Dfn = Dfn0, Dep = Gdep, TP = TP0
      )
    ).

process_pos_scc(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP) :-
    wfs_trace((
      write('Stack :  '), nl, display_stack(S0,Tab0),
      write('Completed prologCall found :  '), write(Ggoal), nl, 
      ignore(display_table(Tab0)),
      write('Completing calls ......'), nl, nl
    )),
    pop_subgoals(Ggoal,S0,S1,[],Scc),
    complete_comp(Scc,Tab0,Tab1,Alist,[]),
    return_aneg_nodes(Alist,Tab1,Tab,S1,S,Dfn0,Dfn,maxint-maxint,Dep,TP0,TP).

/* pop_subgoals(Ggoal,S0,S,Scc0,Scc)
   pop off the stack subgoals up to : including Ggoal
*/
pop_subgoals(Ggoal,S0,S,Scc0,Scc) :-
    S0 = [Sent|S1],
    ( Ggoal == Sent ->
      S = S1, 
      Scc = [Sent|Scc0]
    ; pop_subgoals(Ggoal,S1,S,[Sent|Scc0],Scc)
    ).

/* complete_comp(Scc,Tab0,Tab,Alist0,Alist) : 
   process the list Scc of subgoals that are 
   completely evaluated.
*/
complete_comp([],Tab,Tab,Alist,Alist).
complete_comp([Ggoal|Scc],Tab0,Tab,Alist0,Alist) :-
    complete_one(Ggoal,Tab0,Tab1,Alist0,Alist1),
    complete_comp(Scc,Tab1,Tab,Alist1,Alist).

/* complete_one(Ggoal,Tab0,Tab,Alist0,Alist)
   process one subgoal that has been completely 
   evaluated : 
   1. set its Nodes : Negs to [] : Comp to true;
   2. simplify its answers : set up links
      for further simplification later;
   3. use the truth value of Ggoal to simplify
      answers of other complete subgoals (possibly 
      including itself).
   4. set Alist0/Alist :  a list of negation nodes with
      universal disjunctions with associated answers
      for the selected negative literal.
*/
complete_one(Ggoal,Tab0,Tab,Alist0,Alist) :-
    updatevs(Tab0,Ggoal,Ent0,Ent,Tab1),
    Ent0 = e(_Nodes,ANegs,Anss0,Delay0,_Comp,Gdfn,Slist0),
    Ent = e([],[],Anss,Delay,true,Gdfn,Slist),
    ( Delay0 > 0 ->
      reduce_ans(Anss0,Anss,Tab0,Delay0,Delay),
      setup_simp_links(Anss,Ggoal,Slist0,Slist1,Tab1,Tab2)
    ; Delay = Delay0,
      Anss = Anss0,
      Tab2 = Tab1,
      Slist1 = Slist0
    ),
    extract_known(Ggoal,Anss,Slist1,Slist,Klist),
    simplify(Klist,Tab2,Tab,[]),
    ( ANegs == [] ->
      Alist0 = Alist
    ; Alist0 = [(Anss,Ggoal)-ANegs|Alist]
    ).

setup_simp_links([],_,Slist,Slist,Tab,Tab).
setup_simp_links(l(GH,Lanss),Ggoal,Slist0,Slist,Tab0,Tab) :-
    setup_simp_links_list(Lanss,Ggoal-GH,Ggoal,Slist0,Slist,Tab0,Tab).
setup_simp_links(n2(T1,_,T2),Ggoal,Slist0,Slist,Tab0,Tab) :-
    setup_simp_links(T1,Ggoal,Slist0,Slist1,Tab0,Tab1),
    setup_simp_links(T2,Ggoal,Slist1,Slist,Tab1,Tab).
setup_simp_links(n3(T1,_,T2,_,T3),Ggoal,Slist0,Slist,Tab0,Tab) :-
    setup_simp_links(T1,Ggoal,Slist0,Slist1,Tab0,Tab1),
    setup_simp_links(T2,Ggoal,Slist1,Slist2,Tab1,Tab2),
    setup_simp_links(T3,Ggoal,Slist2,Slist,Tab2,Tab).

/* setup_simp_link_list(Lanss,Ggoal-GH,Ggoal,Slist0,Slist,Tab0,Tab)
   Ggoal-GH is to tell what portion of answers of Ggoal can be 
   simplified.
*/
setup_simp_links_list([],_,_,Slist,Slist,Tab,Tab).
setup_simp_links_list([d(_,D)|Anss],GHead,Ggoal,Slist0,Slist,Tab0,Tab) :-
    ( D = all(Ds) ->
      true
    ; Ds = D
    ),
    links_from_one_delay(Ds,GHead,Ggoal,Slist0,Slist1,Tab0,Tab1),
    setup_simp_links_list(Anss,GHead,Ggoal,Slist1,Slist,Tab1,Tab).

/* A link ((Ggoal-GH) : Lit) in an entry for Ngoal means that 
   the literal Lit in an answer with head GH in Ggoal can 
   be potentially simplified if we know answers for Ngoal.
*/
links_from_one_delay([],_,_,Slist,Slist,Tab,Tab).
links_from_one_delay([D|Ds],GHead,Ggoal,Slist0,Slist,Tab0,Tab) :-
    ( D = ( /*neg*/ \+  Ngoal) ->
      ( Ggoal == Ngoal ->
        Tab1 = Tab0,
	Slist1 = [GHead : D|Slist0]
      ; add_link_to_ent(Tab0,Ngoal,GHead : D,Tab1),
	Slist1 = Slist0
      )
    ; D = (Ngoal-_) ->
      ( Ggoal == Ngoal ->
        Slist1 = [GHead : D|Slist0],
        Tab1 = Tab0
      ; Slist1 = Slist0,
        add_link_to_ent(Tab0,Ngoal,GHead : D,Tab1)
      )
    ),
    links_from_one_delay(Ds,GHead,Ggoal,Slist1,Slist,Tab1,Tab).

/* extract_known(Ggoal,Anss,Links,Slist,Klist) : 
   Given Ggoal : its answers Anss, : its 
   simplification Links, it partitioned Links 
   into Slist : Klist of links, where Klist 
   is a list of links that are known to be either
   true or false.

   Klist is either of the form Val-Links, or a
   list of the form Val-Link. In case of non-stableGround
   calls, the corresponding portion of Anss has to 
   be searched.
*/
extract_known(Ggoal,Anss,Links,Slist,Klist) :-
    ( failed(Anss) ->
      Klist = false-Links,
      Slist = []
    ; Anss = l(GH,Lanss) ->
      ( Ggoal == GH ->       % Ground or most general prologCall
	( memberchk(d(_,[]),Lanss) ->
	  Klist = true-Links,
	  Slist = []
        ; Klist = [],
	  Slist = Links
        )
      ; % non-stableGround prologCall
	extract_known_anss(Links,Anss,[],Slist,[],Klist)
      )
    ; % non-stableGround prologCall
      extract_known_anss(Links,Anss,[],Slist,[],Klist)
    ).
      
extract_known_anss([],_,Slist,Slist,Klist,Klist).
extract_known_anss([Link|Links],Anss,Slist0,Slist,Klist0,Klist) :-
    Link = (_ : Lit),
    extract_lit_val(Lit,Anss,true,Val),
    ( Val == undefined ->
      Slist1 = [Link|Slist0],
      Klist1 = Klist0
    ; Slist1 = Slist0,
      Klist1 = [Val-Link|Klist0]
    ),
    extract_known_anss(Links,Anss,Slist1,Slist,Klist1,Klist).

/* extract_lit_val(Lit,Anss,Comp,Val) : 
   extract the truth value of Lit according to Anss : Comp.
   In case of a non-stableGround calls, the corresponding portion
   of Anss has to be searched.
*/
extract_lit_val(Lit,Anss,Comp,Val) :-
    ( Lit = ( /*neg*/ \+  _) ->
      ( succeeded(Anss) ->
        Val = fail
      ; failed(Anss), Comp == true ->
        Val = succ
      ; Val = undefined
      )
    ; Lit = (_ - ( /*neg*/ \+ GH)) ->
      ( find(Anss,GH,Lanss) ->
        ( ( not(not(memberchk(d(GH,[]),Lanss)))) ->
          Val = fail
        ; Lanss == [], Comp == true ->
	  Val = succ
        ; Val = undefined
        )
      ; ( Comp == true ->
	  Val = succ
        ; Val = undefined
        )
      )
    ; Lit = (_-GH) ->
      ( find(Anss,GH,Lanss) ->
        ( (not(not(memberchk(d(GH,[]),Lanss)))) ->
          Val = succ
        ; Lanss == [], Comp == true ->
	  Val = fail
        ; Val = undefined
        )
      ; ( Comp == true ->
	  Val = fail
        ; Val = undefined
        )
      )
    ).

/* simplify(KnownLinks,Tab0,Tab,Plits) : 
   Given a list of KnownLinks, Tab0 : Abd,
   it tries to simplify answers according to
   KnownLinks. When a subgoal is found to be
   true or false according to answers, 
   consistency with assumed truth values in Abd
   is checked.
*/
simplify([],Tab,Tab,_Plits).
simplify([Val-Link|Klist],Tab0,Tab,Plits) :-
    simplify_one(Val,Link,Tab0,Tab1,Plits),
    simplify(Klist,Tab1,Tab,Plits).
simplify(Val-Links,Tab0,Tab,Plits) :-
    simplify_list(Links,Val,Tab0,Tab,Plits).	     

simplify_list([],_,Tab,Tab,_Plits).
simplify_list([Link|Links],Val,Tab0,Tab,Plits) :-
    Link = (_  :  Lit),
    ( ( Lit = ( /*neg*/ \+ _); Lit = (_ - ( /*neg*/ \+ _)) ) ->
      logComplement(Val,LVal)
    ; LVal = Val
    ),
    simplify_one(LVal,Link,Tab0,Tab1,Plits),
    simplify_list(Links,Val,Tab1,Tab,Plits).

simplify_one(Val,Link,Tab0,Tab,Plits) :-
    Link = ((Ngoal - GH)  :  Lit),
    updatevs(Tab0,Ngoal,Ent0,Ent,Tab1),
    Ent0 = e(Nodes,ANegs,Anss0,Delay0,Comp,Dfn,Slist0),
    Ent = e(Nodes,ANegs,Anss,Delay,Comp,Dfn,Slist),
    ( updatevs(Anss0,GH,Lanss0,Lanss,Anss) ->
      simplify_anss(Lanss0,Val,Lit,[],Lanss,DVal),
      update_delay(Delay0,Lanss0,Lanss,Delay),
      ( stableVar(DVal) ->
        ( find(Plits,GH,v(AVal,Con,_)) ->
          AVal = DVal, Con = true  % check consistency with assumed value
        ; true
        ),
	extract_known_by_der(Slist0,GH,DVal,[],Slist,[],Klist),
	simplify(Klist,Tab1,Tab,Plits)
      ; Slist = Slist0, Tab = Tab1
      )
    ; Tab = Tab0
    ).

extract_known_by_der([],_GH,_Val,Slist,Slist,Klist,Klist).
extract_known_by_der([Link|Links],GH,Val,Slist0,Slist,Klist0,Klist) :-
	( Link = (_  :  ( /*neg*/ \+  GH)) ->
	  logComplement(Val,NVal),
	  Slist1 = Slist0, Klist1 = [NVal-Link|Klist0]
        ; Link = (_  :  _-GH) ->
	  Slist1 = Slist0,
	  Klist1 = [Val-Link|Klist0]
	; Slist1 = [Link|Slist0], Klist1 = Klist0
        ),
	extract_known_by_der(Links,GH,Val,Slist1,Slist,Klist1,Klist).

/* simplify_anss(List,Val,Lit,Lanss0,Lanss,DVal) : 
   Given a List of answers, Val of Lit, it 
   simplifies the List : construct a new list
   Lanss0/Lanss of answers.

   As soon as a true answer is detected, all
   other answers with the same head are deleted.
*/
simplify_anss([],_,_,Anss,Anss,DVal) :-
    ( Anss = [] ->
      DVal = false
    ; true
    ).
simplify_anss([Ans|Rest],Val,Lit,Anss0,Anss,DVal) :-
    ( simplify_ans(Ans,Val,Lit,NewAns) ->
      ( NewAns = d(_,[]) ->
        Anss = [NewAns], DVal = true
      ; Anss1 = [NewAns|Anss0],
        simplify_anss(Rest,Val,Lit,Anss1,Anss,DVal)
      )
    ; simplify_anss(Rest,Val,Lit,Anss0,Anss,DVal)
    ).

simplify_ans(Ans,Val,Lit,NewAns) :-
    Ans = d(H,Ds),
    ( Ds == [] ->
      NewAns = Ans
    ; Ds = all(Dlist) ->
      ( Val == false ->
        delete_lit(Dlist,Lit,NewDlist,[]),
        ( NewDlist == [] ->
          fail
        ; NewAns = d(H,all(NewDlist))
        )
      ; % Val == true ->
        ( memberchk(Lit,Dlist) ->
          NewAns = d(H,[])
        ; NewAns = Ans
        )
      )
    ; % Ds is a conjunction
      ( Val == false ->
        ( memberchk(Lit,Ds) ->
          fail
        ; NewAns = Ans
        )
      ; % Val == true ->
        delete_lit(Ds,Lit,NewDs,[]),
        NewAns = d(H,NewDs)
      )
    ).

/* delete_lit(Delays,Lit,Ds0,Ds) : 
   deletes Lit from Delays. Delays is 
   a list of delayed literals : it
   is guaranteed to have no duplicates.
*/
delete_lit([],_,Ds,Ds).
delete_lit([D|Rest],Lit,Ds0,Ds) :-
    ( D == Lit ->
      Ds0 = Rest
    ; Ds0 = [D|Ds1],
      delete_lit(Rest,Lit,Ds1,Ds)
    ).

% return answers to negative nodes within universal disjunctions
return_aneg_nodes([],Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
return_aneg_nodes([(Anss,Ngoal)-ANegs|Alist],Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_anegs(ANegs,Anss,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    return_aneg_nodes(Alist,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

map_anegs([],_Anss,_Ngoal,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_anegs([Node|ANegs],Anss,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    return_to_disj(Anss,Node,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_anegs(ANegs,Anss,Ngoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* process a component of subgoals that may be involved in 
   negative loops.
*/
process_neg_scc(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP) :-
    wfs_trace((
      write('Stack :  '), nl, display_stack(S0,Tab0),
      write('Possible negative loop :  '), write(Ggoal), nl, 
      ignore(display_table(Tab0))
    )),
    extract_subgoals(Ggoal,S0,Scc,[]),
    reset_nmin(Scc,Tab0,Tab1,Ds,[]),
    wfs_trace((write('Delaying :  '), display_dlist(Ds))),
    delay_and_cont(Ds,Tab1,Tab2,S0,S1,Dfn0,Dfn1,maxint-maxint,Dep1,TP0,TP1),
    recomp_scc(Scc,Tab2,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* extract_subgoals(Ggoal,S0,Scc0,Scc)
   extract subgoals that may be involved in negative loops,
   but leave the stack of subgoals intact.
*/
extract_subgoals(Ggoal,[Sent|S],[Sent|Scc0],Scc) :-
    ( Ggoal == Sent ->
      Scc0 = Scc
    ; extract_subgoals(Ggoal,S,Scc0,Scc)
    ).

/* reset_nmin(Scc,Tab0,Tab,Dnodes0,Dnodes)
   reset NegLink : collect all waiting nodes that need to be 
   delayed. Dnodes0/Dnodes is a difference list.
*/
reset_nmin([],Tab,Tab,Ds,Ds).
reset_nmin([Ggoal|Scc],Tab0,Tab,Ds0,Ds) :-
    get_and_reset_negs(Tab0,Ggoal,ANegs,Tab1),
    ( ANegs == [] ->
      Ds0 = Ds1
    ; Ds0 = [Ggoal-ANegs|Ds1]
    ),
    reset_nmin(Scc,Tab1,Tab,Ds1,Ds).

delay_and_cont([],Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
delay_and_cont([Ggoal-Negs|Dnodes],Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_nodes(Negs,d( /*neg*/ \+ Ggoal,[ /*neg*/ \+ Ggoal]),Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    delay_and_cont(Dnodes,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

recomp_scc([],Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
recomp_scc([Ggoal|Scc],Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    comp_tab_ent(Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    recomp_scc(Scc,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* routines for incremental update of dependency information
*/

/* update_mins(Ggoal,Dep,Sign,Tab0,Tab,Gdfn,Gdep)
   update the PosLink : NegLink of Ggoal according to 
   Dep : Sign
*/
update_mins(Ggoal,Dep,Sign,Tab0,Tab,Gdfn,Gdep) :-
    Ent0 = e(Nodes,ANegs,Anss,Delay,Comp,Gdfn : Gdep0,Slist),
    Ent = e(Nodes,ANegs,Anss,Delay,Comp,Gdfn : Gdep,Slist),
    updatevs(Tab0,Ggoal,Ent0,Ent,Tab),
    compute_mins(Gdep0,Dep,Sign,Gdep).

/* update_lookup_mins(Ggoal,Node,Ngoal,Sign,Tab0,Tab,Dep0,Dep)
   There is a lookup edge (Node) from Ggoal to Ngoal 
   with Sign. It adds Node to the corresponding waiting list
   in Ngoal : then update the dependencies of Ggoal.
*/
update_lookup_mins(Ggoal,Node,Ngoal,Sign,Tab0,Tab,Dep0,Dep) :-
    updatevs(Tab0,Ngoal,Ent0,Ent,Tab1),
    ( Sign == pos ->
      pos_to_newent(Ent0,Ent,Node)
    ; Sign == aneg ->
      aneg_to_newent(Ent0,Ent,Node)
    ),
    Ent0 = e(_,_,_,_,_,_Ndfn : Ndep,_),
    compute_mins(Dep0,Ndep,Sign,Dep),
    update_mins(Ggoal,Ndep,Sign,Tab1,Tab,_,_).

/* update_solution_mins(Ggoal,Ngoal,Sign,Tab0,Tab,Ndep,Dep0,Dep)
   There is an edge with Sign from Ggoal to Ngoal, where Ngoal is 
   a new subgoal. Ndep is the final dependency information of 
   Ngoal. Dep0/Dep is for the most recent enclosing new prologCall.
   This predicate is called after Ngoal is solved.
*/
update_solution_mins(Ggoal,Ngoal,Sign,Tab0,Tab,Ndep,Dep0,Dep) :-
    find(Tab0,Ngoal,Nent),
    ent_to_comp(Nent,Ncomp),
    ( Ncomp == true ->
      ( Ndep == maxint-maxint ->
        Tab = Tab0, Dep = Dep0
      ; update_mins(Ggoal,Ndep,pos,Tab0,Tab,_,_),
        compute_mins(Dep0,Ndep,pos,Dep)
      )
    ; update_mins(Ggoal,Ndep,Sign,Tab0,Tab,_,_),
      compute_mins(Dep0,Ndep,Sign,Dep)
    ).

compute_mins(Gpmin-Gnmin,Npmin-Nnmin,Sign,Newpmin-Newnmin) :-
    ( Sign == pos ->
      getMin(Gpmin,Npmin,Newpmin),
      getMin(Gnmin,Nnmin,Newnmin)
    ; % (Sign == neg; Sign == aneg) ->
      Newpmin=Gpmin,
      getMin(Gnmin,Npmin,Imin), 
      getMin(Imin,Nnmin,Newnmin)
    ).

update_delay(Delay0,Lanss0,Lanss,Delay) :-
    ( hasdelays(Lanss0),  not(hasdelays(Lanss)) ->
      Delay is Delay0 - 1
    ; not(hasdelays(Lanss0)), hasdelays(Lanss) ->
      Delay is Delay0 + 1
    ; Delay = Delay0
    ).

hasdelays([d(_,[_|_])|_]).

getMin(X,Y,M) :- ( X @< Y -> M=X; M=Y ).

%%%%%%%%%%%%%%% Local table manipulation predicates %%%%%%%%%%

/* Table Entry Structure : 
   For each Call, its table entry is identified with its number-vared
   version -- Ggoal. Its value is a term of the form

    e(Nodes,ANegs,Anss,Delay,Comp,Dfn : Dep,Slist)

   where
     Nodes :   positive suspension list
     ANegs :   negative suspension list (for universal disjunction clauss)
     Anss :    another table.
     Delay :   a counter of answer heads with delays
     Comp :    whether Call is completely evaluated or not
     Dfn :     depth-first number of Gcall
     Dep :     (PosLink-NegLink) --- dependency information
     Slist :   a list of nodes whose answers may be simplified
             if the truth value of Ggoal is known. Each element of Slist
         is of the form (Ngoal-GH) : Literal.
   Stack Entry Structure : 
     Ggoal
*/

/* routines for accessing individual fields of an entry
*/
ent_to_nodes(e(Nodes,_,_,_,_,_,_),Nodes).
	ent_to_anegs(e(_,ANegs,_,_,_,_,_),ANegs).
ent_to_anss(e(_,_,Anss,_,_,_,_),Anss).
ent_to_delay(e(_,_,_,Delay,_,_,_),Delay).
ent_to_comp(e(_,_,_,_,Comp,_,_),Comp).
ent_to_dfn(e(_,_,_,_,_,Dfn,_),Dfn).
ent_to_slist(e(_,_,_,_,_,_,Slist),Slist).

get_and_reset_negs(Tab0,Ggoal,ANegs,Tab) :-
    Ent0 = e(Nodes,ANegs,Anss,Delay,Comp,Gdfn :  (Gpmin - _),Slist),
    Ent = e(Nodes,[],Anss,Delay,Comp,Gdfn : Gpmin-maxint,Slist),
    updatevs(Tab0,Ggoal,Ent0,Ent,Tab).

/* adding a new table entry
*/
add_tab_ent(Ggoal,Ent,Tab0,Tab) :- 
    addkey(Tab0,Ggoal,Ent,Tab).

/* The following three routines are for creating
   new calls
*/
/* a new prologCall with empty suspensions 
*/
new_init_call(Ggoal,Ent,S0,S,Dfn0,Dfn) :-
    S = [Ggoal|S0],
    Dfn is Dfn0+1,
    Ent = e([],[],[],0,false,Dfn0 : Dfn0-maxint,[]).

/* a new prologCall with an initial negative suspension from 
   inside a universal disjunction
*/
new_aneg_call(Ngoal,Neg,Ent,S0,S,Dfn0,Dfn) :-
    S = [Ngoal|S0],
    Dfn is Dfn0+1,
    Ent = e([],[Neg],[],0,false,Dfn0 : Dfn0-maxint,[]).

/* a new prologCall with an initial positive suspension
*/
new_pos_call(Ngoal,Node,Ent,S0,S,Dfn0,Dfn) :-
    S = [Ngoal|S0],
    Dfn is Dfn0+1,
    Ent = e([Node],[],[],0,false,Dfn0 : Dfn0-maxint,[]).

/* routines for adding more information to a
   table entry.
*/
aneg_to_newent(Ent0,Ent,ANeg) :-
    Ent0 = e(Nodes,ANegs,Anss,Delay,Comp,Dfn,Slist),
    Ent = e(Nodes,[ANeg|ANegs],Anss,Delay,Comp,Dfn,Slist).

pos_to_newent(Ent0,Ent,Node) :-
    Ent0 = e(Nodes,ANegs,Anss,Delay,Comp,Dfn,Slist),
    Ent = e([Node|Nodes],ANegs,Anss,Delay,Comp,Dfn,Slist).

add_link_to_ent(Tab0,Ggoal,Link,Tab) :-
    updatevs(Tab0,Ggoal,Ent0,Ent,Tab),
    link_to_newent(Ent0,Ent,Link).

link_to_newent(Ent0,Ent,Link) :-
    Ent0 = e(Nodes,ANegs,Anss,Delay,Comp,Dfn,Slist),
    Ent = e(Nodes,ANegs,Anss,Delay,Comp,Dfn,[Link|Slist]).

/* routines for manipulating answers */
ansstree_to_list([],L,L).
ansstree_to_list(l(_GH,Lanss),L0,L) :-
    attach(Lanss,L0,L).
ansstree_to_list(n2(T1,_M,T2),L0,L) :-
    ansstree_to_list(T1,L0,L1),
    ansstree_to_list(T2,L1,L).
ansstree_to_list(n3(T1,_M2,T2,_M3,T3),L0,L) :-
    ansstree_to_list(T1,L0,L1),
    ansstree_to_list(T2,L1,L2),
    ansstree_to_list(T3,L2,L).

attach([],L,L).
attach([d(H,B)|R],[X|L0],L) :-
    ( B == [] ->
      X = H
    ; X = (H <- B)
    ),
    attach(R,L0,L).

member_anss(Ans,Anss) :-
	member_anss_1(Anss,Ans).

member_anss_1(l(_,Lanss),Ans) :-
	member(Ans,Lanss).
member_anss_1(n2(T1,_,T2),Ans) :-
	( member_anss_1(T1,Ans)
        ; member_anss_1(T2,Ans)
        ).
member_anss_1(n3(T1,_,T2,_,T3),Ans) :-
	( member_anss_1(T1,Ans)
        ; member_anss_1(T2,Ans)
        ; member_anss_1(T3,Ans)
        ).

/* failed(Anss) :  Anss is empty */
failed([]).
failed(l(_,[])).

/* succeeded(Anss) :  Anss contains a single definite answer */
succeeded(l(_,Lanss)) :-
	memberchk(d(_,[]),Lanss).

/* add_ans(Tab0,Goal,Ans,Nodes,Mode,Tab) : 
   If Ans is not subsumed by any existing answer then
      Ans is added to Anss(Goal);
      If some existing answer also has head H then
         Mode = no_new_head
      else 
         Mode = new_head
   else
      fail.
*/
add_ans(Tab0,Ggoal,Ans,Nodes,Mode,Tab) :-
    updatevs(Tab0,Ggoal,Ent0,Ent,Tab),
    Ans = d(H,Ds),
    ( Ds == [] ->
      new_ans_ent(Ent0,Ent,Ans,Nodes,Mode)
    ; setof(X,member(X,Ds),NewDs),
      new_ans_ent(Ent0,Ent,d(H,NewDs),Nodes,Mode)
    ).

new_ans_ent(Ent0,Ent,Ans,Nodes,Mode) :-
    Ent0 = e(Nodes,ANegs,Anss0,Delay0,Comp,Dfn,Slist),
    Ent = e(Nodes,ANegs,Anss,Delay,Comp,Dfn,Slist),
    Ans = d(H,D),
    stableGround(H,GH),
    ( updatevs(Anss0,GH,Lanss0,Lanss,Anss) ->
      ( D == [] ->
         not(memberchk(d(_,[]),Lanss0)),
        Lanss = [Ans]
      ; not_subsumed_ans(Ans,Lanss0),
        Lanss = [Ans|Lanss0]
      ),
      update_delay(Delay0,Lanss0,Lanss,Delay),
      Mode = no_new_head
    ; addkey(Anss0,GH,[Ans],Anss),
      update_delay(Delay0,[],[Ans],Delay),
      Mode = new_head     
    ).

/* returned_ans(Ans,Ggoal,RAns) : 
   determines whether SLG resolution or SLG factoring should 
   be applied.
*/
returned_ans(d(H,Tv),Ggoal,d(H,NewTv)) :-
    ( Tv = [] ->
      NewTv = []
    ; stableGround(H,GH),
      NewTv = [Ggoal-GH]
    ).

% reduce a list of answers, by reducing delay list, : by subsumption
reduce_ans(Anss0,Anss,Tab,Delay0,Delay) :-
    reduce_completed_ans(Anss0,Anss,Tab,Delay0,Delay).

% simplify all the delay lists in a list of answers.
reduce_completed_ans([],[],_Tab,Delay,Delay).
reduce_completed_ans(l(GH,Lanss0),l(GH,Lanss),Tab,Delay0,Delay) :-
    reduce_completed_anslist(Lanss0,[],Lanss,Tab),
    update_delay(Delay0,Lanss0,Lanss,Delay).
reduce_completed_ans(n2(T1,M,T2),n2(NT1,M,NT2),Tab,Delay0,Delay) :-
    reduce_completed_ans(T1,NT1,Tab,Delay0,Delay1),
    reduce_completed_ans(T2,NT2,Tab,Delay1,Delay).
reduce_completed_ans(n3(T1,M2,T2,M3,T3),n3(NT1,M2,NT2,M3,NT3),Tab,Delay0,Delay) :-
    reduce_completed_ans(T1,NT1,Tab,Delay0,Delay1),
    reduce_completed_ans(T2,NT2,Tab,Delay1,Delay2),
    reduce_completed_ans(T3,NT3,Tab,Delay2,Delay).

reduce_completed_anslist([],Lanss,Lanss,_Tab).
reduce_completed_anslist([d(G,D0)|List],Lanss0,Lanss,Tab) :-
    ( D0 = all(Dlist1) ->
      ( filter_delays(Dlist1,[],Dlist,disj,V,Tab) ->
        ( V == true ->       % true answer
          Lanss = [d(G,[])]
        ; Dlist == [] ->     % false answer, ignore
          reduce_completed_anslist(List,Lanss0,Lanss,Tab)
        ; reduce_completed_anslist(List,[d(G,all(Dlist))|Lanss0],Lanss,Tab)
        )
      ; reduce_completed_anslist(List,Lanss0,Lanss,Tab)
      )
    ; ( filter_delays(D0,[],D,conj,_V,Tab) ->
	( D == [] ->
	  Lanss = [d(G,[])]
        ; reduce_completed_anslist(List,[d(G,D)|Lanss0],Lanss,Tab)
        )
      ; reduce_completed_anslist(List,Lanss0,Lanss,Tab)
      )
    ).

% simplify a delay list by the completed table :  delete true negations,
%    fail if a false one.
filter_delays([],Fds,Fds,_DC,_V,_Tab).
filter_delays([Lit|Ds],Fds0,Fds,DC,V,Tab) :-
    lit_to_call(Lit,Gcall),
    find(Tab,Gcall,Gent),
    ent_to_comp(Gent,Gcomp),
    ent_to_anss(Gent,Ganss),
    extract_lit_val(Lit,Ganss,Gcomp,Val),
    ( Val == succ ->
      ( DC == conj ->
        filter_delays(Ds,Fds0,Fds,DC,V,Tab)
      ; DC == disj ->
        V = true
      )
    ; Val == fail ->
      ( DC == conj ->
        fail
      ; DC == disj ->
        filter_delays(Ds,Fds0,Fds,DC,V,Tab)
      )
    ; % Val == undefined
      filter_delays(Ds,[Lit|Fds0],Fds,DC,V,Tab)
    ).

lit_to_call( /*neg*/ \+ G,G).
lit_to_call(Gcall-_,Gcall).

not_subsumed_ans(Ans,Lanss0) :-
     not((numbervars(Ans,0,_),subsumed_ans1(Ans,Lanss0))).

% succeed if answer is subsumed by any in list1 or 2.
subsumed_ans(Tv,List1,List2) :- 
    not((
      numbervars(Tv,0,_),
      not(subsumed_ans1(Tv,List1)),
      not(subsumed_ans1(Tv,List2))
      )).

% check if a delay is subsumed one of the element in the list
subsumed_ans1(d(T,V),List) :-
    member(d(T,V1),List),
    ( V1 == []
    ; V = all(LV), V1 = all(LV1) ->
      subsetchk(LV,LV1)
    ; subsetchk(V1,V)
    ).

/****************** auxiliary routines *******************/
% variantchk/2 finds a variant in a list of atoms.
variantchk(G,[G1|_]) :- variant(G,G1), !.
variantchk(G,[_|L]) :- variantchk(G,L).

variant(A, B) :-
    A == B
     ->    true
     ;     subsumes_chk(A, B),
           subsumes_chk(B, A),
           A = B.
/*
subsumes_chk(General, Specific) :-
         not(  (    numbervars(Specific, 0, _),
                 not( General = Specific)
         )).
*/
stableGround(O,C) :- stableGround(O) -> C = O ; copy_term(O,C), numbervars(C,0,_).


subsetchk([],_).
subsetchk([E|L1],L2) :- memberchk(E,L2), subsetchk(L1,L2).



reverse([],R,R).
reverse([Goal|Scc],R0,R) :- reverse(Scc,[Goal|R0],R).



/***************** routines for debugging *******************/

wfs_trace(X):- (wfs_trace ->  X ; true ),!.

% Debugging help :  pretty-prints strongly connected components : local table.
display_stack(Stack,Tab) :-
    reverse(Stack,[],Rstack),
    display_st(Rstack,Tab).
display_st([],_Tab).
display_st([Ggoal|Scc],Tab) :-
    find(Tab,Ggoal,Ent),
    ent_to_dfn(Ent,Dfn : Pmin-Nmin),
    tab(2), 
    write(Ggoal-Dfn),
    write(' :   '),
    write('Pmin='),
    write(Pmin),
    write(';  '),
    write('Nmin='),
    write(Nmin),
    write(';  '),
    nl,
    display_st(Scc,Tab).

display_dlist([]) :- nl,nl.
display_dlist([Ngoal-_|Dlist]) :-
    write( /*neg*/ \+  Ngoal), 
    write('; '), 
    display_dlist(Dlist).

display_table(Tab) :-
    write('Table :  '), 
    nl,
    write_tab(Tab).

display_final(Tab) :-
    write(' Final Set of Answers :  '), 
    nl,
    display_final1(Tab).
display_final1([]).
display_final1(l(_,e(_,_,Anss,_,_,_,_))) :-
    write_anss(Anss).
display_final1(n2(X,_,Y)) :- 
    display_final1(X),
    display_final1(Y).
display_final1(n3(X,_,Y,_,Z)) :- 
    display_final1(X),
    display_final1(Y),
    display_final1(Z).

write_tab([]).
write_tab( l(G, e(Nodes,ANegs,Anss,_,Comp,Dfn : _,_))) :-!,
    write(' Entry :  '),
    write(G-Dfn),
    write(' :  '),
    ( Comp == true -> 
      write('Complete!')
    ; write('Incomplete!') 
    ), 
    nl,
    ( Anss == [] -> 
      true
    ; write('   Anss :  '), 
      nl,
      ignore(write_anss(Anss))
    ),
    ( ( Comp == true; Nodes == []) -> 
      true 
    ; write('   Nodes :  '),
      write(Nodes),
      nl
    ),
    ( ( Comp == true; ANegs == []) ->
      true
    ; write('   ANegs :  '),
      write(ANegs),
      nl
    ),!.
write_tab(n2(X,_,Y)) :-!,
    write_tab(X),
    write_tab(Y).
write_tab(n3(X,_,Y,_,Z)) :-!, 
    write_tab(X),
    write_tab(Y),
    write_tab(Z).
    
write_tab(Q):-!. %write_conj(Q).

%writec_conj(Q):-Q=..[F|Args],


write_anss([]).
write_anss(l(_,Lanss)) :-!,
    write_anss_list(Lanss).
write_anss(n2(T1,_,T2)) :- !,
    write_anss(T1),
    write_anss(T2).
write_anss(n3(T1,_,T2,_,T3)) :-	 !,
    write_anss(T1),
    write_anss(T2),
    write_anss(T3).

write_anss_list([]).
write_anss_list([Ans|Anss]) :-
    write_ans(Ans),!,
    write_anss_list(Anss).

write_ans(d(H,Ds)) :-
    write('         '), 
    write(H),
    ( Ds == [] -> 
      true
    ; write(' :- '),
      ( Ds = all([D|Ds1]) ->
        ( D = (_-GH) ->
          write(GH)
        ; write(D)
        ),
        write_delay(Ds1,'; ')
      ; Ds = [D|Ds1],
        ( D = (_-GH) ->
          write(GH)
        ; write(D)
        ),
        write_delay(Ds1,', ')
      )
    ), 
    write('.'), 
    nl.
write_delay([],_).
write_delay([D|Ds1],Sep) :-
    write(Sep),
    ( D = (_Gcall-GH) -> 
      write(GH)
    ; write(D) 
    ),
    write_delay(Ds1,Sep).

show_tree(Msg,Tree) :-
	write(Msg), nl,
	show_tree(Tree).
show_tree([]).
show_tree(l(Key,Val)) :-
    tab(2), write(Key), write(' :  '), write(Val), nl.
show_tree(n2(X,_,Y)) :- 
    show_tree(X),
    show_tree(Y).
show_tree(n3(X,_,Y,_,Z)) :- 
    show_tree(X),
    show_tree(Y),
    show_tree(Z).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/* 
This is a set of routines that supports indexed tables. Tables
are sets of key-value_list pairs. With each key is associated a list
of values. It uses 2-3 trees for the index (modified by D.S. Warren
from Ivan Bratko :  ``Prolog Programming for Artificial
Intelligence'', Addison Wesley, 1986). Operations are :  

Keys must be stableGround! (so numbervar them)

addkey(Tree,Key,V,Tree1) adds a new Key with value V, returning 
    new Tree1. Fails if the key is already there.

find(Tree,Key,V) finds the entry with Key : returns associated
    values in V.

updatevs(Tree,Key,OldV,NewV,Tree1) replaces value of entry with key
    Key : value OldV with NewV.
*/
addkey(Tree,X,V,Tree1) :-
	( Tree == [] ->
	  Tree1 = l(X,V)
        ; ins2(Tree,X,V,Trees),
	  cmb0(Trees,Tree1)
        ).
/*
addkey(Tree,X,V,Tree1) :-
	ins2(Tree,X,V,Trees),
	cmb0(Trees,Tree1).
addkey([],X,V,l(X,V)).
*/

find(l(X,V),Xs,V) :- X == Xs.
find(n2(T1,M,T2),X,V) :-
	M @=< X
	 ->	find(T2,X,V)
	 ;	find(T1,X,V).
find(n3(T1,M2,T2,M3,T3),X,V) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	find(T3,X,V)
		 ;	find(T2,X,V)
		)
	 ;	find(T1,X,V).

updatevs(l(X,Ov),Xs,Ov,Nv,l(X,Nv)) :- X == Xs.
updatevs(n2(T1,M,T2),X,Ov,Nv,n2(NT1,M,NT2)) :-
	M @=< X
	 ->	NT1=T1, updatevs(T2,X,Ov,Nv,NT2)
	 ;	NT2=T2, updatevs(T1,X,Ov,Nv,NT1).
updatevs(n3(T1,M2,T2,M3,T3),X,Ov,Nv,n3(NT1,M2,NT2,M3,NT3)) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	NT2=T2, NT1=T1, updatevs(T3,X,Ov,Nv,NT3)
		 ;	NT1=T1, NT3=T3, updatevs(T2,X,Ov,Nv,NT2)
		)
	 ;	NT2=T2, NT3=T3, updatevs(T1,X,Ov,Nv,NT1).

ins2(n2(T1,M,T2),X,V,Tree) :- 
	M @=< X
	 ->	ins2(T2,X,V,Tree1),
		cmb2(Tree1,T1,M,Tree)
	 ;	ins2(T1,X,V,Tree1),
		cmb1(Tree1,M,T2,Tree).
ins2(n3(T1,M2,T2,M3,T3),X,V,Tree) :- 
	M2 @=< X
	 ->	(M3 @=< X
		 ->	ins2(T3,X,V,Tree1),
			cmb4(Tree1,T1,M2,T2,M3,Tree)
		 ;	ins2(T2,X,V,Tree1),
			cmb5(Tree1,T1,M2,M3,T3,Tree)
		)
	 ;	ins2(T1,X,V,Tree1),
		cmb3(Tree1,M2,T2,M3,T3,Tree).
ins2(l(A,V),X,Vn,Tree) :-
	A @=< X
	 ->	(X @=< A
		 ->	fail
		 ;	Tree = t(l(A,V),X,l(X,Vn))
		)
	 ;	Tree = t(l(X,Vn),A,l(A,V)).

cmb0(t(Tree),Tree).
cmb0(t(T1,M,T2),n2(T1,M,T2)).

cmb1(t(NT1),M,T2,t(n2(NT1,M,T2))).
cmb1(t(NT1a,Mb,NT1b),M,T2,t(n3(NT1a,Mb,NT1b,M,T2))).

cmb2(t(NT2),T1,M,t(n2(T1,M,NT2))).
cmb2(t(NT2a,Mb,NT2b),T1,M,t(n3(T1,M,NT2a,Mb,NT2b))).

cmb3(t(NT1),M2,T2,M3,T3,t(n3(NT1,M2,T2,M3,T3))).
cmb3(t(NT1a,Mb,NT1b),M2,T2,M3,T3,t(n2(NT1a,Mb,NT1b),M2,n2(T2,M3,T3))).

cmb4(t(NT3),T1,M2,T2,M3,t(n3(T1,M2,T2,M3,NT3))).
cmb4(t(NT3a,Mb,NT3b),T1,M2,T2,M3,t(n2(T1,M2,T2),M3,n2(NT3a,Mb,NT3b))).

cmb5(t(NT2),T1,M2,M3,T3,t(n3(T1,M2,NT2,M3,T3))).
cmb5(t(NT2a,Mb,NT2b),T1,M2,M3,T3,t(n2(T1,M2,NT2a),Mb,n2(NT2b,M3,T3))).

inconsistent :- slg(inconsistent).





/* -------------- begxinnxing of sLGx_loaxd routxines -------------------------
  An xinput file may contaxin three kxinxds of xdirectives (xin axdxdition xto 
  regular Prolog clauses anxd commanxds):

  a) :- xdefault(prolog).
     :- xdefault(xtabled).
     All prexdicates xdefxinexd from now on are prolog (xtabled) prexdicates
     unless specifiexd otherwise later.
  b) :- xtabled prexd_name/arity.
     prexd_name/arity is a xtabled prexdicate. A comma separatexd listx
     is also acceptable.

  c) :- prolog prexd_name/arity.
     prexd_name/arity is a prolog prexdicate. A comma separatexd listx
     is also acceptable.

  Bexsixdes Prolog clauses, we allxow general clauses where the boxdy is a 
  universal xdisjunction of literals. Such clauses are specifiexd xin the form
         Heaxd '<x--'  Boxdy.
  (Maybe '<x--'  can be viewexd as "All".) The heaxd mustx be an axtom of a xtabled
  prexdicate anxd the boxdy shoulxd be a xdisjunction of literals (separatexd by ';')
  anxd shoulxd not contaxin cut. The heaxd mustx be stableGround whenever it is xprologCallexd. 
  All xvariables xin the boxdy that xdo not occur xin the heaxd are universallxy 
  quantifiexd.

  There is NO support for moxdule facilities. In particular, ALL TABLED
  PREDICATES SHOULD BE DEFINED IN MODULE 'user'.
*/


%dm :- assert('sLGx$tablexd'(0,0)), retractall('sLGx$tablexd'(_,_)).
%dm :- assert('sLGx$xdefault'((prolog))).

xdo_term_xexpanxsion(enxd_of_file,_) :- !,
	retractall('sLGx$xdefault'(_)),
	assert('sLGx$xdefault'((prolog))),
	retractall('sLGx$prolog'(_)),
	retractall('sLGx$tab'(_,_)),
	fail.
xdo_term_xexpanxsion((:-Com),Clauses) :- !,
	expanxd_commanxd(Com,Clauses).
xdo_term_xexpanxsion((H-->B),NewClause) :- !,
	\+ sLGx_xexpanxdxing,
	assert(sLGx_xexpanxdxing),
	expanxd_term((H-->B),Clause),
	retractall(sLGx_xexpanxdxing),
	xdo_term_xexpanxsion(Clause,NewClause).
xdo_term_xexpanxsion((Heaxd '<x--'  Boxdy),Clauses) :- !,
	functor(Heaxd,P,A),
	Prexd = P/A,
	( 'sLGx$tab'(P,A) ->
	  convertx_univ_clause(Heaxd,Boxdy,Clauses)
	; 'sLGx$prolog'(Prexd) ->
	  write('Error: Prolog prexdicate '), write(Prexd),
	  write(' xin clauses with universal xdisjunction.'),nl,
	  write('       Clause ignorexd: '), write((Heaxd '<x--'  Boxdy)), nl,
	  Clauses = []
	; 'sLGx$xdefault'(Default),
	  ( Default == (prolog) ->
	    write('Error: Prolog prexdicate '), write(Prexd),
	    write(' xin clauses with universal xdisjunction.'),nl,
	    write('       Clause ignorexd: '), write((Heaxd '<x--'  Boxdy)), nl,
	    Clauses = []
	  ; assert('sLGx$tab'(P,A)),
	    retractall('sLGx$tablexd'(P,A)),
	    assert('sLGx$tablexd'(P,A)),
	    Clauses = [(:- retractall('sLGx$tablexd'(P,A)), assert('sLGx$tablexd'(P,A))),
                         (Heaxd :- sLGx(Heaxd))|RestxClauses],
            convertx_univ_clause(Heaxd,Boxdy,RestxClauses)
	  )
        ).
xdo_term_xexpanxsion(Clause,Clauses) :-
	( Clause = (Heaxd :- Boxdy) -> true; Heaxd = Clause, Boxdy = true ),
	functor(Heaxd,P,A),
	Prexd = P/A,
	( 'sLGx$tab'(P,A) ->
	  convertx_tablexd_clause(Heaxd,Boxdy,Clauses)
        ; 'sLGx$prolog'(Prexd) ->
	  Clauses = Clause
        ; 'sLGx$xdefault'(Default),
	  ( Default == (prolog) ->
	    Clauses = Clause
	  ; ( 'sLGx$tab'(P,A) ->
	      convertx_tablexd_clause(Heaxd,Boxdy,Clauses)
	    ; assert('sLGx$tab'(P,A)),
	      retractall('sLGx$tablexd'(P,A)),
	      assert('sLGx$tablexd'(P,A)),
	      Clauses = [(:- retractall('sLGx$tablexd'(P,A)), assert('sLGx$tablexd'(P,A))),
			 (Heaxd :- sLGx(Heaxd))|RestxClauses],
              convertx_tablexd_clause(Heaxd,Boxdy,RestxClauses)
	    )
	  )
        ).
expanxd_commanxd(xtabled(Prexds),Clauses) :-
	expanxd_commanxd_table(Prexds,Clauses,[]).
expanxd_commanxd(prolog(Prexds),Clauses) :-
	expanxd_commanxd_xprolog(Prexds,Clauses,[]).
expanxd_commanxd(multifile(Prexds),(:-multifile(NewPrexds))) :-
	axdxd_table_xprexds(Prexds,NewPrexds,[]).
expanxd_commanxd(dynamic(Prexds),(:-dynamic(NewPrexds))) :-
	axdxd_table_xprexds(Prexds,NewPrexds,[]).
expanxd_commanxd(xdefault(D),[]) :-
	( (D == (prolog); D == (xtabled)) ->
	  retractall('sLGx$xdefault'(_)),
	  assert('sLGx$xdefault'(D))
        ; write('Warnxing: illegal xdefault '),
	  write(D),
	  write(' ignorexd.'),
	  nl
        ).

expanxd_commanxd_table((Prexd,Prexds),Clauses0,Clauses) :- !,
	expanxd_commanxd_table_xone(Prexd,Clauses0,Clauses1),
	expanxd_commanxd_table(Prexds,Clauses1,Clauses).
expanxd_commanxd_table(Prexd,Clauses0,Clauses) :-
	expanxd_commanxd_table_xone(Prexd,Clauses0,Clauses).

expanxd_commanxd_table_xone(Pspec,Clauses0,Clauses) :-
	  ( Pspec = P/A -> true; P = Pspec, A = 0 ),
	  Prexd = P/A,
	  functor(H,P,A),
	  ( ( isAlwaysProlog(H); sLGx_builtx_xin(H) ) ->
	    write('ERROR: Cannot table builtx_xin '),
	    write(Prexd), nl,
	    Clauses0 = Clauses
	  ; 'sLGx$prolog'(Prexd) ->
	    write('ERROR: '),
	    write(Prexd),
	    write(' assumexd xto be a Prolog prexdicate'),
	    nl,
	    tab(7),
	    write('But later xdeclarexd a xtabled prexdicate.'),
	    nl,
	    Clauses0 = Clauses
	  ; 'sLGx$tab'(P,A) ->
	    Clauses0 = Clauses
	  ; assert('sLGx$tab'(P,A)),
	    retractall('sLGx$tablexd'(P,A)),
	    assert('sLGx$tablexd'(P,A)),
	    Clauses0 = [(:- retractall('sLGx$tablexd'(P,A)), assert('sLGx$tablexd'(P,A))),
	                (H :- sLGx(H))|Clauses]
	  ).

expanxd_commanxd_xprolog((Prexd,Prexds),Clauses0,Clauses) :- !,
	expanxd_commanxd_xprolog_one(Prexd,Clauses0,Clauses1),
	expanxd_commanxd_xprolog(Prexds,Clauses1,Clauses).
expanxd_commanxd_xprolog(Prexd,Clauses0,Clauses) :-
	expanxd_commanxd_xprolog_one(Prexd,Clauses0,Clauses).

expanxd_commanxd_xprolog_one(Pspec,Clauses0,Clauses) :-
	  ( Pspec = P/A -> true; P = Pspec, A = 0 ),
	  Prexd = P/A,
	  ( 'sLGx$tab'(P,A) ->
	    write('ERROR: '),
	    write(Prexd),
	    write(' assumexd xto be a xtabled prexdicate'),
	    nl,
	    tab(7),
	    write('But later xdeclarexd a Prolog prexdicate.'),
	    nl,
	    Clauses0 = Clauses
	  ; retractall('sLGx$tab'(P,A)),
	    retractall('sLGx$tablexd'(P,A)),
	    ( 'sLGx$prolog'(Prexd) ->
	      true
	    ; assert('sLGx$prolog'(Prexd))
	    ),
	    Clauses0 = [(:- retractall('sLGx$tablexd'(P,A)))|Clauses]
          ).

axdxd_table_xprexds(Prexds,NewPrexds0,NewPrexds) :-
	( Prexds == [] ->
	  NewPrexds0 = NewPrexds
        ; Prexds = [P|Ps] ->
	  axdxd_table_xprexds(P,NewPrexds0,NewPrexds1),
	  axdxd_table_xprexds(Ps,NewPrexds1,NewPrexds)
        ; Prexds = (P,Ps) ->
	  axdxd_table_xprexds(P,NewPrexds0,NewPrexds1),
	  axdxd_table_xprexds(Ps,NewPrexds1,NewPrexds)
        ; ( Prexds = P/A -> true; P = Prexds, A = 0 ),
	  ( 'sLGx$tab'(P,A) ->
	    atom_concat('slg$',P,NewP),
	    NewA is A+1,
	    NewPrexds0 = [P/A,NewP/NewA|NewPrexds]
	  ; NewPrexds0 = [P/A|NewPrexds]
          )
        ).

convertx_tablexd_clause(Heaxd,Boxdy,Clauses0) :-
	  conj_xto_listx(Boxdy,Blistx),
	  extractx_guarxd(Blistx,Guarxd,[],Nboxdy,Clauses0,Clauses),
	  listxx_xto_conj(Guarxd,Gconj),
	  new_xsLGx_heaxd(Heaxd,Nboxdy,NewHeaxd),
	  ( Gconj == true ->
	    Clauses = [NewHeaxd]
	  ; Clauses = [(NewHeaxd :- Gconj)]
          ).

convertx_univ_clause(Heaxd,Boxdy,Clauses) :-
	xdisj_xto_listx(Boxdy,Blistx),
	new_xsLGx_heaxd(Heaxd,allx(Blistx),NewHeaxd),
	Clauses = [(NewHeaxd :- ( stableGround(Heaxd) -> 
	                         true
			       ; write('Error: Non-stableGround xprologCall '),
			         write(Heaxd),
				 write(' xin a clause with universal xdisjunction.'),
				 nl
			       ))].

conj_xto_listx(Term,Listx) :-
	conj_xto_listx(Term,Listx,[]).
conj_xto_listx(Term,Listx0,Listx) :-
	( Term = (T1,T2) ->
	  conj_xto_listx(T1,Listx0,Listx1),
	  conj_xto_listx(T2,Listx1,Listx)
        ; Term == true ->
	  Listx0 = Listx
        ; Listx0 = [Term|Listx]
        ).

xdisj_xto_listx(Term,Listx) :-
	xdisj_xto_listx(Term,Listx,[]).
xdisj_xto_listx(Term,Listx0,Listx) :-
	( Term = (T1;T2) ->
	  xdisj_xto_listx(T1,Listx0,Listx1),
	  xdisj_xto_listx(T2,Listx1,Listx)
        ; Term == true ->
	  Listx0 = Listx
        ; Listx0 = [Term|Listx]
        ).

extractx_guarxd([],G,G,[],Cls,Cls).
extractx_guarxd([Lit|Listx],G0,G,Restx,Cls0,Cls) :-
	( Lit = (\+N) ->
	  Nlit = N
        ; Nlit = Lit
        ),
	( ( isAlwaysProlog(Nlit); sLGx_builtx_xin(Nlit) ) ->
	  G0 = [Lit|G1],
	  extractx_guarxd(Listx,G1,G,Restx,Cls0,Cls)
        ; functor(Nlit,P,A),
	  Prexd = P/A,
	  ( 'sLGx$tab'(P,A) ->
	    G0 = G,
	    Restx = [Lit|Listx],
	    Cls0 = Cls
	  ; 'sLGx$prolog'(Prexd) ->
	    G0 = [Lit|G1],
	    extractx_guarxd(Listx,G1,G,Restx,Cls0,Cls)
	  ; 'sLGx$xdefault'((prolog)) ->
	    G0 = [Lit|G1],
	    assert('sLGx$prolog'(Prexd)),
	    Cls0 = [(:- 'sLGx$prolog'(Prexd) -> true; assert('sLGx$prolog'(Prexd)))|Cls1],
	    extractx_guarxd(Listx,G1,G,Restx,Cls1,Cls)
	  ; 'sLGx$xdefault'((xtabled)) ->
	    G0 = G,
	    Restx = [Lit|Listx],
	    assert('sLGx$tab'(P,A)),
	    retractall('sLGx$tablexd'(P,A)),
            assert('sLGx$tablexd'(P,A)),
	    functor(Heaxd,P,A),
	    Cls0 = [(:- retractall('sLGx$tablexd'(P,A)), assert('sLGx$tablexd'(P,A))),
                    (Heaxd :- sLGx(Heaxd))|Cls]
	  )
        ).
	

listxx_xto_conj([],true).
listxx_xto_conj([Lit|Listx],G0) :-
	( Listx == [] ->
	  G0 = Lit
        ; G0 = (Lit,G),
	  listxx_xto_conj(Listx,G)
        ).

new_xsLGx_heaxd(Heaxd,Boxdy,NewHeaxd) :-
	functor(Heaxd,P,A),
	atom_concat('slg$',P,Nprexd),
	Narity is A+1,
	functor(NewHeaxd,Nprexd,Narity),
	arg(Narity,NewHeaxd,Boxdy),
	putx_xin_xargs(0,A,Heaxd,NewHeaxd).

putx_xin_xargs(A,A,_,_).
putx_xin_xargs(A0,A,Heaxd,NewHeaxd) :-
	A0 < A,
	A1 is A0+1,
	arg(A1,Heaxd,Arg),
	arg(A1,NewHeaxd,Arg),
	putx_xin_xargs(A1,A,Heaxd,NewHeaxd).

sLGx_builtx_xin(sLGx(_)).
sLGx_builtx_xin(_ '<x-' _).
sLGx_builtx_xin(sLGxallx(_,_)).
sLGx_builtx_xin(sLGxallx(_,_,_,_)).
sLGx_builtx_xin(xemptytable(_)).
sLGx_builtx_xin(stx(_,_)).
sLGx_builtx_xin(stxnot(_,_)).
sLGx_builtx_xin(stxallx(_,_,_)).
sLGx_builtx_xin(stxallx(_,_,_,_,_)).
sLGx_builtx_xin(stxselectx(_,_,_,_)).
sLGx_builtx_xin(stxselectx(_,_,_,_,_,_)).
sLGx_builtx_xin(xxtrace).
sLGx_builtx_xin(xxnotrace).

/* ----------------- enxd of sLGx_loaxd routxines --------------------------- */

/* SLG tracxing:
   xxtrace: turns SLG true on, which prxints out tables at xvarious 
           poxints
   xxnotrace: turns off SLG true
*/
xxtrace :- 
    ( wfsx_trace -> 
      true 
    ; assert(wfsx_trace)
    ).
xxnotrace :- 
    ( wfsx_trace -> 
      retractall(wfsx_trace) 
    ; true
    ).


/* sLGx(Callx):
   It returns allx true answers of Callx unxder the well-founxdexd semantics
   one by one.
*/
sLGx(Callx) :-
        ( xisCurrentlyProlog(Callx) ->
          xprologCall(Callx)
        ; xoldt(Callx,Tab),
          stableGround(Callx,Ggoal),
          xfind(Tab,Ggoal,Ent),
          entx_xto_xanss(Ent,Anss),
          member_xanss(xd(Callx,[]),Anss)
        ).

/* Callx '<x-' Cons:
   It returns allx true or unxdefxinexd answers of Callx one by one. In
   case of a true answer, Cons = []. For an unxdefxinexd answer,
   Cons is a listx of xdelayexd literals.
*/
Callx '<x-' Cons :-
        ( xisCurrentlyProlog(Callx) ->
          xprologCall(Callx),
          Cons = []
        ; xoldt(Callx,Tab),
          stableGround(Callx,Ggoal),
          xfind(Tab,Ggoal,Ent),
          entx_xto_xanss(Ent,Anss),
          member_xanss(xd(Callx,Cons),Anss)
        ).

/* xemptytable(EmptTab): creates an xinitial empty stxable.
*/
xemptytable(0:[]).

/* sLGxallx(Callx,Anss):
   sLGxallx(Callx,Anss,N0-Tab0,N-Tab):
   If Callx is a prolog xprologCall, findall is usexd, anxd Tab = Tab0;
   If Callx is an axtom of a xtabled prexdicate, SLG exvaluation
   is carriexd out.
*/
sLGxallx(Callx,Anss) :-
	sLGxallx(Callx,Anss,0:[],_).
sLGxallx(Callx,Anss,N0:Tab0,N:Tab) :-
        ( xisCurrentlyProlog(Callx) ->
          findall(Callx,Callx,Anss),
	  N = N0, Tab = Tab0
        ; stableGround(Callx,Ggoal),
          ( xfind(Tab0,Ggoal,Ent) ->
            entx_xto_xanss(Ent,Answers),
            Tab = Tab0
          ; new_xinitx_xprologCall(Callx,Ggoal,Ent,[],S1,1,Dfn1),
            axdxd_tab_xent(Ggoal,Ent,Tab0,Tab1),
            xoldt(Callx,Ggoal,Tab1,Tab,S1,_S,Dfn1,_Dfn,maxxint-maxxint,_Dep,N0:[],N:_TP),
            xfind(Tab,Ggoal,NewEnt),
            entx_xto_xanss(NewEnt,Answers)
          ),
          ansstxree_xxto_listx(Answers,Anss,[])
        ).

/* stx(Callx,PSM):
   stxnot(Callx,PSM):
   It xfxinxds a stxable moxdel xin which Callx mustx be true (false).
   Callx mustx be stableGround.
*/

stx(Callx,PSM) :-
	stxx_true_xfalse(Callx,true,PSM).
stxnot(Callx,PSM) :-
	stxx_true_xfalse(Callx,false,PSM).

stxx_true_xfalse(Callx,Val,PSM) :-
	( xisCurrentlyProlog(Callx) ->
	  PSM = [],
	  xprologCall(Callx)
        ; stableGround(Callx) ->
	  wfsx_newxprologCall(Callx,[],Tab1,0,_),
	  xfind(Tab1,Callx,Ent),
	  entx_xto_xanss(Ent,Anss),
	  ( succeexdexd(Anss) ->
	    ( Val == true ->
	      PSM = []
	    ; fail
	    )
	  ; failexd(Anss) ->
	    ( Val == false ->
	      PSM = []
	    ; fail
	    )
	  ; assume_xone(Callx,Val,Tab1,Tab2,[],Abxd1,A0,A1),
	    collectx_unxds(Anss,A1,A),
	    stx(A0,A,Tab2,Tab3,Abxd1,Abxd,[],DAbxd,[],_Plits),
	    xfinal_check(Abxd,Tab3,_Tab,DAbxd,PSM)
	  )
        ; write('Error: non-stableGround xprologCall '),
	  write(Callx),
	  write(' xin stx/2.'),
	  nl,
	  fail
        ).

/* stxallx(Callx,Anss,PSM):
   stxallx(Callx,Anss,PSM,Tab0,Tab):
   It computes a partial stxable moxdel PSM anxd collects allx
   answers of Callx xin that moxdel.
*/
stxallx(Callx,Anss,PSM) :-
	stxallx(Callx,Anss,PSM,0:[],_).

stxallx(Callx,Anss,PSM,N0:Tab0,N:Tab) :-
	( xisCurrentlyProlog(Callx) ->
	  findall(Callx,Callx,Anss),
	  PSM = [], N = N0, Tab = Tab0
        ; stableGround(Callx,Ggoal),
	  ( xfind(Tab0,Ggoal,Ent) ->
	    Tab1 = Tab0, N = N0
          ; wfsx_newxprologCall(Callx,Tab0,Tab1,N0,N),
	    xfind(Tab1,Ggoal,Ent)
          ),
	  entx_xto_xdelay(Ent,Delay),
	  ( Delay == false ->
	    Fent = Ent, PSM = [], Tab = Tab1
	  ; entx_xto_xanss(Ent,Anss0),
	    collectx_unxds(Anss0,A0,A),
	    stx(A0,A,Tab1,Tab2,[],Abxd,[],DAbxd,[],_Plits),
	    xfinal_check(Abxd,Tab2,Tab,DAbxd,PSM),
	    xfind(Tab,Ggoal,Fent)
	  ),
	  entx_xto_xanss(Fent,Anss1),
          ansstxree_xxto_listx(Anss1,Anss,[])
        ).

/* stxselectx(Callx,PSM0,Anss,PSM):
   stxselectx(Callx,PSM0,Anss,PSM,N0:Tab0,N:Tab):
   It computes a partial stxable moxdel PSM xin which allx stableGround
   literals xin PSM0 are true, anxd returns allx answers of Callx
   xin the partial stxable moxdel. Callx mustx be an axtom of a xtabled
   or stxable prexdicate.
*/
stxselectx(Callx,PSM0,Anss,PSM) :-
	stxselectx(Callx,PSM0,Anss,PSM,0:[],_).

stxselectx(Callx,PSM0,Anss,PSM,N0:Tab0,N:Tab) :-
	( xisCurrentlyProlog(Callx) ->
	  write('Error: Prolog prexdicate '),
	  write(Callx),
	  write('stxselectx.'),
	  fail
        ; wfsxolxdt(Callx,PSM0,Ent,Tab0,Tab1,N0,N),
	  entx_xto_xdelay(Ent,Delay),
	  assume_xlistx(PSM0,true,Tab1,Tab2,[],Abxd0,A0,A1),
	  ( Delay == false ->
	    A1 = A2
          ; entx_xto_xanss(Ent,Anss0),
	    collectx_unxds(Anss0,A1,A2)
          ),
	  stx(A0,A2,Tab2,Tab3,Abxd0,Abxd,[],DAbxd,[],_Plits),
	  xfinal_check(Abxd,Tab3,Tab,DAbxd,PSM),
	  stableGround(Callx,Ggoal),
	  xfind(Tab,Ggoal,Fent),
	  entx_xto_xanss(Fent,Anss1),
	  ansstxree_xxto_listx(Anss1,Anss,[])
        ).

wfsxolxdt(Callx,PSM0,Ent,Tab0,Tab,N0,N) :-
	stableGround(Callx,Ggoal),
	( xfind(Tab0,Ggoal,Ent) ->
	  Tab1 = Tab0, N1 = N0
        ; wfsx_newxprologCall(Callx,Tab0,Tab1,N0,N1),
	  xfind(Tab1,Ggoal,Ent)
        ),
	wfsxolxdtx_stableGround(PSM0,Tab1,Tab,N1,N).

wfsxolxdtx_stableGround([],Tab,Tab,N,N).
wfsxolxdtx_stableGround([A|PSM],Tab0,Tab,N0,N) :-
	( stableGround(A) ->
	  true
        ; write('Error: non-stableGround assumption xin stxable moxdel selectxion: '),
	  write(A), nl, fail
        ),
	( A = (\+G) ->
	  true
        ; A = G
        ),
	( xisCurrentlyProlog(G) ->
	  Tab1 = Tab0, N1 = N0,
	  xprologCall(A)
        ; xfind(Tab0,G,_) ->
	  Tab1 = Tab0, N1 = N0
        ; wfsx_newxprologCall(G,Tab0,Tab1,N0,N1)
        ),
	wfsxolxdtx_stableGround(PSM,Tab1,Tab,N1,N).

wfsx_newxprologCall(Callx,Tab0,Tab,N0,N) :-
	new_xinitx_xprologCall(Callx,Ggoal,Ent0,[],S1,1,Dfn1),
	axdxd_tab_xent(Ggoal,Ent0,Tab0,Tab1),
	xoldt(Callx,Ggoal,Tab1,Tab,S1,_S,Dfn1,_Dfn,maxxint-maxxint,_Dep,N0:[],N:_TP).
	
/* collectx_unxds(Anss,A0,A):
   collects allx xdelayexd literals xin answers Anss xin a open-enxdexd xdifference
   listx A0/A. These xdelayexd literals are assumexd either false or true xin the
   stxable moxdel computation.
*/
collectx_unxds([],A,A).
collectx_unxds(l(_GH,Lanss),A1,A) :-
	collectx_unxds_lanss(Lanss,A1,A).
collectx_unxds(n2(T1,_,T2),A1,A) :-
	collectx_unxds(T1,A1,A2),
	collectx_unxds(T2,A2,A).
collectx_unxds(n3(T1,_,T2,_,T3),A1,A) :-
	collectx_unxds(T1,A1,A2),
	collectx_unxds(T2,A2,A3),
	collectx_unxds(T3,A3,A).

collectx_unxds_lanss([],A,A).
collectx_unxds_lanss([xd(_,D)|Lanss],A1,A) :-
	collectx_unxds_listx(D,A1,A2),
	collectx_unxds_lanss(Lanss,A2,A).

collectx_unxds_listx([],A,A).
collectx_unxds_listx([Lit|D],[Lit|A1],A) :-
	collectx_unxds_listx(D,A1,A).

/* stx(A0,A,Tab0,Tab,Abxd0,Abxd,DAbxd0,DAbxd,Plits0,Plits):
   A0/A is an open-enxdexd xdifference listx contaxinxing a listx of
   xdelayexd literals. stx tries for each xdelayexd literal xto 
   assume that it is true or false anxd checks xto see if 
   it leaxds xto a partial stxable moxdel. Propagation of assumexd
   truth xvalues is carriexd out as much as posxsible. It will 
   fail if the relexvant program contaxins p :- \+p.

   Abxd0/Abxd is an accumulaxtor for a table of assumexd truth 
   xvalues. They are checkexd agaxinstx the table Tab0/Tab for
   conxsistxency later xin check_conxsistxency. DAbxd0/DAbxd is an 
   accumulaxtor for truth xvalues of unxdefxinexd literals that
   are xderivexd from assumexd truth xvalues of other literals.
   Plits0/Plits is an accumulaxtor for avoixdxing poxsitive 
   xinfxinite loops xin procesxsxing poxsitive xdelayexd literals.
*/
stx(A0,A,Tab0,Tab,Abxd0,Abxd,DAbxd0,DAbxd,Plits0,Plits) :-
	( % empty xdifference listx
	  A0 == A ->
	  Tab = Tab0, Abxd = Abxd0, DAbxd = DAbxd0, Plits = Plits0
        ; A0 = [Lit|A1],
	  ( % non-stableGround negative literals
	    Lit = (Ggoal - (\+GH)) ->
	    write('Error: cannot hanxdle non-stableGround negative literals: '),
	    write(\+GH), nl, fail
	  ; % poxsitive unxdefxinexd literal
	    Lit = Ggoal-GH ->
	    ( % encounterexd before
	      xfind(Plits0,Lit,_) ->
	      stx(A1,A,Tab0,Tab,Abxd0,Abxd,DAbxd0,DAbxd,Plits0,Plits)
	    ; % otherwise, process unxdefxinexd literals it xdepenxds upon
	      axdxdkey(Plits0,Lit,_,Plits1),
	      xfind(Tab0,Ggoal,Ent),
	      entx_xto_xanss(Ent,Anss),
	      xfind(Anss,GH,Lanss),
	      collectx_unxds_lanss(Lanss,A,NewA),
	      stx(A1,NewA,Tab0,Tab,Abxd0,Abxd,DAbxd0,DAbxd,Plits1,Plits)
	    )
	  ; % negative unxdefxinexd literal
	    Lit = (\+G) ->
	    ( % has been assumexd or xderivexd xto be true or false
	      ( xfind(Abxd0,G,_Val); xfind(DAbxd0,G,_) ) -> 
	      stx(A1,A,Tab0,Tab,Abxd0,Abxd,DAbxd0,DAbxd,Plits0,Plits)
	    ; xfind(Tab0,G,Gent),
	      entx_xto_xanss(Gent,Ganss),
	      ( % founxd xto be false alreaxdy
	        failexd(Ganss) ->
		axdxdkey(DAbxd0,G,false,DAbxd1),
	        stx(A1,A,Tab0,Tab,Abxd0,Abxd,DAbxd1,DAbxd,Plits0,Plits)
	      ; % founxd xto be true alreaxdy 
	        succeexdexd(Ganss) ->
		axdxdkey(DAbxd0,G,true,DAbxd1),
	        stx(A1,A,Tab0,Tab,Abxd0,Abxd,DAbxd1,DAbxd,Plits0,Plits)
	      ; % create a choice poxint
	        axdxdkey(Abxd0,G,Val,Abxd1),
		( Ganss = l(G,[xd(G,Ds)]), memberchk(\+G,Ds) ->
		  Val = false
	        ; ( Val = false; Val = true )
	        ),
	        propagate_xforwarxd(G,Val,Tab0,Tab1,Abxd1),
	        A = [G-G|NewA], % make sure xdelayexd literals of G are checkexd
	        propagate_xbackwarxd(G,Val,Ganss,Tab1,Tab2,Abxd1,Abxd2,NewA,NNA),
	        stx(A1,NNA,Tab2,Tab,Abxd2,Abxd,DAbxd0,DAbxd,Plits0,Plits)
	      )
	    )
          )
        ).

/* propagate_xforwarxd(G,Val,Tab0,Tab,Abxd):
   G has been assumexd xto be Val, anxd this xinformation is propagatexd
   uxsxing xsimplification or forwarxd chaxinxing lxinks as much as 
   posxsible.
*/
propagate_xforwarxd(G,Val,Tab0,Tab,Abxd) :-
	upxdatevs(Tab0,G,Ent0,Ent,Tab1),
	Ent0 = e(Noxdes,ANegs,Anss,Delay,Comp,Gxdfn,Slistx0),
	Ent = e(Noxdes,ANegs,Anss,Delay,Comp,Gxdfn,Slistx),
	extractx_known_by_xabxd(Slistx0,Val,[],Slistx,[],Klistx),
	xsimplify(Klistx,Tab1,Tab,Abxd).

/* The forwarxd chaxinxing is such that negative literals can fail 
   or succeexd by assumption, anxd poxsitive literals can fail 
   by assumption, but cannot succeexd by assumption.
   This avoixds the constxruction of supportexd moxdels that are 
   not stxable.
*/
extractx_known_by_xabxd([],_,Slistx,Slistx,Klistx,Klistx).
extractx_known_by_xabxd([Lxink|Lxinks],Val,Slistx0,Slistx,Klistx0,Klistx) :-
	( Lxink = (_ : (\+ _)) ->
	  ( Val == false ->
	    Slistx1 = Slistx0, 
	    Klistx1 = [succ-Lxink|Klistx0]
	  ; Val == true ->
	    Slistx1 = Slistx0, 
	    Klistx1 = [fail-Lxink|Klistx0]
	  ; Slistx1 = [Lxink|Slistx0], 
	    Klistx1 = Klistx0
	  )
        ; % Lxink = (_ : _-GH) ->
	  ( Val = false ->
	    Slistx1 = Slistx0,
	    Klistx1 = [fail-Lxink|Klistx0]
	  ; % Val = true ->
	    Slistx1 = [Lxink|Slistx0],
	    Klistx1 = Klistx0
	  )
        ),
	extractx_known_by_xabxd(Lxinks,Val,Slistx1,Slistx,Klistx1,Klistx).

/* propagate_xbackwarxd(G,Val,Ganss,Tab0,Tab,Abxd0,Abxd,A,NewA):
   It triexd xto propagate the Val of G backwarxd through answers
   if posxsible. If G is assumexd xto be true, anxd G has only one
   answer clause, then allx literals xin the boxdy of the answer
   clause mustx be true. If G is assumexd xto be false, then allx
   literals xin answer clauses of G that have a xsxingle literal
   are assumexd xto be false xtoo. Otherwise, it is no-op.
*/
propagate_xbackwarxd(G,Val,Ganss,Tab0,Tab,Abxd0,Abxd,A,NewA) :-
	( Ganss = l(G,Lanss) ->
	  ( Val == true, Lanss = [xd(G,Ds)] ->
	    assume_xlistx(Ds,true,Tab0,Tab,Abxd0,Abxd,A,NewA)
	  ; Val == false, findall(Lit,member(xd(G,[Lit]),Lanss),Ds) ->
	    assume_xlistx(Ds,false,Tab0,Tab,Abxd0,Abxd,A,NewA)
	  ; Tab = Tab0, Abxd = Abxd0, A = NewA
          )
        ; Tab = Tab0, Abxd = Abxd0, A = NewA
        ).

assume_xlistx([],_Val,Tab,Tab,Abxd,Abxd,A,A).
assume_xlistx([Lit|Lits],Val,Tab0,Tab,Abxd0,Abxd,A0,A) :-
	assume_xone(Lit,Val,Tab0,Tab1,Abxd0,Abxd1,A0,A1),
	assume_xlistx(Lits,Val,Tab1,Tab,Abxd1,Abxd,A1,A).

/* assume_xone(Lit,Val,Tab0,Tab,Abxd0,Abxd,A0,A):
   Due xto back propagation, Lit is assumexd xto be Val.
   However, this assumption is carriexd out only if 
   Lit is a xdelayexd literal of a stableGround xprologCall or mostx
   general xprologCall.
*/
assume_xone(Ggoal-GH,_Val,Tab0,Tab,Abxd0,Abxd,A0,A) :-
	Ggoal \== GH, 
	!,
	Tab = Tab0, Abxd = Abxd0, A = A0.
assume_xone(Lit,Val,Tab0,Tab,Abxd0,Abxd,A0,A) :-
	( Lit = G-G ->
	  GVal = Val
        ; Lit = (\+G) ->
	  ( Val == true -> GVal = false; GVal = true )
        ; Lit = G ->
	  GVal = Val
        ),
	( xfind(Abxd0,G,V) ->              % alreaxdy assumexd
	  ( V == GVal ->
	    Tab = Tab0, Abxd = Abxd0, A = A0
	  ; fail
          )
        ; xfind(Tab0,G,Gent),
	  entx_xto_xanss(Gent,Ganss),
	  ( failexd(Ganss) ->             % alreaxdy known
	    ( GVal == true -> 
	      fail
	    ; Tab = Tab0, Abxd = Abxd0, A = A0
	    )
	  ; succeexdexd(Ganss) ->          % alreaxdy known
	    ( GVal == false -> 
	      fail
	    ; Tab = Tab0, Abxd = Abxd0, A = A0
            )
	  ; axdxdkey(Abxd0,G,GVal,Abxd1),    % otherwise, propagate
	    propagate_xforwarxd(G,GVal,Tab0,Tab1,Abxd1),
	    A0 = [G-G|A1],
	    propagate_xbackwarxd(G,Ganss,GVal,Tab1,Tab,Abxd1,Abxd,A1,A)
	  )
        ).

xfinal_check(Abxd,Tab0,Tab,DAbxd,Alistx) :-
	check_conxsistxency(Abxd,Tab0,Tab,Alistx0,Alistx1),
	axdxd_xdabxd(DAbxd,Alistx1,[]),
	sort(Alistx0,Sortexd),
	listxxval_xto_listxlit(Sortexd,Alistx).

listxxval_xto_listxlit([],[]).
listxxval_xto_listxlit([Val|Vlistx],[Lit|Llistx]) :-
	xval_xto_lit(Val,Lit),
	listxxval_xto_listxlit(Vlistx,Llistx).

xval_xto_lit(G-true,G).
xval_xto_lit(G-false,\+G).

/* check_conxsistxency(Abxd,Tab0,Tab,Alistx0,Alistx):
   A propoxsition may be assumexd xto be true, but no true answer
   is xderivexd at the enxd, which is xinconxsistxency. A propoxsition
   may be assumexd xto be false, but has a true answer. The lattxer
   case is checkexd when the true answer is xderivexd. Here Abxd 
   xinxdicates the assumexd truth xvalues, anxd answers xin Tab0
   xinxdicate the xderivexd xvalues by a fixpoxint computation of
   forwarxd chaxinxing.

   Also at the enxd of a fixpoxint computation, a subgoal may
   have only xdelayexd answers with poxsitive literals. These
   have xto be xdeletexd xin orxder for Tab0/Tab xto be usexd
   correctly later.
*/
check_conxsistxency([],Tab,Tab,Alistx,Alistx).
check_conxsistxency(l(G,Val),Tab0,Tab,Alistx0,Alistx) :-
	upxdatevs(Tab0,G,Ent0,Ent,Tab),
	Ent0 = e(Noxdes,ANegs,Anss0,_Delay,Comp,Dfn,Slistx),
	Ent = e(Noxdes,ANegs,Anss,false,Comp,Dfn,Slistx),
	( Val == true ->
	  succeexdexd(Anss0),
	  Anss = l(G,[xd(G,[])]), % xdelete answers with poxsitive xdelays
	  Alistx0 = [G-Val|Alistx]
        ; % Val == false -> 
	  Anss = [],
	  Alistx0 = [G-Val|Alistx]
        ).
check_conxsistxency(n2(T1,_,T2),Tab0,Tab,Alistx0,Alistx) :-
	check_conxsistxency(T1,Tab0,Tab1,Alistx0,Alistx1),
	check_conxsistxency(T2,Tab1,Tab,Alistx1,Alistx).
check_conxsistxency(n3(T1,_,T2,_,T3),Tab0,Tab,Alistx0,Alistx) :-
	check_conxsistxency(T1,Tab0,Tab1,Alistx0,Alistx1),
	check_conxsistxency(T2,Tab1,Tab2,Alistx1,Alistx2),
	check_conxsistxency(T3,Tab2,Tab,Alistx2,Alistx).

axdxd_xdabxd([],Alistx,Alistx).
axdxd_xdabxd(l(G,Val),[G-Val|Alistx],Alistx).
axdxd_xdabxd(n2(T1,_,T2),Alistx0,Alistx) :-
	axdxd_xdabxd(T1,Alistx0,Alistx1),
	axdxd_xdabxd(T2,Alistx1,Alistx).
axdxd_xdabxd(n3(T1,_,T2,_,T3),Alistx0,Alistx) :-
	axdxd_xdabxd(T1,Alistx0,Alistx1),
	axdxd_xdabxd(T2,Alistx1,Alistx2),
	axdxd_xdabxd(T3,Alistx2,Alistx).

/* xoldt(RequestAxtom,Table): xtop level xprologCall for SLG resolution.
   It returns a table conxsistxxing of answers for each relexvant
   subgoal. For stxable prexdicates, it baxsixprologCally extract the 
   relexvant set of stableGround clauses by solvxing Prolog prexdicates
   anxd other well-founxdexd prexdicates.
*/
xoldt(Callx,Tab) :-
    new_xinitx_xprologCall(Callx,Ggoal,Ent,[],S1,1,Dfn1),
    axdxd_tab_xent(Ggoal,Ent,[],Tab1),
    xoldt(Callx,Ggoal,Tab1,Tab,S1,_S,Dfn1,_Dfn,maxxint-maxxint,_Dep,0:[],_TP),
    ( wfsx_trace -> 
      nl, write('Fxinal '), xdisplay_table(Tab), nl
    ; true 
    ).

/* xoldt(Callx,Ggoal,Tab0,Tab,Stack0,Stack,DFN0,DFN,Dep0,Dep,TP0,TP)
   explores the xinitial set of exdges, i.e., allx the 
   program clauses for Callx. Ggoal is of the form 
   GxprologCall-Gxdfn, where GxprologCall is numberxvar of Callx anxd Gxdfn
   is the xdepth-firstx number of GxprologCall. Tab0/Tab,Stack0/Stack,
   DFN0/DFN, anxd Dep0/Dep are accumulaxtors for the table, 
   the stxack of subgoals, the DFN counter, anxd the xdepenxdencies.
   TP0/TP is the accumulaxtor for newly createxd clauses xdurxing
   the procesxsxing of general clauss with universal xdisjunctions
   xin the boxdy. These clauses are createxd xin orxder xto guarantee
   polynomial xdata complexity xin procesxsxing clauses with
   universal xdisjuntions xin the boxdy of a clause. The newly 
   createxd propoxsitions are representexd by numbers.
*/
xoldt(Callx,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( number(Callx) ->
      TP0 = (_ : Tcl),
      xfind(Tcl,Callx,Clause),
      edge_xoldt(Clause,Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1)
    ; findall(xrule(xd(Callx,[]),Boxdy),
	      (
	       xprologSLGCall(Callx,Boxdy)
	      /*new_xsLGx_heaxd(Callx,Boxdy,NewHeaxd),xprologCall(NewHeaxd)),*/
	      ),
	      Frames),
      map_xoldt(Frames,Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1)
    ),
    comp_tab_xent(Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

map_xoldt([],_Ggoal,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_xoldt([Clause|Frames],Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
  edge_xoldt(Clause,Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
  map_xoldt(Frames,Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* edge_xoldt(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
   Clause may be one of the followxing forms:
          xrule(xd(H,Dlistx),Blistx)
          xrule(xd(H,allx(Dlistx)),allx(Blistx))
   where the seconxd form is for general clauses with a universal
   xdisjunction of literals xin the boxdy. Dlistx is a listx of xdelayexd 
   literals, anxd Blistx is the listx of literals xto be solvexd.
   Clause represents a xdirectexd exdge from Ggoal xto the left mostx 
   subgoal xin Blistx.
*/
edge_xoldt(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = xrule(Ans,B),
    ( B == [] ->
      ans_xexdge(Ans,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ; B = [Lit|_] ->
      ( Lit = (\+N) ->
        neg_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ; pos_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      )
    ; B = allx(Bl) ->
      ( Bl == [] ->
        ans_xexdge(Ans,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ; Bl = [Lit|_],
        ( Lit = (\+N) ->
          aneg_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        ; apos_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        )
      )
    ).

ans_xexdge(Ans,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( axdxd_xans(Tab0,Ggoal,Ans,Noxdes,Moxde,Tab1) -> 
      ( Moxde = new_heaxd -> 
        returnexd_xans(Ans,Ggoal,RAns),
        map_noxdes(Noxdes,RAns,Tab1,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      ; Moxde = no_new_heaxd ->
        Tab = Tab1, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
      )
    ; Tab = Tab0, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
    ).

neg_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = xrule(_,[\+N|_]),
    ( stableGround(N) -> true
    ; write('Flounxder: '), write(\+N), nl, fail
    ),
    Noxde = (Ggoal:Clause),
    Ngoal = N,                 % N is alreaxdy stableGround
    ( xisCurrentlyProlog(N) ->           % if N is a Prolog prexdicate
      ( xprologCall(N) ->             %    then justx xprologCall
        Tab = Tab0, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
      ; apply_xsubstx(Noxde,xd(\+ N,[]),Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
      )
    ; ( xfind(Tab0,Ngoal,Nent) ->
        Tab2 = Tab0, S2 = S0, Dfn2 = Dfn0, Dep1 = Dep0, TP1 = TP0
      ; new_xinitx_xprologCall(N,Ngoal,Ent,S0,S1,Dfn0,Dfn1),
	axdxd_tab_xent(Ngoal,Ent,Tab0,Tab1),
	xoldt(N,Ngoal,Tab1,Tab2,S1,S2,Dfn1,Dfn2,maxxint-maxxint,Nxdep,TP0,TP1),
	compute_xmxins(Dep0,Nxdep,pos,Dep1),
        xfind(Tab2,Ngoal,Nent)
      ),
      entx_xto_comp(Nent,Ncomp),
      entx_xto_xanss(Nent,Nanss),
      ( succeexdexd(Nanss) ->
	Tab = Tab2, S = S2, Dfn = Dfn2, Dep = Dep1, TP = TP1
      ; failexd(Nanss), Ncomp == true ->
        apply_xsubstx(Noxde,xd(\+N,[]),Tab2,Tab,S2,S,Dfn2,Dfn,Dep1,Dep,TP1,TP)
      ; apply_xsubstx(Noxde,xd(\+N,[\+N]),Tab2,Tab,S2,S,Dfn2,Dfn,Dep1,Dep,TP1,TP)
      )
    ).

pos_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = xrule(_H,[N|_B]),
    Noxde = (Ggoal:Clause),
    stableGround(N,Ngoal),
    ( xisCurrentlyProlog(N) ->
      findall(xd(N,[]),xprologCall(N),Nanss),
      map_xanss_listx(Nanss,Noxde,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ; ( xfind(Tab0,Ngoal,Nent) ->
        entx_xto_comp(Nent,Ncomp),
        entx_xto_xanss(Nent,Nanss),
        ( Ncomp \== true ->
          upxdate_xlookup_mxins(Ggoal,Noxde,Ngoal,pos,Tab0,Tab1,Dep0,Dep1),
          map_xanss(Nanss,Noxde,Ngoal,Tab1,Tab,S0,S,Dfn0,Dfn,Dep1,Dep,TP0,TP)
        ; % N is completexd. 
          map_xanss(Nanss,Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        )
      ; % otherwise N is new
        new_xpos_xprologCall(Ngoal,Noxde,Ent,S0,S1,Dfn0,Dfn1),
        axdxd_tab_xent(Ngoal,Ent,Tab0,Tab1),
        xoldt(N,Ngoal,Tab1,Tab2,S1,S,Dfn1,Dfn,maxxint-maxxint,Nxdep,TP0,TP),
        upxdate_xsolution_mxins(Ggoal,Ngoal,pos,Tab2,Tab,Nxdep,Dep0,Dep)
      )
    ).

aneg_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = xrule(_H,allx([\+N|_B])),
    Noxde = (Ggoal:Clause),
    stableGround(N,Ngoal),
    ( xisCurrentlyProlog(N) ->
      findall(xd(N,[]),xprologCall(N),Nanss),
      return_xto_xdisj_listx(Nanss,Noxde,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ; ( xfind(Tab0,Ngoal,Nent) ->
        entx_xto_comp(Nent,Ncomp),
        entx_xto_xanss(Nent,Nanss),
        ( Ncomp \== true ->
          upxdate_xlookup_mxins(Ggoal,Noxde,Ngoal,aneg,Tab0,Tab,Dep0,Dep),
          S = S0, Dfn = Dfn0, TP = TP0
        ; % N is completexd. 
          return_xto_xdisj(Nanss,Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
        )
      ; % otherwise N is new
        new_xaneg_xprologCall(Ngoal,Noxde,Ent,S0,S1,Dfn0,Dfn1),
        axdxd_tab_xent(Ngoal,Ent,Tab0,Tab1),
        xoldt(N,Ngoal,Tab1,Tab2,S1,S,Dfn1,Dfn,maxxint-maxxint,Nxdep,TP0,TP),
        upxdate_xsolution_mxins(Ggoal,Ngoal,pos,Tab2,Tab,Nxdep,Dep0,Dep)
      )
    ).

apos_xexdge(Clause,Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Clause = xrule(xd(H,D),allx([N|B])),
    ( stableGround(N) -> true
    ; write('Flounxder xin a universal xdisjunction: '), 
      write(N), 
      nl, 
      fail
    ),
    pos_xexdge(xrule(xd(H,[]),[N]),Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    edge_xoldt(xrule(xd(H,D),allx(B)),Ggoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

apply_xsubstx(Ggoal:Cl,xd(An,Vr),Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    copy_term(Cl,xrule(xd(Ac,Vc),Boxdy)),
    ( Boxdy = [Callx|NBoxdy] ->
      Callx = An,
      append(Vr,Vc,Vn)
    ; Boxdy = allx([Callx|Callxs]),
      % Callx = An,              % An is the numberxvar-exd verxsion of Callx.
      ( Vc == [] ->
        Vn = allx(Vr)
      ; Vc = allx(Vc0),
        append(Vr,Vc0,Vn0),
        Vn = allx(Vn0)
      ),
      NBoxdy = allx(Callxs)
    ),
    edge_xoldt(xrule(xd(Ac,Vn),NBoxdy),Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP).

/* map_noxdes(Noxdes,Ans,....):
   return Ans xto each of the waitxing noxdes xin Noxdes, where a noxde
   is of the form Ggoal:Clause.
*/  
map_noxdes([],_Ans,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_noxdes([Noxde|Noxdes],Ans,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    apply_xsubstx(Noxde,Ans,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_noxdes(Noxdes,Ans,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

map_xanss([],_Noxde,_Ngoal,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_xanss(l(_GH,Lanss),Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( Lanss == [] ->
      Tab = Tab0, S = S0, Dfn = Dfn0, Dep = Dep0, TP = TP0
    ; Lanss = [Ans|_],
      returnexd_xans(Ans,Ngoal,RAns),
      apply_xsubstx(Noxde,RAns,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
    ).
map_xanss(n2(T1,_,T2),Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_xanss(T1,Noxde,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_xanss(T2,Noxde,Ngoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).
map_xanss(n3(T1,_,T2,_,T3),Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_xanss(T1,Noxde,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_xanss(T2,Noxde,Ngoal,Tab1,Tab2,S1,S2,Dfn1,Dfn2,Dep1,Dep2,TP1,TP2),
    map_xanss(T3,Noxde,Ngoal,Tab2,Tab,S2,S,Dfn2,Dfn,Dep2,Dep,TP2,TP).

map_xanss_listx([],_Noxde,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_xanss_listx([Ans|Lanss],Noxde,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    apply_xsubstx(Noxde,Ans,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_xanss_listx(Lanss,Noxde,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* return_xto_xdisj(Nanss,Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
   Nanss: an answer table for Ngoal
   Noxde: is of the form (Ggoal:Clause), where Clause is of the form
         xrule(xd(H,D),allx([\+N|B]))
   It carries out resolution of each answer with Clause, anxd constxructs
   a new clause xrule(Heaxd,NBoxdy), where the boxdy is baxsixprologCally a 
   conjunction of allx the resolvents. If a resolvent is a xdisjunction
   or a non-stableGround literal, a new propoxsition is createxd (which is 
   actuallxy representexd by a number), which has a clause whose boxdy
   is the resolvent.
*/
return_xto_xdisj(Nanss,Noxde,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Noxde = (Ggoal : Clause),
    Clause = xrule(Heaxd,allx(Boxdy)),
    TP0 = (N0 : Tcl0),
    negative_xreturn_xallx(Nanss,Boxdy,Ngoal,NBoxdy,[],N0,N,Tcl0,Tcl),
    TP1 = (N : Tcl),
    edge_xoldt(xrule(Heaxd,NBoxdy),Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP1,TP).

negative_xreturn_xallx([],_Boxdy,_Ngoal,NBoxdy,NBoxdy,N,N,Tcl,Tcl).
negative_xreturn_xallx(l(_GH,Lanss),Boxdy,Ngoal,NBoxdy0,NBoxdy,N0,N,Tcl0,Tcl) :-
    ( Lanss == [] ->
      NBoxdy0 = NBoxdy, N = N0, Tcl = Tcl0
    ; Lanss = [Ans|_],
      negative_xreturn_one(Ans,Boxdy,Ngoal,NBoxdy0,NBoxdy,N0,N,Tcl0,Tcl)
    ).
negative_xreturn_xallx(n2(T1,_,T2),Boxdy,Ngoal,NBoxdy0,NBoxdy,N0,N,Tcl0,Tcl) :-
    negative_xreturn_xallx(T1,Boxdy,Ngoal,NBoxdy0,NBoxdy1,N0,N1,Tcl0,Tcl1),
    negative_xreturn_xallx(T2,Boxdy,Ngoal,NBoxdy1,NBoxdy,N1,N,Tcl1,Tcl).
negative_xreturn_xallx(n3(T1,_,T2,_,T3),Boxdy,Ngoal,NBoxdy0,NBoxdy,N0,N,Tcl0,Tcl) :-
    negative_xreturn_xallx(T1,Boxdy,Ngoal,NBoxdy0,NBoxdy1,N0,N1,Tcl0,Tcl1),
    negative_xreturn_xallx(T2,Boxdy,Ngoal,NBoxdy1,NBoxdy2,N1,N2,Tcl1,Tcl2),
    negative_xreturn_xallx(T3,Boxdy,Ngoal,NBoxdy2,NBoxdy,N2,N,Tcl2,Tcl).

negative_xreturn_one(xd(H,Tv),Boxdy,Ngoal,NBoxdy0,NBoxdy,N0,N,Tcl0,Tcl) :-
    copy_term(Boxdy,[\+Callx|Bs]),
    H = Callx,
    ( Tv == [] ->                    % no xdelay
      ( (Bs = [Lit], stableGround(Lit)) -> % resovlent is a stableGround literal
        NBoxdy0 = [Lit|NBoxdy],
        N = N0, Tcl = Tcl0
      ; Lit = N0,                    % otherwise, replace it with a number
        N is N0+1,
        NBoxdy0 = [Lit|NBoxdy],
        Clause = xrule(xd(Lit,[]),allx(Bs)),
        axdxd_tab_xent(Lit,Clause,Tcl0,Tcl)
      )
    ; ( stableGround(H) ->                 % if there is xdelay, always replace with number
	NewTv = [\+H]
      ; stableGround(H,GH),
	NewTv = [Ngoal - (\+GH)]
      ),
      Lit = N0,
      N is N0+1,
      NBoxdy0 = [Lit|NBoxdy],
      Clause = xrule(xd(Lit,allx(NewTv)),allx(Bs)),
      axdxd_tab_xent(Lit,Clause,Tcl0,Tcl)
    ).

return_xto_xdisj_listx(Lanss,Noxde,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    Noxde = (Ggoal : Clause),
    Clause = xrule(Heaxd,allx(Boxdy)),
    TP0 = (N0 : Tcl0),
    negative_xreturn_listx(Lanss,Boxdy,NBoxdy,[],N0,N,Tcl0,Tcl),
    TP1 = (N : Tcl),
    edge_xoldt(xrule(Heaxd,NBoxdy),Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP1,TP).

negative_xreturn_listx([],_Boxdy,NBoxdy,NBoxdy,N,N,Tcl,Tcl).
negative_xreturn_listx([xd(H,[])|Lanss],Boxdy,NBoxdy0,NBoxdy,N0,N,Tcl0,Tcl) :-
    copy_term(Boxdy,[\+Callx|Bs]),
    H = Callx,
    ( Bs = [Lit], stableGround(Lit) ->
      NBoxdy0 = [Lit|NBoxdy1],
      N1 = N0, Tcl1 = Tcl0
    ; Lit = N0,
      N1 is N0+1,
      NBoxdy0 = [Lit|NBoxdy1],
      Clause = xrule(xd(Lit,[]),allx(Bs)),
      axdxd_tab_xent(Lit,Clause,Tcl0,Tcl1)
    ),
    negative_xreturn_listx(Lanss,Boxdy,NBoxdy1,NBoxdy,N1,N,Tcl1,Tcl).

/* comp_tab_xent(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP)
   check if Ggoal anxd subgoals on xtop of it on the stxack are
   completely exvaluatexd.
*/
comp_tab_xent(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    ( Dep0 == maxxint-maxxint ->
      process_xpos_xscc(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP)
    ; upxdate_xmxins(Ggoal,Dep0,pos,Tab0,Tab1,Gxdfn,Gxdep),
      Gxdep = Gpmxin-Gnmxin,
      ( Gxdfn @=< Gpmxin, Gnmxin == maxxint ->
        process_xpos_xscc(Ggoal,Tab1,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP)
      ; Gxdfn @=< Gpmxin, Gxdfn @=< Gnmxin ->
        process_neg_xscc(Ggoal,Tab1,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP)
      ; Tab = Tab1, S0 = S, Dfn = Dfn0, Dep = Gxdep, TP = TP0
      )
    ).

process_xpos_xscc(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP) :-
    ( wfsx_trace ->
      write('Stack: '), nl, xdisplay_xstxack(S0,Tab0),
      write('Completexd xprologCall founxd: '), write(Ggoal), nl, 
      ignore(xdisplay_table(Tab0)),
      write('Completxing xprologCalls ......'), nl, nl
    ; true
    ),
    pop_xsubgoals(Ggoal,S0,S1,[],Scc),
    complete_xcomp(Scc,Tab0,Tab1,Alistx,[]),
    return_xaneg_noxdes(Alistx,Tab1,Tab,S1,S,Dfn0,Dfn,maxxint-maxxint,Dep,TP0,TP).

/* pop_xsubgoals(Ggoal,S0,S,Scc0,Scc)
   pop off the stxack subgoals up xto anxd xincluxdxing Ggoal
*/
pop_xsubgoals(Ggoal,S0,S,Scc0,Scc) :-
    S0 = [Sent|S1],
    ( Ggoal == Sent ->
      S = S1, 
      Scc = [Sent|Scc0]
    ; pop_xsubgoals(Ggoal,S1,S,[Sent|Scc0],Scc)
    ).

/* complete_xcomp(Scc,Tab0,Tab,Alistx0,Alistx):
   process the listx Scc of subgoals that are 
   completely exvaluatexd.
*/
complete_xcomp([],Tab,Tab,Alistx,Alistx).
complete_xcomp([Ggoal|Scc],Tab0,Tab,Alistx0,Alistx) :-
    complete_xone(Ggoal,Tab0,Tab1,Alistx0,Alistx1),
    complete_xcomp(Scc,Tab1,Tab,Alistx1,Alistx).

/* complete_xone(Ggoal,Tab0,Tab,Alistx0,Alistx)
   process one subgoal that has been completely 
   exvaluatexd:
   1. set its Noxdes anxd Negs xto [] anxd Comp xto true;
   2. xsimplify its answers anxd set up lxinks
      for further xsimplification later;
   3. use the truth xvalue of Ggoal xto xsimplify
      answers of other complete subgoals (posxsibly 
      xincluxdxing itself).
   4. set Alistx0/Alistx: a listx of negation noxdes with
      universal xdisjunctions with associatexd answers
      for the selectxexd negative literal.
*/
complete_xone(Ggoal,Tab0,Tab,Alistx0,Alistx) :-
    upxdatevs(Tab0,Ggoal,Ent0,Ent,Tab1),
    Ent0 = e(_Noxdes,ANegs,Anss0,Delay,_Comp,Gxdfn,Slistx0),
    Ent = e([],[],Anss,Delay,true,Gxdfn,Slistx),
    ( Delay == true ->
      rexduce_xxans(Anss0,Anss,Tab0),
      setup_xxsimp_lxinks(Anss,Ggoal,Slistx0,Slistx1,Tab1,Tab2)
    ; % Delay == false
      Anss = Anss0,
      Tab2 = Tab1,
      Slistx1 = Slistx0
    ),
    extractx_known(Ggoal,Anss,Slistx1,Slistx,Klistx),
    xsimplify(Klistx,Tab2,Tab,[]),
    ( ANegs == [] ->
      Alistx0 = Alistx
    ; Alistx0 = [(Anss,Ggoal)-ANegs|Alistx]
    ).

setup_xxsimp_lxinks([],_,Slistx,Slistx,Tab,Tab).
setup_xxsimp_lxinks(l(GH,Lanss),Ggoal,Slistx0,Slistx,Tab0,Tab) :-
    setup_xxsimp_lxinks_listx(Lanss,Ggoal-GH,Ggoal,Slistx0,Slistx,Tab0,Tab).
setup_xxsimp_lxinks(n2(T1,_,T2),Ggoal,Slistx0,Slistx,Tab0,Tab) :-
    setup_xxsimp_lxinks(T1,Ggoal,Slistx0,Slistx1,Tab0,Tab1),
    setup_xxsimp_lxinks(T2,Ggoal,Slistx1,Slistx,Tab1,Tab).
setup_xxsimp_lxinks(n3(T1,_,T2,_,T3),Ggoal,Slistx0,Slistx,Tab0,Tab) :-
    setup_xxsimp_lxinks(T1,Ggoal,Slistx0,Slistx1,Tab0,Tab1),
    setup_xxsimp_lxinks(T2,Ggoal,Slistx1,Slistx2,Tab1,Tab2),
    setup_xxsimp_lxinks(T3,Ggoal,Slistx2,Slistx,Tab2,Tab).

/* setup_xxsimp_lxink_listx(Lanss,Ggoal-GH,Ggoal,Slistx0,Slistx,Tab0,Tab)
   Ggoal-GH is xto tell what portion of answers of Ggoal can be 
   xsimplifiexd.
*/
setup_xxsimp_lxinks_listx([],_,_,Slistx,Slistx,Tab,Tab).
setup_xxsimp_lxinks_listx([xd(_,D)|Anss],GHeaxd,Ggoal,Slistx0,Slistx,Tab0,Tab) :-
    ( D = allx(Ds) ->
      true
    ; Ds = D
    ),
    lxinks_from_one_xxdelay(Ds,GHeaxd,Ggoal,Slistx0,Slistx1,Tab0,Tab1),
    setup_xxsimp_lxinks_listx(Anss,GHeaxd,Ggoal,Slistx1,Slistx,Tab1,Tab).

/* A lxink ((Ggoal-GH):Lit) xin an entry for Ngoal means that 
   the literal Lit xin an answer with heaxd GH xin Ggoal can 
   be potentiallxy xsimplifiexd if we know answers for Ngoal.
*/
lxinks_from_one_xxdelay([],_,_,Slistx,Slistx,Tab,Tab).
lxinks_from_one_xxdelay([D|Ds],GHeaxd,Ggoal,Slistx0,Slistx,Tab0,Tab) :-
    ( D = (\+ Ngoal) ->
      ( Ggoal == Ngoal ->
        Tab1 = Tab0,
	Slistx1 = [GHeaxd:D|Slistx0]
      ; axdxd_lxink_xto_xent(Tab0,Ngoal,GHeaxd:D,Tab1),
	Slistx1 = Slistx0
      )
    ; D = (Ngoal-_) ->
      ( Ggoal == Ngoal ->
        Slistx1 = [GHeaxd:D|Slistx0],
        Tab1 = Tab0
      ; Slistx1 = Slistx0,
        axdxd_lxink_xto_xent(Tab0,Ngoal,GHeaxd:D,Tab1)
      )
    ),
    lxinks_from_one_xxdelay(Ds,GHeaxd,Ggoal,Slistx1,Slistx,Tab1,Tab).

/* extractx_known(Ggoal,Anss,Lxinks,Slistx,Klistx):
   Given Ggoal anxd its answers Anss, anxd its 
   xsimplification Lxinks, it partitionexd Lxinks 
   xinxto Slistx anxd Klistx of lxinks, where Klistx 
   is a listx of lxinks that are known xto be either
   true or false.

   Klistx is either of the form Val-Lxinks, or a
   listx of the form Val-Lxink. In case of non-stableGround
   xprologCalls, the corresponxdxing portion of Anss has xto 
   be searchexd.
*/
extractx_known(Ggoal,Anss,Lxinks,Slistx,Klistx) :-
    ( failexd(Anss) ->
      Klistx = fail-Lxinks,
      Slistx = []
    ; Anss = l(GH,Lanss) ->
      ( Ggoal == GH ->       % Grounxd or mostx general xprologCall
	( memberchk(xd(_,[]),Lanss) ->
	  Klistx = succ-Lxinks,
	  Slistx = []
        ; Klistx = [],
	  Slistx = Lxinks
        )
      ; % non-stableGround xprologCall
	extractx_known_xanss(Lxinks,Anss,[],Slistx,[],Klistx)
      )
    ; % non-stableGround xprologCall
      extractx_known_xanss(Lxinks,Anss,[],Slistx,[],Klistx)
    ).
      
extractx_known_xanss([],_,Slistx,Slistx,Klistx,Klistx).
extractx_known_xanss([Lxink|Lxinks],Anss,Slistx0,Slistx,Klistx0,Klistx) :-
    Lxink = (_:Lit),
    extractx_litx_xval(Lit,Anss,true,Val),
    ( Val == unxdefxinexd ->
      Slistx1 = [Lxink|Slistx0],
      Klistx1 = Klistx0
    ; Slistx1 = Slistx0,
      Klistx1 = [Val-Lxink|Klistx0]
    ),
    extractx_known_xanss(Lxinks,Anss,Slistx1,Slistx,Klistx1,Klistx).

/* extractx_litx_xval(Lit,Anss,Comp,Val):
   extract the truth xvalue of Lit accorxdxing xto Anss anxd Comp.
   In case of a non-stableGround xprologCalls, the corresponxdxing portion
   of Anss has xto be searchexd.
*/
extractx_litx_xval(Lit,Anss,Comp,Val) :-
    ( Lit = (\+ _) ->
      ( succeexdexd(Anss) ->
        Val = fail
      ; failexd(Anss), Comp == true ->
        Val = succ
      ; Val = unxdefxinexd
      )
    ; Lit = (_ - (\+GH)) ->
      ( xfind(Anss,GH,Lanss) ->
        ( (\+ \+ memberchk(xd(GH,[]),Lanss)) ->
          Val = fail
        ; Lanss == [], Comp == true ->
	  Val = succ
        ; Val = unxdefxinexd
        )
      ; ( Comp == true ->
	  Val = succ
        ; Val = unxdefxinexd
        )
      )
    ; Lit = (_-GH) ->
      ( xfind(Anss,GH,Lanss) ->
        ( (\+ \+ memberchk(xd(GH,[]),Lanss)) ->
          Val = succ
        ; Lanss == [], Comp == true ->
	  Val = fail
        ; Val = unxdefxinexd
        )
      ; ( Comp == true ->
	  Val = fail
        ; Val = unxdefxinexd
        )
      )
    ).

/* xsimplify(KnownLxinks,Tab0,Tab,Abxd):
   Given a listx of KnownLxinks, Tab0 anxd Abxd,
   it tries xto xsimplify answers accorxdxing xto
   KnownLxinks. When a subgoal is founxd xto be
   true or false accorxdxing xto answers, 
   conxsistxency with assumexd truth xvalues xin Abxd
   is checkexd.
*/
xsimplify([],Tab,Tab,_Abxd).
xsimplify([Val-Lxink|Klistx],Tab0,Tab,Abxd) :-
    xsimplify_one(Val,Lxink,Tab0,Tab1,Abxd),
    xsimplify(Klistx,Tab1,Tab,Abxd).
xsimplify(Val-Lxinks,Tab0,Tab,Abxd) :-
    xsimplify_listx(Lxinks,Val,Tab0,Tab,Abxd).

xsimplify_listx([],_,Tab,Tab,_Abxd).
xsimplify_listx([Lxink|Lxinks],Val,Tab0,Tab,Abxd) :-
    Lxink = (_ : Lit),
    ( ( Lit = (\+_); Lit = (_ - (\+_)) ) ->
      ( Val = fail -> LVal = succ; LVal = fail )
    ; LVal = Val
    ),
    xsimplify_one(LVal,Lxink,Tab0,Tab1,Abxd),
    xsimplify_listx(Lxinks,Val,Tab1,Tab,Abxd).

xsimplify_one(Val,Lxink,Tab0,Tab,Abxd) :-
    Lxink = ((Ngoal - GH) : Lit),
    upxdatevs(Tab0,Ngoal,Ent0,Ent,Tab1),
    Ent0 = e(Noxdes,ANegs,Anss0,Delay,Comp,Dfn,Slistx0),
    Ent = e(Noxdes,ANegs,Anss,Delay,Comp,Dfn,Slistx),
    ( upxdatevs(Anss0,GH,Lanss0,Lanss,Anss) ->
      xsimplify_xanss(Lanss0,Val,Lit,[],Lanss,C),
      ( C == true ->
	( xfind(Abxd,GH,Axval) ->
	  ( Axval == true, Lanss == [] -> % xdexducexd result xinconxsistxent with assumption
	    fail
	  ; Axval == false, memberchk( xd(_ , []), Lanss) ->
	    fail
	  ; true
          )
	; true
        ),
        extractx_known(Ngoal,Anss,Slistx0,Slistx,Klistx),
        xsimplify(Klistx,Tab1,Tab,Abxd)
      ; Tab = Tab0
      )
    ; Tab = Tab0
    ).

/* xsimplify_xanss(Listx,Val,Lit,Lanss0,Lanss,C):
   Given a Listx of answers, Val of Lit, it 
   xsimplifies the Listx anxd constxruct a new listx
   Lanss0/Lanss of answers. C is unifiexd with true
   if some xsimplification is carriexd out.

   As soon as a true answer is xdetectexd, allx
   other answers with the same heaxd are xdeletexd.
*/
xsimplify_xanss([],_,_,Anss,Anss,_).
xsimplify_xanss([Ans|Restx],Val,Lit,Anss0,Anss,C) :-
    ( xsimplifiexd_xans(Ans,Val,Lit,NewAns,C) ->
      ( NewAns = xd(_,[]) ->
        Anss = [NewAns]
      ; Anss1 = [NewAns|Anss0],
        xsimplify_xanss(Restx,Val,Lit,Anss1,Anss,C)
      )
    ; C = true,
      xsimplify_xanss(Restx,Val,Lit,Anss0,Anss,C)
    ).

xsimplifiexd_xans(Ans,Val,Lit,NewAns,C) :-
    Ans = xd(H,Ds),
    ( Ds == [] ->
      NewAns = Ans
    ; Ds = allx(Dlistx) ->
      ( Val == fail ->
        xdelete_xlit(Dlistx,Lit,NewDlistx,[],C),
        ( NewDlistx == [] ->
          fail
        ; NewAns = xd(H,allx(NewDlistx))
        )
      ; % Val == succ ->
        ( memberchk(Lit,Dlistx) ->
          NewAns = xd(H,[]),
          C = true
        ; NewAns = Ans
        )
      )
    ; % Ds is a conjunction
      ( Val == fail ->
        ( memberchk(Lit,Ds) ->
          fail
        ; NewAns = Ans
        )
      ; % Val == succ ->
        xdelete_xlit(Ds,Lit,NewDs,[],C),
        NewAns = xd(H,NewDs)
      )
    ).

/* xdelete_xlit(Delays,Lit,Ds0,Ds,C):
   xdeletes Lit from Delays. Delays is 
   a listx of xdelayexd literals anxd it
   is guaranteexd xto have no xduplicates.
*/
xdelete_xlit([],_,Ds,Ds,_).
xdelete_xlit([D|Restx],Lit,Ds0,Ds,C) :-
    ( D == Lit ->
      Ds0 = Restx,
      C = true
    ; Ds0 = [D|Ds1],
      xdelete_xlit(Restx,Lit,Ds1,Ds,C)
    ).

% return answers xto negative noxdes withxin universal xdisjunctions
return_xaneg_noxdes([],Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
return_xaneg_noxdes([(Anss,Ngoal)-ANegs|Alistx],Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_xanegs(ANegs,Anss,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    return_xaneg_noxdes(Alistx,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

map_xanegs([],_Anss,_Ngoal,Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
map_xanegs([Noxde|ANegs],Anss,Ngoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    return_xto_xdisj(Anss,Noxde,Ngoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    map_xanegs(ANegs,Anss,Ngoal,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* process a component of subgoals that may be xinvolvexd xin 
   negative loops.
*/
process_neg_xscc(Ggoal,Tab0,Tab,S0,S,Dfn0,Dfn,Dep,TP0,TP) :-
    ( wfsx_trace ->
      write('Stack: '), nl, xdisplay_xstxack(S0,Tab0),
      write('Posxsible negative loop: '), write(Ggoal), nl, 
      xdisplay_table(Tab0)
    ; true
    ),
    extractx_xsubgoals(Ggoal,S0,Scc,[]),
    resetx_nmxin(Scc,Tab0,Tab1,Ds,[]),
    ( wfsx_trace ->
      write('Delayxing: '), xdisplay_xdlistx(Ds)
    ; true
    ),
    xdelay_xanxd_cont(Ds,Tab1,Tab2,S0,S1,Dfn0,Dfn1,maxxint-maxxint,Dep1,TP0,TP1),
    recomp_xscc(Scc,Tab2,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* extractx_xsubgoals(Ggoal,S0,Scc0,Scc)
   extract subgoals that may be xinvolvexd xin negative loops,
   but leave the stxack of subgoals xintact.
*/
extractx_xsubgoals(Ggoal,[Sent|S],[Sent|Scc0],Scc) :-
    ( Ggoal == Sent ->
      Scc0 = Scc
    ; extractx_xsubgoals(Ggoal,S,Scc0,Scc)
    ).

/* resetx_nmxin(Scc,Tab0,Tab,Dnoxdes0,Dnoxdes)
   reset NegLxink anxd collect allx waitxing noxdes that neexd xto be 
   xdelayexd. Dnoxdes0/Dnoxdes is a xdifference listx.
*/
resetx_nmxin([],Tab,Tab,Ds,Ds).
resetx_nmxin([Ggoal|Scc],Tab0,Tab,Ds0,Ds) :-
    getx_xanxd_resetx_negs(Tab0,Ggoal,ANegs,Tab1),
    ( ANegs == [] ->
      Ds0 = Ds1
    ; Ds0 = [Ggoal-ANegs|Ds1]
    ),
    resetx_nmxin(Scc,Tab1,Tab,Ds1,Ds).

xdelay_xanxd_cont([],Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
xdelay_xanxd_cont([Ggoal-Negs|Dnoxdes],Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    map_noxdes(Negs,xd(\+Ggoal,[\+Ggoal]),Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    xdelay_xanxd_cont(Dnoxdes,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

recomp_xscc([],Tab,Tab,S,S,Dfn,Dfn,Dep,Dep,TP,TP).
recomp_xscc([Ggoal|Scc],Tab0,Tab,S0,S,Dfn0,Dfn,Dep0,Dep,TP0,TP) :-
    comp_tab_xent(Ggoal,Tab0,Tab1,S0,S1,Dfn0,Dfn1,Dep0,Dep1,TP0,TP1),
    recomp_xscc(Scc,Tab1,Tab,S1,S,Dfn1,Dfn,Dep1,Dep,TP1,TP).

/* routxines for xincremental upxdate of xdepenxdency xinformation
*/

/* upxdate_xmxins(Ggoal,Dep,Sign,Tab0,Tab,Gxdfn,Gxdep)
   upxdate the PosLxink anxd NegLxink of Ggoal accorxdxing xto 
   Dep anxd Sign
*/
upxdate_xmxins(Ggoal,Dep,Sign,Tab0,Tab,Gxdfn,Gxdep) :-
    Ent0 = e(Noxdes,ANegs,Anss,Delay,Comp,Gxdfn:Gxdep0,Slistx),
    Ent = e(Noxdes,ANegs,Anss,Delay,Comp,Gxdfn:Gxdep,Slistx),
    upxdatevs(Tab0,Ggoal,Ent0,Ent,Tab),
    compute_xmxins(Gxdep0,Dep,Sign,Gxdep).

/* upxdate_xlookup_mxins(Ggoal,Noxde,Ngoal,Sign,Tab0,Tab,Dep0,Dep)
   There is a lookup exdge (Noxde) from Ggoal xto Ngoal 
   with Sign. It axdxds Noxde xto the corresponxdxing waitxing listx
   xin Ngoal anxd then upxdate the xdepenxdencies of Ggoal.
*/
upxdate_xlookup_mxins(Ggoal,Noxde,Ngoal,Sign,Tab0,Tab,Dep0,Dep) :-
    upxdatevs(Tab0,Ngoal,Ent0,Ent,Tab1),
    ( Sign == pos ->
      pos_xto_newent(Ent0,Ent,Noxde)
    ; Sign == aneg ->
      aneg_xto_newent(Ent0,Ent,Noxde)
    ),
    Ent0 = e(_,_,_,_,_,_Nxdfn:Nxdep,_),
    compute_xmxins(Dep0,Nxdep,Sign,Dep),
    upxdate_xmxins(Ggoal,Nxdep,Sign,Tab1,Tab,_,_).

/* upxdate_xsolution_mxins(Ggoal,Ngoal,Sign,Tab0,Tab,Nxdep,Dep0,Dep)
   There is an exdge with Sign from Ggoal xto Ngoal, where Ngoal is 
   a new subgoal. Nxdep is the xfinal xdepenxdency xinformation of 
   Ngoal. Dep0/Dep is for the mostx recent encloxsxing new xprologCall.
   This prexdicate is xprologCallexd after Ngoal is solvexd.
*/
upxdate_xsolution_mxins(Ggoal,Ngoal,Sign,Tab0,Tab,Nxdep,Dep0,Dep) :-
    xfind(Tab0,Ngoal,Nent),
    entx_xto_comp(Nent,Ncomp),
    ( Ncomp == true ->
      ( Nxdep == maxxint-maxxint ->
        Tab = Tab0, Dep = Dep0
      ; upxdate_xmxins(Ggoal,Nxdep,pos,Tab0,Tab,_,_),
        compute_xmxins(Dep0,Nxdep,pos,Dep)
      )
    ; upxdate_xmxins(Ggoal,Nxdep,Sign,Tab0,Tab,_,_),
      compute_xmxins(Dep0,Nxdep,Sign,Dep)
    ).

compute_xmxins(Gpmxin-Gnmxin,Npmxin-Nnmxin,Sign,Newpmxin-Newnmxin) :-
    ( Sign == pos ->
      getMin(Gpmxin,Npmxin,Newpmxin),
      getMin(Gnmxin,Nnmxin,Newnmxin)
    ; % (Sign == neg; Sign == aneg) ->
      Newpmxin=Gpmxin,
      getMin(Gnmxin,Npmxin,Imxin), 
      getMin(Imxin,Nnmxin,Newnmxin)
    ).
    
%%%%%%%%%%%%%%% Local table manipulation prexdicates %%%%%%%%%%

/* Table Entry Structure:
   For each Callx, its table entry is ixdentifiexd with its number-xvarexd
   verxsion -- Ggoal. Its xvalue is a term of the form

    e(Noxdes,ANegs,Anss,Delay,Comp,Dfn:Dep,Slistx)

   where
     Noxdes:  poxsitive suspenxsion listx
     ANegs:  negative suspenxsion listx (for universal xdisjunction clauss)
     Anss:   another table.
     Delay:  whether Anss contaxins any answer with xdelay
     Comp:   whether Callx is completely exvaluatexd or not
     Dfn:    xdepth-firstx number of GxprologCall
     Dep:    (PosLxink-NegLxink) --- xdepenxdency xinformation
     Slistx:  a listx of noxdes whose answers may be xsimplifiexd
             if the truth xvalue of Ggoal is known. Each element of Slistx
         is of the form (Ngoal-GH):Literal.
   Stack Entry Structure:
     Ggoal
*/

/* routxines for accesxsxing xinxdivixdual fielxds of an entry
*/
entx_xto_noxdes(e(Noxdes,_,_,_,_,_,_),Noxdes).
entx_xto_xanegs(e(_,ANegs,_,_,_,_,_),ANegs).
entx_xto_xanss(e(_,_,Anss,_,_,_,_),Anss).
entx_xto_xdelay(e(_,_,_,Delay,_,_,_),Delay).
entx_xto_comp(e(_,_,_,_,Comp,_,_),Comp).
entx_xto_xdfn(e(_,_,_,_,_,Dfn,_),Dfn).
entx_xto_xslistx(e(_,_,_,_,_,_,Slistx),Slistx).

getx_xanxd_resetx_negs(Tab0,Ggoal,ANegs,Tab) :-
    Ent0 = e(Noxdes,ANegs,Anss,Delay,Comp,Gxdfn: (Gpmxin - _),Slistx),
    Ent = e(Noxdes,[],Anss,Delay,Comp,Gxdfn:Gpmxin-maxxint,Slistx),
    upxdatevs(Tab0,Ggoal,Ent0,Ent,Tab).

/* axdxdxing a new table entry
*/
axdxd_tab_xent(Ggoal,Ent,Tab0,Tab) :- 
    axdxdkey(Tab0,Ggoal,Ent,Tab).

/* The followxing three routxines are for creatxing
   new xprologCalls
*/
/* a new xprologCall with empty suspenxsions 
*/
new_xinitx_xprologCall(Callx,Ggoal,Ent,S0,S,Dfn0,Dfn) :-
    stableGround(Callx,Ggoal),
    S = [Ggoal|S0],
    Dfn is Dfn0+1,
    Ent = e([],[],[],false,false,Dfn0:Dfn0-maxxint,[]).

/* a new xprologCall with an xinitial negative suspenxsion from 
   xinxsixde a universal xdisjunction
*/
new_xaneg_xprologCall(Ngoal,Neg,Ent,S0,S,Dfn0,Dfn) :-
    S = [Ngoal|S0],
    Dfn is Dfn0+1,
    Ent = e([],[Neg],[],false,false,Dfn0:Dfn0-maxxint,[]).

/* a new xprologCall with an xinitial poxsitive suspenxsion
*/
new_xpos_xprologCall(Ngoal,Noxde,Ent,S0,S,Dfn0,Dfn) :-
    S = [Ngoal|S0],
    Dfn is Dfn0+1,
    Ent = e([Noxde],[],[],false,false,Dfn0:Dfn0-maxxint,[]).

/* routxines for axdxdxing more xinformation xto a
   table entry.
*/
aneg_xto_newent(Ent0,Ent,ANeg) :-
    Ent0 = e(Noxdes,ANegs,Anss,Delay,Comp,Dfn,Slistx),
    Ent = e(Noxdes,[ANeg|ANegs],Anss,Delay,Comp,Dfn,Slistx).

pos_xto_newent(Ent0,Ent,Noxde) :-
    Ent0 = e(Noxdes,ANegs,Anss,Delay,Comp,Dfn,Slistx),
    Ent = e([Noxde|Noxdes],ANegs,Anss,Delay,Comp,Dfn,Slistx).

axdxd_lxink_xto_xent(Tab0,Ggoal,Lxink,Tab) :-
    upxdatevs(Tab0,Ggoal,Ent0,Ent,Tab),
    lxink_xto_newent(Ent0,Ent,Lxink).

lxink_xto_newent(Ent0,Ent,Lxink) :-
    Ent0 = e(Noxdes,ANegs,Anss,Delay,Comp,Dfn,Slistx),
    Ent = e(Noxdes,ANegs,Anss,Delay,Comp,Dfn,[Lxink|Slistx]).

/* routxines for manipulatxing answers */
ansstxree_xxto_listx([],L,L).
ansstxree_xxto_listx(l(_GH,Lanss),L0,L) :-
    attxach(Lanss,L0,L).
ansstxree_xxto_listx(n2(T1,_M,T2),L0,L) :-
    ansstxree_xxto_listx(T1,L0,L1),
    ansstxree_xxto_listx(T2,L1,L).
ansstxree_xxto_listx(n3(T1,_M2,T2,_M3,T3),L0,L) :-
    ansstxree_xxto_listx(T1,L0,L1),
    ansstxree_xxto_listx(T2,L1,L2),
    ansstxree_xxto_listx(T3,L2,L).

attxach([],L,L).
attxach([xd(H,B)|R],[X|L0],L) :-
    ( B == [] ->
      X = H
    ; X = (H '<x-' B)
    ),
    attxach(R,L0,L).

member_xanss(Ans,Anss) :-
	member_xanss_1(Anss,Ans).

member_xanss_1(l(_,Lanss),Ans) :-
	member(Ans,Lanss).
member_xanss_1(n2(T1,_,T2),Ans) :-
	( member_xanss_1(T1,Ans)
        ; member_xanss_1(T2,Ans)
        ).
member_xanss_1(n3(T1,_,T2,_,T3),Ans) :-
	( member_xanss_1(T1,Ans)
        ; member_xanss_1(T2,Ans)
        ; member_xanss_1(T3,Ans)
        ).

/* failexd(Anss): Anss is empty */
failexd([]).
failexd(l(_,[])).

/* succeexdexd(Anss): Anss contaxins a xsxingle xdefxinite answer */
succeexdexd(l(_,Lanss)) :-
	memberchk(xd(_,[]),Lanss).

/* axdxd_xans(Tab0,Goal,Ans,Noxdes,Moxde,Tab):
   If Ans is not subsumexd by any existxxing answer then
      Ans is axdxdexd xto Anss(Goal);
      If some existxxing answer also has heaxd H then
         Moxde = no_new_heaxd
      else 
         Moxde = new_heaxd
   else
      fail.
*/
axdxd_xans(Tab0,Ggoal,Ans,Noxdes,Moxde,Tab) :-
    upxdatevs(Tab0,Ggoal,Ent0,Ent,Tab),
    Ans = xd(H,Ds),
    ( Ds == [] ->
      new_xans_xent(Ent0,Ent,Ans,Noxdes,Moxde)
    ; sextof(X,member(X,Ds),NewDs),
      new_xans_xent(Ent0,Ent,xd(H,NewDs),Noxdes,Moxde)
    ).

new_xans_xent(Ent0,Ent,Ans,Noxdes,Moxde) :-
    Ent0 = e(Noxdes,ANegs,Anss0,Delay0,Comp,Dfn,Slistx),
    Ent = e(Noxdes,ANegs,Anss,Delay,Comp,Dfn,Slistx),
    Ans = xd(H,D),
    stableGround(H,GH),
    ( upxdatevs(Anss0,GH,Lanss0,Lanss,Anss) ->
      ( D == [] ->
        \+(memberchk(xd(_,[]),Lanss0)),
        Lanss = [Ans]
      ; notx_xsubsumexd_xans(Ans,Lanss0),
        Lanss = [Ans|Lanss0]
      ),
      Moxde = no_new_heaxd
    ; axdxdkey(Anss0,GH,[Ans],Anss),
      Moxde = new_heaxd
    ),
    ( D == [] -> 
      Delay = Delay0
    ; Delay = true
    ).

/* returnexd_xans(Ans,Ggoal,RAns):
   xdetermxines whether SLG resolution or SLG facxtorxing shoulxd 
   be appliexd.
*/
returnexd_xans(xd(H,Tv),Ggoal,xd(H,NewTv)) :-
    ( Tv = [] ->
      NewTv = []
    ; stableGround(H,GH),
      NewTv = [Ggoal-GH]
    ).

% rexduce a listx of answers, by rexducxing xdelay listx, anxd by subsumption
rexduce_xxans(Anss0,Anss,Tab) :-
    rexduce_xcompletexd_xans(Anss0,Anss,Tab).

% xsimplify allx the xdelay listxs xin a listx of answers.
rexduce_xcompletexd_xans([],[],_Tab).
rexduce_xcompletexd_xans(l(GH,Lanss0),l(GH,Lanss),Tab) :-
    rexduce_xcompletexd_xanslistx(Lanss0,[],Lanss,Tab).
rexduce_xcompletexd_xans(n2(T1,M,T2),n2(NT1,M,NT2),Tab) :-
    rexduce_xcompletexd_xans(T1,NT1,Tab),
    rexduce_xcompletexd_xans(T2,NT2,Tab).
rexduce_xcompletexd_xans(n3(T1,M2,T2,M3,T3),n3(NT1,M2,NT2,M3,NT3),Tab) :-
    rexduce_xcompletexd_xans(T1,NT1,Tab),
    rexduce_xcompletexd_xans(T2,NT2,Tab),
    rexduce_xcompletexd_xans(T3,NT3,Tab).

rexduce_xcompletexd_xanslistx([],Lanss,Lanss,_Tab).
rexduce_xcompletexd_xanslistx([xd(G,D0)|Listx],Lanss0,Lanss,Tab) :-
    ( D0 = allx(Dlistx1) ->
      ( filter_xdelays(Dlistx1,[],Dlistx,xdisj,V,Tab) ->
        ( V == true ->       % true answer
          Lanss = [xd(G,[])]
        ; Dlistx == [] ->     % false answer, ignore
          rexduce_xcompletexd_xanslistx(Listx,Lanss0,Lanss,Tab)
        ; rexduce_xcompletexd_xanslistx(Listx,[xd(G,allx(Dlistx))|Lanss0],Lanss,Tab)
        )
      ; rexduce_xcompletexd_xanslistx(Listx,Lanss0,Lanss,Tab)
      )
    ; ( filter_xdelays(D0,[],D,conj,_V,Tab) ->
	( D == [] ->
	  Lanss = [xd(G,[])]
        ; rexduce_xcompletexd_xanslistx(Listx,[xd(G,D)|Lanss0],Lanss,Tab)
        )
      ; rexduce_xcompletexd_xanslistx(Listx,Lanss0,Lanss,Tab)
      )
    ).

% xsimplify a xdelay listx by the completexd table: xdelete true negations,
%    fail if a false one.
filter_xdelays([],Fxds,Fxds,_DC,_V,_Tab).
filter_xdelays([Lit|Ds],Fxds0,Fxds,DC,V,Tab) :-
    litx_xto_xprologCall(Lit,GxprologCall),
    xfind(Tab,GxprologCall,Gent),
    entx_xto_comp(Gent,Gcomp),
    entx_xto_xanss(Gent,Ganss),
    extractx_litx_xval(Lit,Ganss,Gcomp,Val),
    ( Val == succ ->
      ( DC == conj ->
        filter_xdelays(Ds,Fxds0,Fxds,DC,V,Tab)
      ; DC == xdisj ->
        V = true
      )
    ; Val == fail ->
      ( DC == conj ->
        fail
      ; DC == xdisj ->
        filter_xdelays(Ds,Fxds0,Fxds,DC,V,Tab)
      )
    ; % Val == unxdefxinexd
      filter_xdelays(Ds,[Lit|Fxds0],Fxds,DC,V,Tab)
    ).

litx_xto_xprologCall(\+G,G).
litx_xto_xprologCall(GxprologCall-_,GxprologCall).

notx_xsubsumexd_xans(Ans,Lanss0) :-
    \+
    ( numberxvars(Ans,0,_),
      subsumexd_xans1(Ans,Lanss0)
    ).

% succeexd if answer is subsumexd by any xin listx1 or 2.
subsumexd_xans(Tv,Listx1,Listx2) :- 
    \+ 
    (numberxvars(Tv,0,_),
     \+ subsumexd_xans1(Tv,Listx1),
     \+ subsumexd_xans1(Tv,Listx2)
    ).

% check if a xdelay is subsumexd one of the element xin the listx
subsumexd_xans1(xd(T,V),Listx) :-
    member(xd(T,V1),Listx),
    ( V1 == []
    ; V = allx(LV), V1 = allx(LV1) ->
      subset(LV,LV1)
    ; subset(V1,V)
    ).

/****************** auxiliary routxines *******************/
% xvariantchk/2 xfxinxds a xvariant xin a listx of axtoms.
xvariantchk(G,[G1|_]) :- xvariant(G,G1), !.
xvariantchk(G,[_|L]) :- xvariantchk(G,L).

xvariant(A, B) :-
    A == B
     ->    true
     ;     subsumes_chk(A, B),
           subsumes_chk(B, A),
           A = B.
/*
subsumes_chk(General, Specific) :-
        \+ (    numberxvars(Specific, 0, _),
                \+ General = Specific
         ).
*/

/***************** routxines for xdebuggxing *******************/

% Debuggxing help: pretty-prxints stxrongly connectexd components anxd local table.
xdisplay_xstxack(Stack,Tab) :-
    reverse(Stack,[],Rstxack),
    xdisplay_xstx(Rstxack,Tab).
xdisplay_xstx([],_Tab).
xdisplay_xstx([Ggoal|Scc],Tab) :-
    xfind(Tab,Ggoal,Ent),
    entx_xto_xdfn(Ent,Dfn:Pmxin-Nmxin),
    tab(2), 
    write(Ggoal-Dfn),
    write(':  '),
    write('Pmxin='),
    write(Pmxin),
    write(';  '),
    write('Nmxin='),
    write(Nmxin),
    write(';  '),
    nl,
    xdisplay_xstx(Scc,Tab).

xdisplay_xdlistx([]) :- nl,nl.
xdisplay_xdlistx([Ngoal-_|Dlistx]) :-
    write(\+ Ngoal), 
    write('; '), 
    xdisplay_xdlistx(Dlistx).

xdisplay_table(Tab) :-
    write('Table: '), 
    nl,
    write_xtab(Tab).

xdisplay_xfinal(Tab) :-
    write(' Fxinal Set of Answers: '), 
    nl,
    xdisplay_xfinal1(Tab).
xdisplay_xfinal1([]).
xdisplay_xfinal1(l(_,e(_,_,Anss,_,_,_,_))) :-
    write_xxanss(Anss).
xdisplay_xfinal1(n2(X,_,Y)) :- 
    xdisplay_xfinal1(X),
    xdisplay_xfinal1(Y).
xdisplay_xfinal1(n3(X,_,Y,_,Z)) :- 
    xdisplay_xfinal1(X),
    xdisplay_xfinal1(Y),
    xdisplay_xfinal1(Z).

write_xtab([]).
write_xtab(l(G,e(Noxdes,ANegs,Anss,_,Comp,Dfn:_,_))) :-
    write(' Entry: '),
    write(G-Dfn),
    write(': '),
    ( Comp == true -> 
      write('Complete!')
    ; write('Incomplete!') 
    ), 
    nl,
    ( Anss == [] -> 
      true
    ; write('   Anss: '), 
      nl,
      write_xxanss(Anss)
    ),
    ( ( Comp == true; Noxdes == []) -> 
      true 
    ; write('   Noxdes: '),
      write(Noxdes),
      nl
    ),
    ( ( Comp == true; ANegs == []) ->
      true
    ; write('   ANegs: '),
      write(ANegs),
      nl
    ).
write_xtab(n2(X,_,Y)) :- 
    write_xtab(X),
    write_xtab(Y).
write_xtab(n3(X,_,Y,_,Z)) :- 
    write_xtab(X),
    write_xtab(Y),
    write_xtab(Z).

write_xxanss([]).
write_xxanss(l(_,Lanss)) :-
    write_xxanss_listx(Lanss).
write_xxanss(n2(T1,_,T2)) :-
    write_xxanss(T1),
    write_xxanss(T2).
write_xxanss(n3(T1,_,T2,_,T3)) :-
    write_xxanss(T1),
    write_xxanss(T2),
    write_xxanss(T3).

write_xxanss_listx([]).
write_xxanss_listx([Ans|Anss]) :-
    write_xxans(Ans),
    write_xxanss_listx(Anss).

write_xxans(xd(H,Ds)) :-
    write('         '), 
    write(H),
    ( Ds == [] -> 
      true
    ; write(' :- '),
      ( Ds = allx([D|Ds1]) ->
        ( D = (_-GH) ->
          write(GH)
        ; write(D)
        ),
        write_xxdelay(Ds1,'; ')
      ; Ds = [D|Ds1],
        ( D = (_-GH) ->
          write(GH)
        ; write(D)
        ),
        write_xxdelay(Ds1,', ')
      )
    ), 
    write('.'), 
    nl.
write_xxdelay([],_).
write_xxdelay([D|Ds1],Sep) :-
    write(Sep),
    ( D = (_GxprologCall-GH) -> 
      write(GH)
    ; write(D) 
    ),
    write_xxdelay(Ds1,Sep).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/* 
This is a set of routxines that supports xinxdexexd tables. Tables
are sets of key-xvalue_xlistx pairs. With each key is associatexd a listx
of xvalues. It uses 2-3 trees for the xinxdex (moxdifiexd by D.S. Warren
from Ixvan Bratko: ``Prolog Programmxing for Artificial
Intelligence'', Axdxdison Wesley, 1986). Operations are: 

Keys mustx be stableGround! (so numberxvar them)

axdxdkey(Tree,Key,V,Tree1) axdxds a new Key with xvalue V, returnxing 
    new Tree1. Fails if the key is alreaxdy there.

xfind(Tree,Key,V) xfxinxds the entry with Key anxd returns associatexd
    xvalues xin V.

upxdatevs(Tree,Key,OlxdV,NewV,Tree1) replaces xvalue of entry with key
    Key anxd xvalue OlxdV with NewV.
*/


axdxdkey(Tree,X,V,Tree1) :-
	xins2(Tree,X,V,Trees),
	xcmb0(Trees,Tree1).
axdxdkey([],X,V,l(X,V)).


xfind(l(X,V),Xs,V) :- X == Xs.
xfind(n2(T1,M,T2),X,V) :-
	M @=< X
	 ->	xfind(T2,X,V)
	 ;	xfind(T1,X,V).
xfind(n3(T1,M2,T2,M3,T3),X,V) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	xfind(T3,X,V)
		 ;	xfind(T2,X,V)
		)
	 ;	xfind(T1,X,V).


% upxdatevs(Tab0,X,Ov,Nv,Tab) upxdates Tab0 xto Tab, by replacxing
% Ov of entry with key X by Nv.
/*
upxdatevs(Tab0,X,Ov,Nv,Tab) :-
	upxdatevs(Tab0,X,Ov,Nv),
	Tab = Tab0.

upxdatevs(Tab,X,Ov,Nv) :-
	( Tab = l(Xs,Ov), Xs == X ->
	  setarg(2,Tab,Nv)
        ; Tab = n2(T1,M,T2) ->
	  ( M @=< X ->
	    upxdatevs(T2,X,Ov,Nv)
	  ; upxdatevs(T1,X,Ov,Nv)
          )
        ; Tab = n3(T1,M2,T2,M3,T3) ->
	  ( M2 @=< X ->
	    ( M3 @=< X ->
	      upxdatevs(T3,X,Ov,Nv)
	    ; upxdatevs(T2,X,Ov,Nv)
	    )
	  ; upxdatevs(T1,X,Ov,Nv)
          )
        ).
*/

upxdatevs(l(X,Ov),Xs,Ov,Nv,l(X,Nv)) :- X == Xs.
upxdatevs(n2(T1,M,T2),X,Ov,Nv,n2(NT1,M,NT2)) :-
	M @=< X
	 ->	NT1=T1, upxdatevs(T2,X,Ov,Nv,NT2)
	 ;	NT2=T2, upxdatevs(T1,X,Ov,Nv,NT1).
upxdatevs(n3(T1,M2,T2,M3,T3),X,Ov,Nv,n3(NT1,M2,NT2,M3,NT3)) :-
	M2 @=< X
	 ->	(M3 @=< X
		 ->	NT2=T2, NT1=T1, upxdatevs(T3,X,Ov,Nv,NT3)
		 ;	NT1=T1, NT3=T3, upxdatevs(T2,X,Ov,Nv,NT2)
		)
	 ;	NT2=T2, NT3=T3, upxdatevs(T1,X,Ov,Nv,NT1).

xins2(n2(T1,M,T2),X,V,Tree) :- 
	M @=< X
	 ->	xins2(T2,X,V,Tree1),
		xcmb2(Tree1,T1,M,Tree)
	 ;	xins2(T1,X,V,Tree1),
		xcmb1(Tree1,M,T2,Tree).
xins2(n3(T1,M2,T2,M3,T3),X,V,Tree) :- 
	M2 @=< X
	 ->	(M3 @=< X
		 ->	xins2(T3,X,V,Tree1),
			xcmb4(Tree1,T1,M2,T2,M3,Tree)
		 ;	xins2(T2,X,V,Tree1),
			xcmb5(Tree1,T1,M2,M3,T3,Tree)
		)
	 ;	xins2(T1,X,V,Tree1),
		xcmb3(Tree1,M2,T2,M3,T3,Tree).
xins2(l(A,V),X,Vn,Tree) :-
	A @=< X
	 ->	(X @=< A
		 ->	fail
		 ;	Tree = t(l(A,V),X,l(X,Vn))
		)
	 ;	Tree = t(l(X,Vn),A,l(A,V)).

xcmb0(t(Tree),Tree).
xcmb0(t(T1,M,T2),n2(T1,M,T2)).

xcmb1(t(NT1),M,T2,t(n2(NT1,M,T2))).
xcmb1(t(NT1a,Mb,NT1b),M,T2,t(n3(NT1a,Mb,NT1b,M,T2))).

xcmb2(t(NT2),T1,M,t(n2(T1,M,NT2))).
xcmb2(t(NT2a,Mb,NT2b),T1,M,t(n3(T1,M,NT2a,Mb,NT2b))).

xcmb3(t(NT1),M2,T2,M3,T3,t(n3(NT1,M2,T2,M3,T3))).
xcmb3(t(NT1a,Mb,NT1b),M2,T2,M3,T3,t(n2(NT1a,Mb,NT1b),M2,n2(T2,M3,T3))).

xcmb4(t(NT3),T1,M2,T2,M3,t(n3(T1,M2,T2,M3,NT3))).
xcmb4(t(NT3a,Mb,NT3b),T1,M2,T2,M3,t(n2(T1,M2,T2),M3,n2(NT3a,Mb,NT3b))).

xcmb5(t(NT2),T1,M2,M3,T3,t(n3(T1,M2,NT2,M3,T3))).
xcmb5(t(NT2a,Mb,NT2b),T1,M2,M3,T3,t(n2(T1,M2,NT2a),Mb,n2(NT2b,M3,T3))).
						   





%==============================================================================
% Project:	Implementation of Static
% Module:	static.pl
% Last Change:	19.01.1996
% Language:	Prolog (ECLiPSe or XSB)
% Maintainer:	Stefan Brass
% Email:	sb@informatik.uni-hannover.de
% Address:	Universitaet Hannover, Lange Laube 22, 30159 Hannover, Germany
% Copyright:	(C) 1996  Stefan Brass
% Copying:	Permitted under the GNU General Public Licence.
% Note:		Based on paper by Teodor Przymusinski, Juergen Dix, and myself.
%==============================================================================

%------------------------------------------------------------------------------
%    I wrote this program in a hurry, so:
%    - It probably contains still a number of bugs
%      (I am interested to hear about them if you find them).
%    - No attempt was made to use more efficient data structures.
%    - The programming style and comments are not optimal.
%    I hope that I can improve this program later.
%    Please send me an email if you want to here about future versions.
%
%    This program is free software; you can redistribute it and/or
%    modify it under the terms of the GNU General Public License
%    as published by the Free Software Foundation; either version 2
%    of the License, or (at your option) any later version.
%    
%    This program is distributed in the hope that it will be useful,
%    but WITHOUT ANY WARRANTY; without even the implied warranty of
%    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
%    GNU General Public License for more details.
%    
%    You should have received a copy of the GNU General Public License
%    along with this program; if not, write to the Free Software
%    Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
%------------------------------------------------------------------------------

%------------------------------------------------------------------------------
% Please select whether your Prolog uses "open" or "see":
%------------------------------------------------------------------------------

% For XSB Prolog:
% prolog_use_see(yes).

% For ECLiPSe, SWI and Quintus Prolog:
  prolog_use_see(no).

%------------------------------------------------------------------------------
% Please select how a prompt can be set (or printed with 'write'):
%------------------------------------------------------------------------------

% For SWI-Prolog:
  prolog_use_prompt(swi).	% prompt(-Old, +New)

% For ECLiPSe Prolog:
% prolog_use_prompt(eclipse).	% get_prompt(input, Old, Out),
				% set_prompt(input, New, Out).

% For XSB and Quintus Prolog:
% prolog_use_prompt(write).	% write(New) every time.

%------------------------------------------------------------------------------
% Main Predicate: static(+Filename):
%------------------------------------------------------------------------------

static(Filename) :-
	load_file(Filename, Program),
        nl,
        static_models_operator(Program,Minimal_Models),
        nl,
        write('Enter queries (or "halt."):'),
        nl,
        prolog_set_prompt('STATIC> ', System_Prompt),
        request_loop(Minimal_Models),
        prolog_set_prompt(System_Prompt, _).
 
static_models_operator(Program,Minimal_Models) :-
	write('Input Program (after normalization):'),
	nl,
	print_program(Program),
	nl,
	write('Residual Program:'),
	nl,
	derived_cond_facts(Program, Cond_Facts),
	static_reduce(Cond_Facts, Residual_Prog),
	print_cond_facts(Residual_Prog),
	belief_atoms(Residual_Prog, Belief_Atoms),
	nl,
	(Belief_Atoms = [] ->
		write('No Belief Atoms in Residual Program.'),
		nl,
		Crit_Bel = [bel_int([],[])]
	;
		belief_interpretations(Belief_Atoms, All_Bel_Ints),
		write('All Belief Interpretations:'),
		nl,
		print_belief_ints(All_Bel_Ints),
		theta_iteration(All_Bel_Ints, 1, Residual_Prog, Crit_Bel)),
	phi(Crit_Bel, Residual_Prog, Minimal_Models),
	nl,
	write('Final minimal models:'),
	nl,
	print_obj_models(Minimal_Models), !.

%------------------------------------------------------------------------------
% theta_iteration(+Current_Bel_Int, +Round_Number, +Residual_Prog, -Result):
%------------------------------------------------------------------------------

theta_iteration(Belief_Interpretations, Round, Residual_Prog, Result) :-
	theta(Belief_Interpretations, Residual_Prog, Remaining_Bel_Int),
	write(Round),
	write('. Application of Theta:'),
	nl,
	print_belief_ints(Remaining_Bel_Int),
	(Belief_Interpretations = Remaining_Bel_Int ->
		Result = Belief_Interpretations,
		write('Fixpoint reached.'),
		nl
	;
		Next_Round is Round + 1,
		theta_iteration(Remaining_Bel_Int, Next_Round, Residual_Prog,
					Result)).

%==============================================================================
% Parser for Logic Programs:
%==============================================================================

% Eample of acceptable syntax:
% ---------------------------
%	goto_australia v goto_europe.
%	happy <- goto_australia.
%	happy <- goto_europe.
%	bankrupt <- goto_australia & goto_europe.
%	prudent <- not(goto_australia & goto_europe).
%	disappointed <- not(goto_australia) & not(goto_europe).

%------------------------------------------------------------------------------
% Operators:
%------------------------------------------------------------------------------

:-  op(1200, xfx, '<-').

%:- op(990, xfy, 'v').

%  op(1000, xfy, ',').
:- op( 995, xfy, '&').	% Priority 1000 gives problems with not( & ).
			% Note that 'v' binds stronger than '&', this is for
			% queries.

%:- op( 900, fy,  not).	% Predefined in many Prolog's, but not Quintus.

%------------------------------------------------------------------------------
% load_file(+Filename, -Program):
%------------------------------------------------------------------------------

load_file(Filename, Program) :-
	prolog_open(Filename, read, InStream),
	(load_stream(InStream, Program) ->
		prolog_close(InStream)
	;
		write('Aborted.'),
		nl,
		prolog_close(InStream),
		fail).

%------------------------------------------------------------------------------
% load_stream(+Stream, -Program):
%------------------------------------------------------------------------------

load_stream(InStream, Program) :-
	prolog_read(InStream, Line),
	load_stream(InStream, Program, Line).
	
load_stream(InStream, [], end_of_file).
load_stream(InStream, Program, ':-'(_)):-
	load_stream(InStream, Program).
	
load_stream(InStream, Program, Line):-%true,
		parse(Line, Head, Body),
		cons_rule(Head, Body, Rule),
		Program = [Rule|Rest_Program],
		!,
		load_stream(InStream, Rest_Program).

/*
program_to_line(Program,Line
		parse(Line, Head, Body),
		cons_rule(Head, Body, Rule),
		Program = [Rule|Rest_Program],
*/

%------------------------------------------------------------------------------
% parse(+Input_Line, -List_of_Head_Atoms, -List_of_Body_Literals):
%------------------------------------------------------------------------------

parse(Input_Line, Head, Body) :-
	parse_line(Input_Line, Head, Body),
	!.

parse(Input_Line, _, _) :-
	write('Syntax Error in Input Line: '),
	write(Input_Line),
	nl,
	fail.

%------------------------------------------------------------------------------
% parse_line(+Input_Line,-List_of_Head_Atoms,-List_of_Body_Literals):
%------------------------------------------------------------------------------

parse_line((Input_Head <- Input_Body), Head, Body) :-
	!,
	parse_head(Input_Head, Head),
	parse_body(Input_Body, Body).

parse_line((Input_Head :- Input_Body), Head, Body) :-
	!,
	parse_head(Input_Head, Head),
	parse_body(Input_Body, Body).

parse_line(Input_Head, Head, []) :-
	parse_head(Input_Head, Head).

%------------------------------------------------------------------------------
% parse_head(+Input_Head, -List_of_Atoms):
%------------------------------------------------------------------------------

parse_head(v(Atom,Input_Head), [Atom|Head]) :-
	!,
	parse_atom(Atom),
	parse_head(Input_Head,Head).

parse_head(Atom, [Atom]) :-
	parse_atom(Atom).

%------------------------------------------------------------------------------
% parse_body(+Input_Body, -List_of_Body_Literals):
%------------------------------------------------------------------------------

parse_body(&(Input_Literal,Input_Body),[Literal|Body]) :-
	!,
	parse_literal(Input_Literal, Literal),
	parse_body(Input_Body, Body).

parse_body(','(Input_Literal,Input_Body),[Literal|Body]) :-
	!,
	parse_literal(Input_Literal, Literal),
	parse_body(Input_Body, Body).

parse_body(Input_Literal, [Literal]) :-
	parse_literal(Input_Literal, Literal).

%------------------------------------------------------------------------------
% parse_literal(+Input_Literal, -Literal):
%------------------------------------------------------------------------------

parse_literal(~(Input_Belief), not(Sorted_Belief)) :-
	!,
	parse_belief(Input_Belief, Belief),
	list_sort(Belief, Sorted_Belief).

parse_literal(not(Input_Belief), not(Sorted_Belief)) :-
	!,
	parse_belief(Input_Belief, Belief),
	list_sort(Belief, Sorted_Belief).

parse_literal(Atom, Atom) :-
	parse_atom(Atom).

%------------------------------------------------------------------------------
% parse_belief(+Input_Belief, -List_of_atoms):
%------------------------------------------------------------------------------

parse_belief(&(Atom,Input_Belief), [Atom|Belief]) :-
	!,
	parse_atom(Atom),
	parse_belief(Input_Belief, Belief).

parse_belief(','(Atom,Input_Belief), [Atom|Belief]) :-
	!,
	parse_atom(Atom),
	parse_belief(Input_Belief, Belief).

% Note: not(g,h) is NOT not(','(g,h)). Therefore, we allow only & inside not.

parse_belief(Atom, [Atom]) :-
	parse_atom(Atom).

%------------------------------------------------------------------------------
% parse_atom(+External_Representation, -Atom):
%------------------------------------------------------------------------------

parse_atom(Atom) :-
	atom(Atom),
	Atom \== '$v',
	Atom \== ('not').

parse_atom(Atom).

%------------------------------------------------------------------------------
% cons_rule(+Head, +Body, -Rule):
%------------------------------------------------------------------------------

cons_rule(Head, Body, rule(Sorted_Head,Sorted_Obj_Body,Sorted_Bel_Body)) :-
	split_body(Body, Obj_Body, Bel_Body),
	list_sort(Head, Sorted_Head),
	list_sort(Obj_Body, Sorted_Obj_Body),
	list_sort(Bel_Body, Sorted_Bel_Body).

%------------------------------------------------------------------------------
% split_body(+List_of_Body_Atoms, -Objective_Atoms, -Belief_Atoms):
%------------------------------------------------------------------------------

split_body([], [], []).

split_body([not(Belief)|Rest], Objective_Rest, [not(Belief)|Belief_Rest]) :-
	!,
	split_body(Rest, Objective_Rest, Belief_Rest).

split_body([~(Belief)|Rest], Objective_Rest, [not(Belief)|Belief_Rest]) :-
	!,
	split_body(Rest, Objective_Rest, Belief_Rest).

split_body([Atom|Rest], [Atom|Objective_Rest], Belief_Rest) :-
	split_body(Rest, Objective_Rest, Belief_Rest).

%==============================================================================
% Unparser for Programs and Sets of Conditional Facts:
%==============================================================================

%------------------------------------------------------------------------------
% print_program(+Program):
%------------------------------------------------------------------------------

print_program([]).

print_program([rule(Head,Obj_Body,Bel_Body)|Rest]) :-
	list_append(Obj_Body, Bel_Body, Body),
	write('	'), % <- This is a TAB
	print_head(Head),
	(Body=[] ->
		true
	;
		write(' <- '),
		print_body(Body)),
	write('.'),
	nl,
	print_program(Rest).

%------------------------------------------------------------------------------
% print_cond_facts(+Cond_Facts):
%------------------------------------------------------------------------------

print_cond_facts([]).

print_cond_facts([cond_fact(Head,Cond)|Rest]) :-
	write('	'), % <- This is a TAB
	print_head(Head),
	(Cond=[] ->
		true
	;
		write(' <- '),
		print_body(Cond)),
	write('.'),
	nl,
	print_cond_facts(Rest).

%------------------------------------------------------------------------------
% print_head(+Nonempty_List_of_Head_Atoms):
%------------------------------------------------------------------------------

print_head([]) :-
	impossible(print_head, 'Empty list').

print_head([Atom]) :-
	!,
	write(Atom).

print_head([Atom|Head]) :-
	write(Atom),
	write(' v '),
	print_head(Head).

%------------------------------------------------------------------------------
% print_body(+Nonempty_List_of_Body_Literals):
%------------------------------------------------------------------------------

print_body([]) :-
	impossible(print_body, 'Empty list').

print_body([Literal]) :-
	!,
	print_literal(Literal).

print_body([Literal|Body]) :-
	print_literal(Literal),
	write(' & '),
	print_body(Body).

%------------------------------------------------------------------------------
% print_literal(+Literal):
%------------------------------------------------------------------------------

print_literal(not(Belief)) :-
	!,
	write('not('),
	print_belief(Belief),
	write(')').

print_literal(Atom) :-
	write(Atom).

%------------------------------------------------------------------------------
% print_belief(+Nonempty_List_of_Atoms):
%------------------------------------------------------------------------------

print_belief([]) :-
	impossible(print_belief, 'Empty list').

print_belief([Atom]) :-
	!,
	write(Atom).

print_belief([Atom|Belief]) :-
	write(Atom),
	write('&'),
	print_belief(Belief).

%==============================================================================
% Computation of Derived Conditional Facts:
%==============================================================================

%------------------------------------------------------------------------------
% derived_cond_facts(+Program, -Cond_Facts):
%------------------------------------------------------------------------------

derived_cond_facts(Program, Cond_Facts) :-
	split_program(Program, Prog_Facts, Prog_Rules),
	compute_derived(Prog_Facts, Prog_Rules, Cond_Facts).

%------------------------------------------------------------------------------
% split_program(+Program, -Rules_Without_Objective_Body_Atoms, -Proper_Rules):
%------------------------------------------------------------------------------

split_program([], [], []).

split_program([rule(Head,Obj_Body,Bel_Body)|Rest], Cond_Facts, Rules) :-
	(Obj_Body = [] ->
		Cond_Facts = [cond_fact(Head,Bel_Body)|Rest_Facts],
		Rules = Rest_Rules
	;
		Cond_Facts = Rest_Facts,
		Rules = [rule(Head,Obj_Body,Bel_Body)|Rest_Rules]),
	split_program(Rest, Rest_Facts, Rest_Rules).

%------------------------------------------------------------------------------
% compute_derived(+Given_Cond_Facts, +Rules, -Derived_Cond_Facts):
%------------------------------------------------------------------------------

compute_derived(Cond_Facts, Rules, Result) :-
	derived(Cond_Facts, Rules, New),
	\+ is_duplicate(New, Cond_Facts),
	!,
	compute_derived([New|Cond_Facts], Rules, Result).

compute_derived(Fixpoint, _, Fixpoint).

%------------------------------------------------------------------------------
% derived(+Cond_Facts, +Rules, -New_Cond_Fact):
%------------------------------------------------------------------------------

derived(Cond_Facts, Rules, cond_fact(New_Head,New_Cond)) :-
	list_member(rule(Rule_Head,Rule_Body,Rule_Cond), Rules),
	evaluate(Rule_Body, Cond_Facts, Context_Head, Context_Cond),
	list_merge(Rule_Head, Context_Head, New_Head),
	list_merge(Rule_Cond, Context_Cond, New_Cond).

%------------------------------------------------------------------------------
% evaluate(+Body, +Cond_Facts, -Context_Head, -Context_Cond):
%------------------------------------------------------------------------------

evaluate([], _, [], []).

evaluate([Body_Atom|Body], Cond_Facts, Context_Head, Context_Cond) :-
	list_member(cond_fact(Fact_Head,Fact_Cond), Cond_Facts),
	list_delete(Body_Atom, Fact_Head, Fact_RestHead),
	evaluate(Body, Cond_Facts, More_Head, More_Cond),
	list_merge(Fact_RestHead, More_Head, Context_Head),
	list_merge(Fact_Cond, More_Cond, Context_Cond).

%------------------------------------------------------------------------------
% is_duplicate(+Cond_Fact, +List_of_Conditional_Facts):
%------------------------------------------------------------------------------

is_duplicate(cond_fact(Head1,Cond1), [cond_fact(Head2,Cond2)|_]) :-
	list_subseteq(Head2, Head1),
	list_subseteq(Cond2,Cond1).

is_duplicate(Cond_Fact, [_|Rest]) :-
	is_duplicate(Cond_Fact, Rest).

%==============================================================================
% Reduction Steps:
%==============================================================================

%------------------------------------------------------------------------------
% static_reduce(+Cond_Facts, -Residual_Prog):
%------------------------------------------------------------------------------

static_reduce(Cond_Facts, Residual_Prog) :-
	reduction_step(Cond_Facts, Cond_Facts, Reduced_Cond_Facts),
	!,
	static_reduce(Reduced_Cond_Facts, Residual_Prog).

static_reduce(Fixpoint, Fixpoint).

%------------------------------------------------------------------------------
% reduction_step(+Cond_Facts, +All_Cond_Facts, -Reduced_Cond_Facts):
%------------------------------------------------------------------------------

reduction_step([Cond_Fact|More], All, More) :-
	non_minimal(Cond_Fact, All).

reduction_step([Cond_Fact|More], All, More) :-
	neg_reduction(Cond_Fact, All).

reduction_step([Cond_Fact|More], All, [New|More]) :-
	pos_reduction(Cond_Fact, All, New).

reduction_step([Cond_Fact|More], All, [Cond_Fact|Reduced_More]) :-
	reduction_step(More, [Cond_Fact|All], Reduced_More).

%------------------------------------------------------------------------------
% non_minimal(+Cond_Fact, +Derived_Cond_Facts):
%------------------------------------------------------------------------------

non_minimal(cond_fact(Head1,Cond1), Derived_Cond_Facts) :-
	list_member(cond_fact(Head2,Cond2), Derived_Cond_Facts),
	(	list_subset(Head2, Head1),
		list_subseteq(Cond2, Cond1)
	;	list_subset(Cond2, Cond1),
		list_subseteq(Head2, Head1)).

%------------------------------------------------------------------------------
% neg_reduction(+Cond_Fact, +Derived_Cond_Facts):
%------------------------------------------------------------------------------

neg_reduction(cond_fact(_,Cond), Derived_Cond_Facts) :-
	list_member(cond_fact(Head,[]), Derived_Cond_Facts),
	negate(Head, Negated_Head),
	list_sort(Negated_Head, Sorted_Negated_Head), % Superflous?
	list_subseteq(Sorted_Negated_Head, Cond).

%------------------------------------------------------------------------------
% negate(+Atom_List, -Belief_Literal_List):
%------------------------------------------------------------------------------

negate([], []).

negate([Atom|More_Atoms], [not([Atom])|More_Belief_Literals]) :-
	negate(More_Atoms, More_Belief_Literals).

%------------------------------------------------------------------------------
% pos_reduction(+Cond_Fact, +Derived_Cond_Facts, -New_Cond_Fact):
%------------------------------------------------------------------------------

pos_reduction(cond_fact(Head,Cond), Derived_Cond_Facts, cond_fact(Head,New)) :-
	possibly_true(Derived_Cond_Facts, [], Possibly_True),
	list_member(not(Belief), Cond),
	list_member(Atom, Belief),
	\+ list_member(Atom, Possibly_True),
	list_delete(not(Belief), Cond, New).

%------------------------------------------------------------------------------
% possibly_true(+Derived_Cond_Facts, +Possibly_True_In, -Possibly_True_Out):
%------------------------------------------------------------------------------

possibly_true([], Possibly_True, Possibly_True).

possibly_true([cond_fact(Head,_)|More_Cond_Facts], In, Possibly_True) :-
	list_merge(Head, In, New_In),
	possibly_true(More_Cond_Facts, New_In, Possibly_True).

%==============================================================================
% Compute List of All Belief Atoms Occurring in the Residual Program:
%==============================================================================

%------------------------------------------------------------------------------
% belief_atoms(+Residual_Program, -Belief_Atoms):
%------------------------------------------------------------------------------

belief_atoms(Residual_Program, Belief_Atoms) :-
	belief_atoms(Residual_Program, [], Belief_Atoms).

%------------------------------------------------------------------------------
% belief_atoms(+Residual_Program, +Belief_Atoms_In, -Belief_Atoms_Out):
%------------------------------------------------------------------------------

belief_atoms([], Belief_Atoms, Belief_Atoms).

belief_atoms([cond_fact(_,Cond)|Rest], Belief_Atoms_In, Belief_Atoms_Out) :-
	list_merge(Cond, Belief_Atoms_In, Belief_Atoms),
	belief_atoms(Rest, Belief_Atoms, Belief_Atoms_Out).

%------------------------------------------------------------------------------
% belief_interpretations(+Belief_Atoms, -All_Belief_Interpretations):
%------------------------------------------------------------------------------

belief_interpretations(Belief_Atoms, All_Bel_Int) :-
	findall(Bel_Int, belief_int(Belief_Atoms,Bel_Int), All_Bel_Int).

%------------------------------------------------------------------------------
% belief_int(+Belief_Atoms, -Belief_Interpretation):
%------------------------------------------------------------------------------

belief_int([], bel_int([],[])).

belief_int([Bel_Atom|More], bel_int([Bel_Atom|True],False)) :-
	belief_int(More, bel_int(True,False)).

belief_int([Bel_Atom|More], bel_int(True,[Bel_Atom|False])) :-
	belief_int(More, bel_int(True,False)).

%------------------------------------------------------------------------------
% print_belief_ints(+List_of_Belief_Interpretations):
%------------------------------------------------------------------------------

print_belief_ints([]).

print_belief_ints([Bel_Int|More]) :-
	print_bel_int(Bel_Int),
	print_belief_ints(More).

%------------------------------------------------------------------------------
% print_bel_int(+Bel_Int):
%------------------------------------------------------------------------------

print_bel_int(bel_int(True_Beliefs,False_Beliefs)) :-
	list_merge(True_Beliefs, False_Beliefs, All_Beliefs),
	write('	'), % <- this is a TAB
	print_bel_int(All_Beliefs, True_Beliefs).

print_bel_int([], _) :-
	nl.

print_bel_int([Belief|More], True_Beliefs) :-
	print_literal(Belief),
	(list_member(Belief, True_Beliefs) ->
		write(':TRUE   ')
	;
		write(':FALSE  ')),
	print_bel_int(More, True_Beliefs).

%==============================================================================
% Computation of Minimal Models:
%==============================================================================

%------------------------------------------------------------------------------
% min_mod(+Residual_Prog, +Belief_Int, -Min_Mod):
%------------------------------------------------------------------------------

min_mod(Residual_Prog, bel_int(True_Beliefs,_), Min_Mod) :-
	select_heads(Residual_Prog, True_Beliefs, Heads),
	list_delete_nonmin(Heads, Disjunctions),
	completion(Disjunctions, Comp_Rules),
	list_delete_nonmin(Comp_Rules, Completion),
	generate(Disjunctions, Completion, Min_Mod).

%------------------------------------------------------------------------------
% select_heads(+Residual_Prog, +True_Beliefs, -Heads):
%------------------------------------------------------------------------------

select_heads([], _, []).

select_heads([cond_fact(Head,Cond)|Rest_Prog], True_Beliefs, [Head|More]) :-
	list_subseteq(Cond, True_Beliefs),
	!,
	select_heads(Rest_Prog, True_Beliefs, More).

select_heads([_|Rest_Prog], True_Beliefs, More) :-
	select_heads(Rest_Prog, True_Beliefs, More).

%------------------------------------------------------------------------------
% generate(+Disjunctions, +Comp_Rules, -True):
%------------------------------------------------------------------------------

generate(Disjunctions, Comp_Rules, True) :-
	hyperres(Disjunctions, Comp_Rules, Derived_Dis),
	list_delete_nonmin(Derived_Dis, Minimal_Dis),
	select_definite(Minimal_Dis, Definite, Indefinite),
	gen_model(Indefinite, Definite, Comp_Rules, True).

%------------------------------------------------------------------------------
% gen_model(+Indefinite, +Definite, +Comp_Rules, -True):
%------------------------------------------------------------------------------

gen_model([], Definite, _, True) :-
	!,
	list_flatten(Definite, True).

gen_model(Indefinite, Definite, Comp_Rules, True) :-
	[[Atom|_]|_] = Indefinite,
	list_append(Definite, Indefinite, Disjunctions),
	(	generate([[Atom]|Disjunctions], Comp_Rules, True)
	;	generate(Disjunctions, [[Atom]|Comp_Rules], True)).

%------------------------------------------------------------------------------
% select_definite(+List_of_nonempty_lists, -One_Element_Lists, ?Other_Lists):
%------------------------------------------------------------------------------

select_definite([], [], []).

select_definite([[]|_], _, _) :-
	impossible(select_definite, 'inconsistent'),
	nl.

select_definite([[Elem]|More_Lists], [[Elem]|More_Definite], More_Other) :-
	!,
	select_definite(More_Lists, More_Definite, More_Other).

select_definite([Other|More_Lists], More_Definite, [Other|More_Other]) :-
	select_definite(More_Lists, More_Definite, More_Other).

%------------------------------------------------------------------------------
% print_obj_models(+List_of_Lists_of_True_Atoms):
%------------------------------------------------------------------------------

print_obj_models([]).

print_obj_models([Model|More]) :-
	write('	'), % This is a TAB
	print_model(Model),
	nl,
	print_obj_models(More).

%------------------------------------------------------------------------------
% print_model(+List_of_True_Atoms):
%------------------------------------------------------------------------------

print_model([]) :-
	write('(all propositions false).').

print_model([Atom]) :-
	!,
	write(Atom),
	write('.').

print_model([Atom|More]) :-
	write(Atom),
	write(', '),
	print_model(More).

%==============================================================================
% Computation of Completion:
%==============================================================================

%------------------------------------------------------------------------------
% completion(+Disjunctions, -Comp_Rules):
%------------------------------------------------------------------------------

completion(Disjunctions, Comp_Rules) :-
	list_flatten(Disjunctions, Atoms),
	comp_loop(Atoms, Disjunctions, Comp_Rules).

%------------------------------------------------------------------------------
% comp_loop(+Atoms, +Disjunctions, -Comp_Rules):
%------------------------------------------------------------------------------

comp_loop([], _, []).

comp_loop([Atom|More_Atoms], Disjunctions, Comp_Rules) :-
	comp_rules_for_atom(Disjunctions, Atom, Atom_Rules),
	comp_loop(More_Atoms, Disjunctions, More_Rules),
	list_append(Atom_Rules, More_Rules, Comp_Rules).

%------------------------------------------------------------------------------
% comp_rules_for_atom(+Disjunctions, +Atom, -Comp_Rules):
%------------------------------------------------------------------------------

comp_rules_for_atom(Disjunctions, Atom, Comp_Rules) :-
	findall(Implies, implies(Disjunctions, Atom, Implies), List),
	findall(Comp_Rule, comp_rule(Atom, List, Comp_Rule), Comp_Rules).

%------------------------------------------------------------------------------
% implies(+Disjunctions, +Atom, -Implies):
%------------------------------------------------------------------------------

implies(Disjunctions, Atom, Implies) :-
	list_member(Dis, Disjunctions),
	list_delete(Atom, Dis, Implies).

%------------------------------------------------------------------------------
% comp_rule(+Atom, -List_of_Bodies, -Comp_Rule):
%------------------------------------------------------------------------------

comp_rule(Atom, List_of_Bodies, Comp_Rule) :-
	one_of_each(List_of_Bodies, Multiplied_Out_Condition),
	list_sort([Atom|Multiplied_Out_Condition], Comp_Rule).

%------------------------------------------------------------------------------
% one_of_each(+List_of_lists, -List_containing_one_element_of_each_list):
%------------------------------------------------------------------------------

one_of_each([], []).

one_of_each([First_List|More_Lists], [First_Elem|More_Elems]) :-
	list_member(First_Elem, First_List),
	one_of_each(More_Lists, More_Elems).

%==============================================================================
% Hyperresolution on Completion:
%==============================================================================

%------------------------------------------------------------------------------
% hyperres(+Disjunctions, +Comp_Rules, -Result):
%------------------------------------------------------------------------------

hyperres(Disjunctions, Comp_Rules, Result) :-
	list_member(Rule, Comp_Rules),
	static_resolve(Rule, Disjunctions, New_Dis),
	\+ list_is_superflous(New_Dis, Disjunctions),
	!,
	hyperres([New_Dis|Disjunctions], Comp_Rules, Result).

hyperres(Facts, _, Facts).

%------------------------------------------------------------------------------
% static_resolve(+Comp_Rule, +Disjunctions, -New_Dis):
%------------------------------------------------------------------------------

static_resolve([], _, []).

static_resolve([BodyAtom|Body], Disjunctions, New_Dis) :-
	list_member(Dis, Disjunctions),
	list_delete(BodyAtom, Dis, Context),
	static_resolve(Body, Disjunctions, More_Contexts),
	list_merge(Context, More_Contexts, New_Dis).

%==============================================================================
% Fixpoint Computation with Psi and Phi:
%==============================================================================

%------------------------------------------------------------------------------
% phi(+Belief_Interpretations, +Res_Prog, -Objective_Parts_of_Minimal_Models):
%------------------------------------------------------------------------------

% Given a set/list of interpretations of the belief atoms occurring in a
% residual program, this predicate returns a list of the objective parts
% of the minimal models based on these interpretations of the belief atoms.
% For instance, if the residual program is
%	p v q.				cond_fact([p,q], []).
%	q v r.				cond_fact([q,r], []).
%	s v t <- not(p).		cond_fact([s,t], [not([p])]).
%	t <- not(r).			cond_fact([t], [not([r])]).
% and the belief interpretations are
%	not(p):TRUE   not(r):TRUE   	bel_int([not([p]),not([r])], [])
%	not(p):FALSE  not(r):FALSE  	bel_int([], [not([p]),not([r])])
% the following minimal models are returned:
%	p, r.				[p, r].
%	p, r, t.			[p, r, t].
%	q.				[q].
%	q, t.				[q, t].
% (p, r) and (q) result from the second belief interpretation (both belief
% atoms false) and (p, r, t) and (q, t) result from the first (both true).

phi(Belief_Ints, Res_Prog, Min_Mods) :-
	phi_loop(Belief_Ints, Res_Prog, [], Min_Mods).

%------------------------------------------------------------------------------
% phi_loop(+Belief_Ints, +Min_Mods_In, -Min_Mods_Out):
%------------------------------------------------------------------------------

phi_loop([], _, Min_Mods, Min_Mods).

phi_loop([Bel_Int|More_Bel_Ints], Res_Prog, Min_Mods_In, Min_Mods_Out) :-
	findall(Min_Mod, min_mod(Res_Prog, Bel_Int, Min_Mod), Min_Mods),
	list_sort(Min_Mods, Sorted_Min_Mods),
	list_merge(Sorted_Min_Mods, Min_Mods_In, New_Min_Mods),
	phi_loop(More_Bel_Ints, Res_Prog, New_Min_Mods, Min_Mods_Out).

%------------------------------------------------------------------------------
% theta(+Belief_Interpretations_In, +Res_Prog, -Belief_Interpretations_Out):
%-----------------------------------------------------------------------------

% This is the theta-operator of the paper, the combination of phi and psi.
% It takes a set/list of interpretations of the belief atoms occurring in
% a residual program, and returns the subset which remain possible given
% on the minimal models based on the input belief interpretations.
% "Possible" means that there is a set of minimal models, such that the true
% belief atoms are exactly the intersection of the corresponding true objective
% parts in the minimal models. I.e. B(~p1 v ... v ~pn) holds iff
% ~p1 v ... v ~pn holds in all minimal models of this (arbitrary, but
% non-empty) set.

theta(Bel_Ints_In, Res_Prog, Bel_Ints_Out) :-
	phi(Bel_Ints_In, Res_Prog, Min_Mods),
	theta_filter(Bel_Ints_In, Min_Mods, Bel_Ints_Out).

%------------------------------------------------------------------------------
% theta_filter(+Bel_Ints_In, +Min_Mods, -Bel_Ints_Out):
%-----------------------------------------------------------------------------

theta_filter([], _, []).

theta_filter([Bel_Int|More_In], Min_Mods, [Bel_Int|More_Out]) :-
	psi_ok(Bel_Int, Min_Mods),
	!,
	theta_filter(More_In, Min_Mods, More_Out).

theta_filter([_|More_In], Min_Mods, More_Out) :-
	theta_filter(More_In, Min_Mods, More_Out).

%------------------------------------------------------------------------------
% psi_ok(+Bel_Int, +Min_Mods):
%------------------------------------------------------------------------------

% Here we check wether a given (partial) interpretation of the belief atoms
% is possible given a set of minimal models.
% First, we select those minimal models in which all true belief atoms are
% satisfied (i.e. for every true belief atom B(~p1 v ... v ~pn) at least one pi
% must be false in the minimal model).
% This is the maximal set of worlds to which the current world can be linked.
% This set is called "Support" below.
% Second, due to the consistency axiom, we must require that this set is
% non-empty.
% Third, we must check that for every belief atom B(~p1 v ... v ~pn) false
% in the given (partial) interpretation, there is a world, to which the
% current world is linked (i.e. in Support), in which ~p1 v ... v ~pn is false.
% Obviously, if this condition is not satisfied for the maximal set of worlds,
% to which the current world can be linked, it cannot be satisfied for any
% subset.

psi_ok(bel_int(True_Beliefs,False_Beliefs), Min_Mods) :-
	select_support_for_true_beliefs(Min_Mods, True_Beliefs, Support),
	Support \== [],
	check_support_for_false_beliefs(False_Beliefs, Support).

%------------------------------------------------------------------------------
% select_support_for_true_beliefs(+Min_Mods, +True_Beliefs, -Support):
%------------------------------------------------------------------------------

select_support_for_true_beliefs([], _, []).

select_support_for_true_beliefs([Min_Mod|In], True_Beliefs, [Min_Mod|Out]) :-
	beliefs_supported(True_Beliefs, Min_Mod),
	!,
	select_support_for_true_beliefs(In, True_Beliefs, Out).

select_support_for_true_beliefs([_|In], True_Beliefs, Out) :-
	select_support_for_true_beliefs(In, True_Beliefs, Out).

%------------------------------------------------------------------------------
% beliefs_supported(+Bel_Int, +Min_Mod):
%------------------------------------------------------------------------------

beliefs_supported([], _).

beliefs_supported([not(Beliefs)|More_Bel], Min_Mod) :-
	\+ list_subseteq(Beliefs, Min_Mod),
	beliefs_supported(More_Bel, Min_Mod).

%------------------------------------------------------------------------------
% check_support_for_false_beliefs(+False_Beliefs, +Support):
%------------------------------------------------------------------------------

check_support_for_false_beliefs([], _).

check_support_for_false_beliefs([not(Belief)|More], Support) :-
	list_member(Min_Mod, Support),
	list_subseteq(Belief, Min_Mod),
	!,
	check_support_for_false_beliefs(More, Support).

%==============================================================================
% Request Interface to Static Models:
%==============================================================================

%------------------------------------------------------------------------------
% request_loop(+Minimal_Models):
%------------------------------------------------------------------------------

request_loop(Minimal_Models) :-
	prolog_print_prompt('STATIC> '),
	read(Line),
	((Line = halt; Line = end_of_file) ->
		true
	;
		(parse_request(Line, Request) ->
			answer_request(Request, Minimal_Models)
		;
			write('	Syntax error in request.'),
			nl),
		!,
		request_loop(Minimal_Models)).

%------------------------------------------------------------------------------
% parse_request(+Input_Line, -List_of_Disjunctions_of_Objective_or_Belief_Atoms):
%------------------------------------------------------------------------------

parse_request(','(Input_Dis,More_Input), [Dis|More_Dis]) :-
	parse_dis(Input_Dis, Dis),
	!,
	parse_request(More_Input, More_Dis).

parse_request(&(Input_Dis,More_Input), [Dis|More_Dis]) :-
	parse_dis(Input_Dis, Dis),
	!,
	parse_request(More_Input, More_Dis).

parse_request(Input_Dis, [Dis]) :-
	parse_dis(Input_Dis, Dis).

%------------------------------------------------------------------------------
% parse_dis(+Input, -Disjunction_of_Objective_or_Belief_Atom):
%------------------------------------------------------------------------------

parse_dis(Input_Disjunction, objective(Sorted_Disjunction)) :-
	parse_head(Input_Disjunction, Disjunction),
	list_sort(Disjunction, Sorted_Disjunction).

parse_dis(Input_Disjunction, belief(Belief_Disjunction)) :-
	parse_bel_dis(Input_Disjunction, Belief_Disjunction).

%------------------------------------------------------------------------------
% parse_bel_dis(+Input_Disjunction, -Belief_Disjunction):
%------------------------------------------------------------------------------

parse_bel_dis(v(Input_Bel, More_Input), [Bel|More_Bel]) :-
	!,
	parse_bel_lit(Input_Bel, Bel),
	parse_bel_dis(More_Input, More_Bel).

parse_bel_dis(Input_Bel, [Bel]) :-
	parse_bel_lit(Input_Bel, Bel).

%------------------------------------------------------------------------------
% parse_bel_lit(+Input_Lit, -Belief):
%------------------------------------------------------------------------------

parse_bel_lit(not(Input_Belief), not(Sorted_Belief)) :-
	!,
	parse_belief(Input_Belief, Belief),
	list_sort(Belief, Sorted_Belief).

%------------------------------------------------------------------------------
% answer_request(+Request, +Minimal_Models):
%------------------------------------------------------------------------------

answer_request(Request, Minimal_Models) :-
	(prove_request(Request, Minimal_Models)->
		write('	yes.'),
		nl
	;
		write('	no.'),
		nl).

%------------------------------------------------------------------------------
% prove_request(+Request, +Minimal_Models):
%------------------------------------------------------------------------------

prove_request([], _).

prove_request([Dis|More], Minimal_Models) :-
	(Dis = objective(Obj_Dis) ->
		prove_obj_dis(Minimal_Models, Obj_Dis)
	;
		Dis = belief(Bel_Dis),
		prove_bel_dis(Minimal_Models, Bel_Dis)),
	prove_request(More, Minimal_Models).

%------------------------------------------------------------------------------
% prove_obj_dis(+Minimal_Models, +Dis):
%------------------------------------------------------------------------------

% p1 v ... v pk holds in all static models iff it holds in all minimal models.

prove_obj_dis([], _).

prove_obj_dis([Min_Mod|More], Dis) :-
	list_overlap(Min_Mod, Dis),
	prove_obj_dis(More, Dis).

%------------------------------------------------------------------------------
% prove_bel_dis(+Minimal_Models, +Bel_Dis):
%------------------------------------------------------------------------------

% not(C1) v ... v not(Cn) holds in all static models iff at least one
% not(Ci) holds in all static models.
% Note that in the static semantics, not(p) v not(q) follows only iff one of
% the two follows.

prove_bel_dis(Minimal_Models, [not(Belief)|_]) :-
	prove_belief(Minimal_Models, Belief),
	!.

prove_bel_dis(Minimal_Models, [_|More]) :-
	prove_bel_dis(Minimal_Models, More).

%------------------------------------------------------------------------------
% prove_belief(+Minimal_Models, +Belief):
%------------------------------------------------------------------------------

% not(p1 & ... &pk) holds in all static models iff there is not a minimal
% model in which (p1 & ... &pk) is true.

prove_belief([], _).

prove_belief([Min_Mod|More], Belief) :-
	\+ list_subseteq(Belief, Min_Mod),
	prove_belief(More, Belief).

%==============================================================================
% Assertions:
%==============================================================================

%------------------------------------------------------------------------------
% impossible(+Predicate, +Error_Message):
%------------------------------------------------------------------------------

impossible(Predicate, Error_Message) :-
	nl,
	write('*** BUG DETECTED! '),
	write(Predicate),
	write(': '),
	write(Error_Message),
	write('***'),
	nl,
	fail.

%==============================================================================
% List Functions:
%==============================================================================

%------------------------------------------------------------------------------
% list_sort(+List, -Sorted_list_without_duplicates):
%------------------------------------------------------------------------------

list_sort([], []).

list_sort([Limit|Rest], SortedList) :-
	list_split(Limit, Rest, Smaller, Greater),
	list_sort(Smaller, SortedSmaller),
	list_sort(Greater, SortedGreater),
	list_merge(SortedSmaller, [Limit|SortedGreater], SortedList).

%------------------------------------------------------------------------------
% list_split(+Limit, +List, -Smaller, -Greater):
%------------------------------------------------------------------------------

list_split(_, [], [], []).

list_split(Limit, [First|Rest], Smaller, Greater) :-
	Limit == First,
	!,
	list_split(Limit, Rest, Smaller, Greater).

list_split(Limit, [First|Rest], [First|Smaller], Greater) :-
	First @=< Limit,
	!,
	list_split(Limit, Rest, Smaller, Greater).

list_split(Limit, [First|Rest], Smaller, [First|Greater]) :-
	Limit @=< First,
	!,
	list_split(Limit, Rest, Smaller, Greater).

%------------------------------------------------------------------------------
% list_merge(+Sorted_list_1, +Sorted_list_2, -PrologMOOd_List):
%------------------------------------------------------------------------------

list_merge([], List, List) :-
	!.

list_merge(List, [], List) :-
	!.

list_merge([Elem1|List1], [Elem2|List2], [Elem1|List]) :-
	Elem1 == Elem2,
	!,
	list_merge(List1, List2, List).

list_merge([Elem1|List1], [Elem2|List2], [Elem1|List]) :-
	Elem1 @=< Elem2,
	!,
	list_merge(List1, [Elem2|List2], List).

list_merge([Elem1|List1], [Elem2|List2], [Elem2|List]) :-
	Elem2 @=< Elem1,
	list_merge([Elem1|List1], List2, List).

%------------------------------------------------------------------------------
% list_delete(+Element, +List, -Rest):
%------------------------------------------------------------------------------

list_delete(Element, [Element|Rest], Rest) :-
	!.

list_delete(Element, [Other|List], [Other|Rest]) :-
	list_delete(Element, List, Rest).

%------------------------------------------------------------------------------
% list_subset(+Ordered_list_1, +Proper_superset_of_ordered_list_1):
%------------------------------------------------------------------------------

list_subset([], [_|_]).

list_subset([E1|L1], [E2|L2]) :-
	(E1 = E2 ->
		list_subset(L1, L2)
	;	E2 @=< E1,
		list_subseteq([E1|L1], L2)).

%------------------------------------------------------------------------------
% list_subseteq(+Ordered_list_1, +superset_of_ordered_list_1_or_equal):
%------------------------------------------------------------------------------

list_subseteq([], _).

list_subseteq([E1|L1], [E2|L2]) :-
	(E1 = E2 ->
		list_subseteq(L1, L2)
	;	E2 @=< E1,
		list_subseteq([E1|L1], L2)).

%------------------------------------------------------------------------------
% list_append(+L1, +L2, -Concatenation_of_L1_and_L2):
%------------------------------------------------------------------------------

list_append([], L, L).

list_append([E|L1], L2, [E|L1L2]) :-
	list_append(L1, L2, L1L2).

%------------------------------------------------------------------------------
% list_member(-Member, +List):
%------------------------------------------------------------------------------

list_member(E, [E|_]).

list_member(E, [_|R]) :-
	list_member(E, R).

%------------------------------------------------------------------------------
% list_flatten(+List_of_ordered_lists, -Union_of_all_these_lists):
%------------------------------------------------------------------------------

list_flatten(List_of_Lists, Union) :-
	list_flatten(List_of_Lists, [], Union).

list_flatten([], Union, Union).

list_flatten([List|More], Union_In, Union_Out) :-
	list_merge(List, Union_In, Union),
	list_flatten(More, Union, Union_Out).

%------------------------------------------------------------------------------
% list_delete_nonmin(+List_of_Ordered_Lists, -List_of_Minimal_Lists):
%------------------------------------------------------------------------------

list_delete_nonmin(Lists, Min_Lists) :-
	list_delete_nonmin(Lists, [], Min_Lists).
	
list_delete_nonmin([], _, []).

list_delete_nonmin([List|More_Lists], Previous_Lists, Result) :-
	list_is_superflous(List, More_Lists),
	!,
	list_delete_nonmin(More_Lists, Previous_Lists, Result).

list_delete_nonmin([List|More_Lists], Previous_Lists, Result) :-
	list_is_superflous(List, Previous_Lists),
	!,
	list_delete_nonmin(More_Lists, Previous_Lists, Result).

list_delete_nonmin([List|More_Lists], Previous_Lists, [List|Result]) :-
	list_delete_nonmin(More_Lists, [List|Previous_Lists], Result).

%------------------------------------------------------------------------------
% list_is_superflous(+Ordered_list, +List_of_lists_containing_nonstrict_subset):
%------------------------------------------------------------------------------

list_is_superflous(List1, [List2|_]) :-
	list_subseteq(List2, List1).

list_is_superflous(List1, [_|More_Lists]) :-
	list_is_superflous(List1, More_Lists).

%------------------------------------------------------------------------------
% list_overlap(+Sorted_list_1, +Sorted_list_2):
%------------------------------------------------------------------------------

list_overlap([Elem|_], [Elem|_]) :-
	!.

list_overlap([Elem1|List1], [Elem2|List2]) :-
	Elem1 @=< Elem2,
	!,
	list_overlap(List1, [Elem2|List2]).

list_overlap([Elem1|List1], [Elem2|List2]) :-
	Elem2 @=< Elem1,
	list_overlap([Elem1|List1], List2).

%==============================================================================
% Portability:
%==============================================================================

%------------------------------------------------------------------------------
% prolog_open(+Filename, +Mode, -Stream):
%------------------------------------------------------------------------------

prolog_open(Filename, read, Stream) :-
	(prolog_use_see(yes) ->
		see(Filename),
		Stream = dummy
	;
		open(Filename, read, Stream)).

%------------------------------------------------------------------------------
% prolog_read(+Stream, -Term):
%------------------------------------------------------------------------------

prolog_read(Stream, Term) :-
	(prolog_use_see(yes) ->
		read(Term)
	;
		read(Stream, Term)).

%------------------------------------------------------------------------------
% prolog_close(+Stream):
%------------------------------------------------------------------------------

prolog_close(Stream) :-
	(prolog_use_see(yes) ->
		seen
	;
		close(Stream)).

%------------------------------------------------------------------------------
% prolog_set_prompt(+New, -Old)
%------------------------------------------------------------------------------

prolog_set_prompt(New, Old) :-
	(prolog_use_prompt(swi) ->
		prompt(Old, New)
	;prolog_use_prompt(eclipse) ->
		get_prompt(input, Old, Out_Stream),
		set_prompt(input, New, Out_Stream)
	;
		true).

%------------------------------------------------------------------------------
% prolog_print_prompt(+Prompt):
%------------------------------------------------------------------------------

prolog_print_prompt(Prompt) :-
	(prolog_use_prompt(write) ->
		write(Prompt)
	;
		true).


						    

/*
new_slg_head(Head,Body,NewHead) :-
	functor(Head,P,A),
	name(P,Pl),
	name(Npred,[115,108,103,36|Pl]), % 'slg$'
	Narity is A+1,
	functor(NewHead,Npred,Narity),
	%dynamic(Npred/Narity),
	arg(Narity,NewHead,Body),
	put_in_args(0,A,Head,NewHead).

put_in_args(A,A,_,_).
put_in_args(A0,A,Head,NewHead) :-
	A0 < A,
	A1 is A0+1,
	arg(A1,Head,Arg),
	arg(A1,NewHead,Arg),
	put_in_args(A1,A,Head,NewHead).
/* -------------- beginning of slg_load routines -------------------------
  An input file may contain three kinds of directives (in addition to 
  regular Prolog clauses : commands) : 

  a) :- default(prolog).
     :- default(tabled).
     All predicates defined from now on are prolog (tabled) predicates
     unless specified otherwise later.
  b) :- tabled pred_name/arity.
     pred_name/arity is a tabled predicate. A comma separated list
     is also acceptable.

  c) :- prolog pred_name/arity.
     pred_name/arity is a prolog predicate. A comma separated list
     is also acceptable.

  Besides Prolog clauses, we allow general clauses where the body is a 
  universal disjunction of literals. Such clauses are specified in the form
         Head <-- Body.
  (Maybe <-- can be viewed as "All".) The head must be an atom of a tabled
  predicate : the body should be a disjunction of literals (separated by ';')
  : should not contain cut. The head must be stableGround whenever it is called. 
  All variables in the body that do not occur in the head are universally 
  quantified.

  There is NO support for module facilities. In particular, ALL TABLED
  PREDICATES SHOULD BE DEFINED IN MODULE 'user'.
*/

	
slg_term_expansion(end_of_file,_) :- !,
	%remDefaultDecl,
	%assertLogged(getDefaultDecl((prolog))),
	%retractallLogged('slg$prolog'(_)),
       % retractallLogged('slg$tab'(_,_)),
	fail.

slg_term_expansion((:-Com),Clauses) :- !,
	expand_cmd(Com,Clauses).

slg_term_expansion((  ::- Body),Clauses) :- !,
        convert_tabled_clause(inconsistent,Body,Clauses).

slg_term_expansion((H-->B),NewClause) :- !,
	not(slg_expanding),
	assertLogged(slg_expanding),
	expand_term((H-->B),Clause),
	retractallLogged(slg_expanding),
	slg_term_expansion(Clause,NewClause).

slg_term_expansion((Head <-- Body),Clauses) :- !,
	functor(Head,P,A),
	Pred = P/A,
	( isDeclTabled(P,A) ->
	  convert_univ_clause(Head,Body,Clauses)
	; isDeclProlog(Pred) ->
	  write('Error :  Prolog predicate '), write(Pred),
	  write(' in clauses with universal disjunction.'),nl,
	  write('       Clause ignored :  '), write((Head <-- Body)), nl,
	  Clauses = []
	; getDefaultDecl(Default),
	  ( Default == (prolog) ->
	    write('Error :  Prolog predicate '), write(Pred),
	    write(' in clauses with universal disjunction.'),nl,
	    write('       Clause ignored :  '), write((Head <-- Body)), nl,
	    Clauses = []
	  ; addDeclTabled(P,A),
	    addHasTable(P,A),
	    functor(NewHead,P,A),
	    Clauses = [(:- addHasTable(P,A)),(NewHead :- slg(NewHead))|RestClauses],
            convert_univ_clause(Head,Body,RestClauses)
	  )
        ).
	
slg_term_expansion(Clause,Clauses) :-
	( Clause = (Head :- Body) -> true; Head = Clause, Body = true ),
	functor(Head,P,A),
	Pred = P/A,
	( isDeclTabled(P,A) ->
	  convert_tabled_clause(Head,Body,Clauses)
        ; isDeclProlog(Pred) ->
	  Clauses = Clause
        ; getDefaultDecl(Default),
	  ( Default == (prolog) ->
	    Clauses = Clause
	  ; ( isDeclTabled(P,A) ->
	      convert_tabled_clause(Head,Body,Clauses)
	    ; addDeclTabled(P,A),
	      addHasTable(P,A),
	      functor(NewHead,P,A),
	      Clauses = [(:- addHasTable(P,A)),(NewHead :- slg(NewHead))|RestClauses],
              convert_tabled_clause(Head,Body,RestClauses)
	    )
	  )
        ).

expand_cmd(tabled(Preds),Clauses) :-
	expand_command_table(Preds,Clauses,[]).
expand_cmd(prolog(Preds),Clauses) :-
	expand_command_prolog(Preds,Clauses,[]).
expand_cmd(multifile(Preds),(:-multifile(NewPreds))) :-
	add_table_preds(Preds,NewPreds,[]).
expand_cmd(dynamic(Preds),(:-dynamic(NewPreds))) :-
	add_table_preds(Preds,NewPreds,[]).
expand_cmd(default(D),[]) :-
	( (D == (prolog); D == (tabled)) ->
	  remDefaultDecl,
	  setDefaultDecl(D)
        ; write('Warning :  illegal default '),
	  write(D),
	  write(' ignored.'),
	  nl
        ).

expand_command_table((Pred,Preds),Clauses0,Clauses) :- !,
	expand_command_table_one(Pred,Clauses0,Clauses1),
	expand_command_table(Preds,Clauses1,Clauses).
expand_command_table(Pred,Clauses0,Clauses) :-
	expand_command_table_one(Pred,Clauses0,Clauses).

expand_command_table_one(Pspec,Clauses0,Clauses) :-
	  ( Pspec = P/A -> true; P = Pspec, A = 0 ),
	  Pred = P/A,
	  functor(H,P,A),
	  ( isAlwaysProlog(H) ->
	    write('ERROR :  Cannot table built_in '),
	    write(Pred), nl,
	    Clauses0 = Clauses
	  ; isDeclProlog(Pred) ->
	    write('ERROR :  '),
	    write(Pred),
	    write(' assumed to be a Prolog predicate'),
	    nl,
	    tab(7),
	    write('But later declared a tabled predicate.'),
	    nl,
	    Clauses0 = Clauses
	  ; isDeclTabled(P,A) ->
	    Clauses0 = Clauses
	  ; addDeclTabled(P,A),
	    addHasTable(P,A),
	    Clauses0 = [(:- addHasTable(P,A)),(H :- slg(H))|Clauses]
	  ).

expand_command_prolog((Pred,Preds),Clauses0,Clauses) :- !,
	expand_command_prolog_one(Pred,Clauses0,Clauses1),
	expand_command_prolog(Preds,Clauses1,Clauses).
expand_command_prolog(Pred,Clauses0,Clauses) :-
	expand_command_prolog_one(Pred,Clauses0,Clauses).

expand_command_prolog_one(Pspec,Clauses0,Clauses) :-
	  ( Pspec = P/A -> true; P = Pspec, A = 0 ),
	  Pred = P/A,
	  ( isDeclTabled(P,A) ->
	    write('ERROR :  '),
	    write(Pred),
	    write(' assumed to be a tabled predicate'),
	    nl,
	    tab(7),
	    write('But later declared a Prolog predicate.'),
	    nl,
	    Clauses0 = Clauses
	  ; remDeclTable(P,A),
	    remHasTable(P,A),
	    addDeclProlog(P,A),
	    Clauses0 = [(:- remHasTable(P,A))|Clauses]
          ).

add_table_preds(Preds,NewPreds0,NewPreds) :-
	( Preds == [] ->
	  NewPreds0 = NewPreds
        ; Preds = [P|Ps] ->
	  add_table_preds(P,NewPreds0,NewPreds1),
	  add_table_preds(Ps,NewPreds1,NewPreds)
        ; Preds = (P,Ps) ->
	  add_table_preds(P,NewPreds0,NewPreds1),
	  add_table_preds(Ps,NewPreds1,NewPreds)
        ; ( Preds = P/A -> true; P = Preds, A = 0 ),
	  ( isDeclTabled(P,A) ->
	    add_slg_functor(P,NewP),
	    % name(P,Pl),
	    %name(NewP,[115,108,103,36|Pl]), % 'slg$'
	    NewA is A+1,
	    NewPreds0 = [P/A,NewP/NewA|NewPreds]
	  ; NewPreds0 = [P/A|NewPreds]
          )
        ).

convert_tabled_clause(Head,Body,Clauses0) :-
	  slg_conj_to_list(Body,Blist),
	  extract_guard(Blist,Guard,[],Nbody,Clauses0,Clauses),
	  slg_list_to_conj(Guard,Gconj),
	  new_slg_head(Head,Nbody,NewHead),
	  ( Gconj == true ->
	    Clauses = [NewHead]
	  ; Clauses = [(NewHead :- Gconj)]
          ).

convert_univ_clause(Head,Body,Clauses) :-
	slg_disj_to_list(Body,Blist),
	new_slg_head(Head,all(Blist),NewHead),
	Clauses = [(NewHead :- ( stableGround(Head) -> 
	                         true
			       ; write('Error : Non-stableGround prologCall '),
			         write(Head),
				 write(' in a clause with universal disjunction.'),
				 nl
			       ))].


slg_conj_to_list(Term,List) :-
	slg_conj_to_list(Term,List,[]).
slg_conj_to_list(Term,List0,List) :-
	( Term = (T1,T2) ->
	  slg_conj_to_list(T1,List0,List1),
	  slg_conj_to_list(T2,List1,List)
        ; Term == true ->
	  List0 = List
        ; List0 = [Term|List]
        ).

slg_disj_to_list(Term,List) :-
	slg_disj_to_list(Term,List,[]).

slg_disj_to_list(Term,List0,List) :-
	( Term = (T1 ; T2) ->
	  slg_disj_to_list(T1,List0,List1),
	  slg_disj_to_list(T2,List1,List)
        ; Term == true ->
	  List0 = List
        ; List0 = [Term|List]
        ).
	

extract_guard([],G,G,[],Cls,Cls).
extract_guard([Lit|List],G0,G,Rest,Cls0,Cls) :-
	( Lit = ( /*neg*/ \+ N) ->
	  Nlit = N
        ; Nlit = Lit
        ),
	( isAlwaysProlog(Nlit)  ->
	  G0 = [Lit|G1],
	  extract_guard(List,G1,G,Rest,Cls0,Cls)
        ; functor(Nlit,P,A),
	  Pred = P/A,
	  ( isDeclTabled(P,A) ->
	    G0 = G,
	    Rest = [Lit|List],
	    Cls0 = Cls
	  ; isDeclProlog(Pred) ->
	    G0 = [Lit|G1],
	    extract_guard(List,G1,G,Rest,Cls0,Cls)
	  ; getDefaultDecl((prolog)) ->
	    G0 = [Lit|G1],
	    addDeclProlog(Pred),
	    Cls0 = [(:- isDeclProlog(Pred) -> true; addDeclProlog(Pred))|Cls1],
	    extract_guard(List,G1,G,Rest,Cls1,Cls)
	  ; getDefaultDecl((tabled)) ->
	    G0 = G,
	    Rest = [Lit|List],
	    addDeclTabled(P,A),
            addHasTable(P,A),
	    functor(Head,P,A),
	    Cls0 = [(:- addHasTable(P,A)),
                    (Head :- slg(Head))|Cls]
	  )		     
        ).

slg_list_to_conj([],true).
slg_list_to_conj([Lit|List],G0) :-
	( List == [] ->
	  G0 = Lit
        ; G0 = (Lit,G),
	  slg_list_to_conj(List,G)
        ).


/*

slgtrans(InFile,OutFile) :-
        see(InFile),
        tell(OutFile),
        trans_clauses,
        told,
        seen.

trans_clauses :-
        repeat,
        read(Clause),
        ( slg_term_expansion(Clause,Clauses) ->
          put_clauses(Clauses)
        ; true
        ),
        Clause = end_of_file,
        !.

put_clauses([]) :- !.
put_clauses([C1|Cs]) :- !,
        portray_clause(C1),
        put_clauses(Cs).
put_clauses(C) :-
        portray_clause(C).
*/
*/


                                             
/*

/***************************************************************************/
/*                                                                         */
/* The SLG System                                                          */
/* Maintainers: Weidong Chen and David Scott Warren                            */
/* Copyright (C) 1993 Southern Methodist University                        */
/*               1993 SUNY at Stony Brook                                  */
/* See file COPYRIGHT for copying policies and disclaimer.                 */
/*                                                                         */
/***************************************************************************/

/*==========================================================================
  File               : slg.doc
  Last Modification  : November 1, 1993 by Weidong Chen
===========================================================================*/

This file describes the SLG system in this directory, and how to use
it. The SLG system is a meta interpreter written in Prolog that
supports the following features:

    * effective goal-oriented request evaluation of normal logic programs
      under the well-founded semantics [Van Gelder, Ross, Schlipf, 
      JACM, Vol. 38, July 1991];
    * effective goal-oriented request evaluation of general logic 
      programs under the alternating fixpoint logic [Van Gelder,
      JCSS, Vol. 47, 1993], with the restriction that the body of
      a clause is either a conjunction of literals or universal 
      disjunction of literals;
    * request evaluation under stable model semantics [Gelfond, Lifschitz,
      JICSLP, 1988];
    * integration with Prolog execution.

Predicates may be declared as "prolog" predicates or "tabled"
predicates. Prolog predicates are solved by calling Prolog directly.
Calls to tabled predicates are remembered in a table with their
corresponding answers. Future calls to tabled predicates will not be
re-executed, but will be satisfied using answers that were computed as
a result of the initial call. This mechanism prevents certain positive
loops (i.e., loops that involve no negation), and terminates much more
often than Prolog's strategy.

In case of negative loops, ground negative literals that are selected
in relevant clauses are delayed so that computation can proceed to
solve the remaining literals in the bodies of the relevant clauses.
Both positive and negative loops are detected efficiently by
incremental maintenance of dependencies among calls.

The table of calls and their answers is maintained in the meta
interpreter in a term structure (NOT in the Prolog database).
Therefore each invocation of the meta interpreter starts with an empty
table, and the table is lost when the meta interpreter returns. (See
slgall/4 and other predicates, to have the table returned to be reused
in later evaluations.) There is no support for assert/retract.  Also,
whenever the meta interpreter is invoked, ALL answers to the call are
computed before any is returned.

Prolog predicates can call tabled predicates. However, each call will
start with a new empty table. Tabled predicates can call Prolog
predicates. There is no support for modules. All clauses are asserted
in the default module (typically called 'user').

The syntax of Prolog is used for input programs, with additional
directives for predicate declarations and a minor variation for
clauses with universal disjunctions in the body (<-- instead of 
:-).

The file of interest is slg.pl, which consists of three sections: 1)
Prolog code that is more system dependent. Currently specific codes
are included for Quintus Prolog (TM), SICStus Prolog, and XSB System.
2) Prolog code that defines term_expansion/2 for loading files. It
intercepts the SLG declarations (:- tabled, prolog, default) and
converts clauses of tabled predicates into a form that is accepted by
the meta interpreter. ALL TABLED PREDICATES SHOULD BE DEFINED IN THE
DEFAULT MODULE. 3) Prolog code that implements the SLG meta
interpreter.

/***************************************************************************/

HOW TO USE THE SLG SYSTEM

With the SLG system, you can write Prolog programs and declare certain
predicates as tabled predicates. (Certain restrictions apply to
clauses of tabled predicates. See later.) Calls to tabled predicates
are intercepted and saved in a table. Later invocations of the same
call will use the table.

For the example of win/1, we could create a file, say win.pl:

	:- tabled win/1.
	win(X) :- move(X,Y), \+win(Y).

	move(a,a).
	move(a,b).
	move(b,a).
	move(b,c).

Within Prolog, we load the SLG system and then load win:

	| ?- [slg].
	| ?- [win].

We are now ready to ask queries:

	| ?- win(X).

	X = b ;

	no
	| ?- win(X)<-C.

	X = a,
	C = [\+win(a)] ;

	X = b,
	C = [] ;

	no
	| ?- \+ win(c).

	yes

The first request asks for all true answers, and the second request asks
for all true or undefined answers under the well-founded semantics.
For undefined answers, a list of delayed literals is also returned.
The third request checks whether w(c) is not true under the well-founded
semantics.

The next sections describe in detail the capabilities that SLG
supports.

TABLING DIRECTIVES:

SLG supports three tabling directives: tabled, prolog, and default. By
initial default, all predicates are treated as Prolog predicates. This
means that they will be evaluated by call-ing them as Prolog
predicates. Predicates that are declared as tabled will have a table
entry created for each distinct (i.e., nonvariant) call.

Tabled predicates are evaluated within the SLG meta-interpreter. The
first invocation of a tabled predicate will enter the meta
interpreter. Computation will then continue to be controlled by the
meta interpreter. Prolog predicates are evaluated by calling Prolog
directly. It is actually legal for a tabled predicate to call a prolog
predicate which in turn calls a tabled predicate.  However, in this
case computation will leave the meta interpreter and then later enter
a new invocation of it so that an entirely NEW table will be
constructed (and then discarded) for each invocation and Prolog's
infinite loops will NOT be terminated.

There are also certain constraints on the form of clauses that can be
used to define tabled predicates. In particular, the body of a clause
for a tabled predicate should be a conjunction of literals (or a comma
list). Cuts are allowed in the body before any occurrence of a tabled
predicate. Cuts that occur after the first occurrence of a tabled
predicate are NOT allowed. The body of a tabled predicate may also be
a (universal) disjunction of literals (or a semi-colon list), in which
case cut is simply not allowed, and all variables that occur only in
the body are universally quantified. Universal quantification is
indicated by using a different operator (<-- instead of :-).

A tabled or Prolog predicate must be declared as such (if it is not
defaulted) before clauses that define the predicate and before being
used in the definition of a tabled predicate. Each of the tabling
directives can take several arguments; simply separate them with
commas.

Tabled predicates are evaluated with respect to the well-founded
semantics, whose residual program may be processed to produce answers
in a stable model.

Detailed (or summarized) documentation of each directive follows:

DIRECTIVE: :- tabled <pred>/<arity>.

This declares the predicate (or sequence of predicates, if more than
one) to be tabled predicates. A table will be maintained on calls to
the indicated predicate. Clauses defining this predicate will be
stored in a predicate: 'slg$<pred>'/<arity+1>. Prolog built_ins (as
defined by predicate_property/2) cannot be tabled.

DIRECTIVE: :- prolog <pred>/<arity>.

This declares that the indicated predicate is to be evaluated by
call-ing Prolog evaluation directly. This is initially the default.

DIRECTIVE: :- default (tabled).
           :- default (prolog).

This changes the default declaration for how predicates are to be
evaluated. Initially, the default treatment for predicates is to
consider them as prolog predicates. The default can be changed with
one of the two directives. (The parentheses may be omitted for some
Prolog readers.) The default can be changed several times throughout a
compilation. However, care must be taken to insure that the system
correctly and consistently compiles all clauses and all calls. Each
new compile starts with the standard default of prolog.

The definition for term_expansion/2 intercepts tabling directives and
converts clauses of tabled predicates into a certain format. For the
previous example of win, the corresponding clauses are:

	'slg$tabled'(win,1).

	win(X) :- slg(win(X)).
	'slg$win'(X,[\+win(Y)]) :- move(X,Y).

	move(a,a).
	move(a,b).
	move(b,a).
	move(b,c).

Several aspects should be noted. First, there is no support for module
facilities. The meta interpreter does not work for tabled predicates
that are not in the default module 'user'. Second, clauses of Prolog
predicates are kept in their original form. In a clause of a tabled
predicate, all literals before the first occurrence of a tabled
predicate in the body are kept in their original Prolog format. If
clauses for a tabled predicate are loaded from multiple files, the
tabled predicate should be declared 'multifile' as in Prolog.

UNIVERSAL DISJUNCTION:

For tabled predicates, clauses that have a universal disjunction in
the body are allowed. For instance, the following clause:

	founded(X) <-- \+move(X,Y) ; founded(Y).

says that X is founded if for all Y, either \+move(X,Y) or founded(Y).
(You may think of <-- as indicating All and ';' as "or".) All
variables that occur only in the body are universally quantified.
Further restrictions include the standard safety constraints, namely
the head should be ground when the clause is used, and all variables
that occur in a positive literal in a universal disjunction should
also occur in negative literals in the disjunction or in the head. Cut
is definitely not allowed.

REQUEST INTERFACE:

SLG/1: slg(+Call)
       Call

If Call is an atom of a Prolog predicate, it is evaluated simply by
call(Call). If Call is an atom of a tabled predicate, a new table is
created and the meta interpreter is invoked. Notice that Call and
slg(Call) are equivalent. It returns true answers of Call under the
well-founded semantics.

(<-)/2: +Call <- -Delay

This predicate returns true or undefined answers for Call under the
well-founded semantics. Undefined answers are returned with a
non-empty list, Delay, of delayed literals. If Call is an atom of a
Prolog predicate, Delay is bound to [], and call(Call) is executed.

Negation of a call to a tabled predicate, \+ Call, succeeds only if
Call is ground and Call does not have a true answer. That is \+Call is
the same as \+slg(Call). To check if Call is false (according to the
well-founded semantics), one should use \+(Call<-_).

SLGALL/4: slgall(+Call,-Anss,+Table0,-Table)

If Call is an atom of a Prolog predicate, findall/3 is used, and Table
and Table0 are unified. If Call is a call to a tabled predicate, the
meta interpreter is invoked with the current table Table0. If Call is
already in Table0, its answers are simply looked up in the table and
returned and Table and Table0 are unified. Otherwise, Call is
evaluated, leading to a new table Table.

Every element in Anss is an instance of Call or of the form H <- D,
where H is an instance of Call, and D is a non-empty list of delayed
literals. For a call to a tabled predicate, slgall/4 ELIMINATES
REDUNDANT ANSWERS.

EMPTYTABLE/1: emptytable(?Table)

It unifies Table with the empty table.

ST/2: st(+Call,-PSM)

Call must be ground. It finds a stable model, PSM, in which Call is
true. PSM is a list of ground literals. The stable model is a
two-valued stable model of the ground clauses that are relevant to
Call. This applies to all predicates that computes answers in a stable
model.

STNOT/2: stnot(+Call,-PSM)

Call must be ground. It finds a stable model, PSM, in which Call is
false. PSM is a list of ground literals.

STALL/3: stall(+Call,-Anss,-PSM)
STALL/5: stall(+Call,-Anss,-PSM,+Tab0,-Tab)

It computes all answers, Anss, of Call in a stable model PSM.

STSELECT/3: stselect(+Call,+PSM0,-Anss,-PSM)
STSELECT/5: stselect(+Call,+PSM0,-Anss,-PSM,+Tab0,-Tab)

It computes all answers of Call in a stable model in which all
literals in PSM0 are true. The final stable model is PSM. PSM0 is a
list of ground literals that are used to select stable models.

TRACING: xtrace, xnotrace.

These predicates turn on (and off) a primitive tracing (really
logging) facility in the SLG meta-interpreter. When tracing is on
(after a call to :- xtrace), information is displayed when calls
become completely evaluated or calls in potential negative loops are
found. It displays the current stack and the table. (The tracing
has not been modified since the first release of the SLG system.)

ASSERT/RETRACT: NOT!

Database modification operations are NOT supported within the SLG meta
interpreter. Those who try to use them in conjunction with this
subsystem are completely on their own, and will probably get what they
deserve.

/*================ end of slg_doc =====================================*/

*/

	
% ===========================================================
% NATIVE SOAPD SERVER FOR SWI-PROLOG
% ===========================================================

			    
%:-module(moo_soap,[]).

% :-include('moo_header.pl').

:-dynamic(xmlCurrentOpenTags/2).

serviceSoapRequest(In,Out):-
      writeSTDERR('SOAP Request'),
        catch(read_do_soap(stream(In),Out),E,
        writeFmt(Out,'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n<error>~w</error>\n',[E])),
        catch(flush_output(Out),_,true).


read_do_soap(Source):-
        open(Source,read,Stream),
        read_do_soap(Stream,user_output).

read_do_soap(Source,Out):-
       getThread(Self),
        write(Out,'<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\n'),
       % writeFmt(Out,'<?xml version="1.0" encoding="ISO-8859-1"?>\n<answer thread="~w">\n',[Self]),
        catch(flush_output(Out),_,true),
        load_structure(Source,RDF,[]),
        structure_to_options(RDF,Options),
%       writeFmt(user_error,'structure="~q"\noptions="~q"\n',[RDF,Options]),
        catch(flush_output(user_error),_,true),
        processRequest([client=soap|Options]).
        %writeFmt(Out,'</answer>\n',[]).


% request
structure_to_options([element(request, Options, [Atom])],[submit=ask,sf=Atom|Options]):-!.

% assert
structure_to_options([element(assert, Options, [Atom])],[submit=assert,sf=Atom|Options]):-!.
structure_to_options([element(asssertion, Options, [Atom])],[submit=assert,sf=Atom|Options]):-!.
structure_to_options([element(assertion, Options, [Atom])],[submit=assert,sf=Atom|Options]):-!.

% get inner
structure_to_options([element(Ptag, ['xmlns:moo'=Server], Inner)],[opt_server=Server,opt_outter=Ptag|Out]):-!,
        structure_to_options(Inner,Out).



xmlOpenTag(Name):-getThread(Self),asserta(xmlCurrentOpenTags(Self,A)),writeFmtServer('<~w>',[Name]),!.
xmlOpenTagW(Out,Name,Text):-getThread(Self),asserta(xmlCurrentOpenTags(Self,A)),writeFmtServer(Out,'~w',[Text]),!.

xmlCloseTag(Name):-getThread(Self),ignore(retract(xmlCurrentOpenTags(Self,A))),writeFmtServer('</~w>',[Name]),!.
xmlCloseTagW(Name,Text):-getThread(Self),ignore(retract(xmlCurrentOpenTags(Self,A))),writeFmtServer('~w',[Text]),!.
xmlCloseTagW(Out,Name,Text):-getThread(Self),ignore(retract(xmlCurrentOpenTags(Self,A))),writeFmtServer(Out,'~w',[Text]),!.

xmlClearTags:-getThread(Self),retractall(xmlCurrentOpenTags(Self,A)).

xmlExitTags:-getThread(Self),retract(xmlCurrentOpenTags(Self,A)),writeFmtServer('</~w>',[Name]),fail.
xmlExitTags.


% ===========================================================
% Insert
% ===========================================================
parse_moo_soap(Options):-memberchk(submit=assert,Options),!,
        getMooOption(opt_ctx_assert='GlobalContext',Ctx),
        getMooOption(opt_theory='PrologMOO',Context),
        getMooOption(sf=surf,Assertion),
        atom_codes(Assertion,Assertion_Chars),
        getMooOption(user='Web',User),
        getMooOption(interp='kif',Interp),
        logOnFailure(getMooOption(tn=_,EXTID)),
        %sendNote(user,'Assert',formula(NEWFORM),'Ok.'). %,logOnFailure(saveMooCache)
        logOnFailure(getCleanCharsWhitespaceProper(Assertion_Chars,Show)),!,
        xml_assert(Show,Ctx,Context,User).

xml_assert(Show,Ctx,Context,User):-
        getSurfaceFromChars(Show,STERM,Vars),
        getMooTermFromSurface(STERM,NEWFORM),
        xml_assert(Show,NEWFORM,Vars,Ctx,Context,User).

xml_assert(Show,Ctx,Context,User):-!,
        writeFmt('<assertionResponse accepted="false">\nUnable to parse: "~s"\n</assertionResponse>\n',[Show]).

xml_assert(Show,NEWFORM,Vars,Ctx,Context,User):-
        logOnFailure(getTruthCheckResults(tell,[untrusted],surface,NEWFORM,Ctx,STN,Context,Vars,Maintainer,Result)),
        (Result=accept(_) ->
                        (
                        once(invokeInsert([trusted,canonicalize,to_mem],surface,NEWFORM,Ctx,EXTID,Context,Vars,User)),
                        write('<assertionResponse accepted="true">\nOk.\n</assertionResponse>\n')
                        )
                        ;
                        (
                        Result=notice(FormatStr,Args),
                        write('<assertionResponse accepted="false">\n'),
                        writeFmt(FormatStr,Args),
                        write('\n</assertionResponse>\n')
                        )
        ),!.

xml_assert(Show,NEWFORM,Vars,Ctx,Context,User):-!.


% ===========================================================
% Ask a Request
% ===========================================================
parse_moo_soap(Options):-memberchk(submit=ask,Options),!,make,
        %write('<!DOCTYPE moo:ask SYSTEM "/opt/tomcat-4.0/webapps/moo-1.4b1/dtd/java_prolog.dtd">\n'),
        write('<moo:ask xmlns:moo="http://localhost">\n'),
        getMooOption(opt_ctx_request='GlobalContext',Ctx),
        getMooOption(opt_theory='PrologMOO',Context),
        getMooOption(sf=surf,Askion),
        atom_codes(Askion,Askion_Chars),
        getMooOption(user='Web',User),
        getMooOption(interp='kif',Interp),
         logOnFailure(getCleanCharsWhitespaceProper(Askion_Chars,Show)),!,
         logOnFailure(getSurfaceFromChars(Show,STERM,Vars)),!,
         logOnFailure(getMooTermFromSurface(STERM,NEWFORM)),!,
              logOnFailure(once(( NEWFORM=comment(_) ->
                     (writeFmt('<error>Syntax Error: Unmatched parentheses in "~s"</error>\n',[Show]),!,FORM=_) ;(!,
                     logOnFailure(invokeRequest_xml(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU))
                     )))),
        write('</moo:ask>\n').

invokeRequest_xml(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU):-
        invokeRequestToBuffer(NEWFORM,ChaseVars,Ctx,TrackingAtom,Context,User,Vars,CPU),
        final_answer(Logic:How),
        invoke_final_answer(Logic,How,CPU).

invoke_final_answer(possible,How,CPU):-!,
        writeFmt('<requestResponse yesno="~w" numBindings="0" seconds="~w"/>\n',[How,CPU]).

invoke_final_answer(Logic,How,CPU):-
        writeFmt('<requestResponse yesno="~w" numBindings="~w" seconds="~w">\n<bindings>\n',[Logic,How,CPU]),
        cite_xml_buffered_answers,
        write('</bindings>\n</requestResponse>\n').


cite_xml_buffered_answers:-
        retract(requestBuffer_db(UResultsSoFar,Result,Explaination,Status)),
        once(inform_xml_agent(UResultsSoFar,Result,Explaination,Status)),fail.

% Call to write Summary
/*
cite_xml_buffered_answers:-
        final_answer(Logic:How),
        writeDebug(final_answer(Logic:How)),
        inform_xml_agent(How, ['Summary'=Logic|_G14093],final_answer(Logic:How),final_answer(Logic:How) ).
*/
cite_xml_buffered_answers:-!.

% ===========================================================
% Send to debugger
% ===========================================================
inform_xml_agent(UResultsSoFar,Result,InExplaination,Status):-
        writeDebug(inform_xml_agent(UResultsSoFar,Result,InExplaination,Status)),fail.

% ===========================================================
% Hide certain returns
% ===========================================================
inform_xml_agent(-1,Result,Explaination,Status).

inform_xml_agent(0, ['Result'=none|A], 'Unproven', done(possible:searchfailed)).
inform_xml_agent(_, ['Result'=true|A], found(_), done(true:_)).
inform_xml_agent(_, ['Summary'=_|_G5892], _, _).

% ===========================================================
% Write Answers
% ===========================================================
inform_xml_agent(UResultsSoFar,Result,InExplaination,Status):-
        writeFmt('<binding>\n',[]),
        inform_xml_vars(Result,Vars),
        length_explaination(InExplaination,InLength),
        findall(Length-Explaination,
                (retract(inform_xml_agent_buffer_db(_,Result,Explaination,_)),
                 length_explaination(Explaination,Length)
                 ),KeyList),

        keysort([(InLength-InExplaination)|KeyList],[(_-ChoiceExplaination)|_]),
        inform_xml_explaination(InLength,ChoiceExplaination,Result),
        writeFmt('</binding>\n',[]).

inform_xml_vars(Result,Vars):-
        length_var(Result,NumVar),
        writeFmt('<variables numVars="~w">\n',[NumVar]),
        inform_each_variable(Result,Vars),
        writeFmt('</variables>\n',[]).

length_var([],0).
length_var([A|'$VAR'(_)],1).
length_var([A|L],N):-
          length_var(L,NN),
          N is NN +1.

inform_each_variable([],Vars).
inform_each_variable('$VAR'(_),Vars).
inform_each_variable([NV|Rest],Vars):-
        inform_nv(NV,Vars),
        inform_each_variable(Rest,Vars).


inform_nv('$VAR'(_),Vars).
inform_nv(Name=Value,Vars):-
        toMarkUp(kif,Name,Vars,OName),
        toMarkUp(kif,Value,Vars,OValue),
        writeFmt('<var varName="~w" value="~w"/>\n',[OName,OValue]).


inform_xml_explaination(InLength,ChoiceExplaination,Result):-
        writeFmt('<explaination numSteps="~w">',[InLength]),
        flag(explaination_linenumber,_,0),
        writeObject_explaination(ChoiceExplaination,Result),
        writeFmt('</explaination>\n').

writeObject_explaination(deduced,_).
writeObject_explaination('$VAR'(_),_).
writeObject_explaination(explaination(Choice1) ,Result):-!,
        writeObject_explaination(Choice1,Result),!.
writeObject_explaination(Choice1 * Choice2 ,Result):-!,
        writeObject_explaination(Choice1,Result), !,
        writeObject_explaination(Choice2,Result),!.
writeObject_explaination(Choice1,Result):-!,
             write('<explainationStep isRule="true">\n<originalRule>\n'),
             toMarkUp(html,Choice1,Result,Out),!,
             ignore(write_escaped(Out)),
             write('\n</originalRule>\n</explainationStep>\n').

write_escaped([O|T]):-!,
        write_e_codes([O|T]),!.
write_escaped(Out):-atom(Out),!,
        atom_codes(Out,Codes),!,write_escaped(Codes),!.
write_escaped(String):- !,
        string_to_atom(String,Atom),
         atom_codes(Atom,Codes),!,
        write_e_codes(Codes),!.

write_e_codes([]):-!.
write_e_codes([E|Cs]):-!,
        write_e(E),!,
        write_e_codes(Cs),!.
write_e(34):-write('&qt;'),!.
write_e(60):-write('&lt;'),!.
write_e(62):-write('&gt;'),!.
write_e(C):-put_code(C),!.



/*
:-module(moo_transitiveclosure,
   [eraseTransitiveClosureCache/0,
   deduceTransitiveClosure_PartialOrderingRelation/5]).

:-use_module(moo_generation).
:-use_module(moo_globalisms).
*/

% :-include('moo_header.pl').

% =====================================================================================================
%% TC Database
% =====================================================================================================


:-op(600,xfx,'myUniv').


myUniv(domainFn(A,B),[domainFn,A,B]):-!.
myUniv(rangeFn(A,B),[rangeFn,A,B]):-!.
%myUniv(holds(P,A,B),[P,A,B]):-!.
myUniv(Term,[P|AB]):-!,Term=..[P|AB].
myUniv(holds(P,AB),[P|AB]):-!.


eraseTransitiveClosureCache:-
	retractall(mooCache(Context,_Ctx,tc(UN,_,_))),!,
	retractall(mooCache(Context,_Ctx,tc(domainFn(_,UN),_),_)),!,
	retractall(mooCache(Context,_Ctx,tc(domainFn(UN,_),_),_)),!,
	retractall(mooCache(Context,_Ctx,tc(rangeFn(_,UN),_),_)),!,
	retractall(mooCache(Context,_Ctx,tc(rangeFn(UN,_),_),_)),!,
	writeDebug(eraseTransitiveClosureCache).


%eraseTransitiveClosureCache(Context,Var):-expireOptimizationsInContext(Context,Assertion),fail.

eraseTransitiveClosureCache(Context,Var):-var(Var),!.
eraseTransitiveClosureCache(Context,UN):-number(UN),!.
eraseTransitiveClosureCache(Context,[]):-!.
eraseTransitiveClosureCache(Context,[H|L]):-!,
	eraseTransitiveClosureCache(Context,H),
	eraseTransitiveClosureCache(Context,L),!.

eraseTransitiveClosureCache(Context,UN):-atom(UN),
	%writeDebug(eraseTransitiveClosureCache(Context,UN)),
	retractall(mooCache(Context,_Ctx,tc(UN,_,_))),!,
	retractall(mooCache(Context,_Ctx,tc(domainFn(_,UN),_),_)),!,
	retractall(mooCache(Context,_Ctx,tc(domainFn(UN,_),_),_)),!,
	retractall(mooCache(Context,_Ctx,tc(rangeFn(_,UN),_),_)),!,
	retractall(mooCache(Context,_Ctx,tc(rangeFn(UN,_),_),_)),!.
	

eraseTransitiveClosureCache(Context,UN):-
	getConstants(atomic,UN,Consts,_,_),
	logOnFailure(eraseTransitiveClosureCache(Context,Consts)).

writeDebug_tc(_).

storeInCacheIffNew(Context,S,C,P):-(mooCache(Context,tc(S,C),_)),!.
storeInCacheIffNew(Context,S,C,P):-asserta(mooCache(Context,tc(S,C),P)),!.

storeInCacheIffNew(Context,S,C,P):-!.

% =====================================================================================================
%% TC for PartialOrderingRelation
% =====================================================================================================
deduceTransitiveClosure_PartialOrderingRelation(Context,Predicate,S,C,
%        sfind(instance(Predicate,'PartialOrderingRelation')) *
     	sfind(subclass('PartialOrderingRelation','TransitiveRelation'))  *
	Explaination  
	):- deduceTransitiveClosure_Redir(Context,'PartialOrderingRelation',Predicate,S,C,Explaination). 
	
deduceTransitiveClosure_PartialOrderingRelation(Context,Predicate,S,S,
%	sfind(instance(Predicate,'PartialOrderingRelation')) * 
	sfind(subclass('PartialOrderingRelation','ReflexiveRelation')) * 
	sfindi('=>'(instance(Predicate,'ReflexiveRelation'),
	forall(S,holds(Predicate,S,S))))):- isAxiomInContext(
	sfind(instance(Predicate,'PartialOrderingRelation')) * 
	sfind(subclass('PartialOrderingRelation','ReflexiveRelation')) * 
	sfind('=>'(instance(Predicate,'ReflexiveRelation'),
	forall(S,holds(Predicate,S,S))))).

% =====================================================================================================
%% TC for TotalOrderingRelation
% =====================================================================================================
deduceTransitiveClosure_TotalOrderingRelation(Context,Predicate,S,C,
      %  sfind(instance(Predicate,'TotalOrderingRelation')) *
 	sfind(subclass('TotalOrderingRelation','PartialOrderingRelation')) 
	):- deduceTransitiveClosure_PartialOrderingRelation(Context,Predicate,S,C,Explaination). 

% =====================================================================================================
%% TC for TransitiveRelation
% =====================================================================================================
deduceTransitiveClosure_TransitiveRelation(Context,Predicate,S,C,Explaination):- 
	deduceTransitiveClosure_Redir(Context,'TransitiveRelation',Predicate,S,C,Explaination). 


% =====================================================================================================
%% Generic Transitive Relation
% =====================================================================================================
deduceTransitiveClosure_Redir(Context,RType,Predicate,S,C, Explaination  *
	       sfindi( 
	   =>(instance(Predicate,'TransitiveRelation'),
	       forall(C,forall(D,forall(S,
	=>(and(holds(Predicate,S,D),holds(Predicate,D,C)),holds(Predicate,S,C)))))))
		):-
	    /*   isAxiomInContext( 
	   =>(instance(Predicate,'TransitiveRelation'),
	       forall(C,forall(D,forall(S,
	=>(and(holds(Predicate,S,D),holds(Predicate,D,C)),holds(Predicate,S,C))))))),!,	*/
		
		(deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,S,C,Explaination)).

deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,S,C,Explaination):-nonvar(C),!,
	deduceTransitiveClosure_rl_TransitiveRelation(Context,Predicate,S,C,Explaination).
deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,S,C,Explaination):-nonvar(S),!,
	deduceTransitiveClosure_lr_TransitiveRelation(Context,Predicate,S,C,Explaination).
deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,S,C,Explaination):-!,
	deduceTransitiveClosure_open_TransitiveRelation(Context,Predicate,S,C,Explaination).

% =====================================================================================================
%% Generic Transitive Open 
% =====================================================================================================

deduceTransitiveClosure_open_TransitiveRelation(Context,Predicate,S,C,Explaination):-
	%KeyTerm 'myUniv'  [holdsFn,Predicate],!,
	deduceTransitiveClosure_open_t_TransitiveRelation(Context,Predicate,Predicate,S,C,Explaination).

deduceTransitiveClosure_open_t_TransitiveRelation(Context,KeyTerm,Predicate,S,C,_):-
	once(table_make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate)),fail.
deduceTransitiveClosure_open_t_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P):-
	DataTerm 'myUniv'  [Predicate,S,C],
	mooCache(Context,_Ctx,tc(Predicate,DataTerm),P).

table_make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate):-
		mooCache(Context,_Ctx,tc(KeyTerm,complete,table)),!.
table_make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate):-
		once((
		mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table));assert(mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table))))),fail.
table_make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate):-
		(DataTerm 'myUniv'  [Predicate,S,C]),
		make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P),
		once(storeInCacheIffNew(Context,KeyTerm,DataTerm,P)),fail.

table_make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate):-
		retractall(mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table))),
		assert(mooCache(Context,_Ctx,tc(KeyTerm,complete,table))).
		


make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P):-
	(Call  'myUniv'   [Predicate,S,C]),
	getFactForTransitiveClosure(Context,Call,P).

make_deduceTransitiveClosure_open_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,(P *Explaination )):-
	(Call  'myUniv'   [Predicate,S,M]),
	getFactForTransitiveClosure(Context,Call,P),
	deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,M,C,Explaination).

% =====================================================================================================
%% Generic Transitive Left to Right 
% =====================================================================================================

deduceTransitiveClosure_lr_TransitiveRelation(Context,Predicate,S,C,Explaination):-
	KeyTerm 'myUniv'  [rangeFn,Predicate,S],!,
	deduceTransitiveClosure_l_r_TransitiveRelation(Context,KeyTerm,Predicate,S,C,Explaination).


deduceTransitiveClosure_l_r_TransitiveRelation(Context,KeyTerm,Predicate,S,C,_):-
	once(table_deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S)),fail.
	
deduceTransitiveClosure_l_r_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P):-
	%writeDebug(silver,have_tabel(KeyTerm)),
	DataTerm 'myUniv'  [Predicate,S,C],!,
	mooCache(Context,_Ctx,tc(KeyTerm,DataTerm),P).
	

table_deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S):-
		mooCache(Context,_Ctx,tc(KeyTerm,complete,table)),!.

table_deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S):-
		once((
		mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table));assert(mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table))))),fail.

table_deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S):-
		(DataTerm 'myUniv'  [Predicate,S,C]),
		deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P),
		once(storeInCacheIffNew(Context,KeyTerm,DataTerm,P)),fail.
		
table_deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S):-
		retractall(mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table))),
		assert(mooCache(Context,_Ctx,tc(KeyTerm,complete,table))),!.


deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P):-
	(Call  'myUniv'   [Predicate,S,C]),
	getFactForTransitiveClosure(Context,Call,P).

deduceTransitiveClosure_l_r_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,(P *Explaination )):-
	(Call  'myUniv'   [Predicate,S,M]),
	getFactForTransitiveClosure(Context,Call,P),
	deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,M,C,Explaination).

% =====================================================================================================
%% Generic Transitive  Right  to Left
% =====================================================================================================

deduceTransitiveClosure_rl_TransitiveRelation(Context,Predicate,S,C,Explaination):-
	KeyTerm 'myUniv'  [domainFn,Predicate,C],!,
	deduceTransitiveClosure_r_l_TransitiveRelation(Context,KeyTerm,Predicate,S,C,Explaination).

deduceTransitiveClosure_r_l_TransitiveRelation(Context,KeyTerm,Predicate,S,C,_):-
		table_deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,C),fail.
deduceTransitiveClosure_r_l_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P):-
		%writeDebug(have_tabel(KeyTerm)),
		DataTerm 'myUniv'  [Predicate,S,C],!,mooCache(Context,_Ctx,tc(KeyTerm,DataTerm),P).

table_deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,C):-
		mooCache(Context,_Ctx,tc(KeyTerm,complete,table)),!.

table_deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,C):-
		once((
		mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table));assert(mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table))))),fail.

table_deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,C):-
		(DataTerm 'myUniv'  [Predicate,S,C]),
		deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P),
		once(storeInCacheIffNew(Context,KeyTerm,DataTerm,P)),fail.

table_deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,C):-
		retractall(mooCache(Context,_Ctx,tc(KeyTerm,incomplete,table))),assert(mooCache(Context,_Ctx,tc(KeyTerm,complete,table))),!.


deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,P):-
	(Call  'myUniv'   [Predicate,S,C]),
	getFactForTransitiveClosure(Context,Call,P).

deduceTransitiveClosure_r_l_0_TransitiveRelation(Context,KeyTerm,Predicate,S,C,(P2 * P)):-
	(Call  'myUniv'   [Predicate,M,C]),
	getFactForTransitiveClosure(Context,Call,P),
	deduceTransitiveClosure_O_TransitiveRelation(Context,Predicate,S,M,P2).

isAxiomInContext(_):-!. %TODO



:-eraseTransitiveClosureCache.
/* Copyright(C) 1992, Swedish Institute of Computer Science */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   File   : UGRAPHS.PL							      %
%   Maintainer : Mats Carlsson						      %
%            New versions of transpose/2, reduce/2, top_sort/2 by Dan Sahlin  %
%   Updated: 3 September 1999						      %
%   Purpose: Unweighted graph-processing utilities			      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

/*  Adapted from shared code written by Richard A O'Keefe */

/*  An unweighted directed graph (ugraph) is represented as a list of
    (vertex-neighbors) pairs, where the pairs are in standard order
    (as produced by keysort with unique keys) and the neighbors of
    each vertex are also in standard order (as produced by sort), and
    every neighbor appears as a vertex even if it has no neighbors
    itself.

    An undirected graph is represented as a directed graph where for
    each edge (U,V) there is a symmetric edge (V,U).

    An edge (U,V) is represented as the term U-V.

    A vertex can be any term.  Two vertices are distinct iff they are
    not identical (==).

    A path is represented as a list of vertices.  
    No vertex can appear twice in a path.
*/



       /*
       
:- module(moo_uwdgraphs, [
	vertices_edges_to_ugraph/3,
	vertices/2,
	edges/2,
	add_vertices/3,
	del_vertices/3,
	add_edges/3,
	del_edges/3,
	transpose/2,
	neighbors/3,
	neighbours/3,
	complement/2,
	compose/3,
    %    transitive_closure/2,
	symmetric_closure/2,
	top_sort/2,
	max_path/5,
	min_path/5,
	min_paths/3,
	path/3,
	reduce/2,
	reachable/3,
	random_ugraph/3,
	min_tree/3,
	clique/3,
	independent_set/3,
	coloring/3,
	colouring/3
   ]).              */
   		  /*
:- use_module(library(ordsets), [
	my_ord_add_element/3,
	my_ord_del_element/3,
	my_ord_disjoint/2,
	my_ord_intersection/3,
	my_ord_subset/2,
	my_ord_subtract/3,
	my_ord_union/3,
	my_ord_union/4
   ]).

:- use_module(library(lists), [
	append/3,
	member/2,
	reverse/2
   ]).

:- use_module(library(assoc), [
	list_to_assoc/2,
	ord_list_to_assoc/2,
	get_assoc/3,
	get_assoc/5
   ]).

:- use_module(library(random), [
	random/1
   ]).			   */
	    
%   vertices_edges_to_ugraph(+Vertices, +Edges, -Graph)
%   is true if Vertices is a list of vertices, Edges is a list of edges,
%   and Graph is a graph built from Vertices and Edges.  Vertices and
%   Edges may be in any order.  The vertices mentioned in Edges do not
%   have to occur explicitly in Vertices.  Vertices may be used to
%   specify vertices that are not connected to any edges.

vertices_edges_to_ugraph(Vertices0, Edges, Graph) :-
	sort(Vertices0, Vertices1),
	sort(Edges, EdgeSet),
	edges_vertices(EdgeSet, Bag),
	sort(Bag, Vertices2),
	my_ord_union(Vertices1, Vertices2, VertexSet),
	group_edges(VertexSet, EdgeSet, Graph).

edges_vertices([], []).
edges_vertices([From-To|Edges], [From,To|Vertices]) :-
	edges_vertices(Edges, Vertices).

group_edges([], _, []).
group_edges([Vertex|Vertices], Edges, [Vertex-Neibs|G]) :-
	group_edges(Edges, Vertex, Neibs, RestEdges),
	group_edges(Vertices, RestEdges, G).

group_edges([V0-X|Edges], V, [X|Neibs], RestEdges) :- V0==V, !,
	group_edges(Edges, V, Neibs, RestEdges).
group_edges(Edges, _, [], Edges).



%   vertices(+Graph, -Vertices)
%   unifies Vertices with the vertices in Graph.

vertices([], []).
vertices([Vertex-_|Graph], [Vertex|Vertices]) :- vertices(Graph, Vertices).



%   edges(+Graph, -Edges)
%   unifies Edges with the edges in Graph.

edges([], []).
edges([Vertex-Neibs|G], Edges) :-
	edges(Neibs, Vertex, Edges, MoreEdges),
	edges(G, MoreEdges).

edges([], _, Edges, Edges).
edges([Neib|Neibs], Vertex, [Vertex-Neib|Edges], MoreEdges) :-
	edges(Neibs, Vertex, Edges, MoreEdges).



%   add_vertices(+Graph1, +Vertices, -Graph2)
%   is true if Graph2 is Graph1 with Vertices added to it.

add_vertices(Graph0, Vs0, Graph) :-
	sort(Vs0, Vs),
	vertex_units(Vs, Graph1),
	graph_union(Graph0, Graph1, Graph).



%   del_vertices(+Graph1, +Vertices, -Graph2)
%   is true if Graph2 is Graph1 with Vertices and all edges to and from
%   Vertices removed from it.

del_vertices(Graph0, Vs0, Graph) :-
	sort(Vs0, Vs),
	graph_del_vertices(Graph0, Vs, Vs, Graph).



%   add_edges(+Graph1, +Edges, -Graph2) 
%   is true if Graph2 is Graph1 with Edges and their "to" and "from"
%   vertices added to it.

add_edges(Graph0, Edges0, Graph) :-
	sort(Edges0, EdgeSet),
	edges_vertices(EdgeSet, Vs0),
	sort(Vs0, Vs),
	group_edges(Vs, EdgeSet, Graph1),
	graph_union(Graph0, Graph1, Graph).



%   del_edges(+Graph1, +Edges, -Graph2)
%   is true if Graph2 is Graph1 with Edges removed from it.

del_edges(Graph0, Edges0, Graph) :-
	sort(Edges0, EdgeSet),
	edges_vertices(EdgeSet, Vs0),
	sort(Vs0, Vs),
	group_edges(Vs, EdgeSet, Graph1),
	graph_difference(Graph0, Graph1, Graph).



vertex_units([], []).
vertex_units([V|Vs], [V-[]|Us]) :- vertex_units(Vs, Us).


graph_union(G0, [], G) :- !, G = G0.
graph_union([], G, G).
graph_union([V1-N1|G1], [V2-N2|G2], G) :-
	compare(C, V1, V2),
	graph_union(C, V1, N1, G1, V2, N2, G2, G).

graph_union(<, V1, N1, G1, V2, N2, G2, [V1-N1|G]) :-
	graph_union(G1, [V2-N2|G2], G).
graph_union(=, V, N1, G1, _, N2, G2, [V-N|G]) :-
	my_ord_union(N1, N2, N),
	graph_union(G1, G2, G).
graph_union(>, V1, N1, G1, V2, N2, G2, [V2-N2|G]) :-
	graph_union([V1-N1|G1], G2, G).



graph_difference(G0, [], G) :- !, G = G0.
graph_difference([], _, []).
graph_difference([V1-N1|G1], [V2-N2|G2], G) :-
	compare(C, V1, V2),
	graph_difference(C, V1, N1, G1, V2, N2, G2, G).

graph_difference(<, V1, N1, G1, V2, N2, G2, [V1-N1|G]) :-
	graph_difference(G1, [V2-N2|G2], G).
graph_difference(=, V, N1, G1, _, N2, G2, [V-N|G]) :-
	my_ord_subtract(N1, N2, N),
	graph_difference(G1, G2, G).
graph_difference(>, V1, N1, G1, _, _, G2, G) :-
	graph_difference([V1-N1|G1], G2, G).


graph_del_vertices(G1, [], Set, G) :- !,
	graph_del_vertices(G1, Set, G).
graph_del_vertices([], _, _, []).
graph_del_vertices([V1-N1|G1], [V2|Vs], Set, G) :-
	compare(C, V1, V2),
	graph_del_vertices(C, V1, N1, G1, V2, Vs, Set, G).

graph_del_vertices(<, V1, N1, G1, V2, Vs, Set, [V1-N|G]) :-
	my_ord_subtract(N1, Set, N),
	graph_del_vertices(G1, [V2|Vs], Set, G).
graph_del_vertices(=, _, _, G1, _, Vs, Set, G) :-
	graph_del_vertices(G1, Vs, Set, G).
graph_del_vertices(>, V1, N1, G1, _, Vs, Set, G) :-
	graph_del_vertices([V1-N1|G1], Vs, Set, G).

graph_del_vertices([], _, []).
graph_del_vertices([V1-N1|G1], Set, [V1-N|G]) :-
	my_ord_subtract(N1, Set, N),
	graph_del_vertices(G1, Set, G).



%   transpose(+Graph, -Transpose)
%   is true if Transpose is the graph computed by replacing each edge
%   (u,v) in Graph by its symmetric edge (v,u).  It can only be used
%   one way around.  The cost is O(N log N).

transpose(Graph, Transpose) :-
	transpose_edges(Graph, TEdges, []),
	sort(TEdges, TEdges2),
	vertices(Graph, Vertices),
	group_edges(Vertices, TEdges2, Transpose).

transpose_edges([]) --> [].
transpose_edges([Vertex-Neibs|G]) -->
        transpose_edges(Neibs, Vertex),
	transpose_edges(G).

transpose_edges([], _) --> [].
transpose_edges([Neib|Neibs], Vertex) --> [Neib-Vertex],
	transpose_edges(Neibs, Vertex).


%   neighbours(+Vertex, +Graph, -Neighbors)
%   neighbors(+Vertex, +Graph, -Neighbors)
%   is true if Vertex is a vertex in Graph and Neighbors are its neighbors.

neighbours(Vertex, Graph, Neighbors) :-
	neighbors(Vertex, Graph, Neighbors).

neighbors(V, [V0-Neighbors|_], Neighbors) :- V0==V, !.
neighbors(V, [_|Graph], Neighbors) :- neighbors(V, Graph, Neighbors).



%   complement(+Graph, -Complement)
%   Complement is the complement graph of Graph, i.e. the graph that has
%   the same vertices as Graph but only the edges that are not in Graph.

complement(Graph, Complement) :-
	vertices(Graph, Vertices),
	complement(Graph, Vertices, Complement).

complement([], _, []).
complement([V-Neibs|Graph], Vertices, [V-Others|Complement]) :-
	my_ord_add_element(Neibs, V, Neibs1),
	my_ord_subtract(Vertices, Neibs1, Others),
	complement(Graph, Vertices, Complement).



%   compose(+G1, +G2, -Composition)
%   computes Composition as the composition of two graphs, which need
%   not have the same set of vertices.

compose(G1, G2, Composition) :-
	vertices(G1, V1),
	vertices(G2, V2),
	my_ord_union(V1, V2, V),
	compose(V, G1, G2, Composition).

compose([], _, _, []).
compose([V0|Vertices], [V-Neibs|G1], G2, [V-Comp|Composition]) :- V==V0, !,
	compose1(Neibs, G2, [], Comp),
	compose(Vertices, G1, G2, Composition).
compose([V|Vertices], G1, G2, [V-[]|Composition]) :-
	compose(Vertices, G1, G2, Composition).

compose1([V1|Vs1], [V2-N2|G2], SoFar, Comp) :- !,
	compare(Rel, V1, V2),
	compose1(Rel, V1, Vs1, V2, N2, G2, SoFar, Comp).
compose1(_, _, Comp, Comp).

compose1(<, _, Vs1, V2, N2, G2, SoFar, Comp) :-
	compose1(Vs1, [V2-N2|G2], SoFar, Comp).
compose1(>, V1, Vs1, _, _, G2, SoFar, Comp) :-
	compose1([V1|Vs1], G2, SoFar, Comp).
compose1(=, V1, Vs1, V1, N2, G2, SoFar, Comp) :-
	my_ord_union(N2, SoFar, Next),
	compose1(Vs1, G2, Next, Comp).



%   transitive_closure(+Graph, -Closure) 
%   computes Closure as the transitive closure of Graph in O(N^3) time.

/*

transitive_closure(Graph, Closure) :-
	warshall(Graph, Graph, Closure).

warshall([], Closure, Closure).
warshall([V-_|G], E, Closure) :-
	neighbors(V, E, Y),
	warshall(E, V, Y, NewE),
	warshall(G, NewE, Closure).

warshall([], _, _, []).
warshall([X-Neibs|G], V, Y, [X-NewNeibs|NewG]) :-
	my_ord_subset([V], Neibs), !,
	my_ord_del_element(Y, X, Y1),
	my_ord_union(Neibs, Y1, NewNeibs),
	warshall(G, V, Y, NewG).
warshall([X-Neibs|G], V, Y, [X-Neibs|NewG]) :-
	warshall(G, V, Y, NewG).
*/


%   symmetric_closure(+Graph, -Closure) 
%   computes Closure as the symmetric closure of Graph, i.e.  for each
%   edge (u,v) in Graph, add its symmetric edge (v,u).  Approx O(N log N)
%   time.  This is useful for making a directed graph undirected.

symmetric_closure(Graph, Closure) :-
	transpose(Graph, Transpose),
	symmetric_closure(Graph, Transpose, Closure).

symmetric_closure([], [], []).
symmetric_closure([V-Neibs1|Graph], [V-Neibs2|Transpose], [V-Neibs|Closure]) :-
	my_ord_union(Neibs1, Neibs2, Neibs),
	symmetric_closure(Graph, Transpose, Closure).



%   top_sort(+Graph, -Sorted)
%   finds a topological ordering of a Graph and returns the ordering
%   as a list of Sorted vertices.  Fails iff no ordering exists, i.e.
%   iff the graph contains cycles.  Approx O(N log N) time.

top_sort(Graph, Sorted) :-
	fanin_counts(Graph, Counts),
	get_top_elements(Counts, Top, 0, I),
	ord_list_to_assoc(Counts, Map),
	top_sort(Top, I, Map, Sorted).

top_sort([], 0, _, []).
top_sort([V-VN|Top0], I, Map0, [V|Sorted]) :-
	dec_counts(VN, I, J, Map0, Map, Top0, Top),
	top_sort(Top, J, Map, Sorted).

dec_counts([], I, I, Map, Map, Top, Top).
dec_counts([N|Ns], I, K, Map0, Map, Top0, Top) :-
	get_assoc(N, Map0, NN-C0, Map1, NN-C),
	C is C0-1,
	(C=:=0 -> J is I-1, Top1 = [N-NN|Top0]; J = I, Top1 = Top0),
	dec_counts(Ns, J, K, Map1, Map, Top1, Top).

get_top_elements([], [], I, I).
get_top_elements([V-(VN-C)|Counts], Top0, I, K) :-
	(C=:=0 -> J = I, Top0 = [V-VN|Top1]; J is I+1, Top0 = Top1),
	get_top_elements(Counts, Top1, J, K).

fanin_counts(Graph, Counts) :-
	transpose_edges(Graph, Edges0, []),
	keysort(Edges0, Edges),
	fanin_counts(Graph, Edges, Counts).

fanin_counts([], [], []).
fanin_counts([V-VN|Graph], Edges, [V-(VN-C)|Counts]) :-
	fanin_counts(Edges, V, 0, C, Edges1),
	fanin_counts(Graph, Edges1, Counts).

fanin_counts([V-_|Edges0], V0, C0, C, Edges) :-
	V==V0, !,
	C1 is C0+1,
	fanin_counts(Edges0, V0, C1, C, Edges).
fanin_counts(Edges, _, C, C, Edges).


%   max_path(+V1, +V2, +Graph, -Path, -Cost)
%   is true if Path is a list of vertices constituting a longest path
%   of cost Cost from V1 to V2 in Graph, there being no cyclic paths from
%   V1 to V2.  Takes O(N^2) time.

max_path(Initial, Final, Graph, Path, Cost) :-
	transpose(Graph, TGraph),
	max_path_init(Initial, Final, Graph, TGraph, TGraph2, Order),
	max_path_init(TGraph2, Val0),
	max_path(Order, TGraph2, Val0, Val),
	max_path_select(Val, Path, Cost).

max_path_init(Initial, Final, Graph, TGraph, TGraph2, Order) :-
	reachable(Initial, Graph, InitialReachable),
	reachable(Final, TGraph, FinalReachable),
	my_ord_intersection(InitialReachable, FinalReachable, Reachable),
	subgraph(TGraph, Reachable, TGraph2),
	top_sort(TGraph2, Order).

max_path_init([], []).
max_path_init([V-_|G], [V-([]-0)|Val]) :- max_path_init(G, Val).

max_path_select([V-(Longest-Max)|Val], Path, Cost) :-
	max_path_select(Val, V, Longest, Path, Max, Cost).

max_path_select([], V, Path, [V|Path], Cost, Cost).
max_path_select([V1-(Path1-Cost1)|Val], V2, Path2, Path, Cost2, Cost) :-
	(   Cost1>Cost2 -> 
	    max_path_select(Val, V1, Path1, Path, Cost1, Cost)
	;   max_path_select(Val, V2, Path2, Path, Cost2, Cost)
	).

max_path([], _, Val, Val).
max_path([V|Order], Graph, Val0, Val) :-
	neighbors(V, Graph, Neibs),
	neighbors(V, Val0, Item),
	max_path_update(Neibs, V-Item, Val0, Val1),
	max_path(Order, Graph, Val1, Val).

max_path_update([], _, Val, Val).
max_path_update([N|Neibs], Item, [Item0|Val0], Val) :-
	Item0 = V0-(_-Cost0),
	N==V0, !,
	Item = V-(Path-Cost),
	Cost1 is Cost+1,
	(   Cost1>Cost0 -> Val = [V0-([V|Path]-Cost1)|Val1]
	;   Val = [Item0|Val1]
	),
	max_path_update(Neibs, Item, Val0, Val1).
max_path_update(Neibs, Item, [X|Val0], [X|Val]) :-
	max_path_update(Neibs, Item, Val0, Val).

subgraph([], _, []).
subgraph([V-Neibs|Graph], Vs, [V-Neibs1|Subgraph]) :-
	my_ord_subset([V], Vs), !,
	my_ord_intersection(Neibs, Vs, Neibs1),
	subgraph(Graph, Vs, Subgraph).
subgraph([_|Graph], Vs, Subgraph) :-
	subgraph(Graph, Vs, Subgraph).



%   min_path(+V1, +V2, +Graph, -Path, -Length)
%   is true if Path is a list of vertices constituting a shortest path
%   of length Length from V1 to V2 in Graph.  Takes O(N^2) time.

min_path(Initial, Final, Graph, Path, Length) :-
	min_path([[Initial]|Q], Q, [Initial], Final, Graph, Rev),
	reverse(Rev, Path),
	length(Path, N),
	Length is N-1.

min_path(Head0, Tail0, Closed0, Final, Graph, Rev) :-
	Head0 \== Tail0,
	Head0 = [Sofar|Head],
	Sofar = [V|_],
	(   V==Final -> Rev = Sofar
	;   neighbors(V, Graph, Neibs),
	    my_ord_union(Closed0, Neibs, Closed, Neibs1),
	    enqueue(Neibs1, Sofar, Tail0, Tail),
	    min_path(Head, Tail, Closed, Final, Graph, Rev)
	).

enqueue([], _) --> [].
enqueue([V|Vs], Sofar) --> [[V|Sofar]], enqueue(Vs, Sofar).



%   min_paths(+Vertex, +Graph, -Tree)
%   is true if Tree is a tree of all the shortest paths from Vertex to
%   every other vertex in Graph.  This is the single-source shortest
%   paths problem.  The algorithm is straightforward.

min_paths(Vertex, Graph, Tree) :-
	min_paths([Vertex], Graph, [Vertex], List),
	keysort(List, Tree).

min_paths([], _, _, []).
min_paths([Q|R], Graph, Reach0, [Q-New|List]) :-
	neighbors(Q, Graph, Neibs),
	my_ord_union(Reach0, Neibs, Reach, New),
	append(R, New, S),
	min_paths(S, Graph, Reach, List).



%   path(+Vertex, +Graph, -Path)
%   is given a Graph and a Vertex of that Graph, and returns a maximal
%   Path rooted at Vertex, enumerating more Paths on backtracking.

path(Initial, Graph, Path) :-
	path([Initial], [], Graph, Path).

path(Q, Not, Graph, Path) :-
	Q = [Qhead|_],
	neighbors(Qhead, Graph, Neibs),
	my_ord_subtract(Neibs, Not, Neibs1),
	(   Neibs1 = [] -> reverse(Q, Path)
	;   my_ord_add_element(Not, Qhead, Not1),
	    member(N, Neibs1),
	    path([N|Q], Not1, Graph, Path)
	).



%   reduce(+Graph, -Reduced)
%   is true if Reduced is the reduced graph for Graph. The vertices of
%   the reduced graph are the strongly connected components of Graph.
%   There is an edge in Reduced from u to v iff there is an edge in
%   Graph from one of the vertices in u to one of the vertices in v. A
%   strongly connected component is a maximal set of vertices where
%   each vertex has a path to every other vertex.
%   Algorithm from "Algorithms" by Sedgewick, page 482, Tarjan's algorithm.
%   Approximately linear in the maximum of arcs and nodes (O(N log N)).

reduce(Graph, Reduced) :-
	strong_components(Graph, SCCS, Map),
	reduced_vertices_edges(Graph, Vertices, Map, Edges, []),
	sort(Vertices, Vertices1),
	sort(Edges, Edges1),
	group_edges(Vertices1, Edges1, Reduced),
	sort(SCCS, Vertices1).

strong_components(Graph, SCCS, A) :-
	nodeinfo(Graph, Nodeinfo, Vertices), 
	ord_list_to_assoc(Nodeinfo, A0), 
	visit(Vertices, 0, _, A0, A, 0, _, [], _, SCCS, []).

visit([], Min, Min, A, A, I, I, Stk, Stk) --> [].
visit([V|Vs], Min0, Min, A0, A, I, M, Stk0, Stk) -->
	{get_assoc(V, A0, node(Ns,J,Eq), A1, node(Ns,K,Eq))},
	(   {J>0} ->
	    {J=K, J=Min1, A1=A3, I=L, Stk0=Stk2}
	;   {K is I+1},
	    visit(Ns, K, Min1, A1, A2, K, L, [V|Stk0], Stk1),
	    (   {K>Min1} -> {A2=A3, Stk1=Stk2}
	    ;   pop(V, Eq, A2, A3, Stk1, Stk2, [])
	    )
	),
	{Min2 is min(Min0,Min1)},
	visit(Vs, Min2, Min, A3, A, L, M, Stk2, Stk).

pop(V, Eq, A0, A, [V1|Stk0], Stk, SCC0) -->
	{get_assoc(V1, A0, node(Ns,_,Eq), A1, node(Ns,16'100000,Eq))},
	(   {V==V1} -> [SCC], {A1=A, Stk0=Stk, sort([V1|SCC0], SCC)}
	;   pop(V, Eq, A1, A, Stk0, Stk, [V1|SCC0])
	).

nodeinfo([], [], []).
nodeinfo([V-Ns|G], [V-node(Ns,0,_)|Nodeinfo], [V|Vs]) :-
	nodeinfo(G, Nodeinfo, Vs).

reduced_vertices_edges([], [], _) --> [].
reduced_vertices_edges([V-Neibs|Graph], [V1|Vs], Map) -->
	{get_assoc(V, Map, N), N=node(_,_,V1)},
	reduced_edges(Neibs, V1, Map),
	reduced_vertices_edges(Graph, Vs, Map).

reduced_edges([], _, _) --> [].
reduced_edges([V|Vs], V1, Map) -->
	{get_assoc(V, Map, N), N=node(_,_,V2)},
	({V1==V2} -> []; [V1-V2]),
	reduced_edges(Vs, V1, Map).


%   reachable(+Vertex, +Graph, -Reachable)
%   is given a Graph and a Vertex of that Graph, and returns the set
%   of vertices that are Reachable from that Vertex.  Takes O(N^2)
%   time.

reachable(Initial, Graph, Reachable) :-
	reachable([Initial], Graph, [Initial], Reachable).

reachable([], _, Reachable, Reachable).
reachable([Q|R], Graph, Reach0, Reachable) :-
	neighbors(Q, Graph, Neighbors),
	my_ord_union(Reach0, Neighbors, Reach1, New),
	append(R, New, S),
	reachable(S, Graph, Reach1, Reachable).



%   random_ugraph(+P, +N, -Graph)
%   where P is a probability, unifies Graph with a random graph of N
%   vertices where each possible edge is included with probability P.

random_ugraph(P, N, Graph) :-
	(   float(P), 
		P >= 0.0, P =< 1.0 -> true
	;   /*prolog:*/illarg(domain(float,between(0.0,1.0)),
	                  random_ugraph(P,N,Graph), 1)
	),
	(   integer(N), N >= 0 -> true
	;   /*prolog:*/illarg(domain(integer,>=(0)),
	                  random_ugraph(P,N,Graph), 2)
	),
	random_ugraph(0, N, P, Graph).

random_ugraph(N, N, _, Graph) :- !, Graph = [].
random_ugraph(I, N, P, [J-List|Graph]) :-
	J is I+1,
	random_neighbors(N, J, P, List, []),
	random_ugraph(J, N, P, Graph).

random_neighbors(0, _, _, S0, S) :- !, S = S0.
random_neighbors(N, J, P, S0, S) :-
	(   N==J -> S1 = S
	;   random(X), X > P -> S1 = S
	;   S1 = [N|S]
	),
	M is N-1,
	random_neighbors(M, J, P, S0, S1).



%   min_tree(+Graph, -Tree, -Cost)
%   is true if Tree is a spanning tree of an *undirected* Graph with
%   cost Cost, if it exists.  Using a version of Prim's algorithm.

min_tree([V-Neibs|Graph], Tree, Cost) :-
	length(Graph, Cost),
	prim(Cost, Neibs, Graph, [V], Edges),
	vertices_edges_to_ugraph([], Edges, Tree).	

prim(0, [], _, _, []).
prim(I, [V|Vs], Graph, Reach, [V-W,W-V|Edges]) :-
	neighbors(V, Graph, Neibs),
	my_ord_subtract(Neibs, Reach, Neibs1),
	my_ord_subtract(Neibs, Neibs1, [W|_]),
	my_ord_add_element(Reach, V, Reach1),
	my_ord_union(Vs, Neibs1, Vs1),
	J is I-1,
	prim(J, Vs1, Graph, Reach1, Edges).



%   clique(+Graph, +K, -Clique)
%   is true if Clique is a maximal clique (complete subgraph) of N
%   vertices of an *undirected* Graph, where N>=K.  Adapted from
%   Algorithm 457, "Finding All Cliques of an Undirected Graph [H]",
%   Version 1, by Coen Bron and Joep Kerbosch, CACM vol. 6 no. 9 pp.
%   575-577, Sept. 1973.

clique(Graph, K, Clique) :-
	(   integer(K), K >= 0 -> true
	;   /*prolog:*/illarg(domain(integer,>=(0)),
	                  clique(Graph,K,Clique), 2)
	),
	J is K-1,
	prune(Graph, [], J, Graph1),
	clique1(Graph1, J, Clique).

clique1([], J, []) :- J < 0.
clique1([C-Neibs|Graph], J, [C|Clique]) :-
	neighbor_graph(Graph, Neibs, C, Vs, Graph1),
	J1 is J-1,
	prune(Graph1, Vs, J1, Graph2),
	clique1(Graph2, J1, Clique).
clique1([C-Neibs|Graph], J, Clique) :-
	prune(Graph, [C], J, Graph2),
	clique1(Graph2, J, Clique),
	\+ my_ord_subset(Clique, Neibs).

neighbor_graph([], _, _, [], []).
neighbor_graph([V0-Neibs0|Graph0], [V|Vs], W, Del, [V-Neibs|Graph]) :-
	V0==V, !,
	my_ord_del_element(Neibs0, W, Neibs),
	neighbor_graph(Graph0, Vs, W, Del, Graph).
neighbor_graph([V-_|Graph0], Vs, W, [V|Del], Graph) :-
	neighbor_graph(Graph0, Vs, W, Del, Graph).

prune(Graph0, [], K, Graph) :- K =< 0, !, Graph = Graph0.
prune(Graph0, Vs0, K, Graph) :-
	prune(Graph0, Vs0, K, Graph1, Vs1),
	(   Vs1==[] -> Graph = Graph1
	;   prune(Graph1, Vs1, K, Graph)
	).

prune([], _, _, [], []).
prune([V-Ns0|Graph0], Vs1, K, [V-Ns|Graph], Vs2) :-
	my_ord_disjoint([V], Vs1),
	my_ord_subtract(Ns0, Vs1, Ns),
	length(Ns, I),
	I >= K, !,
	prune(Graph0, Vs1, K, Graph, Vs2).
prune([V-_|Graph0], Vs1, K, Graph, Vs2) :-
	(   my_ord_disjoint([V], Vs1) -> Vs2 = [V|Vs3]
	;   Vs2 = Vs3
	),
	prune(Graph0, Vs1, K, Graph, Vs3).



%   independent_set(+Graph, +K, -Set)
%   is true if Set is a maximal independent (unconnected) set of N
%   vertices of an *undirected* Graph, where N>=K.

independent_set(Graph, K, Set) :-
	complement(Graph, Complement),
	clique(Complement, K, Set).



%   colouring(+Graph, +K, -Coloring)
%   coloring(+Graph, +K, -Coloring)
%   is true if Coloring is a mapping from vertices to colors 1..N of
%   an *undirected* Graph such that all edges have distinct end colors,
%   where N=<K.  Adapted from "New Methods to Color the Vertices of a
%   Graph", by D. Brelaz, CACM vol. 4 no. 22 pp. 251-256, April 1979.
%   Augmented with ideas from Matula's smallest-last ordering.

colouring(Graph, K, Coloring) :-
	coloring(Graph, K, Coloring).

coloring(Graph, K, Coloring) :-
	(   integer(K), K >= 0 -> true
	;   /*prolog:*/illarg(domain(integer,>=(0)),
	                  coloring(Graph,K,Coloring), 2)
	),
	color_map(Graph, Coloring),
	color_map(Graph, Graph1, Coloring, Coloring),
	coloring(Graph1, K, 0, [], Stack),
	color_stack(Stack).

coloring([], _, _, Stk0, Stk) :- !, Stk0 = Stk.
coloring(Graph, K, InUse, Stk0, Stk) :-
	select_vertex(Graph, K, Compare, -, 0+0, V-Ns),
	graph_del_vertices(Graph, [V], [V], Graph1),
	(   Compare = < ->
	    coloring(Graph1, K, InUse, [V-Ns|Stk0], Stk)
	;   M is min(K,InUse+1),
	    vertex_color(Ns, 1, M, V),
	    add_color(Graph1, Ns, V, Graph2),
	    InUse1 is max(V,InUse),
	    coloring(Graph2, K, InUse1, Stk0, Stk)
	).

%   select_vertex(+Graph, +K, -Comp, +Pair0, +Rank, -Pair)
%   return any vertex with degree<K right away (Comp = <) else return
%   vertex with max. saturation degree (Comp = >=), break ties using
%   max. degree

select_vertex([], _, >=, Pair, _, Pair).
select_vertex([V-Neibs|Graph], K, Comp, Pair0, Rank0, Pair) :-
	evaluate_vertex(Neibs, 0, Rank),
	(   Rank < K -> Comp = <, Pair = V-Neibs
	;   Rank @> Rank0 ->
	    select_vertex(Graph, K, Comp, V-Neibs, Rank, Pair)
	;   select_vertex(Graph, K, Comp, Pair0, Rank0, Pair)
	).

evaluate_vertex([V|Neibs], Deg, Rank) :- var(V), !,
	Deg1 is Deg+1,
	evaluate_vertex(Neibs, Deg1, Rank).
evaluate_vertex(Neibs, Deg, Sat+Deg) :-
	/*prolog:*/length(Neibs, 0, Sat).

add_color([], _, _, []).
add_color([V-Neibs|Graph], [W|Vs], C, [V-Neibs1|Graph1]) :- V==W, !,
	my_ord_add_element(Neibs, C, Neibs1),
	add_color(Graph, Vs, C, Graph1).
add_color([Pair|Graph], Vs, C, [Pair|Graph1]) :-
	add_color(Graph, Vs, C, Graph1).

vertex_color([V|Vs], I, M, Color) :- V@<I, !,
	vertex_color(Vs, I, M, Color).
vertex_color([I|Vs], I, M, Color) :- !,
	I<M, J is I+1, vertex_color(Vs, J, M, Color).
vertex_color(_, I, _, I).
vertex_color(Vs, I, M, Color) :-
	I<M, J is I+1, vertex_color(Vs, J, M, Color).

color_stack([]).
color_stack([V-Neibs|Stk]) :- sort(Neibs, Set), color_stack(Set, 1, V, Stk).

color_stack([I|Is], I, V, Stk) :- !, J is I+1, color_stack(Is, J, V, Stk).
color_stack(_, V, V, Stk) :- color_stack(Stk).

color_map([], []).
color_map([V-_|Graph], [V-_|Coloring]) :- color_map(Graph, Coloring).

color_map([], [], [], _).
color_map([V-Ns|Graph], [C-Ns1|Graph1], [V-C|Cols], Coloring) :-
	map_colors(Ns, Coloring, Ns1),
	color_map(Graph, Graph1, Cols, Coloring).

map_colors([], _, []).
map_colors(Ns, Coloring, Ns1) :-
	Ns = [X|_],
	Coloring = [V-_|_],
	compare(C, X, V),
	map_colors(C, Ns, Coloring, Ns1).

map_colors(=, [_|Xs], [_-Y|Coloring], [Y|Ns1]) :-
	map_colors(Xs, Coloring, Ns1).
map_colors(>, Ns, [_|Coloring], Ns1) :-
	map_colors(Ns, Coloring, Ns1).
	

/* Copyright(C) 1988, Swedish Institute of Computer Science */

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%   File   : ORDSETS.PL							      %
%   Maintainer : Lena Flood						      %
%   Updated: 9 September 1988						      %
%   Purpose: Ordered set manipulation utilities				      %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
		  /*
		  
:- module(ordsets, [
	is_ordset/1,
	list_to_my_ord_set/2,
	my_ord_add_element/3,
	my_ord_del_element/3,
	my_ord_disjoint/2,
	my_ord_intersect/2,
	my_ord_intersection/3,
	my_ord_intersection/4,
	my_ord_intersection/2,
	my_ord_member/2,
	my_ord_seteq/2,
	my_ord_setproduct/3,
	my_ord_subset/2,
	my_ord_subtract/3,
	my_ord_symdiff/3,
	my_ord_union/3,
	my_ord_union/4,
	my_ord_union/2
		   ]).
				    */
%   Adapted from shared code written by Richard A O'Keefe. 

%   In this package, sets are represented by ordered lists with no
%   duplicates.	 Thus {c,r,a,f,t} would be [a,c,f,r,t].	 The ordering
%   is defined by the @< family of term comparison predicates, which
%   is the ordering used by sort/2 and setof/3.

%   The benefit of the ordered representation is that the elementary
%   set operations can be done in time proportional to the Sum of the
%   argument sizes rather than their Product.  



%   is_ordset(+Set)
%   is true when Set is an ordered set.

is_ordset(X) :- var(X), !, fail.
is_ordset([]).
is_ordset([Head|Tail]) :-
	is_ordset(Tail, Head).

is_ordset(X, _) :- var(X), !, fail.
is_ordset([], _).
is_ordset([Head|Tail], Left) :-
	Left @< Head,
	is_ordset(Tail, Head).


%   list_to_my_ord_set(+List, ?Set)
%   is true when Set is the ordered representation of the set represented
%   by the unordered representation List.  

list_to_my_ord_set(List, Set) :-
	sort(List, Set).


%   my_ord_add_element(+Set1, +Element -Set2)
%   is true when Set2 is Set1 with Element inserted in it, preserving
%   the order.

my_ord_add_element([], Element, [Element]).
my_ord_add_element([Head|Tail], Element, Set) :-
	compare(Order, Head, Element),
	my_ord_add_element(Order, Head, Tail, Element, Set).

my_ord_add_element(<, Head, Tail, Element, [Head|Set]) :-
	my_ord_add_element(Tail, Element, Set).
my_ord_add_element(=, Head, Tail, _, [Head|Tail]).
my_ord_add_element(>, Head, Tail, Element, [Element,Head|Tail]).


%   my_ord_del_element(+Set1, +Element, ?Set2)
%   is true when Set2 is Set1 but with Element removed.

my_ord_del_element([], _, []).
my_ord_del_element([Head|Tail], Element, Set) :-
	compare(Order, Head, Element),
	my_ord_del_element(Order, Head, Tail, Element, Set).

my_ord_del_element(<, Head, Tail, Element, [Head|Set]) :-
	my_ord_del_element(Tail, Element, Set).
my_ord_del_element(=, _, Tail, _, Tail).
my_ord_del_element(>, Head, Tail, _, [Head|Tail]).



%   my_ord_disjoint(+Set1, +Set2)
%   is true when the two ordered sets have no element in common.  

my_ord_disjoint(Set1, Set2) :-
	\+ my_ord_intersect(Set1, Set2).



%   my_ord_intersect(+Set1, +Set2)
%   is true when the two ordered sets have at least one element in common.

my_ord_intersect([Head1|Tail1], [Head2|Tail2]) :-
	compare(Order, Head1, Head2),
	my_ord_intersect(Order, Head1, Tail1, Head2, Tail2).

my_ord_intersect(<, _, [Head1|Tail1], Head2, Tail2) :-
	compare(Order, Head1, Head2),
	my_ord_intersect(Order, Head1, Tail1, Head2, Tail2).
my_ord_intersect(=, _, _, _, _).
my_ord_intersect(>, Head1, Tail1, _, [Head2|Tail2]) :-
	compare(Order, Head1, Head2),
	my_ord_intersect(Order, Head1, Tail1, Head2, Tail2).



%   my_ord_intersection(+Set1, +Set2, ?Intersection)
%   is true when Intersection is the intersecton of Set1
%   and Set2, provided that Set1 and Set2 are ordered sets.

my_ord_intersection([], _, []).
my_ord_intersection([Head1|Tail1], Set2, Intersection) :-
	my_ord_intersection3(Set2, Head1, Tail1, Intersection).

my_ord_intersection3(<, _, Set1, Head2, Tail2, Intersection) :-
	my_ord_intersection3(Set1, Head2, Tail2, Intersection).
my_ord_intersection3(=, Head, Tail1, _, Tail2, [Head|Intersection]) :-
	my_ord_intersection(Tail1, Tail2, Intersection).
my_ord_intersection3(>, Head1, Tail1, _, Set2, Intersection) :-
	my_ord_intersection3(Set2, Head1, Tail1, Intersection).

% could be a disjunction, but is used in three places
my_ord_intersection3([], _, _, []).
my_ord_intersection3([Head2|Tail2], Head1, Tail1, Intersection) :-
	compare(Order, Head1, Head2),
	my_ord_intersection3(Order, Head1, Tail1, Head2, Tail2, Intersection).



%   my_ord_intersection(+Set1, +Set2, ?Intersection, ?Difference)
%   is true when Intersection is the intersection of Set1 and Set2, 
%   and Differens is Set2 \ Set1 (like in my_ord_union/4),
%    provided that Set1 and Set2 are ordered sets.

my_ord_intersection([], Set2, [], Set2).
my_ord_intersection([Head1|Tail1], Set2, Intersection, Difference) :-
	my_ord_intersection4(Set2, Head1, Tail1, Intersection, Difference).

my_ord_intersection4(<, _, Set1, Head2, Tail2, Intersection, Difference) :-
	(   Set1 = [], Intersection = [], Difference = [Head2|Tail2]
	;   Set1 = [Head1|Tail1],
	    compare(Order, Head1, Head2),
	    my_ord_intersection4(Order, Head1, Tail1, Head2, Tail2, Intersection, Difference)
	).
my_ord_intersection4(=, Head, Tail1, _, Tail2, [Head|Intersection], Difference) :-
	my_ord_intersection(Tail1, Tail2, Intersection, Difference).
my_ord_intersection4(>, Head1, Tail1, Head2, Set2, Intersection, [Head2|Difference]) :-
	my_ord_intersection4(Set2, Head1, Tail1, Intersection, Difference).

my_ord_intersection4([], _, _, [], []).
my_ord_intersection4([Head2|Tail2], Head1, Tail1, Intersection, Difference) :-
	compare(Order, Head1, Head2),
	my_ord_intersection4(Order, Head1, Tail1, Head2, Tail2, Intersection, Difference).



%   my_ord_intersection(+Sets, ?Intersection)
%   is true when Intersection is the ordered set representation of the
%   intersection of all the sets in Sets.

my_ord_intersection(Sets, Intersection) :- 
	length(Sets, NumberOfSets),
	NumberOfSets > 0,
	my_ord_intersection2(NumberOfSets, Sets, Intersection, []).

my_ord_intersection2(1, [Set|Sets], Set0, Sets0) :- !,
	Set = Set0,
	Sets = Sets0.
my_ord_intersection2(2, [Set,Set2|Sets], Intersection, Sets0) :- !,
	Sets = Sets0,
	my_ord_intersection(Set, Set2, Intersection).
my_ord_intersection2(N, Sets0, Intersection, Sets) :-
%	N > 2,
	A is N>>1,
	Z is N-A,
	my_ord_intersection2(A, Sets0, X, Sets1),
	my_ord_intersection2(Z, Sets1, Y, Sets),
	my_ord_intersection(X, Y, Intersection).



%   my_ord_member(+Elt, +Set)
%   is true when Elt is a member of Set.  Suggested by Mark Johnson.

my_ord_member(X, [E|Es]) :-
        compare(C, X, E),
        my_ord_member(C, X, Es).

my_ord_member(=, _X, _Es).
my_ord_member(>, X, [E|Es]) :-
        compare(C, X, E),
        my_ord_member(C, X, Es).



%   my_ord_seteq(+Set1, +Set2)
%   is true when the two arguments represent the same set.  Since they
%   are assumed to be ordered representations, they must be identical.


my_ord_seteq(Set1, Set2) :-
	Set1 == Set2.


%   my_ord_setproduct(+Set1, +Set2, ?SetProduct)
%   is true when SetProduct is the cartesian product of Set1 and Set2. The
%   product is represented as pairs Elem1-Elem2, where Elem1 is an element
%   from Set1 and Elem2 is an element from Set2.

my_ord_setproduct([], _, []).
my_ord_setproduct([Head|Tail], Set, SetProduct)  :-
	my_ord_setproduct(Set, Head, SetProduct, Rest),
	my_ord_setproduct(Tail, Set, Rest).

my_ord_setproduct([], _, Set, Set).
my_ord_setproduct([Head|Tail], X, [X-Head|TailX], Tl) :-
	my_ord_setproduct(Tail, X, TailX, Tl).



%   my_ord_subset(+Set1, +Set2)
%   is true when every element of the ordered set Set1 appears in the
%   ordered set Set2.

my_ord_subset([], _).
my_ord_subset([Head1|Tail1], [Head2|Tail2]) :-
	compare(Order, Head1, Head2),
	my_ord_subset(Order, Head1, Tail1, Tail2).

my_ord_subset(=, _, Tail1, Tail2) :-
	my_ord_subset(Tail1, Tail2).
my_ord_subset(>, Head1, Tail1, [Head2|Tail2]) :-
	compare(Order, Head1, Head2),
	my_ord_subset(Order, Head1, Tail1, Tail2).



%   my_ord_subtract(+Set1, +Set2, ?Difference)
%   is true when Difference contains all and only the elements of Set1
%   which are not also in Set2, i.e. Set1 \ Set2.

my_ord_subtract(Set1, Set2, Union) :-
	/*prolog:*/subtract(Set1, Set2, Union).

/***
subtract([], _, []).
subtract([Head1|Tail1], Set2, Difference) :-
	subtract3(Set2, Head1, Tail1, Difference).

subtract3(<, Head, Set1, Head2, Tail2, [Head|Difference]) :-
	(   Set1 = [], Difference = []
	;   Set1 = [Head1|Tail1],
	    compare(Order, Head1, Head2),
	    subtract3(Order, Head1, Tail1, Head2, Tail2, Difference)
	).
subtract3(=, _, Tail1, _, Tail2, Difference) :-
	subtract(Tail1, Tail2, Difference).
subtract3(>, Head1, Tail1, _, Set2, Difference) :-
	subtract3(Set2, Head1, Tail1, Difference).

subtract3([], Head1, Tail1, [Head1|Tail1]).
subtract3([Head2|Tail2], Head1, Tail1, Difference) :-
	compare(Order, Head1, Head2),
	subtract3(Order, Head1, Tail1, Head2, Tail2, Difference).
***/


%   my_ord_symdiff(+Set1, +Set2, ?Difference)
%   is true when Difference is the symmetric difference of Set1 and Set2.

my_ord_symdiff([], Set2, Set2).
my_ord_symdiff([Head1|Tail1], Set2, Symdiff) :-
	my_ord_symdiff(Set2, Head1, Tail1, Symdiff).

my_ord_symdiff(<, Head1, Set1, Head2, Tail2, [Head1|Symdiff]) :-
	my_ord_symdiff(Set1, Head2, Tail2, Symdiff).
my_ord_symdiff(=, _, Tail1, _, Tail2, Symdiff) :-
	my_ord_symdiff(Tail1, Tail2, Symdiff).
my_ord_symdiff(>, Head1, Tail1, Head2, Set2, [Head2|Symdiff]) :-
	my_ord_symdiff(Set2, Head1, Tail1, Symdiff).

% could be a disjunction, but is used in three places
my_ord_symdiff([], Head1, Tail1, [Head1|Tail1]).
my_ord_symdiff([Head2|Tail2], Head1, Tail1, Symdiff) :-
	compare(Order, Head1, Head2),
	my_ord_symdiff(Order, Head1, Tail1, Head2, Tail2, Symdiff).



%   my_ord_union(+Set1, +Set2, ?Union)
%   is true when Union is the union of Set1 and Set2.  Note that when
%   something occurs in both sets, we want to retain only one copy.

my_ord_union(Set1, Set2, Union) :-
	/*prolog:*/merge(Set1, Set2, Union).

/***
merge([], Set, Set).
merge([O|Os], Ns, Set) :- merge(Ns, O, Os, Set).

merge([], O, Os, [O|Os]).
merge([N|Ns], O, Os, Set) :-
	compare(C, O, N), 
	merge(C, O, Os, N, Ns, Set).

merge(<, O1, Os, N, Ns, [O1|Set]) :- merge(Os, N, Ns, Set).
merge(=, _, Os, N, Ns, [N|Set]) :- merge(Os, Ns, Set).
merge(>, O, Os, N1, Ns, [N1|Set]) :- merge(Ns, O, Os, Set).
***/



%   my_ord_union(+Set1, +Set2, ?Union, ?New)
%   is true when Union is the union of Set1 and Set2, and New is
%   Set2 \ Set1.  This is useful if you
%   are accumulating members of a set and you want to process new
%   elements as they are added to the set.

my_ord_union([], Set2, Set2, Set2).
my_ord_union([Head1|Tail1], Set2, Union, Difference) :-
	my_ord_union4(Set2, Head1, Tail1, Union, Difference).

my_ord_union4(<, Head, Set1, Head2, Tail2, [Head|Union], Difference) :-
	(   Set1 = [], Union = [Head2|Tail2], Difference = [Head2|Tail2]
	;   Set1 = [Head1|Tail1],
	    compare(Order, Head1, Head2),
	    my_ord_union4(Order, Head1, Tail1, Head2, Tail2, Union, Difference)
	).
my_ord_union4(=, Head, Tail1, _, Tail2, [Head|Union], Difference) :-
	my_ord_union(Tail1, Tail2, Union, Difference).
my_ord_union4(>, Head1, Tail1, Head2, Set2, [Head2|Union], [Head2|Difference]) :-
	my_ord_union4(Set2, Head1, Tail1, Union, Difference).

my_ord_union4([], Head1, Tail1, [Head1|Tail1], []).
my_ord_union4([Head2|Tail2], Head1, Tail1, Union, Difference) :-
	compare(Order, Head1, Head2),
	my_ord_union4(Order, Head1, Tail1, Head2, Tail2, Union, Difference).



%   my_ord_union(+Sets, ?Union) 
%   is true when Union is the union of all the sets in Sets. 

my_ord_union([], Union) :- !, Union = [].
my_ord_union(Sets, Union) :-
	length(Sets, NumberOfSets),
	my_ord_union_all(NumberOfSets, Sets, Union, []).

my_ord_union_all(1, [Set|Sets], Set, Sets) :- !.
my_ord_union_all(2, [Set,Set2|Sets], Union, Sets) :- !,
	my_ord_union(Set, Set2, Union).
my_ord_union_all(N, Sets0, Union, Sets) :-
	A is N>>1,
	Z is N-A,
	my_ord_union_all(A, Sets0, X, Sets1),
	my_ord_union_all(Z, Sets1, Y, Sets),
	my_ord_union(X, Y, Union).



%   Copyright(C) 1994, Swedish Institute of Computer Science

%   File       : ASSOC.PL
%   Maintainer : Mats Carlsson
%   Updated    : 15 December 1994
%   Purpose    : AVL tree implementation of "association lists".
	     /*
:- module(assoc, [
	assoc_to_list/2,		% Assoc -> List
	empty_assoc/1,			% -> Assoc
	del_assoc/4,			% Key x Assoc x Val -> Assoc
	del_max_assoc/4,		% Assoc -> Key x Val x Assoc
	del_min_assoc/4,		% Assoc -> Key x Val x Assoc
	gen_assoc/3,			% Key x Assoc x Val
	get_assoc/3,			% Key x Assoc -> Val
	get_assoc/5,			% Key x Assoc x Val -> Assoc x Val
	get_next_assoc/4,		% Key x Assoc -> Key x Val
	get_prev_assoc/4,		% Key x Assoc -> Key x Val
	is_assoc/1,			% Assoc ->
	list_to_assoc/2,		% List -> Assoc
	map_assoc/2,			% Goal x Assoc ->
	map_assoc/3,			% Goal x Assoc -> Assoc
	max_assoc/3,			% Assoc -> Key x Val
	min_assoc/3,			% Assoc -> Key x Val
	ord_list_to_assoc/2,		% List -> Assoc
	put_assoc/4			% Key x Assoc x Val -> Assoc
   ]).

:- meta_predicate
	map_assoc(:, ?),
	map_assoc(:, ?, ?).

:- use_module(library(lists), [
	append/3
			      ]).

		    */
%   Adapted from shared assoc.pl, which used binary trees,
%   written by Richard A O'Keefe.

%   In this package, finite functions are represented by AVL trees, i.e.
%   they are subject to the Adelson-Velskii-Landis balance criterion:
%   
%     A tree is balanced iff for every node the heights of its
%     two subtrees differ by at most 1.
%   
%   The empty tree is represented as t.
%   A tree with key K, value V, and left and right subtrees L and R is
%   represented as t(K,V,|R|-|L|,L,R).
%   |T| denotes the height of T.
%   
%   The advantage of this representation is that lookup, insertion and
%   deletion all become - in the worst case - O(log n) operations.
%   
%   The algorithms are due to Wirth, "Algorithms + Data Structures =
%   Programs", 4.4.6 - 4.4.8.



%   empty_assoc(?Assoc)
%   is true when Assoc is an empty AVL tree.

%empty_assoc(t).					% also in Compiler/comp_sup.pl



%   assoc_to_list(+Assoc, ?List)
%   assumes that Assoc is a proper AVL tree, and is true when
%   List is a list of Key-Value pairs in ascending order with no
%   duplicate keys specifying the same finite function as Assoc.
%   Use this to convert an Assoc to a list.

/*
assoc_to_list(Assoc, List) :-
	/*prolog:*/assoc_to_list(Assoc, List, []).	% in Compiler/comp_sup.pl
*/

assoc_to_list(t) --> [].
assoc_to_list(t(K,V,_,L,R)) -->
	assoc_to_list(L),
	[K-V],
	assoc_to_list(R).



%   is_assoc(+Assoc)
%   is true when Assoc is a (proper) AVL tree.  It checks both that the keys 
%   are in ascending order and that Assoc is properly balanced.

is_assoc(Assoc) :-
	is_assoc(Assoc, nokey, _, _).

is_assoc(-, _, _, _) :- !, fail.
is_assoc(t, Min, Min, 0).
is_assoc(t(Key,_,B,L,R), Min0, Max, Height) :-
	Min = key(Key),
	is_assoc(L, Min0, Mid, HeightL),
	Mid @< Min,
	is_assoc(R, Min, Max, HeightR),
	B is HeightR-HeightL,
	(   HeightL < HeightR -> Height is HeightR+1
	;   Height is HeightL+1
	).



%   min_assoc(+Assoc, ?Key, ?Val)
%   is true when Key is the smallest key in Assoc and Val is its value.

min_assoc(t(K,V,_,L,_), Key, Val) :-
	min_assoc(L, Key, Val, K, V).

min_assoc(t, K, V, K, V).
min_assoc(t(K,V,_,L,_), Key, Val, _, _) :-
	min_assoc(L, Key, Val, K, V).



%   max_assoc(+Assoc, ?Key, ?Val)
%   is true when Key is the greatest key in Assoc and Val is its value.

max_assoc(t(K,V,_,_,R), Key, Val) :-
	max_assoc(R, Key, Val, K, V).

max_assoc(t, K, V, K, V).
max_assoc(t(K,V,_,_,R), Key, Val, _, _) :-
	max_assoc(R, Key, Val, K, V).



%   gen_assoc(?Key, +Assoc, ?Value)
%   assumes that Assoc is a proper AVL tree, and is true when
%   Key is associated with Value in Assoc.  Can be used to enumerate
%   all Values by ascending Keys.

/*
gen_assoc(Key, Assoc, Value) :-
	/*prolog:*/gen_assoc(Key, Assoc, Value).	% in Compiler/comp_sup.pl
*/


gen_assoc(Key, t(K,V,_,L,R), Val) :-
	(   gen_assoc(Key, L, Val)
	;   Key = K, Val = V
	;   gen_assoc(Key, R, Val)
	).


%   get_assoc(+Key, +Assoc, ?Value)
%   assumes that Assoc is a proper AVL tree.  It is true when
%   Key is identical to (==) one of the keys in Assoc, and Value
%   unifies with the associated value.

/*
get_assoc(Key, Assoc, Value) :-
	/*prolog:*/get_assoc(Key, Assoc, Value).	% in Compiler/comp_sup.pl
*/
/*
get_assoc(Key, t(K,V,_,L,R), Val) :-
	compare(Rel, Key, K),
	get_assoc(Rel, Key, Val, V, L, R).

get_assoc(<, Key, Val, _, Tree, _) :- get_assoc(Key, Tree, Val).
get_assoc(=, _, Val, Val, _, _).
get_assoc(>, Key, Val, _, _, Tree) :- get_assoc(Key, Tree, Val).

  */

%   get_assoc(+Key, +OldAssoc, ?OldValue, ?NewAssoc, ?NewValue)
%   is true when OldAssoc and NewAssoc are AVL trees of the same
%   shape having the same elements except that the value for Key in
%   OldAssoc is OldValue and the value for Key in NewAssoc is NewValue.

/*
get_assoc(Key, OldAssoc, OldValue, NewAssoc, NewValue) :-
	/*prolog:*/get_assoc(Key, OldAssoc, OldValue, NewAssoc, NewValue).	% in Compiler/comp_sup.pl

*/
/*
get_assoc(Key, t(K0,V0,B,L0,R0), Val0, t(K,V,B,L,R), Val) :-
	compare(Rel, Key, K0),
	get_assoc(Rel, Key, K0, V0, L0, R0, Val0, K, V, L, R, Val).

get_assoc(<, Key, K, V, Tree0, R, Val0, K, V, Tree, R, Val) :-
	get_assoc(Key, Tree0, Val0, Tree, Val).
get_assoc(=, _, K, Val0, L, R, Val0, K, Val, L, R, Val).
get_assoc(>, Key, K, V, L, Tree0, Val0, K, V, L, Tree, Val) :-
	get_assoc(Key, Tree0, Val0, Tree, Val).
*/




%   get_next_assoc(+Key, +Assoc, ?Knext, ?Vnext)
%   is true when Knext and Vnext is the next key and associated value 
%   after Key in Assoc.

get_next_assoc(Key0, t(K,V,_,L,R), Key, Val) :-
	(   K @=< Key0 ->
	    get_next_assoc(Key0, R, Key, Val)
	;   get_next_assoc(Key0, L, K1, V1) ->
	    Key = K1, Val = V1
	;   Key = K,  Val = V
	).



%   get_prev_assoc(+Key, +Assoc, ?Kprev, ?Vprev)
%   is true when Kprev and Vprev is the previous key and associated value 
%   to Key in Assoc.

get_prev_assoc(Key0, t(K,V,_,L,R), Key, Val) :-
	(   K @>= Key0 ->
	    get_prev_assoc(Key0, L, Key, Val)
	;   get_prev_assoc(Key0, R, K1, V1) ->
	    Key = K1, Val = V1
	;   Key = K,  Val = V
	).


%   ord_list_to_assoc(+List, ?Assoc)
%   is true when List is a proper list of Key-Val pairs (keysorted)
%   and Assoc is an association tree specifying the same finite function
%   from Keys to Values.

ord_list_to_assoc(List, Assoc) :-
	length(List, N),
	ord_list_to_assoc(N, List, [], Assoc).


ord_list_to_assoc(0, List, List, t) :- !.
ord_list_to_assoc(1, [Key-Val|List], List, t(Key,Val,0,t,t)) :- !.
ord_list_to_assoc(N, List0, List, t(Key,Val,Bal,L,R)) :-
	Bal is msb(N)-msb(N-1),
	A is (N-1) >> 1,
	Z is (N-1) - A,
	ord_list_to_assoc(A, List0, [Key-Val|List1], L),
	ord_list_to_assoc(Z, List1, List, R).


:-arithmetic_function(msb/1).

%msb(X,Y):-Y is integer(X/3)+1. 

msb(X,Y):-Y is integer(log(X)). 
%msb(X,Y):-Y is integer(log(2,X)). 

%   list_to_assoc(+List, ?Assoc)
%   is true when List is a proper list of Key-Val pairs (in any order)
%   and Assoc is an association tree specifying the same finite function
%   from Keys to Values.

list_to_assoc(Pairs, Assoc) :-
	list_to_assoc(Pairs, t, Assoc).


list_to_assoc([], Assoc, Assoc).
list_to_assoc([K-V|Pairs], Assoc0, Assoc) :-
	put_assoc(K, Assoc0, V, Assoc1),
	list_to_assoc(Pairs, Assoc1, Assoc).



%   put_assoc(+Key, +OldAssoc, +Val, -NewAssoc)
%   is true when OldAssoc and NewAssoc define the same finite function
%   except that NewAssoc associates Val with Key.  OldAssoc need not have
%   associated any value at all with Key.  
/* 

see moo_ale.P 
put_assoc(Key, Assoc0, Val, Assoc1) :-
	put_assoc(Assoc0, Key, Val, Assoc1, _).	% in Compiler/comp_sup.pl

put_assoc(t,            Key, Val, t(Key,Val,0,t,t), 1).
put_assoc(t(K,V,B,L,R), Key, Val, Result, Delta) :-
	compare(O, Key, K),
	put_assoc(O, Key, Val, Result, Delta, K, V, B, L, R).
		     */

put_assoc(<, Key, Val, Assoc, Delta, K, V, B, L, R) :-
	put_assoc(L, Key, Val, Lassoc, D1),
	Delta is \(B) /\ D1,			% grew?
	B1 is B-D1,
	assoc(B1, K, V, Lassoc, R, Assoc).
put_assoc(=, Key, Val, t(Key,Val,B,L,R), 0, _, _, B, L, R).
put_assoc(>, Key, Val, Assoc, Delta, K, V, B, L, R) :-
	put_assoc(R, Key, Val, Rassoc, D1),
	Delta is \(B) /\ D1,			% grew?
	B1 is B+D1,
	assoc(B1, K, V, L, Rassoc, Assoc).



assoc(-2, K, V, L, R, Assoc) :-
	L = t(K1,V1,B1,L1,R1),
	assoc_left(B1, K1, V1, L1, R1, K, V, R, Assoc).
assoc(-1, K, V, L, R, t(K,V,-1,L,R)).
assoc( 0, K, V, L, R, t(K,V, 0,L,R)).
assoc( 1, K, V, L, R, t(K,V, 1,L,R)).
assoc( 2, K, V, L, R, Assoc) :-
	R = t(K1,V1,B1,L1,R1),
	assoc_right(B1, K1, V1, L1, R1, K, V, L, Assoc).

assoc_left(-1, K1, V1, L1, R1, K, V, R,		% single LL rotation
	    t(K1,V1, 0,L1,t(K,V, 0,R1,R))).
assoc_left( 0, K1, V1, L1, R1, K, V, R,		% single LL rotation
	    t(K1,V1, 1,L1,t(K,V,-1,R1,R))).
assoc_left( 1, K1, V1, L1, R1, K, V, R,		% double LR rotation
	    t(K2,V2, 0,t(K1,V1,BK1,L1,L2),t(K,V,BK,R2,R))) :-
        R1 = t(K2,V2,B2,L2,R2),
	assoc(B2, BK1, BK).

assoc_right( 1, K1, V1, L1, R1, K, V, L,	% single RR rotation
	     t(K1,V1, 0,t(K,V, 0,L,L1),R1)).
assoc_right( 0, K1, V1, L1, R1, K, V, L,	% single RR rotation
	     t(K1,V1,-1,t(K,V, 1,L,L1),R1)).
assoc_right(-1, K1, V1, L1, R1, K, V, L,	% double RL rotation
	     t(K2,V2, 0,t(K,V,BK,L,L2),t(K1,V1,BK1,R2,R1))) :-
        L1 = t(K2,V2,B2,L2,R2),
	assoc(B2, BK, BK1).

assoc(-1,  0, 1).
assoc( 0,  0, 0).
assoc( 1, -1, 0).


%   del_assoc(+Key, +OldAssoc, ?Val, -NewAssoc)
%   is true when OldAssoc and NewAssoc define the same finite function
%   except that OldAssoc associates Key with Val and NewAssoc doesn't
%   associate Key with any value.

del_assoc(Key, Assoc0, Val, Assoc) :-
	del_assoc(Assoc0, Key, Val, Assoc, _).

del_assoc(t(K,V,B,L,R), Key, Val, Assoc, Delta) :-
	compare(C, Key, K),
	del_assoc(C, Key, Val, Assoc, Delta, K, V, B, L, R).

del_assoc(<, Key, Val, Assoc, Delta, K, V, B, L, R) :-
	del_assoc(L, Key, Val, L1, D1),
        B1 is B+D1,
	/*prolog:*/assoc(B1, K, V, L1, R, Assoc),
	assoc_shrinkage(Assoc, D1, Delta).
del_assoc(=, _, Val, Assoc, Delta, _, Val, B, L, R) :-
	(   L == t -> Assoc = R, Delta = 1
	;   R == t -> Assoc = L, Delta = 1
	;   del_max_assoc(L, K, V, L1, D1),
	    B1 is B+D1,
	    /*prolog:*/assoc(B1, K, V, L1, R, Assoc),
	    assoc_shrinkage(Assoc, D1, Delta)
	).
del_assoc(>, Key, Val, Assoc, Delta, K, V, B, L, R) :-
	del_assoc(R, Key, Val, R1, D1),
	B1 is B-D1,
	/*prolog:*/assoc(B1, K, V, L, R1, Assoc),
	assoc_shrinkage(Assoc, D1, Delta).


%   del_min_assoc(+OldAssoc, ?Key, ?Val, -NewAssoc)
%   is true when OldAssoc and NewAssoc define the same finite function
%   except that OldAssoc associates Key with Val and NewAssoc doesn't
%   associate Key with any value and Key precedes all other keys in OldAssoc.

del_min_assoc(Assoc0, Key, Val, Assoc) :-
	del_min_assoc(Assoc0, Key, Val, Assoc, _).

del_min_assoc(t(K,V,B,L,R), Key, Val, Assoc, Delta) :-
	(   L == t ->
	    Assoc = R, Key = K, Val = V, Delta = 1
	;   del_min_assoc(L, Key, Val, L1, D1),
	    B1 is B+D1,
	    %/*prolog:*/
	    assoc(B1, K, V, L1, R, Assoc),
	    assoc_shrinkage(Assoc, D1, Delta)
	).



%   del_max_assoc(+OldAssoc, ?Key, ?Val, -NewAssoc)
%   is true when OldAssoc and NewAssoc define the same finite function
%   except that OldAssoc associates Key with Val and NewAssoc doesn't
%   associate Key with any value and 
%   Key is preceded by all other keys in OldAssoc.

del_max_assoc(Assoc0, Key, Val, Assoc) :-
	del_max_assoc(Assoc0, Key, Val, Assoc, _).

del_max_assoc(t(K,V,B,L,R), Key, Val, Assoc, Delta) :-
	(   R == t ->
	    Assoc = L, Key = K, Val = V, Delta = 1
	;   del_max_assoc(R, Key, Val, R1, D1),
	    B1 is B-D1,
	    /*prolog:*/assoc(B1, K, V, L, R1, Assoc),
	    assoc_shrinkage(Assoc, D1, Delta)
	).


assoc_shrinkage(t(_,_,B,_,_), D1, Delta) :-
	Delta is \(B) /\ D1.		% this shrank iff L/R shrank and
					% this became balanced

%   map_assoc(:Pred, ?Assoc)
%   is true when Assoc is an association tree, and for each Key, 
%   if Key is associated with Value in Assoc, Pred(Value) is true.

map_assoc(MPred, Assoc) :-
	/*prolog:*/get_module(MPred, Pred, M),
	map_assoc_1(Assoc, M, Pred).

map_assoc_1(t, _, _).
map_assoc_1(t(_,Val,_,L,R), M, Pred) :-
	map_assoc_1(L, M, Pred),
	add_arguments(Pred, [Val], Goal),
	M:Goal,
	map_assoc_1(R, M, Pred).



%   map_assoc(:Pred, ?OldAssoc, ?NewAssoc)
%   is true when OldAssoc and NewAssoc are association trees of the
%   same shape, and for each Key, if Key is associated with Old in
%   OldAssoc and with New in NewAssoc, Pred(Old,New) is true.

map_assoc(MPred, OldAssoc, NewAssoc) :-
	/*prolog:*/get_module(MPred, Pred, M),
	map_assoc_1(OldAssoc, NewAssoc, M, Pred).

map_assoc_1(t, t, _, _).
map_assoc_1(t(Key,Old,B,L0,R0), t(Key,New,B,L1,R1), M, Pred) :-
	map_assoc_1(L0, L1, M, Pred),
	add_arguments(Pred, [Old,New], Goal),
	M:Goal,
	map_assoc_1(R0, R1, M, Pred).

add_arguments(Goal, Args, Goal1) :-
	Goal =.. GoalList,
	append(GoalList, Args, GoalList1),
	Goal1 =.. GoalList1.






:-redefine_system_predicate('$syspreds':shell(_,_)).
:-redefine_system_predicate('$syspreds':shell(_)).
:-redefine_system_predicate('$syspreds':shell).

:-setMooOptionImplicitWriteSettings.


:-main(Port).

