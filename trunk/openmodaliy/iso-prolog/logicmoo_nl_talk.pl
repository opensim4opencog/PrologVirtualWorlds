
/******************************************************

                     TALK Program

******************************************************/



/*=====================================================
                       Operators
=====================================================*/

:- op(500,xfy,&). 
:- op(510,xfy,=>). 
:- op(100,fx,`).


/*=====================================================
                   Dialogue Manager
=====================================================*/

%%% main_loop
%%% =========

main_loop :-
    write('>> '),        % prompt the user
    read_sent(Words),    % read a sentence
    talk(Words, Reply),  % process it with TALK
    print_reply(Reply),  % generate a printed reply
    main_loop.           % pocess more sentences


%%% talk(Sentence, Reply)
%%% =====================
%%%
%%%     Sentence ==> sentence to form a reply to
%%%     Reply    <== appropriate reply to the sentence

talk(Sentence, Reply) :-
   % parse the sentence
   parse(Sentence, LF, Type),
   % convert the FOL logical form into a Horn 
   % clause, if possible
   clausify(LF, Clause, FreeVars), !,
   % concoct a reply, based on the clause and 
   % whether sentence was a query or assertion
   reply(Type, FreeVars, Clause, Reply).

% No parse was found, sentence is too difficult.
talk(_Sentence, error('too difficult')).


%%% reply(Type, FreeVars, Clause, Reply)
%%% ====================================
%%%
%%%     Type     ==> the constant "query" or "assertion"
%%%                  depending on whether clause should 
%%%                  be interpreted as a query or 
%%%                  assertion
%%%     FreeVars ==> the free variables (to be 
%%%                  interpreted existentially) in the 
%%%                  clause
%%%     Clause   ==> the clause being replied to
%%%     Reply    <== the reply
%%%
%%%     If the clause is interpreted as an assertion, 
%%%     the predicate has a side effect of asserting
%%%     the clause to the database.

% Replying to a query.
reply(query, FreeVars, (answer(Answer):-Condition), Reply) :-
   % find all the answers that satisfy the query,
   % replying with that set if it exists, or "no"
   % or "none" if it doesn't.
   (setof(Answer, FreeVars^Condition, Answers)
      -> Reply = answer(Answers)
      ;  (Answer = yes 
            -> Reply = answer([no])
            ;  Reply = answer([none]))), !.

% Replying to an assertion.
reply(assertion, _FreeVars,  Assertion, asserted(Assertion)) :-
   % assert the assertion and tell user what we asserted
   assert(Assertion), !.

% Replying to some other type of sentence.
reply(_Type, _FreeVars, _Clause, error('unknown type')).


%%% print_reply(Reply)
%%% ==================
%%%
%%%     Reply ==> reply generated by reply predicate
%%%               that is to be printed to the
%%%               standard output.

print_reply(error(ErrorType)) :-
   write('Error: "'), write(ErrorType), write('."'), nl.

print_reply(asserted(Assertion)) :-
   write('Asserted "'), write(Assertion), write('."'), nl.

print_reply(answer(Answers)) :-
   print_answers(Answers).

%%% print_answer(Answers)
%%% =====================
%%%
%%%     Answers ==> nonempty list of answers to be printed
%%%                 to the standard output separated
%%%                 by commas.

print_answers([Answer]) :- !,
   write(Answer), write('.'), nl.

print_answers([Answer|Rest]) :-
   write(Answer), write(', '),
   print_reply(answer(Rest)).


/*=====================================================
                      Clausifier
=====================================================*/

%%% clausify(FOL, Clause, FreeVars)
%%% ===============================
%%%
%%%     FOL      ==> FOL expression to be converted
%%%                  to clause form
%%%     Clause   <== clause form of FOL expression
%%%     FreeVars <== free variables in clause
% Universals: variable is left implicitly scoped.
/*
clausify(all(X,F0),F,[X|V]) :- clausify(F0,F,V).

% Implications: consequent must be a literal, 
%               antecedent is clausified specially.
clausify(A0=>C0,(C:-A),V) :-
   clausify_literal(C0,C),
   clausify_antecedent(A0,A,V).

% Literals: left unchanged (except literal 
%           marker is removed).
clausify(C0,C,[]) :- clausify_literal(C0,C).

*/
   % Note that conjunctions and existentials are
% disallowed, since they can't form Horn clauses.


%%% clausify_antecedent(FOL, Clause, FreeVars)
%%% ==========================================
%%%
%%%     FOL      ==> FOL expression to be converted
%%%                  to clause form
%%%     Clause   <== clause form of FOL expression
%%%     FreeVars ==> list of free variables in clause

% Literals: left unchanged (except literal
%           marker is removed).
clausify_antecedent(L0,L,[]) :- clausify_literal(L0,L).

% Conjunctions: each conjunct is clausified separately.
clausify_antecedent(E0&F0,(E,F),V) :-
   clausify_antecedent(E0,E,V0),
   clausify_antecedent(F0,F,V1),
   conc(V0,V1,V).

% Existentials: variable is left implicitly scoped.
clausify_antecedent(exists(X,F0),F,[X|V]) :-
   clausify_antecedent(F0,F,V).

%%% clausify_literal(Literal, Clause)
%%% =================================
%%%
%%%     Literal  ==> FOL literal to be converted
%%%                  to clause form
%%%     Clause   <== clause form of FOL expression
% Literal is left unchanged (except literal
% marker is removed).
clausify_literal(`L,L).


/*=====================================================
                 Auxiliary Predicates
=====================================================*/


%%% conc(List1, List2, List)
%%% ========================
%%%
%%%     List1 ==> a list
%%%     List2 ==> a list
%%%     List  <== the concatenation of the two lists
conc([], List, List).

conc([Element|Rest], List, [Element|LongRest]) :-
    conc(Rest, List, LongRest).



%%% read_sent(Words)
%%% ================
%%%
%%%      Words ==> set of words read from the 
%%%                standard input
%%%
%%%     Words are delimited by spaces and the 
%%%     line is ended by a newline.  Case is not 
%%%     folded; punctuation is not stripped.

read_sent(Words) :-
    get0(Char),               % prime the lookahead
    read_sent(Char, Words).   % get the words
 
% Newlines end the input.
read_sent(C, []) :- newline(C), !.

% Spaces are ignored.
read_sent(C, Words) :- space(C), !,
    get0(Char),
    read_sent(Char, Words).

% Everything else starts a word.
read_sent(Char, [Word|Words]) :-
    read_word(Char, Chars, Next),  % get the word
    name(Word, Chars),             % pack the characters
                                   % into an atom
    read_sent(Next, Words).        % get some more words



%%% read_word(Chars)
%%% ================
%%%
%%%     Chars ==> list of characters read from standard
%%%               input and delimited by spaces or 
%%%               newlines

% Space and newline end a word.
read_word(C, [], C) :- space(C), !.
read_word(C, [], C) :- newline(C), !.

% All other chars are added to the list.
read_word(Char, [Char|Chars], Last) :-
   get0(Next),
   read_word(Next, Chars, Last).


%%% space(Char)
%%% ===========
%%%
%%%     Char === the ASCII code for the space
%%%              character

space(32).


%%% newline(Char)
%%% =============
%%%
%%%     Char === the ASCII code for the newline 
%%%              character

newline(10).





